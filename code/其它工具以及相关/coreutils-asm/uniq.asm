;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	11D9C6C1BB0CA2C0225052CC2A295CCA
; Input	CRC32 :	3E48017F

; File Name   :	D:\coreutils-o\uniq.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'uniq.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: find_field+54p
					; find_field+97p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+19Bp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1ABp	main+30Ap ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002CE
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[INPUT [OUTPUT]]\"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFilterAdjacent ; "Filter adjacent matching lines from INP"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCCountPrefixLi ; "  -c,	--count		  prefix lines by"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDAllRepeatedDe ; "  -D,	--all-repeated[=delimit-method]	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWCheckCharsNCo ; "  -w,	--check-chars=N	  compare no more"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAFieldIsARunOf ; "\nA field is a run of	blanks (usually	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoteUniqDoesNo ; "\nNote: 'uniq' does not detect repeated"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80002CE:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl size_opt(const	char *opt, const char *msgid)
size_opt	proc near		; CODE XREF: main+439p	main+465p ...

msgid		= dword	ptr -20h
opt		= dword	ptr -1Ch
size		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+opt], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+msgid], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+size]
		push	eax
		push	0Ah
		push	0
		push	[ebp+opt]
		call	xstrtoul
		add	esp, 20h
		cmp	eax, 1
		jbe	short loc_800033E
		sub	esp, 0Ch
		push	[ebp+msgid]	; msgid
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		push	[ebp+opt]
		push	offset format	; "%s: %s"
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h
		jmp	short loc_800033F
; ---------------------------------------------------------------------------

loc_800033E:				; CODE XREF: size_opt+3Bj
		nop

loc_800033F:				; CODE XREF: size_opt+63j
		mov	eax, [ebp+size]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8000353
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000353:				; CODE XREF: size_opt+73j
		leave
		retn
size_opt	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	find_field(const linebuffer *line)
find_field	proc near		; CODE XREF: check_file+13Fp
					; check_file+223p ...

count		= dword	ptr -18h
i		= dword	ptr -14h
lp		= dword	ptr -10h
size		= dword	ptr -0Ch
var_4		= dword	ptr -4
line		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		mov	[ebp+lp], eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		sub	eax, 1
		mov	[ebp+size], eax
		mov	[ebp+i], 0
		mov	[ebp+count], 0
		jmp	loc_800040C
; ---------------------------------------------------------------------------

loc_8000384:				; CODE XREF: find_field+6Ej
		add	[ebp+i], 1

loc_8000388:				; CODE XREF: find_field+BFj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+size]
		jnb	short loc_80003CB
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	edx, [ebp+lp]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_8000384
		jmp	short loc_80003CB
; ---------------------------------------------------------------------------

loc_80003C7:				; CODE XREF: find_field+B1j
		add	[ebp+i], 1

loc_80003CB:				; CODE XREF: find_field+39j
					; find_field+70j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+size]
		jnb	short loc_8000408
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	edx, [ebp+lp]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jz	short loc_80003C7

loc_8000408:				; CODE XREF: find_field+7Cj
		add	[ebp+count], 1

loc_800040C:				; CODE XREF: find_field+2Aj
		mov	eax, ds:skip_fields
		cmp	[ebp+count], eax
		jb	loc_8000388
		mov	[ebp+count], 0
		jmp	short loc_800042B
; ---------------------------------------------------------------------------

loc_8000423:				; CODE XREF: find_field+E6j
		add	[ebp+i], 1
		add	[ebp+count], 1

loc_800042B:				; CODE XREF: find_field+CCj
		mov	eax, ds:skip_chars
		cmp	[ebp+count], eax
		jnb	short loc_800043D
		mov	eax, [ebp+i]
		cmp	eax, [ebp+size]
		jb	short loc_8000423

loc_800043D:				; CODE XREF: find_field+DEj
		mov	eax, [ebp+line]
		mov	edx, [eax+8]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	ebx, [ebp+var_4]
		leave
		retn
find_field	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	different(char *old, char *new,	size_t oldlen, size_t newlen)
different	proc near		; CODE XREF: check_file+17Dp
					; check_file+2C5p

old		= dword	ptr  8
new		= dword	ptr  0Ch
oldlen		= dword	ptr  10h
newlen		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:check_chars
		cmp	eax, [ebp+oldlen]
		jnb	short loc_8000465
		mov	eax, ds:check_chars
		mov	[ebp+oldlen], eax

loc_8000465:				; CODE XREF: different+Ej
		mov	eax, ds:check_chars
		cmp	eax, [ebp+newlen]
		jnb	short loc_8000477
		mov	eax, ds:check_chars
		mov	[ebp+newlen], eax

loc_8000477:				; CODE XREF: different+20j
		movzx	eax, ds:ignore_case
		test	al, al
		jz	short loc_80004B3
		mov	eax, [ebp+oldlen]
		cmp	eax, [ebp+newlen]
		jnz	short loc_80004A2
		sub	esp, 4
		push	[ebp+oldlen]
		push	[ebp+new]
		push	[ebp+old]
		call	memcasecmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80004A9

loc_80004A2:				; CODE XREF: different+3Bj
		mov	eax, 1
		jmp	short loc_80004AE
; ---------------------------------------------------------------------------

loc_80004A9:				; CODE XREF: different+53j
		mov	eax, 0

loc_80004AE:				; CODE XREF: different+5Aj
		and	eax, 1
		jmp	short locret_8000508
; ---------------------------------------------------------------------------

loc_80004B3:				; CODE XREF: different+33j
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	short loc_80004D9
		push	[ebp+newlen]
		push	[ebp+new]
		push	[ebp+oldlen]
		push	[ebp+old]
		call	xmemcoll
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short locret_8000508
; ---------------------------------------------------------------------------

loc_80004D9:				; CODE XREF: different+6Fj
		mov	eax, [ebp+oldlen]
		cmp	eax, [ebp+newlen]
		jnz	short loc_80004F9
		sub	esp, 4
		push	[ebp+oldlen]	; n
		push	[ebp+new]	; s2
		push	[ebp+old]	; s1
		call	memcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000500

loc_80004F9:				; CODE XREF: different+92j
		mov	eax, 1
		jmp	short loc_8000505
; ---------------------------------------------------------------------------

loc_8000500:				; CODE XREF: different+AAj
		mov	eax, 0

loc_8000505:				; CODE XREF: different+B1j
		and	eax, 1

locret_8000508:				; CODE XREF: different+64j
					; different+8Aj
		leave
		retn
different	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl writeline(const linebuffer *line, _Bool match, uintmax_t	linecount)
writeline	proc near		; CODE XREF: check_file+391p
					; check_file+3F7p

linecount	= qword	ptr -18h
match		= byte ptr -0Ch
line		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	[ebp+match], al
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+linecount], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+linecount+4], eax
		mov	eax, dword ptr [ebp+linecount+4]
		or	eax, dword ptr [ebp+linecount]
		test	eax, eax
		jnz	short loc_8000538
		movzx	eax, ds:output_unique
		xor	eax, 1
		jmp	short loc_8000559
; ---------------------------------------------------------------------------

loc_8000538:				; CODE XREF: writeline+20j
		movzx	eax, [ebp+match]
		xor	eax, 1
		test	al, al
		jz	short loc_800054F
		movzx	eax, ds:output_first_repeated
		xor	eax, 1
		jmp	short loc_8000559
; ---------------------------------------------------------------------------

loc_800054F:				; CODE XREF: writeline+37j
		movzx	eax, ds:output_later_repeated
		xor	eax, 1

loc_8000559:				; CODE XREF: writeline+2Cj
					; writeline+43j
		test	al, al
		jnz	short loc_80005A5
		mov	eax, ds:countmode_0
		test	eax, eax
		jnz	short loc_8000584
		mov	eax, dword ptr [ebp+linecount]
		mov	edx, dword ptr [ebp+linecount+4]
		add	eax, 1
		adc	edx, 0
		sub	esp, 4
		push	edx
		push	eax
		push	offset a7llu	; "%7llu "
		call	printf
		add	esp, 10h

loc_8000584:				; CODE XREF: writeline+5Aj
		mov	ecx, ds:stdout
		mov	eax, [ebp+line]
		mov	edx, [eax+4]
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short locret_80005A6
; ---------------------------------------------------------------------------

loc_80005A5:				; CODE XREF: writeline+51j
		nop

locret_80005A6:				; CODE XREF: writeline+99j
		leave
		retn
writeline	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_file(const	char *infile, const char *outfile, char	delimiter)
check_file	proc near		; CODE XREF: main+540p

delimiter	= byte ptr -74h
outfile		= dword	ptr -70h
infile		= dword	ptr -6Ch
first_delimiter	= byte ptr -62h
match		= byte ptr -61h
thisline	= dword	ptr -60h
prevline	= dword	ptr -5Ch
prevfield	= dword	ptr -58h
prevlen		= dword	ptr -54h
prevfield_0	= dword	ptr -50h
prevlen_0	= dword	ptr -4Ch
thisfield	= dword	ptr -48h
thislen		= dword	ptr -44h
_tmp		= dword	ptr -40h
thisfield_0	= dword	ptr -3Ch
thislen_0	= dword	ptr -38h
_tmp_0		= dword	ptr -34h
match_count	= qword	ptr -30h
lb1		= linebuffer ptr -24h
lb2		= linebuffer ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 78h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+infile], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+outfile], edx
		mov	[ebp+delimiter], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		push	offset asc_8001813 ; "-"
		push	[ebp+infile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000619
		mov	eax, ds:stdin
		sub	esp, 4
		push	eax
		push	offset aR	; "r"
		push	[ebp+infile]
		call	freopen_safer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000619
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+infile]
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000619:				; CODE XREF: check_file+38j
					; check_file+55j
		sub	esp, 8
		push	offset asc_8001813 ; "-"
		push	[ebp+outfile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000667
		mov	eax, ds:stdout
		sub	esp, 4
		push	eax
		push	offset aW	; "w"
		push	[ebp+outfile]
		call	freopen_safer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000667
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+outfile]
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000667:				; CODE XREF: check_file+86j
					; check_file+A3j
		lea	eax, [ebp+lb1]
		mov	[ebp+thisline],	eax
		lea	eax, [ebp+lb2]
		mov	[ebp+prevline],	eax
		sub	esp, 0Ch
		push	[ebp+thisline]
		call	initbuffer
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+prevline]
		call	initbuffer
		add	esp, 10h
		movzx	eax, ds:output_unique
		test	al, al
		jz	loc_8000792
		movzx	eax, ds:output_first_repeated
		test	al, al
		jz	loc_8000792
		mov	eax, ds:countmode_0
		cmp	eax, 1
		jnz	loc_8000792
		jmp	loc_800076E
; ---------------------------------------------------------------------------

loc_80006C0:				; CODE XREF: check_file+1D9j
		movsx	edx, [ebp+delimiter]
		mov	eax, ds:stdin
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+thisline]
		call	readlinebuffer_delim
		add	esp, 10h
		test	eax, eax
		jz	loc_800078C
		sub	esp, 0Ch
		push	[ebp+thisline]	; line
		call	find_field
		add	esp, 10h
		mov	[ebp+thisfield], eax
		mov	eax, [ebp+thisline]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+8]
		mov	ecx, eax
		mov	eax, [ebp+thisfield]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		sub	eax, 1
		mov	[ebp+thislen], eax
		mov	eax, [ebp+prevline]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_8000731
		push	[ebp+prevlen]	; newlen
		push	[ebp+thislen]	; oldlen
		push	[ebp+prevfield]	; new
		push	[ebp+thisfield]	; old
		call	different
		add	esp, 10h
		test	al, al
		jz	short loc_800076E

loc_8000731:				; CODE XREF: check_file+16Fj
		mov	ecx, ds:stdout
		mov	eax, [ebp+thisline]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+8]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, [ebp+prevline]
		mov	[ebp+_tmp], eax
		mov	eax, [ebp+thisline]
		mov	[ebp+prevline],	eax
		mov	eax, [ebp+_tmp]
		mov	[ebp+thisline],	eax
		mov	eax, [ebp+thisfield]
		mov	[ebp+prevfield], eax
		mov	eax, [ebp+thislen]
		mov	[ebp+prevlen], eax

loc_800076E:				; CODE XREF: check_file+113j
					; check_file+187j
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_80006C0
		jmp	closefiles
; ---------------------------------------------------------------------------

loc_800078C:				; CODE XREF: check_file+133j
		nop
		jmp	closefiles
; ---------------------------------------------------------------------------

loc_8000792:				; CODE XREF: check_file+F0j
					; check_file+FFj ...
		mov	dword ptr [ebp+match_count], 0
		mov	dword ptr [ebp+match_count+4], 0
		mov	[ebp+first_delimiter], 1
		movsx	edx, [ebp+delimiter]
		mov	eax, ds:stdin
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+prevline]
		call	readlinebuffer_delim
		add	esp, 10h
		test	eax, eax
		jz	loc_80009A9
		sub	esp, 0Ch
		push	[ebp+prevline]	; line
		call	find_field
		add	esp, 10h
		mov	[ebp+prevfield_0], eax
		mov	eax, [ebp+prevline]
		mov	edx, [eax+4]
		mov	eax, [ebp+prevline]
		mov	eax, [eax+8]
		mov	ecx, eax
		mov	eax, [ebp+prevfield_0]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		sub	eax, 1
		mov	[ebp+prevlen_0], eax
		jmp	loc_8000978
; ---------------------------------------------------------------------------

loc_80007F8:				; CODE XREF: check_file+3E3j
		movsx	edx, [ebp+delimiter]
		mov	eax, ds:stdin
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+thisline]
		call	readlinebuffer_delim
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000833
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_8000993
		jmp	closefiles
; ---------------------------------------------------------------------------

loc_8000833:				; CODE XREF: check_file+26Bj
		sub	esp, 0Ch
		push	[ebp+thisline]	; line
		call	find_field
		add	esp, 10h
		mov	[ebp+thisfield_0], eax
		mov	eax, [ebp+thisline]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+8]
		mov	ecx, eax
		mov	eax, [ebp+thisfield_0]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		sub	eax, 1
		mov	[ebp+thislen_0], eax
		push	[ebp+prevlen_0]	; newlen
		push	[ebp+thislen_0]	; oldlen
		push	[ebp+prevfield_0] ; new
		push	[ebp+thisfield_0] ; old
		call	different
		add	esp, 10h
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+match], al
		and	[ebp+match], 1
		movzx	eax, [ebp+match]
		mov	edx, 0
		add	dword ptr [ebp+match_count], eax
		adc	dword ptr [ebp+match_count+4], edx
		mov	eax, dword ptr [ebp+match_count+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+match_count]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jnz	short loc_80008B5
		add	dword ptr [ebp+match_count], 0FFFFFFFFh
		adc	dword ptr [ebp+match_count+4], 0FFFFFFFFh

loc_80008B5:				; CODE XREF: check_file+303j
		mov	eax, ds:delimit_groups
		test	eax, eax
		jz	short loc_8000915
		movzx	eax, [ebp+match]
		xor	eax, 1
		test	al, al
		jz	short loc_80008D9
		mov	eax, dword ptr [ebp+match_count+4]
		or	eax, dword ptr [ebp+match_count]
		test	eax, eax
		jz	short loc_8000915
		mov	[ebp+first_delimiter], 0
		jmp	short loc_8000915
; ---------------------------------------------------------------------------

loc_80008D9:				; CODE XREF: check_file+31Fj
		mov	eax, dword ptr [ebp+match_count]
		xor	eax, 1
		or	eax, dword ptr [ebp+match_count+4]
		test	eax, eax
		jnz	short loc_8000915
		mov	eax, ds:delimit_groups
		cmp	eax, 1
		jz	short loc_8000905
		mov	eax, ds:delimit_groups
		cmp	eax, 2
		jnz	short loc_8000915
		movzx	eax, [ebp+first_delimiter]
		xor	eax, 1
		test	al, al
		jz	short loc_8000915

loc_8000905:				; CODE XREF: check_file+346j
		movsx	eax, [ebp+delimiter]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000915:				; CODE XREF: check_file+314j
					; check_file+329j ...
		movzx	eax, [ebp+match]
		xor	eax, 1
		test	al, al
		jnz	short loc_800092B
		movzx	eax, ds:output_later_repeated
		test	al, al
		jz	short loc_8000978

loc_800092B:				; CODE XREF: check_file+376j
		movzx	eax, [ebp+match]
		push	dword ptr [ebp+match_count+4]
		push	dword ptr [ebp+match_count] ; linecount
		push	eax		; match
		push	[ebp+prevline]	; line
		call	writeline
		add	esp, 10h
		mov	eax, [ebp+prevline]
		mov	[ebp+_tmp_0], eax
		mov	eax, [ebp+thisline]
		mov	[ebp+prevline],	eax
		mov	eax, [ebp+_tmp_0]
		mov	[ebp+thisline],	eax
		mov	eax, [ebp+thisfield_0]
		mov	[ebp+prevfield_0], eax
		mov	eax, [ebp+thislen_0]
		mov	[ebp+prevlen_0], eax
		movzx	eax, [ebp+match]
		xor	eax, 1
		test	al, al
		jz	short loc_8000978
		mov	dword ptr [ebp+match_count], 0
		mov	dword ptr [ebp+match_count+4], 0

loc_8000978:				; CODE XREF: check_file+24Bj
					; check_file+381j ...
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_80007F8
		jmp	short loc_8000994
; ---------------------------------------------------------------------------

loc_8000993:				; CODE XREF: check_file+280j
		nop

loc_8000994:				; CODE XREF: check_file+3E9j
		push	dword ptr [ebp+match_count+4]
		push	dword ptr [ebp+match_count] ; linecount
		push	0		; match
		push	[ebp+prevline]	; line
		call	writeline
		add	esp, 10h
		jmp	short closefiles
; ---------------------------------------------------------------------------

loc_80009A9:				; CODE XREF: check_file+217j
		nop

closefiles:				; CODE XREF: check_file+1DFj
					; check_file+1E5j ...
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80009D4
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_80009F4

loc_80009D4:				; CODE XREF: check_file+415j
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		push	[ebp+infile]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009F4:				; CODE XREF: check_file+42Aj
		mov	eax, [ebp+lb1.buffer]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+lb2.buffer]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000A24
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000A24:				; CODE XREF: check_file+475j
		leave
		retn
check_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -2Ch
delimiter	= byte ptr -26h
posixly_correct	= byte ptr -25h
size		= dword	ptr -24h
optc		= dword	ptr -20h
skip_field_option_type=	dword ptr -1Ch
nfiles		= dword	ptr -18h
file		= dword	ptr -14h
var_C		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 30h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+optc], 0
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+posixly_correct], al
		mov	[ebp+skip_field_option_type], 0
		mov	[ebp+nfiles], 0
		mov	[ebp+delimiter], 0Ah
		mov	[ebp+file+4], offset asc_8001813 ; "-"
		mov	eax, [ebp+file+4]
		mov	[ebp+file], eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	3
		call	hard_locale
		add	esp, 10h
		mov	ds:hard_LC_COLLATE, al
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:skip_chars, 0
		mov	ds:skip_fields,	0
		mov	ds:check_chars,	0FFFFFFFFh
		mov	ds:output_first_repeated, 1
		movzx	eax, ds:output_first_repeated
		mov	ds:output_unique, al
		mov	ds:output_later_repeated, 0
		mov	ds:countmode_0,	1
		mov	ds:delimit_groups, 0

loc_8000B3F:				; CODE XREF: main:loc_8000F12j
		cmp	[ebp+optc], 0FFFFFFFFh
		jz	short loc_8000B7A
		cmp	[ebp+posixly_correct], 0
		jz	short loc_8000B51
		cmp	[ebp+nfiles], 0
		jnz	short loc_8000B7A

loc_8000B51:				; CODE XREF: main+123j
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "-0123456789Dcdf:is:uw:z"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_8000C05

loc_8000B7A:				; CODE XREF: main+11Dj	main+129j
		mov	eax, ds:optind
		cmp	[ebx], eax
		jle	loc_8000F17
		cmp	[ebp+nfiles], 2
		jnz	short loc_8000BD6
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000BD6:				; CODE XREF: main+165j
		mov	eax, [ebp+nfiles]
		lea	edx, [eax+1]
		mov	[ebp+nfiles], edx
		mov	edx, ds:optind
		lea	ecx, [edx+1]
		mov	ds:optind, ecx
		lea	ecx, ds:0[edx*4]
		mov	edx, [ebp+argv]
		add	edx, ecx
		mov	edx, [edx]
		mov	[ebp+eax*4+file], edx
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000C05:				; CODE XREF: main+14Ej
		mov	eax, [ebp+optc]
		cmp	eax, 63h
		jz	loc_8000DCF
		cmp	eax, 63h
		jg	short loc_8000C5F
		cmp	eax, 1
		jz	loc_8000CAD
		cmp	eax, 1
		jg	short loc_8000C3F
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000ED0
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000EC6
		jmp	loc_8000F08
; ---------------------------------------------------------------------------

loc_8000C3F:				; CODE XREF: main+1FCj
		cmp	eax, 30h
		jl	loc_8000F08
		cmp	eax, 39h
		jle	loc_8000D4D
		cmp	eax, 44h
		jz	loc_8000DEA
		jmp	loc_8000F08
; ---------------------------------------------------------------------------

loc_8000C5F:				; CODE XREF: main+1EEj
		cmp	eax, 73h
		jz	loc_8000E7D
		cmp	eax, 73h
		jg	short loc_8000C8D
		cmp	eax, 66h
		jz	loc_8000E4A
		cmp	eax, 69h
		jz	loc_8000E71
		cmp	eax, 64h
		jz	loc_8000DDE
		jmp	loc_8000F08
; ---------------------------------------------------------------------------

loc_8000C8D:				; CODE XREF: main+245j
		cmp	eax, 77h
		jz	loc_8000EA3
		cmp	eax, 7Ah
		jz	loc_8000EC0
		cmp	eax, 75h
		jz	loc_8000E9A
		jmp	loc_8000F08
; ---------------------------------------------------------------------------

loc_8000CAD:				; CODE XREF: main+1F3j
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	short loc_8000CF4
		call	posix2_version
		cmp	eax, 30DAFh
		jg	short loc_8000CF4
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+size]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000CF4
		mov	eax, [ebp+size]
		mov	ds:skip_chars, eax
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000CF4:				; CODE XREF: main+291j	main+29Dj ...
		cmp	[ebp+nfiles], 2
		jnz	short loc_8000D35
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000D35:				; CODE XREF: main+2D2j
		mov	eax, [ebp+nfiles]
		lea	edx, [eax+1]
		mov	[ebp+nfiles], edx
		mov	edx, ds:optarg
		mov	[ebp+eax*4+file], edx
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000D4D:				; CODE XREF: main+225j
		cmp	[ebp+skip_field_option_type], 2
		jnz	short loc_8000D5D
		mov	ds:skip_fields,	0

loc_8000D5D:				; CODE XREF: main+32Bj
		mov	eax, ds:skip_fields
		cmp	eax, 19999999h
		ja	short loc_8000DB0
		mov	edx, ds:skip_fields
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+optc]
		add	eax, edx
		lea	edx, [eax-30h]
		mov	eax, ds:skip_fields
		cmp	edx, eax
		jb	short loc_8000DB0
		mov	edx, ds:skip_fields
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+optc]
		add	eax, edx
		sub	eax, 30h
		mov	ds:skip_fields,	eax
		mov	eax, 0
		jmp	short loc_8000DB5
; ---------------------------------------------------------------------------

loc_8000DB0:				; CODE XREF: main+341j	main+363j
		mov	eax, 1

loc_8000DB5:				; CODE XREF: main+388j
		test	al, al
		jz	short loc_8000DC3
		mov	ds:skip_fields,	0FFFFFFFFh

loc_8000DC3:				; CODE XREF: main+391j
		mov	[ebp+skip_field_option_type], 1
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000DCF:				; CODE XREF: main+1E5j
		mov	ds:countmode_0,	0
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000DDE:				; CODE XREF: main+25Cj
		mov	ds:output_unique, 0
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000DEA:				; CODE XREF: main+22Ej
		mov	ds:output_unique, 0
		mov	ds:output_later_repeated, 1
		mov	eax, ds:optarg
		test	eax, eax
		jnz	short loc_8000E10
		mov	ds:delimit_groups, 0
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000E10:				; CODE XREF: main+3D9j
		mov	edx, ds:argmatch_die
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset delimit_method_map
		push	offset delimit_method_string
		push	eax
		push	offset aAllRepeated ; "--all-repeated"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:delimit_method_map[eax*4]
		mov	ds:delimit_groups, eax
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000E4A:				; CODE XREF: main+24Aj
		mov	[ebp+skip_field_option_type], 2
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aInvalidNumberO ; "invalid number of fields to skip"
		push	eax		; opt
		call	size_opt
		add	esp, 10h
		mov	ds:skip_fields,	eax
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000E71:				; CODE XREF: main+253j
		mov	ds:ignore_case,	1
		jmp	loc_8000F12
; ---------------------------------------------------------------------------

loc_8000E7D:				; CODE XREF: main+23Cj
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aInvalidNumbe_0 ; "invalid number of bytes to skip"
		push	eax		; opt
		call	size_opt
		add	esp, 10h
		mov	ds:skip_chars, eax
		jmp	short loc_8000F12
; ---------------------------------------------------------------------------

loc_8000E9A:				; CODE XREF: main+27Cj
		mov	ds:output_first_repeated, 0
		jmp	short loc_8000F12
; ---------------------------------------------------------------------------

loc_8000EA3:				; CODE XREF: main+26Aj
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aInvalidNumbe_1 ; "invalid number of bytes to compare"
		push	eax		; opt
		call	size_opt
		add	esp, 10h
		mov	ds:check_chars,	eax
		jmp	short loc_8000F12
; ---------------------------------------------------------------------------

loc_8000EC0:				; CODE XREF: main+273j
		mov	[ebp+delimiter], 0
		jmp	short loc_8000F12
; ---------------------------------------------------------------------------

loc_8000EC6:				; CODE XREF: main+20Ej
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000ED0:				; CODE XREF: main+203j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aRichardM_Stall ; "Richard M. Stallman"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aUniq	; "uniq"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000F08:				; CODE XREF: main+214j	main+21Cj ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F12:				; CODE XREF: main+1DAj	main+2C9j ...
		jmp	loc_8000B3F
; ---------------------------------------------------------------------------

loc_8000F17:				; CODE XREF: main+15Bj
		nop
		mov	eax, ds:countmode_0
		test	eax, eax
		jnz	short loc_8000F56
		movzx	eax, ds:output_later_repeated
		test	al, al
		jz	short loc_8000F56
		sub	esp, 0Ch
		push	offset aPrintingAllDup ; "printing all duplicated lines	and repea"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F56:				; CODE XREF: main+4F9j	main+504j
		movsx	ecx, [ebp+delimiter]
		mov	edx, [ebp+file+4]
		mov	eax, [ebp+file]
		sub	esp, 4
		push	ecx		; delimiter
		push	edx		; outfile
		push	eax		; infile
		call	check_file
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; status

loc_8000F73:				; DATA XREF: .eh_frame:08001980o
					; .eh_frame:080019A0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8000F7Ch
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	hard_LC_COLLATE
hard_LC_COLLATE	db ?			; DATA XREF: different:loc_80004B3r
					; main+B8w
		align 10h
; size_t skip_fields
skip_fields	dd ?			; DATA XREF: find_field:loc_800040Cr
					; main+D7w ...
; size_t skip_chars
skip_chars	dd ?			; DATA XREF: find_field:loc_800042Br
					; main+CDw ...
; size_t check_chars
check_chars	dd ?			; DATA XREF: different+6r
					; different+10r ...
; countmode countmode_0
countmode_0	dd ?			; DATA XREF: writeline+53r
					; check_file+105r ...
; _Bool	output_unique
output_unique	db ?			; DATA XREF: writeline+22r
					; check_file+E7r ...
; _Bool	output_first_repeated
output_first_repeated db ?		; DATA XREF: writeline+39r
					; check_file+F6r ...
; _Bool	output_later_repeated
output_later_repeated db ?		; DATA XREF: writeline:loc_800054Fr
					; check_file+378r ...
; _Bool	ignore_case
ignore_case	db ?			; DATA XREF: different:loc_8000477r
					; main:loc_8000E71w
; delimit_method delimit_groups
delimit_groups	dd ?			; DATA XREF: check_file:loc_80008B5r
					; check_file+33Er ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000FA0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+8Eo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+4C5o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aNone		db 'none',0             ; DATA XREF: .rodata:delimit_method_stringo
aPrepend	db 'prepend',0          ; DATA XREF: .rodata:delimit_method_stringo
aSeparate	db 'separate',0         ; DATA XREF: .rodata:delimit_method_stringo
		align 10h
; const	char *const delimit_method_string[4]
delimit_method_string dd offset	aNone, offset aPrepend,	offset aSeparate, 0
					; DATA XREF: main+400o
					; "none"
; const	delimit_method delimit_method_map[3]
delimit_method_map dd DM_NONE, DM_PREPEND, DM_SEPARATE ; DATA XREF: main+3FBo
					; main+413r
aCount		db 'count',0            ; DATA XREF: .rodata:longoptso
aRepeated	db 'repeated',0         ; DATA XREF: .rodata:longoptso
aAllRepeated_0	db 'all-repeated',0     ; DATA XREF: .rodata:longoptso
aIgnoreCase	db 'ignore-case',0      ; DATA XREF: .rodata:longoptso
aUnique		db 'unique',0           ; DATA XREF: .rodata:longoptso
aSkipFields	db 'skip-fields',0      ; DATA XREF: .rodata:longoptso
aSkipChars	db 'skip-chars',0       ; DATA XREF: .rodata:longoptso
aCheckChars	db 'check-chars',0      ; DATA XREF: .rodata:longoptso
aZeroTerminated	db 'zero-terminated',0  ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[12]
longopts	option <offset aCount, 0, 0, 63h> ; DATA XREF: main+130o
		option <offset aRepeated, 0, 0,	64h> ; "count"
		option <offset aAllRepeated_0, 2, 0, 44h>
		option <offset aIgnoreCase, 0, 0, 69h>
		option <offset aUnique,	0, 0, 75h>
		option <offset aSkipFields, 1, 0, 66h>
		option <offset aSkipChars, 1, 0, 73h>
		option <offset aCheckChars, 1, 0, 77h>
		option <offset aZeroTerminated,	0, 0, 7Ah>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [INPUT [OUTPUT]]',0Ah,0 ; DATA XREF: usage+46o
; char aFilterAdjacent[]
aFilterAdjacent	db 'Filter adjacent matching lines from INPUT (or standard input),',0Ah
					; DATA XREF: usage+69o
		db 'writing to OUTPUT (or standard output).',0Ah
		db 0Ah
		db 'With no options, matching lines are merged to the first occurrenc'
		db 'e.',0Ah
		db 0Ah,0
		align 10h
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aCCountPrefixLi[]
aCCountPrefixLi	db '  -c, --count           prefix lines by the number of occurrences'
					; DATA XREF: usage+AFo
		db 0Ah
		db '  -d, --repeated        only print duplicate lines',0Ah,0
		align 4
; char aDAllRepeatedDe[]
aDAllRepeatedDe	db '  -D, --all-repeated[=delimit-method]  print all duplicate lines',0Ah
					; DATA XREF: usage+D2o
		db '                        delimit-method={none(default),prepend,sep'
		db 'arate}',0Ah
		db '                        Delimiting is done with blank lines.',0Ah
		db '  -f, --skip-fields=N   avoid comparing the first N fields',0Ah
		db '  -i, --ignore-case     ignore differences in case when comparing'
		db 0Ah
		db '  -s, --skip-chars=N    avoid comparing the first N characters',0Ah
		db '  -u, --unique          only print unique lines',0Ah
		db '  -z, --zero-terminated  end lines with 0 byte, not newline',0Ah,0
		align 4
; char aWCheckCharsNCo[]
aWCheckCharsNCo	db '  -w, --check-chars=N   compare no more than N characters in line'
					; DATA XREF: usage+F5o
		db 's',0Ah,0
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+118o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+13Bo
		align 10h
; char aAFieldIsARunOf[]
aAFieldIsARunOf	db 0Ah			; DATA XREF: usage+15Eo
		db 'A field is a run of blanks (usually spaces and/or TABs), then non'
		db '-blank',0Ah
		db 'characters.  Fields are skipped before chars.',0Ah,0
; char aNoteUniqDoesNo[]
aNoteUniqDoesNo	db 0Ah			; DATA XREF: usage+181o
		db 'Note: ',27h,'uniq',27h,' does not detect repeated lines unless they are'
		db ' adjacent.',0Ah
		db 'You may want to sort the input first, or use `sort -u',27h,' without'
		db ' `uniq',27h,'.',0Ah
		db 'Also, comparisons honor the rules specified by `LC_COLLATE',27h,'.',0Ah
		db 0
; char locale
locale		db 0			; DATA XREF: size_opt+20o main+77o ...
; char format[]
format		db '%s: %s',0           ; DATA XREF: size_opt+52o
; char a7llu[]
a7llu		db '%7llu ',0           ; DATA XREF: writeline+6Do
; char asc_8001813[]
asc_8001813	db '-',0                ; DATA XREF: check_file+26o
					; check_file+74o ...
aR		db 'r',0                ; DATA XREF: check_file+43o
; char aS[]
aS		db '%s',0               ; DATA XREF: check_file+61o
					; check_file+AFo
aW		db 'w',0                ; DATA XREF: check_file+91o
; char aErrorReadingS[]
aErrorReadingS	db 'error reading %s',0 ; DATA XREF: check_file+42Fo
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: main+2Fo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+89o
; char shortopts[]
shortopts	db '-0123456789Dcdf:is:uw:z',0 ; DATA XREF: main+135o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+18Bo main+2EAo
aAllRepeated	db '--all-repeated',0   ; DATA XREF: main+406o
		align 10h
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of fields to skip',0 ; DATA XREF: main+433o
		align 4
; char aInvalidNumbe_0[]
aInvalidNumbe_0	db 'invalid number of bytes to skip',0 ; DATA XREF: main+45Fo
; char aInvalidNumbe_1[]
aInvalidNumbe_1	db 'invalid number of bytes to compare',0 ; DATA XREF: main+485o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+4BAo
aRichardM_Stall	db 'Richard M. Stallman',0 ; DATA XREF: main+4BFo
aUniq		db 'uniq',0             ; DATA XREF: main+4CAo
; char aPrintingAllDup[]
aPrintingAllDup	db 'printing all duplicated lines and repeat counts is meaningless',0
					; DATA XREF: main+509o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001960h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000F73-80028F3h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8000F73-8002901h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	60h
		dd offset loc_8000F73-8002809h
		dd 1ABh, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_8000F73-800267Ah
		dd 7Ch,	80E4100h, 0D420285h, 0C5780205h, 4040Ch, 20h, 9Ch
		dd offset loc_8000F73-800261Eh
		dd 0F8h, 80E4100h, 0D420285h, 3834405h,	0C3C5F002h, 4040Ch
		dd 1Ch,	0C0h
		dd offset loc_8000F73-800254Ah
		dd 0BDh, 80E4100h, 0D420285h, 0C5B90205h, 4040Ch, 1Ch
		dd 0E0h
		dd offset loc_8000F73-80024ADh
		dd 9Eh,	80E4100h, 0D420285h, 0C59A0205h, 4040Ch, 1Ch, 100h
		dd offset loc_8000F73-800242Fh
		dd 47Eh, 80E4100h, 0D420285h, 47A0305h,	4040CC5h, 24h
		dd 120h
		dd offset loc_8000F73-8001FD1h
		dd 552h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+7Ep
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1A6p main+4DDp ...
		extrn xstrtoul:near	; CODE XREF: size_opt+30p main+2B5p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: size_opt+5Bp
					; check_file+69p ...
		extrn __stack_chk_fail:near ; CODE XREF: size_opt+75p
					; check_file+477p
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: find_field+3Bp
					; find_field+7Ep
		extrn memcasecmp:near	; CODE XREF: different+49p
		extrn xmemcoll:near	; CODE XREF: different+7Dp
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: different+A0p
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	writeline+91p
					; check_file+1A0p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: check_file+2Ep
					; check_file+7Cp
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: check_file+3Ar
					; check_file+11Cr ...
		extrn freopen_safer:near ; CODE	XREF: check_file+4Bp
					; check_file+99p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: check_file+57p
					; check_file+A5p
		extrn initbuffer:near	; CODE XREF: check_file+D1p
					; check_file+DFp
		extrn readlinebuffer_delim:near	; CODE XREF: check_file+129p
					; check_file+20Dp ...
; int feof_unlocked(FILE *stream)
		extrn feof_unlocked:near ; CODE	XREF: check_file+1CFp
					; check_file+3D9p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	check_file+276p
					; check_file+40Bp
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: check_file+365p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: check_file+420p
; void free(void *ptr)
		extrn free:near		; CODE XREF: check_file+453p
					; check_file+462p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: main+34p
		extrn set_program_name:near ; CODE XREF: main+6Cp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+93p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+A3p
		extrn hard_locale:near	; CODE XREF: main+B0p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+C0o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+C5p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+13Fp
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000B7Ar
					; main+167r ...
		extrn quote:near	; CODE XREF: main+17Ep	main+2DDp
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000CADr
					; main+29Fr ...
		extrn posix2_version:near ; CODE XREF: main+293p
		extrn argmatch_die:dword ; DATA	XREF: main:loc_8000E10r
		extrn __xargmatch_internal:near	; CODE XREF: main+40Bp
		extrn Version:dword	; DATA XREF: main:loc_8000ED0r
		extrn version_etc:near	; CODE XREF: main+4D0p


		end
