;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4A2B404D7152FDB084F57E8C348AB49E
; Input	CRC32 :	F1F53F9B

; File Name   :	D:\coreutils-o\ls.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'ls.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl freecon(char *con)
freecon		proc near		; CODE XREF: clear_files+5Bp

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
freecon		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl getfilecon(const char *file, char	**con)
getfilecon	proc near		; CODE XREF: gobble_file+509p

file		= dword	ptr  8
con		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
getfilecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl lgetfilecon(const	char *file, char **con)
lgetfilecon	proc near		; CODE XREF: gobble_file+526p

file		= dword	ptr  8
con		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
lgetfilecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+7Dp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000047
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000047:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl timespec_cmp(timespec a, timespec	b)
timespec_cmp	proc near		; CODE XREF: cmp_ctime+55p
					; cmp_mtime+55p ...

a		= timespec ptr	8
b		= timespec ptr	10h

		push	ebp
		mov	ebp, esp
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jl	short loc_8000089
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jg	short loc_8000082
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		jl	short loc_800007B
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		setnle	al
		movzx	eax, al
		jmp	short loc_800008E
; ---------------------------------------------------------------------------

loc_800007B:				; CODE XREF: timespec_cmp+1Fj
		mov	eax, 0FFFFFFFFh
		jmp	short loc_800008E
; ---------------------------------------------------------------------------

loc_8000082:				; CODE XREF: timespec_cmp+15j
		mov	eax, 1
		jmp	short loc_800008E
; ---------------------------------------------------------------------------

loc_8000089:				; CODE XREF: timespec_cmp+Bj
		mov	eax, 0FFFFFFFFh

loc_800008E:				; CODE XREF: timespec_cmp+2Fj
					; timespec_cmp+36j ...
		pop	ebp
		retn
timespec_cmp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: quote_name+35Fp
					; quote_name+427p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	dot_or_dotdot(const char *file_name)
dot_or_dotdot	proc near		; CODE XREF: basename_is_dot_or_dotdot+1Dp

sep		= byte ptr -1
file_name	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+file_name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_80000F3
		mov	eax, [ebp+file_name]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_80000C6
		mov	edx, 2
		jmp	short loc_80000CB
; ---------------------------------------------------------------------------

loc_80000C6:				; CODE XREF: dot_or_dotdot+1Bj
		mov	edx, 1

loc_80000CB:				; CODE XREF: dot_or_dotdot+22j
		mov	eax, [ebp+file_name]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sep], al
		cmp	[ebp+sep], 0
		jz	short loc_80000E2
		cmp	[ebp+sep], 2Fh
		jnz	short loc_80000E9

loc_80000E2:				; CODE XREF: dot_or_dotdot+38j
		mov	eax, 1
		jmp	short loc_80000EE
; ---------------------------------------------------------------------------

loc_80000E9:				; CODE XREF: dot_or_dotdot+3Ej
		mov	eax, 0

loc_80000EE:				; CODE XREF: dot_or_dotdot+45j
		and	eax, 1
		jmp	short locret_80000F8
; ---------------------------------------------------------------------------

loc_80000F3:				; CODE XREF: dot_or_dotdot+Ej
		mov	eax, 0

locret_80000F8:				; CODE XREF: dot_or_dotdot+4Fj
		leave
		retn
dot_or_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_size_note()
emit_size_note	proc near		; CODE XREF: usage+362p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset msgid	; "\nSIZE may be (or may be an integer opt"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_size_note	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+3ADp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSBugsToS ; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000210
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000210
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000210:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	timetostr(time_t t, char *buf)
timetostr	proc near		; CODE XREF: print_long_format+84Bp

t		= dword	ptr  8
buf		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+t]
		cdq
		sub	esp, 4
		push	[ebp+buf]
		push	edx
		push	eax
		call	imaxtostr
		add	esp, 10h
		leave
		retn
timetostr	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	bad_cast(const char *s)
bad_cast	proc near		; CODE XREF: decode_switches+8A0p
					; decode_switches+C48p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+s]
		pop	ebp
		retn
bad_cast	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_atime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_atime	proc near		; CODE XREF: cmp_atime+2Ep
					; cmp_atime+41p ...

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+44h]
		mov	eax, [eax+40h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_ctime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_ctime	proc near		; CODE XREF: cmp_ctime+2Ep
					; cmp_ctime+41p ...

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+54h]
		mov	eax, [eax+50h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_ctime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: cmp_mtime+2Ep
					; cmp_mtime+41p ...

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; dev_ino *dev_ino_pop(dev_ino *__return_ptr __struct_ptr retstr)
dev_ino_pop	proc near		; CODE XREF: main+588p

__o		= dword	ptr -14h
__o_0		= dword	ptr -10h
__len		= dword	ptr -0Ch
retstr		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+__o], offset dev_ino_obstack
		mov	eax, [ebp+__o]
		mov	eax, [eax+0Ch]
		mov	edx, eax
		mov	eax, [ebp+__o]
		mov	eax, [eax+8]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 0Fh
		ja	short loc_80002F8
		push	offset __PRETTY_FUNCTION___6896	; "dev_ino_pop"
		push	3D5h		; line
		push	offset file	; "ls.c"
		push	offset assertion ; "sizeof (struct dev_ino) <= obstack_obje"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80002F8:				; CODE XREF: dev_ino_pop+22j
		mov	[ebp+__o_0], offset dev_ino_obstack
		mov	[ebp+__len], 0FFFFFFF0h
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+10h]
		mov	edx, eax
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+0Ch]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, [ebp+__len]
		jge	short loc_800032E
		sub	esp, 8
		push	[ebp+__len]	; int
		push	[ebp+__o_0]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_800032E:				; CODE XREF: dev_ino_pop+60j
		mov	eax, [ebp+__o_0]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len]
		add	edx, eax
		mov	eax, [ebp+__o_0]
		mov	[eax+0Ch], edx
		mov	edx, ds:dev_ino_obstack.next_free
		mov	eax, [ebp+retstr]
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+retstr]
		leave
		retn	4
dev_ino_pop	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl dired_dump_obstack(const	char *prefix, obstack *os)
dired_dump_obstack proc	near		; CODE XREF: main+735p	main+74Ap

i		= dword	ptr -20h
__o		= dword	ptr -1Ch
n_pos		= dword	ptr -18h
__o1		= dword	ptr -14h
__value		= dword	ptr -10h
pos		= dword	ptr -0Ch
prefix		= dword	ptr  8
os		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+os]
		mov	[ebp+__o], eax
		mov	eax, [ebp+__o]
		mov	eax, [eax+0Ch]
		mov	edx, eax
		mov	eax, [ebp+__o]
		mov	eax, [eax+8]
		sub	edx, eax
		mov	eax, edx
		shr	eax, 2
		mov	[ebp+n_pos], eax
		cmp	[ebp+n_pos], 0
		jz	loc_8000478
		mov	eax, [ebp+os]
		mov	[ebp+__o1], eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+8]
		mov	[ebp+__value], eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+__value]
		jnz	short loc_80003BA
		mov	eax, [ebp+__o1]
		movzx	edx, byte ptr [eax+28h]
		or	edx, 2
		mov	[eax+28h], dl

loc_80003BA:				; CODE XREF: dired_dump_obstack+46j
		mov	eax, [ebp+__o1]
		mov	eax, [eax+0Ch]
		mov	edx, eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+18h]
		add	edx, eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+18h]
		not	eax
		and	eax, edx
		mov	edx, eax
		mov	eax, [ebp+__o1]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+__o1]
		mov	eax, [eax+0Ch]
		mov	edx, eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+4]
		sub	edx, eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+10h]
		mov	ecx, eax
		mov	eax, [ebp+__o1]
		mov	eax, [eax+4]
		sub	ecx, eax
		mov	eax, ecx
		cmp	edx, eax
		jle	short loc_800040E
		mov	eax, [ebp+__o1]
		mov	edx, [eax+10h]
		mov	eax, [ebp+__o1]
		mov	[eax+0Ch], edx

loc_800040E:				; CODE XREF: dired_dump_obstack+9Bj
		mov	eax, [ebp+__o1]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__o1]
		mov	[eax+8], edx
		mov	eax, [ebp+__value]
		mov	[ebp+pos], eax
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		push	[ebp+prefix]
		call	fputs_unlocked
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8000463
; ---------------------------------------------------------------------------

loc_800043D:				; CODE XREF: dired_dump_obstack+104j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+pos]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	offset aLu_1	; " %lu"
		call	printf
		add	esp, 10h
		add	[ebp+i], 1

loc_8000463:				; CODE XREF: dired_dump_obstack+D6j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_pos]
		jb	short loc_800043D
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000478:				; CODE XREF: dired_dump_obstack+28j
		nop
		leave
		retn
dired_dump_obstack endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t abmon_init()
abmon_init	proc near		; CODE XREF: decode_switches:loc_8001EB3p

width		= dword	ptr -1Ch
i		= dword	ptr -18h
curr_max_width	= dword	ptr -14h
req		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	ds:required_mon_width, 5

loc_8000497:				; CODE XREF: abmon_init+C7j
		mov	eax, ds:required_mon_width
		mov	[ebp+curr_max_width], eax
		mov	ds:required_mon_width, 0
		mov	[ebp+i], 0
		jmp	short loc_8000530
; ---------------------------------------------------------------------------

loc_80004B2:				; CODE XREF: abmon_init+B9j
		mov	eax, [ebp+curr_max_width]
		mov	[ebp+width], eax
		mov	eax, [ebp+i]
		imul	eax, 0A1h
		lea	ebx, abmon[eax]
		mov	eax, [ebp+i]
		add	eax, 2000Eh
		sub	esp, 0Ch
		push	eax		; item
		call	nl_langinfo
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		push	0
		push	0
		lea	eax, [ebp+width]
		push	eax
		push	0A1h
		push	ebx
		push	edx
		call	mbsalign
		add	esp, 20h
		mov	[ebp+req], eax
		cmp	[ebp+req], 0FFFFFFFFh
		jz	short loc_8000509
		cmp	[ebp+req], 0A0h
		jbe	short loc_800051A

loc_8000509:				; CODE XREF: abmon_init+83j
		mov	ds:required_mon_width, 0
		mov	eax, ds:required_mon_width
		jmp	short loc_800054D
; ---------------------------------------------------------------------------

loc_800051A:				; CODE XREF: abmon_init+8Cj
		mov	edx, [ebp+width]
		mov	eax, ds:required_mon_width
		cmp	edx, eax
		cmovnb	eax, edx
		mov	ds:required_mon_width, eax
		add	[ebp+i], 1

loc_8000530:				; CODE XREF: abmon_init+35j
		cmp	[ebp+i], 0Bh
		jle	loc_80004B2
		mov	eax, ds:required_mon_width
		cmp	[ebp+curr_max_width], eax
		ja	loc_8000497
		mov	eax, ds:required_mon_width

loc_800054D:				; CODE XREF: abmon_init+9Dj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800055E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800055E:				; CODE XREF: abmon_init+DCj
		mov	ebx, [ebp+var_4]
		leave
		retn
abmon_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl dev_ino_hash(const void *x, size_t table_size)
dev_ino_hash	proc near		; DATA XREF: main+2C8o

p		= dword	ptr -0Ch
var_4		= dword	ptr -4
x		= dword	ptr  8
table_size	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+x]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+table_size]
		mov	ebx, 0
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	__umoddi3
		add	esp, 10h
		mov	ebx, [ebp+var_4]
		leave
		retn
dev_ino_hash	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	dev_ino_compare(const void *x, const void *y)
dev_ino_compare	proc near		; DATA XREF: main+2C3o

a		= dword	ptr -10h
b		= dword	ptr -0Ch
x		= dword	ptr  8
y		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+x]
		mov	[ebp+a], eax
		mov	eax, [ebp+y]
		mov	[ebp+b], eax
		mov	eax, [ebp+a]
		mov	ecx, [eax]
		mov	ebx, [eax+4]
		mov	eax, [ebp+b]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_80005E6
		mov	eax, [ebp+a]
		mov	ecx, [eax+8]
		mov	ebx, [eax+0Ch]
		mov	eax, [ebp+b]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_80005E6
		mov	eax, 1
		jmp	short loc_80005EB
; ---------------------------------------------------------------------------

loc_80005E6:				; CODE XREF: dev_ino_compare+2Ej
					; dev_ino_compare+4Cj
		mov	eax, 0

loc_80005EB:				; CODE XREF: dev_ino_compare+53j
		and	eax, 1
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
dev_ino_compare	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl dev_ino_free(void *x)
dev_ino_free	proc near		; CODE XREF: main+5D9p
					; DATA XREF: main+2BEo

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+x]		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
dev_ino_free	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	visit_dir(dev_t	dev, ino_t ino)
visit_dir	proc near		; CODE XREF: print_dir+167p

ino		= qword	ptr -28h
dev		= qword	ptr -20h
found_match	= byte ptr -11h
ent		= dword	ptr -10h
ent_from_table	= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+dev], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+dev+4], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+ino], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+ino+4], eax
		sub	esp, 0Ch
		push	10h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+ent], eax
		mov	ecx, [ebp+ent]
		mov	eax, dword ptr [ebp+ino]
		mov	edx, dword ptr [ebp+ino+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	ecx, [ebp+ent]
		mov	eax, dword ptr [ebp+dev]
		mov	edx, dword ptr [ebp+dev+4]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		mov	eax, ds:active_dir_set
		sub	esp, 8
		push	[ebp+ent]
		push	eax
		call	hash_insert
		add	esp, 10h
		mov	[ebp+ent_from_table], eax
		cmp	[ebp+ent_from_table], 0
		jnz	short loc_8000679
		call	xalloc_die

loc_8000679:				; CODE XREF: visit_dir+66j
		mov	eax, [ebp+ent_from_table]
		cmp	eax, [ebp+ent]
		setnz	al
		mov	[ebp+found_match], al
		cmp	[ebp+found_match], 0
		jz	short loc_8000699
		sub	esp, 0Ch
		push	[ebp+ent]	; ptr
		call	free
		add	esp, 10h

loc_8000699:				; CODE XREF: visit_dir+7Dj
		movzx	eax, [ebp+found_match]
		leave
		retn
visit_dir	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl free_pending_ent(pending	*p)
free_pending_ent proc near		; CODE XREF: main+5EAp	main+629p

p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
free_pending_ent endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_colored(indicator_no	type)
is_colored	proc near		; CODE XREF: main+101p	main+112p ...

len		= dword	ptr -10h
s		= dword	ptr -0Ch
type		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+type]
		mov	eax, color_indicator[eax*8]
		mov	[ebp+len], eax
		mov	eax, [ebp+type]
		mov	eax, off_8007D84[eax*8]
		mov	[ebp+s], eax
		cmp	[ebp+len], 0
		jz	short loc_800073D
		cmp	[ebp+len], 1
		jnz	short loc_8000717
		mov	eax, [ebp+s]
		movzx	edx, byte ptr [eax]
		mov	eax, offset byte_8008C29
		movzx	eax, byte ptr [eax]
		cmp	dl, al
		jz	short loc_800073D

loc_8000717:				; CODE XREF: is_colored+2Aj
		cmp	[ebp+len], 2
		jnz	short loc_8000736
		sub	esp, 4
		push	2		; n
		push	offset a00	; "00"
		push	[ebp+s]		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800073D

loc_8000736:				; CODE XREF: is_colored+42j
		mov	eax, 1
		jmp	short loc_8000742
; ---------------------------------------------------------------------------

loc_800073D:				; CODE XREF: is_colored+24j
					; is_colored+3Cj ...
		mov	eax, 0

loc_8000742:				; CODE XREF: is_colored+62j
		and	eax, 1
		leave
		retn
is_colored	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void restore_default_color()
restore_default_color proc near		; CODE XREF: process_signals+24p
					; main+65Fp
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset color_indicator ; ind
		call	put_indicator
		add	esp, 10h
		sub	esp, 0Ch
		push	offset ind	; ind
		call	put_indicator
		add	esp, 10h
		nop
		leave
		retn
restore_default_color endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sighandler(int sig)
sighandler	proc near		; DATA XREF: main:loc_8000AD1o

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, ds:interrupt_signal
		test	eax, eax
		jnz	short loc_8000784
		mov	eax, [ebp+sig]
		mov	ds:interrupt_signal, eax

loc_8000784:				; CODE XREF: sighandler+Aj
		nop
		pop	ebp
		retn
sighandler	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl stophandler(int sig)
stophandler	proc near		; DATA XREF: main+233o

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, ds:interrupt_signal
		test	eax, eax
		jnz	short loc_80007A0
		mov	eax, ds:stop_signal_count
		add	eax, 1
		mov	ds:stop_signal_count, eax

loc_80007A0:				; CODE XREF: stophandler+Aj
		nop
		pop	ebp
		retn
stophandler	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void process_signals()
process_signals	proc near		; CODE XREF: print_name_with_quoting+16Bp

sig		= dword	ptr -94h
stops		= dword	ptr -90h
oldset		= sigset_t ptr -8Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 98h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_8000869
; ---------------------------------------------------------------------------

loc_80007BC:				; CODE XREF: process_signals+CDj
					; process_signals+DAj
		movzx	eax, ds:used_color
		test	al, al
		jz	short loc_80007CC
		call	restore_default_color

loc_80007CC:				; CODE XREF: process_signals+22j
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		sub	esp, 4
		lea	eax, [ebp+oldset]
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		mov	eax, ds:interrupt_signal
		mov	[ebp+sig], eax
		mov	eax, ds:stop_signal_count
		mov	[ebp+stops], eax
		cmp	[ebp+stops], 0
		jz	short loc_800082F
		mov	eax, [ebp+stops]
		sub	eax, 1
		mov	ds:stop_signal_count, eax
		mov	[ebp+sig], 13h
		jmp	short loc_8000842
; ---------------------------------------------------------------------------

loc_800082F:				; CODE XREF: process_signals+70j
		sub	esp, 8
		push	0		; handler
		push	[ebp+sig]	; sig
		call	signal
		add	esp, 10h

loc_8000842:				; CODE XREF: process_signals+8Aj
		sub	esp, 0Ch
		push	[ebp+sig]	; sig
		call	raise
		add	esp, 10h
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+oldset]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h

loc_8000869:				; CODE XREF: process_signals+14j
		mov	eax, ds:interrupt_signal
		test	eax, eax
		jnz	loc_80007BC
		mov	eax, ds:stop_signal_count
		test	eax, eax
		jnz	loc_80007BC
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000895
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000895:				; CODE XREF: process_signals+EBj
		leave
		retn
process_signals	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0DCh
i		= dword	ptr -0D0h
j		= dword	ptr -0CCh
j_0		= dword	ptr -0C8h
n_files		= dword	ptr -0C4h
thispend	= dword	ptr -0C0h
found		= dword	ptr -0BCh
di_0		= dev_ino ptr -0B8h
act		= sigaction ptr	-0A8h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0D8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:exit_status,	0
		mov	ds:print_dir_name, 1
		mov	ds:pending_dirs, 0
		mov	ds:current_time.tv_sec,	80000000h
		mov	ds:current_time.tv_nsec, 0FFFFFFFFh
		sub	esp, 8
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	decode_switches
		add	esp, 10h
		mov	[ebp+i], eax
		movzx	eax, ds:print_with_color
		test	al, al
		jz	short loc_8000984
		call	parse_ls_color

loc_8000984:				; CODE XREF: main+E6j
		movzx	eax, ds:print_with_color
		test	al, al
		jz	loc_8000B0E
		sub	esp, 0Ch
		push	0Dh		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jnz	short loc_80009DA
		sub	esp, 0Ch
		push	0Eh		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_80009C0
		movzx	eax, ds:color_symlink_as_referent
		test	al, al
		jnz	short loc_80009DA

loc_80009C0:				; CODE XREF: main+11Cj
		sub	esp, 0Ch
		push	0Ch		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_80009E1
		mov	eax, ds:format_0
		test	eax, eax
		jnz	short loc_80009E1

loc_80009DA:				; CODE XREF: main+10Bj	main+127j
		mov	ds:check_symlink_color,	1

loc_80009E1:				; CODE XREF: main+138j	main+141j
		sub	esp, 0Ch
		push	1		; fd
		call	tcgetpgrp
		add	esp, 10h
		test	eax, eax
		js	loc_8000B0E
		sub	esp, 0Ch
		push	offset caught_signals ;	set
		call	sigemptyset
		add	esp, 10h
		mov	[ebp+j], 0
		jmp	short loc_8000A64
; ---------------------------------------------------------------------------

loc_8000A12:				; CODE XREF: main+1D4j
		mov	eax, [ebp+j]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 4
		lea	edx, [ebp+act]
		push	edx		; oact
		push	0		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h
		mov	eax, dword ptr [ebp+act.__sigaction_handler]
		cmp	eax, 1
		jz	short loc_8000A5D
		mov	eax, [ebp+j]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigaddset
		add	esp, 10h

loc_8000A5D:				; CODE XREF: main+1A6j
		add	[ebp+j], 1

loc_8000A64:				; CODE XREF: main+179j
		cmp	[ebp+j], 0Bh
		jle	short loc_8000A12
		lea	eax, [ebp+act.sa_mask]
		mov	esi, offset caught_signals
		mov	edx, 20h
		mov	edi, eax
		mov	ecx, edx
		rep movsd
		mov	[ebp+act.sa_flags], 10000000h
		mov	[ebp+j], 0
		jmp	short loc_8000B05
; ---------------------------------------------------------------------------

loc_8000A96:				; CODE XREF: main+275j
		mov	eax, [ebp+j]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000AFE
		mov	eax, [ebp+j]
		mov	eax, ds:sig_6984[eax*4]
		cmp	eax, 14h
		jnz	short loc_8000AD1
		mov	eax, offset stophandler
		jmp	short loc_8000AD6
; ---------------------------------------------------------------------------

loc_8000AD1:				; CODE XREF: main+231j
		mov	eax, offset sighandler

loc_8000AD6:				; CODE XREF: main+238j
		mov	dword ptr [ebp+act.__sigaction_handler], eax
		mov	eax, [ebp+j]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 4
		push	0		; oact
		lea	edx, [ebp+act]
		push	edx		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h

loc_8000AFE:				; CODE XREF: main+21Fj
		add	[ebp+j], 1

loc_8000B05:				; CODE XREF: main+1FDj
		cmp	[ebp+j], 0Bh
		jle	short loc_8000A96

loc_8000B0E:				; CODE XREF: main+F6j main+159j
		mov	eax, ds:dereference
		cmp	eax, 1
		jnz	short loc_8000B47
		movzx	eax, ds:immediate_dirs
		test	al, al
		jnz	short loc_8000B36
		mov	eax, ds:indicator_style_0
		cmp	eax, 3
		jz	short loc_8000B36
		mov	eax, ds:format_0
		test	eax, eax
		jnz	short loc_8000B3D

loc_8000B36:				; CODE XREF: main+28Aj	main+294j
		mov	eax, 2
		jmp	short loc_8000B42
; ---------------------------------------------------------------------------

loc_8000B3D:				; CODE XREF: main+29Dj
		mov	eax, 4

loc_8000B42:				; CODE XREF: main+2A4j
		mov	ds:dereference,	eax

loc_8000B47:				; CODE XREF: main+27Fj
		movzx	eax, ds:recursive
		test	al, al
		jz	short loc_8000BA1
		sub	esp, 0Ch
		push	offset dev_ino_free
		push	offset dev_ino_compare
		push	offset dev_ino_hash
		push	0
		push	1Eh
		call	hash_initialize
		add	esp, 20h
		mov	ds:active_dir_set, eax
		mov	eax, ds:active_dir_set
		test	eax, eax
		jnz	short loc_8000B83
		call	xalloc_die

loc_8000B83:				; CODE XREF: main+2E5j
		sub	esp, 0Ch
		push	offset free	; void (*)(void	*)
		push	offset malloc	; void *(*)(__int32)
		push	0		; int
		push	0		; int
		push	offset dev_ino_obstack ; struct	obstack	*
		call	_obstack_begin
		add	esp, 20h

loc_8000BA1:				; CODE XREF: main+2B9j
		mov	eax, ds:sort_type_0
		cmp	eax, 4
		jz	short loc_8000BD4
		mov	eax, ds:sort_type_0
		cmp	eax, 2
		jz	short loc_8000BD4
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8000BD4
		movzx	eax, ds:print_scontext
		test	al, al
		jnz	short loc_8000BD4
		movzx	eax, ds:print_block_size
		test	al, al
		jz	short loc_8000BDB

loc_8000BD4:				; CODE XREF: main+312j	main+31Cj ...
		mov	eax, 1
		jmp	short loc_8000BE0
; ---------------------------------------------------------------------------

loc_8000BDB:				; CODE XREF: main+33Bj
		mov	eax, 0

loc_8000BE0:				; CODE XREF: main+342j
		and	eax, 1
		mov	ds:format_needs_stat, al
		movzx	eax, ds:format_needs_stat
		xor	eax, 1
		test	al, al
		jz	short loc_8000C27
		movzx	eax, ds:recursive
		test	al, al
		jnz	short loc_8000C20
		movzx	eax, ds:print_with_color
		test	al, al
		jnz	short loc_8000C20
		mov	eax, ds:indicator_style_0
		test	eax, eax
		jnz	short loc_8000C20
		movzx	eax, ds:directories_first
		test	al, al
		jz	short loc_8000C27

loc_8000C20:				; CODE XREF: main+368j	main+373j ...
		mov	eax, 1
		jmp	short loc_8000C2C
; ---------------------------------------------------------------------------

loc_8000C27:				; CODE XREF: main+35Dj	main+387j
		mov	eax, 0

loc_8000C2C:				; CODE XREF: main+38Ej
		and	eax, 1
		mov	ds:format_needs_type, al
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8000C7B
		sub	esp, 0Ch
		push	offset free	; void (*)(void	*)
		push	offset malloc	; void *(*)(__int32)
		push	0		; int
		push	0		; int
		push	offset dired_obstack ; struct obstack *
		call	_obstack_begin
		add	esp, 20h
		sub	esp, 0Ch
		push	offset free	; void (*)(void	*)
		push	offset malloc	; void *(*)(__int32)
		push	0		; int
		push	0		; int
		push	offset subdired_obstack	; struct obstack *
		call	_obstack_begin
		add	esp, 20h

loc_8000C7B:				; CODE XREF: main+3A6j
		mov	ds:cwd_n_alloc,	64h
		mov	eax, ds:cwd_n_alloc
		sub	esp, 8
		push	80h
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	ds:cwd_file, eax
		mov	ds:cwd_n_used, 0
		call	clear_files
		mov	eax, [ebx]
		sub	eax, [ebp+i]
		mov	[ebp+n_files], eax
		cmp	[ebp+n_files], 0
		jg	short loc_8000D06
		movzx	eax, ds:immediate_dirs
		test	al, al
		jz	short loc_8000CF0
		sub	esp, 8
		push	offset locale	; dirname
		push	1		; command_line_arg
		push	0
		push	0		; inode
		push	3		; type
		push	offset name	; "."
		call	gobble_file
		add	esp, 20h
		jmp	short loc_8000D49
; ---------------------------------------------------------------------------

loc_8000CF0:				; CODE XREF: main+438j
		sub	esp, 4
		push	1		; command_line_arg
		push	0		; realname
		push	offset name	; "."
		call	queue_directory
		add	esp, 10h
		jmp	short loc_8000D49
; ---------------------------------------------------------------------------

loc_8000D06:				; CODE XREF: main+42Dj	main+4B0j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset locale	; dirname
		push	1		; command_line_arg
		push	0
		push	0		; inode
		push	0		; type
		push	eax		; name
		call	gobble_file
		add	esp, 20h
		mov	eax, [ebp+i]
		cmp	eax, [ebx]
		jl	short loc_8000D06

loc_8000D49:				; CODE XREF: main+457j	main+46Dj
		mov	eax, ds:cwd_n_used
		test	eax, eax
		jz	short loc_8000D74
		call	sort_files
		movzx	eax, ds:immediate_dirs
		xor	eax, 1
		test	al, al
		jz	short loc_8000D74
		sub	esp, 8
		push	1		; command_line_arg
		push	0		; dirname
		call	extract_dirs_from_files
		add	esp, 10h

loc_8000D74:				; CODE XREF: main+4B9j	main+4CCj
		mov	eax, ds:cwd_n_used
		test	eax, eax
		jz	short loc_8000DAE
		call	print_current_files
		mov	eax, ds:pending_dirs
		test	eax, eax
		jz	loc_8000ECF
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax
		jmp	loc_8000ECF
; ---------------------------------------------------------------------------

loc_8000DAE:				; CODE XREF: main+4E4j
		cmp	[ebp+n_files], 1
		jg	loc_8000ECF
		mov	eax, ds:pending_dirs
		test	eax, eax
		jz	loc_8000ECF
		mov	eax, ds:pending_dirs
		mov	eax, [eax+0Ch]
		test	eax, eax
		jnz	loc_8000ECF
		mov	ds:print_dir_name, 0
		jmp	loc_8000ECF
; ---------------------------------------------------------------------------

loc_8000DE4:				; CODE XREF: main+63Fj
		mov	eax, ds:pending_dirs
		mov	[ebp+thispend],	eax
		mov	eax, ds:pending_dirs
		mov	eax, [eax+0Ch]
		mov	ds:pending_dirs, eax
		mov	eax, ds:active_dir_set
		test	eax, eax
		jz	loc_8000E8B
		mov	eax, [ebp+thispend]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8000E8B
		lea	eax, [ebp+di_0]
		sub	esp, 0Ch
		push	eax		; retstr
		call	dev_ino_pop
		add	esp, 0Ch
		mov	eax, ds:active_dir_set
		sub	esp, 8
		lea	edx, [ebp+di_0]
		push	edx
		push	eax
		call	hash_delete
		add	esp, 10h
		mov	[ebp+found], eax
		cmp	[ebp+found], 0
		jnz	short loc_8000E67
		push	offset __PRETTY_FUNCTION___6987	; "main"
		push	592h		; line
		push	offset file	; "ls.c"
		push	offset aFound	; "found"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000E67:				; CODE XREF: main+5B5j
		sub	esp, 0Ch
		push	[ebp+found]	; x
		call	dev_ino_free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+thispend]	; p
		call	free_pending_ent
		add	esp, 10h
		jmp	short loc_8000ECF
; ---------------------------------------------------------------------------

loc_8000E8B:				; CODE XREF: main+56Cj	main+57Cj
		mov	eax, [ebp+thispend]
		movzx	eax, byte ptr [eax+8]
		movzx	ecx, al
		mov	eax, [ebp+thispend]
		mov	edx, [eax+4]
		mov	eax, [ebp+thispend]
		mov	eax, [eax]
		sub	esp, 4
		push	ecx		; command_line_arg
		push	edx		; realname
		push	eax		; name
		call	print_dir
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+thispend]	; p
		call	free_pending_ent
		add	esp, 10h
		mov	ds:print_dir_name, 1

loc_8000ECF:				; CODE XREF: main+4F2j	main+512j ...
		mov	eax, ds:pending_dirs
		test	eax, eax
		jnz	loc_8000DE4
		movzx	eax, ds:print_with_color
		test	al, al
		jz	loc_8000FB4
		movzx	eax, ds:used_color
		test	al, al
		jz	short loc_8000EFB
		call	restore_default_color

loc_8000EFB:				; CODE XREF: main+65Dj
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		mov	[ebp+j_0], 0
		jmp	short loc_8000F5C
; ---------------------------------------------------------------------------

loc_8000F18:				; CODE XREF: main+6CCj
		mov	eax, [ebp+j_0]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000F55
		mov	eax, [ebp+j_0]
		mov	eax, ds:sig_6984[eax*4]
		sub	esp, 8
		push	0		; handler
		push	eax		; sig
		call	signal
		add	esp, 10h

loc_8000F55:				; CODE XREF: main+6A1j
		add	[ebp+j_0], 1

loc_8000F5C:				; CODE XREF: main+67Fj
		cmp	[ebp+j_0], 0Bh
		jle	short loc_8000F18
		mov	eax, ds:stop_signal_count
		mov	[ebp+j_0], eax
		jmp	short loc_8000F86
; ---------------------------------------------------------------------------

loc_8000F72:				; CODE XREF: main+6F6j
		sub	esp, 0Ch
		push	13h		; sig
		call	raise
		add	esp, 10h
		sub	[ebp+j_0], 1

loc_8000F86:				; CODE XREF: main+6D9j
		cmp	[ebp+j_0], 0
		jnz	short loc_8000F72
		mov	eax, ds:interrupt_signal
		mov	[ebp+j_0], eax
		cmp	[ebp+j_0], 0
		jz	short loc_8000FB4
		sub	esp, 0Ch
		push	[ebp+j_0]	; sig
		call	raise
		add	esp, 10h

loc_8000FB4:				; CODE XREF: main+64Ej	main+70Aj
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8001012
		sub	esp, 8
		push	offset dired_obstack ; os
		push	offset prefix	; "//DIRED//"
		call	dired_dump_obstack
		add	esp, 10h
		sub	esp, 8
		push	offset subdired_obstack	; os
		push	offset aSubdired ; "//SUBDIRED//"
		call	dired_dump_obstack
		add	esp, 10h
		mov	eax, ds:filename_quoting_options
		sub	esp, 0Ch
		push	eax
		call	get_quoting_style
		add	esp, 10h
		mov	eax, ds:quoting_style_args[eax*4]
		sub	esp, 8
		push	eax
		push	offset aDiredOptionsQu ; "//DIRED-OPTIONS// --quoting-style=%s\n"
		call	printf
		add	esp, 10h

loc_8001012:				; CODE XREF: main+726j
		mov	eax, ds:active_dir_set
		test	eax, eax
		jz	short loc_800105A
		mov	eax, ds:active_dir_set
		sub	esp, 0Ch
		push	eax
		call	hash_get_n_entries
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001049
		push	offset __PRETTY_FUNCTION___6987	; "main"
		push	5C9h		; line
		push	offset file	; "ls.c"
		push	offset aHash_get_n_ent ; "hash_get_n_entries (active_dir_set) == "...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001049:				; CODE XREF: main+797j
		mov	eax, ds:active_dir_set
		sub	esp, 0Ch
		push	eax
		call	hash_free
		add	esp, 10h

loc_800105A:				; CODE XREF: main+782j
		mov	eax, ds:exit_status
		sub	esp, 0Ch
		push	eax		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl decode_switches(int argc,	char **argv)
decode_switches	proc near		; CODE XREF: main+CFp

argv		= dword	ptr -6Ch
sort_type_specified= byte ptr -59h
oi		= dword	ptr -58h
time_style_option= dword ptr -54h
i_0		= dword	ptr -50h
p_1		= dword	ptr -4Ch
style		= dword	ptr -48h
p1		= dword	ptr -44h
i_1		= dword	ptr -40h
q_style		= dword	ptr -3Ch
i		= dword	ptr -38h
ls_block_size	= dword	ptr -34h
p		= dword	ptr -30h
p_0		= dword	ptr -2Ch
c		= dword	ptr -28h
hide		= dword	ptr -24h
e		= dword	ptr -20h
p0		= dword	ptr -1Ch
locale_format	= dword	ptr -18h
tmp_ulong	= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 74h
		mov	eax, [ebp+arg_4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+time_style_option], 0
		mov	[ebp+sort_type_specified], 0
		mov	ds:qmark_funny_chars, 0
		mov	eax, ds:ls_mode
		cmp	eax, 2
		jz	short loc_80010A8
		cmp	eax, 3
		jz	short loc_80010C3
		cmp	eax, 1
		jz	short loc_80010DE
		jmp	short loc_8001115
; ---------------------------------------------------------------------------

loc_80010A8:				; CODE XREF: decode_switches+32j
		mov	ds:format_0, 2
		sub	esp, 8
		push	5
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	short loc_800111A
; ---------------------------------------------------------------------------

loc_80010C3:				; CODE XREF: decode_switches+37j
		mov	ds:format_0, 0
		sub	esp, 8
		push	5
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	short loc_800111A
; ---------------------------------------------------------------------------

loc_80010DE:				; CODE XREF: decode_switches+3Cj
		sub	esp, 0Ch
		push	1		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001102
		mov	ds:format_0, 2
		mov	ds:qmark_funny_chars, 1
		jmp	short loc_800111A
; ---------------------------------------------------------------------------

loc_8001102:				; CODE XREF: decode_switches+85j
		mov	ds:format_0, 1
		mov	ds:qmark_funny_chars, 0
		jmp	short loc_800111A
; ---------------------------------------------------------------------------

loc_8001115:				; CODE XREF: decode_switches+3Ej
		call	abort
; ---------------------------------------------------------------------------

loc_800111A:				; CODE XREF: decode_switches+59j
					; decode_switches+74j ...
		mov	ds:time_type_0,	0
		mov	ds:sort_type_0,	0
		mov	ds:sort_reverse, 0
		mov	ds:numeric_ids,	0
		mov	ds:print_block_size, 0
		mov	ds:indicator_style_0, 0
		mov	ds:print_inode,	0
		mov	ds:dereference,	1
		mov	ds:recursive, 0
		mov	ds:immediate_dirs, 0
		mov	ds:ignore_mode,	0
		mov	ds:ignore_patterns, 0
		mov	ds:hide_patterns, 0
		mov	ds:print_scontext, 0
		sub	esp, 0Ch
		push	offset aQuoting_style ;	"QUOTING_STYLE"
		call	getenv
		add	esp, 10h
		mov	[ebp+q_style], eax
		cmp	[ebp+q_style], 0
		jz	short loc_8001212
		push	4
		push	offset quoting_style_vals
		push	offset quoting_style_args
		push	[ebp+q_style]
		call	argmatch
		add	esp, 10h
		mov	[ebp+i], eax
		cmp	[ebp+i], 0
		js	short loc_80011E4
		mov	eax, [ebp+i]
		mov	eax, ds:quoting_style_vals[eax*4]
		sub	esp, 8
		push	eax
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	short loc_8001212
; ---------------------------------------------------------------------------

loc_80011E4:				; CODE XREF: decode_switches+160j
		sub	esp, 0Ch
		push	[ebp+q_style]
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aIgnoringInvali ; "ignoring invalid value of environment	v"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001212:				; CODE XREF: decode_switches+140j
					; decode_switches+17Aj
		sub	esp, 0Ch
		push	offset aLs_block_size ;	"LS_BLOCK_SIZE"
		call	getenv
		add	esp, 10h
		mov	[ebp+ls_block_size], eax
		sub	esp, 4
		push	offset output_block_size
		push	offset human_output_opts
		push	[ebp+ls_block_size]
		call	human_options
		add	esp, 10h
		cmp	[ebp+ls_block_size], 0
		jnz	short loc_8001257
		sub	esp, 0Ch
		push	offset aBlock_size ; "BLOCK_SIZE"
		call	getenv
		add	esp, 10h
		test	eax, eax
		jz	short loc_800126D

loc_8001257:				; CODE XREF: decode_switches+1D9j
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	dword ptr file_output_block_size, eax
		mov	dword ptr file_output_block_size+4, edx

loc_800126D:				; CODE XREF: decode_switches+1EDj
		mov	ds:line_length,	50h
		sub	esp, 0Ch
		push	offset aColumns	; "COLUMNS"
		call	getenv
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jz	short loc_80012F5
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80012F5
		sub	esp, 0Ch
		push	0
		lea	eax, [ebp+tmp_ulong]
		push	eax
		push	0
		push	0
		push	[ebp+p]
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_80012C7
		mov	eax, [ebp+tmp_ulong]
		test	eax, eax
		jz	short loc_80012C7
		mov	eax, [ebp+tmp_ulong]
		mov	ds:line_length,	eax
		jmp	short loc_80012F5
; ---------------------------------------------------------------------------

loc_80012C7:				; CODE XREF: decode_switches+24Cj
					; decode_switches+253j
		sub	esp, 0Ch
		push	[ebp+p]
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aIgnoringInva_0 ; "ignoring invalid width in environment	v"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80012F5:				; CODE XREF: decode_switches+226j
					; decode_switches+230j	...
		sub	esp, 4
		lea	eax, [ebp+tmp_ulong]
		push	eax
		push	5413h		; request
		push	1		; fd
		call	ioctl
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8001325
		movzx	eax, word ptr [ebp+tmp_ulong+2]
		test	ax, ax
		jz	short loc_8001325
		movzx	eax, word ptr [ebp+tmp_ulong+2]
		movzx	eax, ax
		mov	ds:line_length,	eax

loc_8001325:				; CODE XREF: decode_switches+2A6j
					; decode_switches+2AFj
		sub	esp, 0Ch
		push	offset aTabsize	; "TABSIZE"
		call	getenv
		add	esp, 10h
		mov	[ebp+p_0], eax
		mov	ds:tabsize, 8
		cmp	[ebp+p_0], 0
		jz	short loc_800139C
		sub	esp, 0Ch
		push	0
		lea	eax, [ebp+tmp_ulong]
		push	eax
		push	0
		push	0
		push	[ebp+p_0]
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_800136E
		mov	eax, [ebp+tmp_ulong]
		mov	ds:tabsize, eax
		jmp	short loc_800139C
; ---------------------------------------------------------------------------

loc_800136E:				; CODE XREF: decode_switches+2FAj
		sub	esp, 0Ch
		push	[ebp+p_0]
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aIgnoringInva_1 ; "ignoring invalid tab size in environmen"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800139C:				; CODE XREF: decode_switches+2DEj
					; decode_switches+304j	...
		mov	[ebp+oi], 0FFFFFFFFh
		sub	esp, 0Ch
		lea	eax, [ebp+oi]
		push	eax		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:"...
		push	[ebp+argv]	; argv
		push	[ebp+argc]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_80013DE
		mov	eax, ds:line_length
		cmp	eax, 2
		ja	loc_8001B62
		jmp	loc_8001B74
; ---------------------------------------------------------------------------

loc_80013DE:				; CODE XREF: decode_switches+361j
		mov	eax, [ebp+c]
		add	eax, 83h	; switch 275 cases
		cmp	eax, 112h
		ja	loc_8001B46	; jumptable 080013F8 default case
		mov	eax, ds:off_80095C8[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80013FA:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:ignore_mode,	2 ; jumptable 080013F8 case 97
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001409:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 8		; jumptable 080013F8 case 98
		push	5
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800141D:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:time_type_0,	1 ; jumptable 080013F8 case 99
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800142C:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:immediate_dirs, 1 ; jumptable 080013F8 case 100
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001438:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:ignore_mode,	2 ; jumptable 080013F8 case 102
		mov	ds:sort_type_0,	0FFFFFFFFh
		mov	[ebp+sort_type_specified], 1
		mov	eax, ds:format_0
		test	eax, eax
		jnz	short loc_800147B
		sub	esp, 0Ch
		push	1		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001471
		mov	eax, 2
		jmp	short loc_8001476
; ---------------------------------------------------------------------------

loc_8001471:				; CODE XREF: decode_switches+400j
		mov	eax, 1

loc_8001476:				; CODE XREF: decode_switches+407j
		mov	ds:format_0, eax

loc_800147B:				; CODE XREF: decode_switches+3EFj
		mov	ds:print_block_size, 0
		mov	ds:print_with_color, 0
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800148E:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:indicator_style_0, 2	; jumptable 080013F8 case 132
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800149D:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 0	; jumptable 080013F8 case 103
		mov	print_owner, 0
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80014B3:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:human_output_opts, 0B0h ; jumptable 080013F8	case 104
		mov	dword ptr ds:output_block_size,	1
		mov	dword ptr ds:output_block_size+4, 0
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	dword ptr file_output_block_size, eax
		mov	dword ptr file_output_block_size+4, edx
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80014EC:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:print_inode,	1 ; jumptable 080013F8 case 105
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80014F8:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:human_output_opts, 0	; jumptable 080013F8 case 107
		mov	dword ptr ds:output_block_size,	400h
		mov	dword ptr ds:output_block_size+4, 0
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	dword ptr file_output_block_size, eax
		mov	dword ptr file_output_block_size+4, edx
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001531:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 0	; jumptable 080013F8 case 108
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001540:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 4	; jumptable 080013F8 case 109
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800154F:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:numeric_ids,	1 ; jumptable 080013F8 case 110
		mov	ds:format_0, 0
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001565:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 0	; jumptable 080013F8 case 111
		mov	print_group, 0
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800157B:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:indicator_style_0, 1	; jumptable 080013F8 case 112
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_800158A:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:qmark_funny_chars, 1	; jumptable 080013F8 case 113
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001596:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_reverse, 1 ; jumptable 080013F8	case 114
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80015A2:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:print_block_size, 1 ; jumptable 080013F8 case 115
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80015AE:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_type_0,	4 ; jumptable 080013F8 case 116
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80015C1:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:time_type_0,	2 ; jumptable 080013F8 case 117
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80015D0:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_type_0,	3 ; jumptable 080013F8 case 118
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80015E3:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 119
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+tmp_ulong]
		push	edx
		push	0
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8001609
		mov	eax, [ebp+tmp_ulong]
		test	eax, eax
		jnz	short loc_800163A

loc_8001609:				; CODE XREF: decode_switches+598j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidLineWid ; "invalid line width: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_800163A:				; CODE XREF: decode_switches+59Fj
		mov	eax, [ebp+tmp_ulong]
		mov	ds:line_length,	eax
		nop
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001648:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 3	; jumptable 080013F8 case 120
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001657:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:ignore_mode ; jumptable	080013F8 case 65
		test	eax, eax
		jnz	loc_8001B50
		mov	ds:ignore_mode,	1
		jmp	loc_8001B50
; ---------------------------------------------------------------------------

loc_8001673:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 0Ch	; jumptable 080013F8 case 66
		push	offset pattern	; "*~"
		call	add_ignore_pattern
		add	esp, 10h
		sub	esp, 0Ch
		push	offset a__0	; ".*~"
		call	add_ignore_pattern
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001698:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 2	; jumptable 080013F8 case 67
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016A7:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:dired, 1	; jumptable 080013F8 case 68
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016B3:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:indicator_style_0, 3	; jumptable 080013F8 case 70
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016C2:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	print_group, 0	; jumptable 080013F8 case 71
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016CE:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:dereference,	3 ; jumptable 080013F8 case 72
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016DD:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:dereference,	4 ; jumptable 080013F8 case 131
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80016EC:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 73
		sub	esp, 0Ch
		push	eax		; pattern
		call	add_ignore_pattern
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001702:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:dereference,	5 ; jumptable 080013F8 case 76
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001711:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 8		; jumptable 080013F8 case 78
		push	0
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001725:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 8		; jumptable 080013F8 case 81
		push	3
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001739:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:recursive, 1	; jumptable 080013F8 case 82
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001745:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_type_0,	2 ; jumptable 080013F8 case 83
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001758:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 84
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+tmp_ulong]
		push	edx
		push	0
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jz	short loc_80017A8
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidTabSize ; "invalid tab size: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_80017A8:				; CODE XREF: decode_switches+70Dj
		mov	eax, [ebp+tmp_ulong]
		mov	ds:tabsize, eax
		nop
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80017B6:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_type_0,	0FFFFFFFFh ; jumptable 080013F8	case 85
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80017C9:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:sort_type_0,	1 ; jumptable 080013F8 case 88
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80017DC:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:format_0 ; jumptable 080013F8 case 49
		test	eax, eax
		jz	loc_8001B56
		mov	ds:format_0, 1
		jmp	loc_8001B56
; ---------------------------------------------------------------------------

loc_80017F8:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:print_author, 1 ; jumptable 080013F8	case 128
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001804:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 0Ch	; jumptable 080013F8 case 136
		push	8		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+hide], eax
		mov	edx, ds:optarg
		mov	eax, [ebp+hide]
		mov	[eax], edx
		mov	edx, ds:hide_patterns
		mov	eax, [ebp+hide]
		mov	[eax+4], edx
		mov	eax, [ebp+hide]
		mov	ds:hide_patterns, eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001838:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	edx, ds:argmatch_die ; jumptable 080013F8 case 141
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset sort_types
		push	offset sort_args
		push	eax
		push	offset aSort	; "--sort"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:sort_types[eax*4]
		mov	ds:sort_type_0,	eax
		mov	[ebp+sort_type_specified], 1
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001876:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:directories_first, 1	; jumptable 080013F8 case 135
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001882:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	edx, ds:argmatch_die ; jumptable 080013F8 case 142
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset time_types
		push	offset time_args
		push	eax
		push	offset aTime	; "--time"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:time_types[eax*4]
		mov	ds:time_type_0,	eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80018BC:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	edx, ds:argmatch_die ; jumptable 080013F8 case 133
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset format_types
		push	offset format_args
		push	eax
		push	offset aFormat	; "--format"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:format_types[eax*4]
		mov	ds:format_0, eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80018F6:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:format_0, 0	; jumptable 080013F8 case 134
		sub	esp, 0Ch
		push	offset s	; "full-iso"
		call	bad_cast
		add	esp, 10h
		mov	[ebp+time_style_option], eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001918:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 130
		test	eax, eax
		jz	short loc_8001956
		mov	edx, ds:argmatch_die
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset color_types
		push	offset color_args
		push	eax
		push	offset aColor	; "--color"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:color_types[eax*4]
		mov	[ebp+i_0], eax
		jmp	short loc_800195D
; ---------------------------------------------------------------------------

loc_8001956:				; CODE XREF: decode_switches+8B7j
		mov	[ebp+i_0], 1

loc_800195D:				; CODE XREF: decode_switches+8ECj
		cmp	[ebp+i_0], 1
		jz	short loc_800197A
		cmp	[ebp+i_0], 2
		jnz	short loc_8001981
		sub	esp, 0Ch
		push	1		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001981

loc_800197A:				; CODE XREF: decode_switches+8F9j
		mov	eax, 1
		jmp	short loc_8001986
; ---------------------------------------------------------------------------

loc_8001981:				; CODE XREF: decode_switches+8FFj
					; decode_switches+910j
		mov	eax, 0

loc_8001986:				; CODE XREF: decode_switches+917j
		and	eax, 1
		mov	ds:print_with_color, al
		movzx	eax, ds:print_with_color
		test	al, al
		jz	loc_8001B5C
		mov	ds:tabsize, 0
		jmp	loc_8001B5C
; ---------------------------------------------------------------------------

loc_80019AC:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	edx, ds:argmatch_die ; jumptable 080013F8 case 137
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset indicator_style_types
		push	offset indicator_style_args
		push	eax
		push	offset aIndicatorStyle ; "--indicator-style"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:indicator_style_types[eax*4]
		mov	ds:indicator_style_0, eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_80019E6:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	edx, ds:argmatch_die ; jumptable 080013F8 case 138
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset quoting_style_vals
		push	offset quoting_style_args
		push	eax
		push	offset aQuotingStyle ; "--quoting-style"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:quoting_style_vals[eax*4]
		sub	esp, 8
		push	eax
		push	0
		call	set_quoting_style
		add	esp, 10h
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001A29:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 143
		mov	[ebp+time_style_option], eax
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001A36:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:qmark_funny_chars, 0	; jumptable 080013F8 case 139
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001A42:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	eax, ds:optarg	; jumptable 080013F8 case 129
		sub	esp, 4
		push	offset output_block_size
		push	offset human_output_opts
		push	eax
		call	human_options
		add	esp, 10h
		mov	[ebp+e], eax
		cmp	[ebp+e], 0
		jz	short loc_8001A83
		mov	edx, ds:optarg
		mov	eax, [ebp+oi]
		sub	esp, 0Ch
		push	edx
		push	offset long_options
		push	0
		push	eax
		push	[ebp+e]
		call	xstrtol_fatal

loc_8001A83:				; CODE XREF: decode_switches+9FCj
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	dword ptr file_output_block_size, eax
		mov	dword ptr file_output_block_size+4, edx
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001A9E:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:human_output_opts, 90h ; jumptable 080013F8 case 140
		mov	dword ptr ds:output_block_size,	1
		mov	dword ptr ds:output_block_size+4, 0
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	dword ptr file_output_block_size, eax
		mov	dword ptr file_output_block_size+4, edx
		jmp	loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001AD7:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ds:print_scontext, 1 ; jumptable 080013F8 case 90
		jmp	short loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001AE0:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		sub	esp, 0Ch	; jumptable 080013F8 case -130
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001AEA:				; CODE XREF: decode_switches+390j
					; DATA XREF: .rodata:off_80095C8o
		mov	ecx, ds:Version	; jumptable 080013F8 case -131
		mov	eax, ds:ls_mode
		cmp	eax, 1
		jz	short loc_8001B12
		mov	eax, ds:ls_mode
		cmp	eax, 2
		jnz	short loc_8001B0B
		mov	eax, offset aDir ; "dir"
		jmp	short loc_8001B17
; ---------------------------------------------------------------------------

loc_8001B0B:				; CODE XREF: decode_switches+A9Aj
		mov	eax, offset aVdir ; "vdir"
		jmp	short loc_8001B17
; ---------------------------------------------------------------------------

loc_8001B12:				; CODE XREF: decode_switches+A90j
		mov	eax, offset aLs	; "ls"

loc_8001B17:				; CODE XREF: decode_switches+AA1j
					; decode_switches+AA8j
		mov	edx, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aRichardM_Stall ; "Richard M. Stallman"
		push	ecx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax
		push	edx
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001B46:				; CODE XREF: decode_switches+383j
					; decode_switches+390j
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 080013F8 default case
		push	2		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001B50:				; CODE XREF: decode_switches+5F6j
					; decode_switches+606j
		nop
		jmp	loc_800139C
; ---------------------------------------------------------------------------

loc_8001B56:				; CODE XREF: decode_switches+77Bj
					; decode_switches+78Bj
		nop
		jmp	loc_800139C
; ---------------------------------------------------------------------------

loc_8001B5C:				; CODE XREF: decode_switches+92Fj
					; decode_switches+93Fj
		nop

loc_8001B5D:				; CODE XREF: decode_switches+39Cj
					; decode_switches+3B0j	...
		jmp	loc_800139C
; ---------------------------------------------------------------------------

loc_8001B62:				; CODE XREF: decode_switches+36Bj
		mov	eax, ds:line_length
		mov	edx, 0AAAAAAABh
		mul	edx
		mov	eax, edx
		shr	eax, 1
		jmp	short loc_8001B79
; ---------------------------------------------------------------------------

loc_8001B74:				; CODE XREF: decode_switches+371j
		mov	eax, 1

loc_8001B79:				; CODE XREF: decode_switches+B0Aj
		mov	ds:max_idx, eax
		sub	esp, 0Ch
		push	0
		call	clone_quoting_options
		add	esp, 10h
		mov	ds:filename_quoting_options, eax
		mov	eax, ds:filename_quoting_options
		sub	esp, 0Ch
		push	eax
		call	get_quoting_style
		add	esp, 10h
		cmp	eax, 5
		jnz	short loc_8001BBB
		mov	eax, ds:filename_quoting_options
		sub	esp, 4
		push	1
		push	20h
		push	eax
		call	set_char_quoting
		add	esp, 10h

loc_8001BBB:				; CODE XREF: decode_switches+B3Cj
		mov	eax, ds:indicator_style_0
		cmp	eax, 1
		jbe	short loc_8001C02
		mov	eax, ds:indicator_style_0
		sub	eax, 2
		add	eax, offset a@	; "*=>@|"
		mov	[ebp+p_1], eax
		jmp	short loc_8001BF8
; ---------------------------------------------------------------------------

loc_8001BD7:				; CODE XREF: decode_switches+B98j
		mov	eax, [ebp+p_1]
		movzx	eax, byte ptr [eax]
		movsx	edx, al
		mov	eax, ds:filename_quoting_options
		sub	esp, 4
		push	1
		push	edx
		push	eax
		call	set_char_quoting
		add	esp, 10h
		add	[ebp+p_1], 1

loc_8001BF8:				; CODE XREF: decode_switches+B6Dj
		mov	eax, [ebp+p_1]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8001BD7

loc_8001C02:				; CODE XREF: decode_switches+B5Bj
		sub	esp, 0Ch
		push	0
		call	clone_quoting_options
		add	esp, 10h
		mov	ds:dirname_quoting_options, eax
		mov	eax, ds:dirname_quoting_options
		sub	esp, 4
		push	1
		push	3Ah
		push	eax
		call	set_char_quoting
		add	esp, 10h
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8001C44
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8001C44
		mov	ds:dired, 0

loc_8001C44:				; CODE XREF: decode_switches+BCAj
					; decode_switches+BD3j
		mov	eax, ds:time_type_0
		cmp	eax, 1
		jz	short loc_8001C58
		mov	eax, ds:time_type_0
		cmp	eax, 2
		jnz	short loc_8001C76

loc_8001C58:				; CODE XREF: decode_switches+BE4j
		movzx	eax, [ebp+sort_type_specified]
		xor	eax, 1
		test	al, al
		jz	short loc_8001C76
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8001C76
		mov	ds:sort_type_0,	4

loc_8001C76:				; CODE XREF: decode_switches+BEEj
					; decode_switches+BF9j	...
		mov	eax, ds:format_0
		test	eax, eax
		jnz	loc_8001EDC
		mov	eax, [ebp+time_style_option]
		mov	[ebp+style], eax
		cmp	[ebp+style], 0
		jnz	short loc_8001CDF
		sub	esp, 0Ch
		push	offset aTime_style ; "TIME_STYLE"
		call	getenv
		add	esp, 10h
		mov	[ebp+style], eax
		cmp	[ebp+style], 0
		jnz	short loc_8001CDF
		sub	esp, 0Ch
		push	offset aLocale	; "locale"
		call	bad_cast
		add	esp, 10h
		mov	[ebp+style], eax
		jmp	short loc_8001CDF
; ---------------------------------------------------------------------------

loc_8001CBD:				; CODE XREF: decode_switches+C8Ej
		sub	esp, 0Ch
		push	2
		call	hard_locale
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001CDB
		mov	eax, ds:optind
		jmp	loc_8001EE1
; ---------------------------------------------------------------------------

loc_8001CDB:				; CODE XREF: decode_switches+C67j
		add	[ebp+style], 6

loc_8001CDF:				; CODE XREF: decode_switches+C25j
					; decode_switches+C3Ej	...
		sub	esp, 4
		push	6		; n
		push	offset posix_prefix_7109 ; "posix-"
		push	[ebp+style]	; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001CBD
		mov	eax, [ebp+style]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	loc_8001D97
		mov	eax, [ebp+style]
		add	eax, 1
		mov	[ebp+p0], eax
		sub	esp, 8
		push	0Ah		; c
		push	[ebp+p0]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+p1], eax
		cmp	[ebp+p1], 0
		jnz	short loc_8001D30
		mov	eax, [ebp+p0]
		mov	[ebp+p1], eax
		jmp	short loc_8001D82
; ---------------------------------------------------------------------------

loc_8001D30:				; CODE XREF: decode_switches+CBEj
		mov	eax, [ebp+p1]
		add	eax, 1
		sub	esp, 8
		push	0Ah		; c
		push	eax		; s
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001D76
		sub	esp, 0Ch
		push	[ebp+p0]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidTimeSty ; "invalid time style format %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8001D76:				; CODE XREF: decode_switches+CDEj
		mov	eax, [ebp+p1]
		lea	edx, [eax+1]
		mov	[ebp+p1], edx
		mov	byte ptr [eax],	0

loc_8001D82:				; CODE XREF: decode_switches+CC6j
		mov	eax, [ebp+p0]
		mov	long_time_format, eax
		mov	eax, [ebp+p1]
		mov	long_time_format+4, eax
		jmp	loc_8001E7F
; ---------------------------------------------------------------------------

loc_8001D97:				; CODE XREF: decode_switches+C98j
		mov	eax, ds:argmatch_die
		sub	esp, 8
		push	eax
		push	4
		push	offset time_style_types
		push	offset time_style_args
		push	[ebp+style]
		push	offset aTimeStyle ; "time style"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:time_style_types[eax*4]
		cmp	eax, 1
		jz	short case_long_iso_time_style
		cmp	eax, 1
		jb	short loc_8001DDC
		cmp	eax, 2
		jz	short loc_8001E0C
		cmp	eax, 3
		jz	short loc_8001E22
		jmp	loc_8001E7F
; ---------------------------------------------------------------------------

loc_8001DDC:				; CODE XREF: decode_switches+D63j
		mov	long_time_format+4, offset aYMDHMS_NZ ;	"%Y-%m-%d %H:%M:%S.%N %z"
		mov	eax, long_time_format+4
		mov	long_time_format, eax
		jmp	loc_8001E7F
; ---------------------------------------------------------------------------

loc_8001DF5:				; CODE XREF: decode_switches+DFEj
		nop

case_long_iso_time_style:		; CODE XREF: decode_switches+D5Ej
		mov	long_time_format+4, offset aYMDHM ; "%Y-%m-%d %H:%M"
		mov	eax, long_time_format+4
		mov	long_time_format, eax
		jmp	short loc_8001E7F
; ---------------------------------------------------------------------------

loc_8001E0C:				; CODE XREF: decode_switches+D68j
		mov	long_time_format, offset aYMD ;	"%Y-%m-%d "
		mov	long_time_format+4, offset aMDHM ; "%m-%d %H:%M"
		jmp	short loc_8001E7F
; ---------------------------------------------------------------------------

loc_8001E22:				; CODE XREF: decode_switches+D6Dj
		sub	esp, 0Ch
		push	2
		call	hard_locale
		add	esp, 10h
		test	al, al
		jz	short loc_8001E7F
		mov	[ebp+i_1], 0
		jmp	short loc_8001E79
; ---------------------------------------------------------------------------

loc_8001E3C:				; CODE XREF: decode_switches+E15j
		mov	eax, [ebp+i_1]
		mov	eax, long_time_format[eax*4]
		sub	esp, 4
		push	2		; category
		push	eax		; msgid
		push	0		; domainname
		call	dcgettext
		add	esp, 10h
		mov	[ebp+locale_format], eax
		mov	eax, [ebp+i_1]
		mov	eax, long_time_format[eax*4]
		cmp	eax, [ebp+locale_format]
		jz	short loc_8001DF5
		mov	eax, [ebp+i_1]
		mov	edx, [ebp+locale_format]
		mov	long_time_format[eax*4], edx
		add	[ebp+i_1], 1

loc_8001E79:				; CODE XREF: decode_switches+DD2j
		cmp	[ebp+i_1], 1
		jle	short loc_8001E3C

loc_8001E7F:				; CODE XREF: decode_switches+D2Aj
					; decode_switches+D6Fj	...
		mov	eax, long_time_format
		sub	esp, 8
		push	offset needle	; "%b"
		push	eax		; haystack
		call	strstr
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001EB3
		mov	eax, long_time_format+4
		sub	esp, 8
		push	offset needle	; "%b"
		push	eax		; haystack
		call	strstr
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001EDC

loc_8001EB3:				; CODE XREF: decode_switches+E2Fj
		call	abmon_init
		test	eax, eax
		jnz	short loc_8001EDC
		sub	esp, 0Ch
		push	offset aErrorInitializ ; "error	initializing month strings"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001EDC:				; CODE XREF: decode_switches+C15j
					; decode_switches+E49j	...
		mov	eax, ds:optind

loc_8001EE1:				; CODE XREF: decode_switches+C6Ej
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8001EF2
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001EF2:				; CODE XREF: decode_switches+E83j
		mov	ebx, [ebp+var_4]
		leave
		retn
decode_switches	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	get_funky_string(char **dest, const char **src,	_Bool equals_end, size_t *output_count)
get_funky_string proc near		; CODE XREF: parse_ls_color+114p
					; parse_ls_color+1ECp ...

equals_end	= byte ptr -2Ch
num		= byte ptr -19h
count		= dword	ptr -18h
state		= dword	ptr -14h
p		= dword	ptr -10h
q		= dword	ptr -0Ch
dest		= dword	ptr  8
src		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
output_count	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_8]
		mov	[ebp+equals_end], al
		mov	eax, [ebp+src]
		mov	eax, [eax]
		mov	[ebp+p], eax
		mov	eax, [ebp+dest]
		mov	eax, [eax]
		mov	[ebp+q], eax
		mov	[ebp+count], 0
		mov	[ebp+num], 0
		mov	[ebp+state], 0
		jmp	loc_80021BE
; ---------------------------------------------------------------------------

loc_8001F2A:				; CODE XREF: get_funky_string+2CBj
		cmp	[ebp+state], 4	; switch 5 cases
		ja	loc_80021B9	; jumptable 08001F41 default case
		mov	eax, [ebp+state]
		shl	eax, 2
		add	eax, offset off_8009A14
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001F43:				; CODE XREF: get_funky_string+4Aj
					; DATA XREF: .rodata:off_8009A14o
		mov	eax, [ebp+p]	; jumptable 08001F41 case 0
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 3Dh
		jz	short loc_8001F90
		cmp	eax, 3Dh
		jg	short loc_8001F61
		test	eax, eax
		jz	short loc_8001F6D
		cmp	eax, 3Ah
		jz	short loc_8001F6D
		jmp	short loc_8001F9F
; ---------------------------------------------------------------------------

loc_8001F61:				; CODE XREF: get_funky_string+5Dj
		cmp	eax, 5Ch
		jz	short loc_8001F76
		cmp	eax, 5Eh
		jz	short loc_8001F83
		jmp	short loc_8001F9F
; ---------------------------------------------------------------------------

loc_8001F6D:				; CODE XREF: get_funky_string+61j
					; get_funky_string+66j
		mov	[ebp+state], 5
		jmp	short loc_8001FBB
; ---------------------------------------------------------------------------

loc_8001F76:				; CODE XREF: get_funky_string+6Dj
		mov	[ebp+state], 1
		add	[ebp+p], 1
		jmp	short loc_8001FBB
; ---------------------------------------------------------------------------

loc_8001F83:				; CODE XREF: get_funky_string+72j
		mov	[ebp+state], 4
		add	[ebp+p], 1
		jmp	short loc_8001FBB
; ---------------------------------------------------------------------------

loc_8001F90:				; CODE XREF: get_funky_string+58j
		cmp	[ebp+equals_end], 0
		jz	short loc_8001F9F
		mov	[ebp+state], 5
		jmp	short loc_8001FBB
; ---------------------------------------------------------------------------

loc_8001F9F:				; CODE XREF: get_funky_string+68j
					; get_funky_string+74j	...
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	edx, [ebp+p]
		lea	ecx, [edx+1]
		mov	[ebp+p], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		add	[ebp+count], 1
		nop

loc_8001FBB:				; CODE XREF: get_funky_string+7Dj
					; get_funky_string+8Aj	...
		jmp	loc_80021BE
; ---------------------------------------------------------------------------

loc_8001FC0:				; CODE XREF: get_funky_string+4Aj
					; DATA XREF: .rodata:off_8009A14o
		mov	eax, [ebp+p]	; jumptable 08001F41 case 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 78h	; switch 121 cases
		ja	short loc_800203E ; jumptable 08001FD5 default case
		mov	eax, ds:off_8009A28[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001FD7:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+state], 2	; jumptable 08001FD5 cases 48-55
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		sub	eax, 30h
		mov	[ebp+num], al
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8001FEC:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+state], 3	; jumptable 08001FD5 cases 88,120
		mov	[ebp+num], 0
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8001FF9:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 7	; jumptable 08001FD5 case 97
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8001FFF:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 8	; jumptable 08001FD5 case 98
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002005:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 1Bh	; jumptable 08001FD5 case 101
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_800200B:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 0Ch	; jumptable 08001FD5 case 102
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002011:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 0Ah	; jumptable 08001FD5 case 110
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002017:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 0Dh	; jumptable 08001FD5 case 114
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_800201D:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 9	; jumptable 08001FD5 case 116
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002023:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 0Bh	; jumptable 08001FD5 case 118
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002029:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 7Fh	; jumptable 08001FD5 case 63
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_800202F:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+num], 20h	; jumptable 08001FD5 case 95
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_8002035:				; CODE XREF: get_funky_string+DEj
					; DATA XREF: .rodata:off_8009A28o
		mov	[ebp+state], 6	; jumptable 08001FD5 case 0
		jmp	short loc_8002048
; ---------------------------------------------------------------------------

loc_800203E:				; CODE XREF: get_funky_string+D5j
					; get_funky_string+DEj
					; DATA XREF: ...
		mov	eax, [ebp+p]	; jumptable 08001FD5 default case
		movzx	eax, byte ptr [eax]
		mov	[ebp+num], al
		nop

loc_8002048:				; CODE XREF: get_funky_string+F3j
					; get_funky_string+100j ...
		cmp	[ebp+state], 1
		jnz	short loc_8002068
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		movzx	edx, [ebp+num]
		mov	[eax], dl
		add	[ebp+count], 1
		mov	[ebp+state], 0

loc_8002068:				; CODE XREF: get_funky_string+155j
		add	[ebp+p], 1
		jmp	loc_80021BE
; ---------------------------------------------------------------------------

loc_8002071:				; CODE XREF: get_funky_string+4Aj
					; DATA XREF: .rodata:off_8009A14o
		mov	eax, [ebp+p]	; jumptable 08001F41 case 2
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jle	short loc_8002085
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 37h
		jle	short loc_80020A1

loc_8002085:				; CODE XREF: get_funky_string+182j
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		movzx	edx, [ebp+num]
		mov	[eax], dl
		add	[ebp+count], 1
		mov	[ebp+state], 0
		jmp	short loc_80020C0
; ---------------------------------------------------------------------------

loc_80020A1:				; CODE XREF: get_funky_string+18Cj
		movzx	eax, [ebp+num]
		lea	ecx, ds:0[eax*8]
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		add	eax, ecx
		sub	eax, 30h
		mov	[ebp+num], al

loc_80020C0:				; CODE XREF: get_funky_string+1A8j
		jmp	loc_80021BE
; ---------------------------------------------------------------------------

loc_80020C5:				; CODE XREF: get_funky_string+4Aj
					; DATA XREF: .rodata:off_8009A14o
		mov	eax, [ebp+p]	; jumptable 08001F41 case 3
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h	; switch 55 cases
		cmp	eax, 36h
		ja	short loc_800213C ; jumptable 080020DD default case
		mov	eax, ds:off_8009C0C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80020DF:				; CODE XREF: get_funky_string+1E6j
					; DATA XREF: .rodata:off_8009C0Co
		movzx	eax, [ebp+num]	; jumptable 080020DD cases 48-57
		shl	eax, 4
		mov	ecx, eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		add	eax, ecx
		sub	eax, 30h
		mov	[ebp+num], al
		jmp	short loc_8002157
; ---------------------------------------------------------------------------

loc_80020FE:				; CODE XREF: get_funky_string+1E6j
					; DATA XREF: .rodata:off_8009C0Co
		movzx	eax, [ebp+num]	; jumptable 080020DD cases 97-102
		shl	eax, 4
		mov	ecx, eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		add	eax, ecx
		sub	eax, 57h
		mov	[ebp+num], al
		jmp	short loc_8002157
; ---------------------------------------------------------------------------

loc_800211D:				; CODE XREF: get_funky_string+1E6j
					; DATA XREF: .rodata:off_8009C0Co
		movzx	eax, [ebp+num]	; jumptable 080020DD cases 65-70
		shl	eax, 4
		mov	ecx, eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		add	eax, ecx
		sub	eax, 37h
		mov	[ebp+num], al
		jmp	short loc_8002157
; ---------------------------------------------------------------------------

loc_800213C:				; CODE XREF: get_funky_string+1DDj
					; get_funky_string+1E6j
					; DATA XREF: ...
		mov	eax, [ebp+q]	; jumptable 080020DD default case
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		movzx	edx, [ebp+num]
		mov	[eax], dl
		add	[ebp+count], 1
		mov	[ebp+state], 0
		nop

loc_8002157:				; CODE XREF: get_funky_string+205j
					; get_funky_string+224j ...
		jmp	short loc_80021BE
; ---------------------------------------------------------------------------

loc_8002159:				; CODE XREF: get_funky_string+4Aj
					; DATA XREF: .rodata:off_8009A14o
		mov	[ebp+state], 0	; jumptable 08001F41 case 4
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 3Fh
		jle	short loc_8002194
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 7Fh
		jz	short loc_8002194
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	edx, [ebp+p]
		lea	ecx, [edx+1]
		mov	[ebp+p], ecx
		movzx	edx, byte ptr [edx]
		and	edx, 1Fh
		mov	[eax], dl
		add	[ebp+count], 1
		jmp	short loc_80021B7
; ---------------------------------------------------------------------------

loc_8002194:				; CODE XREF: get_funky_string+271j
					; get_funky_string+27Bj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 3Fh
		jnz	short loc_80021B0
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	byte ptr [eax],	7Fh
		add	[ebp+count], 1
		jmp	short loc_80021BE
; ---------------------------------------------------------------------------

loc_80021B0:				; CODE XREF: get_funky_string+2A5j
		mov	[ebp+state], 6

loc_80021B7:				; CODE XREF: get_funky_string+29Bj
		jmp	short loc_80021BE
; ---------------------------------------------------------------------------

loc_80021B9:				; CODE XREF: get_funky_string+37j
		call	abort		; jumptable 08001F41 default case
; ---------------------------------------------------------------------------

loc_80021BE:				; CODE XREF: get_funky_string+2Ej
					; get_funky_string:loc_8001FBBj ...
		cmp	[ebp+state], 4
		jbe	loc_8001F2A
		mov	eax, [ebp+dest]
		mov	edx, [ebp+q]
		mov	[eax], edx
		mov	eax, [ebp+src]
		mov	edx, [ebp+p]
		mov	[eax], edx
		mov	eax, [ebp+output_count]
		mov	edx, [ebp+count]
		mov	[eax], edx
		cmp	[ebp+state], 6
		setnz	al
		leave
		retn
get_funky_string endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void parse_ls_color()
parse_ls_color	proc near		; CODE XREF: main+E8p

p		= dword	ptr -2Ch
buf		= dword	ptr -28h
state		= dword	ptr -24h
ind_no		= dword	ptr -20h
ext		= dword	ptr -1Ch
e		= dword	ptr -18h
e2		= dword	ptr -14h
label		= byte ptr -0Fh
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aLs_colors ; "LS_COLORS"
		call	getenv
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		test	eax, eax
		jz	loc_8002532
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	loc_8002532
		mov	[ebp+ext], 0
		mov	word ptr [ebp+label], 3F3Fh
		mov	[ebp+label+2], 0
		mov	eax, [ebp+p]
		sub	esp, 0Ch
		push	eax		; char *
		call	xstrdup
		add	esp, 10h
		mov	ds:color_buf, eax
		mov	eax, ds:color_buf
		mov	[ebp+buf], eax
		mov	[ebp+state], 1
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_8002260:				; CODE XREF: parse_ls_color+2A9j
		mov	eax, [ebp+state]
		cmp	eax, 2
		jz	loc_800233F
		cmp	eax, 2
		jg	short loc_800227B
		cmp	eax, 1
		jz	short loc_8002292
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_800227B:				; CODE XREF: parse_ls_color+86j
		cmp	eax, 3
		jz	loc_8002370
		cmp	eax, 4
		jz	loc_800243F
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_8002292:				; CODE XREF: parse_ls_color+8Bj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 2Ah
		jz	short loc_80022B9
		cmp	eax, 3Ah
		jz	short loc_80022AB
		test	eax, eax
		jz	short loc_800231A
		jmp	short loc_8002323
; ---------------------------------------------------------------------------

loc_80022AB:				; CODE XREF: parse_ls_color+BAj
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+p], eax
		jmp	loc_800233A
; ---------------------------------------------------------------------------

loc_80022B9:				; CODE XREF: parse_ls_color+B5j
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+ext], eax
		mov	edx, ds:color_ext_list
		mov	eax, [ebp+ext]
		mov	[eax+10h], edx
		mov	eax, [ebp+ext]
		mov	ds:color_ext_list, eax
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+p], eax
		mov	edx, [ebp+buf]
		mov	eax, [ebp+ext]
		mov	[eax+4], edx
		mov	eax, [ebp+ext]
		push	eax		; output_count
		push	1		; equals_end
		lea	eax, [ebp+p]
		push	eax		; src
		lea	eax, [ebp+buf]
		push	eax		; dest
		call	get_funky_string
		add	esp, 10h
		test	al, al
		jz	short loc_8002310
		mov	eax, 4
		jmp	short loc_8002315
; ---------------------------------------------------------------------------

loc_8002310:				; CODE XREF: parse_ls_color+11Ej
		mov	eax, 0FFFFFFFFh

loc_8002315:				; CODE XREF: parse_ls_color+125j
		mov	[ebp+state], eax
		jmp	short loc_800233A
; ---------------------------------------------------------------------------

loc_800231A:				; CODE XREF: parse_ls_color+BEj
		mov	[ebp+state], 0
		jmp	short loc_800233A
; ---------------------------------------------------------------------------

loc_8002323:				; CODE XREF: parse_ls_color+C0j
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+label], al
		mov	[ebp+state], 2
		nop

loc_800233A:				; CODE XREF: parse_ls_color+CBj
					; parse_ls_color+12Fj ...
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_800233F:				; CODE XREF: parse_ls_color+7Dj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8002364
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+label+1], al
		mov	[ebp+state], 3
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_8002364:				; CODE XREF: parse_ls_color+15Ej
		mov	[ebp+state], 0FFFFFFFFh
		jmp	loc_800248E
; ---------------------------------------------------------------------------

loc_8002370:				; CODE XREF: parse_ls_color+95j
		mov	[ebp+state], 0FFFFFFFFh
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		cmp	al, 3Dh
		jnz	loc_800248E
		mov	[ebp+ind_no], 0
		jmp	short loc_80023F6
; ---------------------------------------------------------------------------

loc_8002394:				; CODE XREF: parse_ls_color+219j
		mov	eax, [ebp+ind_no]
		mov	eax, ds:indicator_name[eax*4]
		sub	esp, 8
		push	eax		; s2
		lea	eax, [ebp+label]
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80023F2
		mov	edx, [ebp+buf]
		mov	eax, [ebp+ind_no]
		mov	off_8007D84[eax*8], edx
		mov	eax, [ebp+ind_no]
		shl	eax, 3
		add	eax, offset color_indicator
		push	eax		; output_count
		push	0		; equals_end
		lea	eax, [ebp+p]
		push	eax		; src
		lea	eax, [ebp+buf]
		push	eax		; dest
		call	get_funky_string
		add	esp, 10h
		test	al, al
		jz	short loc_80023E8
		mov	eax, 1
		jmp	short loc_80023ED
; ---------------------------------------------------------------------------

loc_80023E8:				; CODE XREF: parse_ls_color+1F6j
		mov	eax, 0FFFFFFFFh

loc_80023ED:				; CODE XREF: parse_ls_color+1FDj
		mov	[ebp+state], eax
		jmp	short loc_8002404
; ---------------------------------------------------------------------------

loc_80023F2:				; CODE XREF: parse_ls_color+1C7j
		add	[ebp+ind_no], 1

loc_80023F6:				; CODE XREF: parse_ls_color+1A9j
		mov	eax, [ebp+ind_no]
		mov	eax, ds:indicator_name[eax*4]
		test	eax, eax
		jnz	short loc_8002394

loc_8002404:				; CODE XREF: parse_ls_color+207j
		cmp	[ebp+state], 0FFFFFFFFh
		jnz	loc_800248E
		sub	esp, 0Ch
		lea	eax, [ebp+label]
		push	eax
		call	quotearg
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aUnrecognizedPr ; "unrecognized prefix: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_800248E
; ---------------------------------------------------------------------------

loc_800243F:				; CODE XREF: parse_ls_color+9Ej
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		cmp	al, 3Dh
		jnz	short loc_8002486
		mov	edx, [ebp+buf]
		mov	eax, [ebp+ext]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+ext]
		add	eax, 8
		push	eax		; output_count
		push	0		; equals_end
		lea	eax, [ebp+p]
		push	eax		; src
		lea	eax, [ebp+buf]
		push	eax		; dest
		call	get_funky_string
		add	esp, 10h
		test	al, al
		jz	short loc_800247C
		mov	eax, 1
		jmp	short loc_8002481
; ---------------------------------------------------------------------------

loc_800247C:				; CODE XREF: parse_ls_color+28Aj
		mov	eax, 0FFFFFFFFh

loc_8002481:				; CODE XREF: parse_ls_color+291j
		mov	[ebp+state], eax
		jmp	short loc_800248D
; ---------------------------------------------------------------------------

loc_8002486:				; CODE XREF: parse_ls_color+264j
		mov	[ebp+state], 0FFFFFFFFh

loc_800248D:				; CODE XREF: parse_ls_color+29Bj
		nop

loc_800248E:				; CODE XREF: parse_ls_color+72j
					; parse_ls_color+8Dj ...
		cmp	[ebp+state], 0
		jg	loc_8002260
		cmp	[ebp+state], 0
		jns	short loc_8002503
		sub	esp, 0Ch
		push	offset aUnparsableValu ; "unparsable value for LS_COLORS environm"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, ds:color_buf
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:color_ext_list
		mov	[ebp+e], eax
		jmp	short loc_80024F6
; ---------------------------------------------------------------------------

loc_80024D9:				; CODE XREF: parse_ls_color+311j
		mov	eax, [ebp+e]
		mov	[ebp+e2], eax
		mov	eax, [ebp+e]
		mov	eax, [eax+10h]
		mov	[ebp+e], eax
		sub	esp, 0Ch
		push	[ebp+e2]	; ptr
		call	free
		add	esp, 10h

loc_80024F6:				; CODE XREF: parse_ls_color+2EEj
		cmp	[ebp+e], 0
		jnz	short loc_80024D9
		mov	ds:print_with_color, 0

loc_8002503:				; CODE XREF: parse_ls_color+2B3j
		mov	eax, dword_8007DB8
		cmp	eax, 6
		jnz	short loc_8002533
		mov	eax, s1
		sub	esp, 4
		push	6		; n
		push	offset aTarget	; "target"
		push	eax		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002533
		mov	ds:color_symlink_as_referent, 1
		jmp	short loc_8002533
; ---------------------------------------------------------------------------

loc_8002532:				; CODE XREF: parse_ls_color+2Aj
					; parse_ls_color+38j
		nop

loc_8002533:				; CODE XREF: parse_ls_color+322j
					; parse_ls_color+33Ej ...
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002544
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002544:				; CODE XREF: parse_ls_color+354j
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_ls_color	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_exit_status(_Bool serious)
set_exit_status	proc near		; CODE XREF: file_failure+3Bp
					; print_dir+1BAp ...

serious		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+serious], al
		cmp	[ebp+serious], 0
		jz	short loc_8002567
		mov	ds:exit_status,	2
		jmp	short loc_800257A
; ---------------------------------------------------------------------------

loc_8002567:				; CODE XREF: set_exit_status+10j
		mov	eax, ds:exit_status
		test	eax, eax
		jnz	short loc_800257A
		mov	ds:exit_status,	1

loc_800257A:				; CODE XREF: set_exit_status+1Cj
					; set_exit_status+25j
		nop
		leave
		retn
set_exit_status	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl file_failure(_Bool serious, const char *message,	const char *file)
file_failure	proc near		; CODE XREF: print_dir+93p
					; print_dir+12Dp ...

serious		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
message		= dword	ptr  0Ch
file		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	[ebp+serious], al
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	[ebp+message]	; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		movzx	eax, [ebp+serious]
		sub	esp, 0Ch
		push	eax		; serious
		call	set_exit_status
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
file_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl queue_directory(const char *name, const char *realname, _Bool command_line_arg)
queue_directory	proc near		; CODE XREF: main+465p
					; extract_dirs_from_files+2Fp ...

command_line_arg= byte ptr -1Ch
new		= dword	ptr -0Ch
name		= dword	ptr  8
realname	= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_8]
		mov	[ebp+command_line_arg],	al
		sub	esp, 0Ch
		push	10h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		cmp	[ebp+realname],	0
		jz	short loc_80025FA
		sub	esp, 0Ch
		push	[ebp+realname]	; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_80025FF
; ---------------------------------------------------------------------------

loc_80025FA:				; CODE XREF: queue_directory+20j
		mov	edx, 0

loc_80025FF:				; CODE XREF: queue_directory+32j
		mov	eax, [ebp+new]
		mov	[eax+4], edx
		cmp	[ebp+name], 0
		jz	short loc_800261D
		sub	esp, 0Ch
		push	[ebp+name]	; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_8002622
; ---------------------------------------------------------------------------

loc_800261D:				; CODE XREF: queue_directory+43j
		mov	edx, 0

loc_8002622:				; CODE XREF: queue_directory+55j
		mov	eax, [ebp+new]
		mov	[eax], edx
		mov	eax, [ebp+new]
		movzx	edx, [ebp+command_line_arg]
		mov	[eax+8], dl
		mov	edx, ds:pending_dirs
		mov	eax, [ebp+new]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+new]
		mov	ds:pending_dirs, eax
		nop
		leave
		retn
queue_directory	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_dir(const char *name, const char *realname, _Bool command_line_arg)
print_dir	proc near		; CODE XREF: main+618p

command_line_arg= byte ptr -344h
realname	= dword	ptr -340h
name		= dword	ptr -33Ch
type		= dword	ptr -330h
dirp		= dword	ptr -32Ch
fd		= dword	ptr -328h
__o		= dword	ptr -324h
__len		= dword	ptr -320h
di_0		= dword	ptr -31Ch
__o_0		= dword	ptr -318h
__len_0		= dword	ptr -314h
__o_1		= dword	ptr -310h
__len_1		= dword	ptr -30Ch
next		= dword	ptr -308h
p		= dword	ptr -304h
total_blocks	= qword	ptr -300h
dir_stat	= stat ptr -2F8h
buf		= byte ptr -298h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 344h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+name], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+realname],	edx
		mov	[ebp+command_line_arg],	al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	dword ptr [ebp+total_blocks], 0
		mov	dword ptr [ebp+total_blocks+4],	0
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 0Ch
		push	[ebp+name]	; name
		call	opendir
		add	esp, 10h
		mov	[ebp+dirp], eax
		cmp	[ebp+dirp], 0
		jnz	short loc_80026E8
		sub	esp, 0Ch
		push	offset aCannotOpenDire ; "cannot open directory	%s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+name]	; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h
		jmp	loc_8002E0A
; ---------------------------------------------------------------------------

loc_80026E8:				; CODE XREF: print_dir+6Dj
		mov	eax, ds:active_dir_set
		test	eax, eax
		jz	loc_80028B2
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	dirfd
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		js	short loc_8002732
		sub	esp, 8
		lea	eax, [ebp+dir_stat]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		shr	eax, 1Fh
		jmp	short loc_800274D
; ---------------------------------------------------------------------------

loc_8002732:				; CODE XREF: print_dir+CBj
		sub	esp, 8
		lea	eax, [ebp+dir_stat]
		push	eax
		push	[ebp+name]
		call	stat64
		add	esp, 10h
		shr	eax, 1Fh

loc_800274D:				; CODE XREF: print_dir+E8j
		test	al, al
		jz	short loc_8002793
		sub	esp, 0Ch
		push	offset aCannotDetermin ; "cannot determine device and inode of %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+name]	; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		jmp	loc_8002E0A
; ---------------------------------------------------------------------------

loc_8002793:				; CODE XREF: print_dir+107j
		mov	ecx, dword ptr [ebp+dir_stat.st_ino]
		mov	ebx, dword ptr [ebp+dir_stat.st_ino+4]
		mov	eax, dword ptr [ebp+dir_stat.st_dev]
		mov	edx, dword ptr [ebp+dir_stat.st_dev+4]
		push	ebx
		push	ecx		; ino
		push	edx
		push	eax		; dev
		call	visit_dir
		add	esp, 10h
		test	al, al
		jz	short loc_8002810
		sub	esp, 0Ch
		push	[ebp+name]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSNotListingAlr ; "%s: not listing already-listed director"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; serious
		call	set_exit_status
		add	esp, 10h
		nop
		jmp	loc_8002E0A
; ---------------------------------------------------------------------------

loc_8002810:				; CODE XREF: print_dir+171j
		mov	[ebp+__o], offset dev_ino_obstack
		mov	[ebp+__len], 10h
		mov	eax, [ebp+__o]
		mov	eax, [eax+10h]
		mov	edx, eax
		mov	eax, [ebp+__o]
		mov	eax, [eax+0Ch]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, [ebp+__len]
		jge	short loc_800285B
		sub	esp, 8
		push	[ebp+__len]	; int
		push	[ebp+__o]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_800285B:				; CODE XREF: print_dir+1FAj
		mov	eax, [ebp+__o]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len]
		add	edx, eax
		mov	eax, [ebp+__o]
		mov	[eax+0Ch], edx
		mov	eax, ds:dev_ino_obstack.next_free
		sub	eax, 10h
		mov	[ebp+di_0], eax
		mov	eax, dword ptr [ebp+dir_stat.st_dev]
		mov	edx, dword ptr [ebp+dir_stat.st_dev+4]
		mov	ecx, [ebp+di_0]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		mov	eax, dword ptr [ebp+dir_stat.st_ino]
		mov	edx, dword ptr [ebp+dir_stat.st_ino+4]
		mov	ecx, [ebp+di_0]
		mov	[ecx], eax
		mov	[ecx+4], edx

loc_80028B2:				; CODE XREF: print_dir+A7j
		movzx	eax, ds:recursive
		test	al, al
		jnz	short loc_80028CC
		movzx	eax, ds:print_dir_name
		test	al, al
		jz	loc_8002AB2

loc_80028CC:				; CODE XREF: print_dir+273j
		movzx	eax, first_7261
		xor	eax, 1
		test	al, al
		jz	short loc_80028F4
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax

loc_80028F4:				; CODE XREF: print_dir+290j
		mov	first_7261, 0
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_800292A
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_8009DB1 ; "	"
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 2
		mov	ds:dired_pos, eax

loc_800292A:				; CODE XREF: print_dir+2BCj
		movzx	eax, ds:dired
		test	al, al
		jz	loc_80029BD
		mov	[ebp+__o_0], offset subdired_obstack
		mov	[ebp+__len_0], 4
		mov	eax, [ebp+__o_0]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_0]
		add	edx, eax
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jbe	short loc_8002982
		sub	esp, 8
		push	[ebp+__len_0]	; int
		push	[ebp+__o_0]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_8002982:				; CODE XREF: print_dir+321j
		mov	edx, [ebp+__len_0]
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+0Ch]
		sub	esp, 4
		push	edx		; n
		push	offset dired_pos ; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+__o_0]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_0]
		add	edx, eax
		mov	eax, [ebp+__o_0]
		mov	[eax+0Ch], edx

loc_80029BD:				; CODE XREF: print_dir+2EBj
		mov	ecx, ds:dirname_quoting_options
		cmp	[ebp+realname],	0
		jz	short loc_80029D4
		mov	eax, [ebp+realname]
		jmp	short loc_80029DA
; ---------------------------------------------------------------------------

loc_80029D4:				; CODE XREF: print_dir+382j
		mov	eax, [ebp+name]

loc_80029DA:				; CODE XREF: print_dir+38Aj
		mov	edx, ds:stdout
		push	0		; width
		push	ecx		; options
		push	eax		; name
		push	edx		; out
		call	quote_name
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:dired_pos
		add	eax, edx
		mov	ds:dired_pos, eax
		movzx	eax, ds:dired
		test	al, al
		jz	loc_8002A8E
		mov	[ebp+__o_1], offset subdired_obstack
		mov	[ebp+__len_1], 4
		mov	eax, [ebp+__o_1]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_1]
		add	edx, eax
		mov	eax, [ebp+__o_1]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jbe	short loc_8002A53
		sub	esp, 8
		push	[ebp+__len_1]	; int
		push	[ebp+__o_1]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_8002A53:				; CODE XREF: print_dir+3F2j
		mov	edx, [ebp+__len_1]
		mov	eax, [ebp+__o_1]
		mov	eax, [eax+0Ch]
		sub	esp, 4
		push	edx		; n
		push	offset dired_pos ; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+__o_1]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_1]
		add	edx, eax
		mov	eax, [ebp+__o_1]
		mov	[eax+0Ch], edx

loc_8002A8E:				; CODE XREF: print_dir+3BCj
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_8009DB4 ; ":\n"
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 2
		mov	ds:dired_pos, eax

loc_8002AB2:				; CODE XREF: print_dir+27Ej
		call	clear_files

loc_8002AB7:				; CODE XREF: print_dir+4B8j
					; print_dir+579j ...
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 0Ch
		push	[ebp+dirp]
		call	readdir64
		add	esp, 10h
		mov	[ebp+next], eax
		cmp	[ebp+next], 0
		jz	loc_8002C0D
		mov	eax, [ebp+next]
		add	eax, 13h
		sub	esp, 0Ch
		push	eax		; name
		call	file_ignored
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8002AB7
		mov	[ebp+type], 0
		mov	eax, [ebp+next]
		movzx	eax, byte ptr [eax+12h]
		movzx	eax, al
		cmp	eax, 0Eh	; switch 15 cases
		ja	short loc_8002B86 ; jumptable 08002B25 default case
		mov	eax, ds:off_8009DE8[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8002B27:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 4	; jumptable 08002B25 case 6
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B33:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 2	; jumptable 08002B25 case 2
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B3F:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 3	; jumptable 08002B25 case 4
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B4B:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 1	; jumptable 08002B25 case 1
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B57:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 6	; jumptable 08002B25 case 10
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B63:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 5	; jumptable 08002B25 case 8
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B6F:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 7	; jumptable 08002B25 case 12
		jmp	short loc_8002B86 ; jumptable 08002B25 default case
; ---------------------------------------------------------------------------

loc_8002B7B:				; CODE XREF: print_dir+4DDj
					; DATA XREF: .rodata:off_8009DE8o
		mov	[ebp+type], 8	; jumptable 08002B25 case 14
		nop

loc_8002B86:				; CODE XREF: print_dir+4D4j
					; print_dir+4DDj ...
		mov	eax, [ebp+next]	; jumptable 08002B25 default case
		add	eax, 13h
		sub	esp, 8
		push	[ebp+name]	; dirname
		push	0		; command_line_arg
		push	0
		push	0		; inode
		push	[ebp+type]	; type
		push	eax		; name
		call	gobble_file
		add	esp, 20h
		add	dword ptr [ebp+total_blocks], eax
		adc	dword ptr [ebp+total_blocks+4],	edx
		mov	eax, ds:format_0
		cmp	eax, 1
		jnz	loc_8002AB7
		mov	eax, ds:sort_type_0
		cmp	eax, 0FFFFFFFFh
		jnz	loc_8002AB7
		movzx	eax, ds:print_block_size
		xor	eax, 1
		test	al, al
		jz	loc_8002AB7
		movzx	eax, ds:recursive
		xor	eax, 1
		test	al, al
		jz	loc_8002AB7
		call	sort_files
		call	print_current_files
		call	clear_files
		jmp	loc_8002AB7
; ---------------------------------------------------------------------------

loc_8002C0D:				; CODE XREF: print_dir+498j
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8002C55
		sub	esp, 0Ch
		push	offset aReadingDirecto ; "reading directory %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+name]	; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 4Bh
		jnz	short loc_8002C58
		jmp	loc_8002AB7
; ---------------------------------------------------------------------------

loc_8002C55:				; CODE XREF: print_dir+5CEj
		nop
		jmp	short loc_8002C59
; ---------------------------------------------------------------------------

loc_8002C58:				; CODE XREF: print_dir+606j
		nop

loc_8002C59:				; CODE XREF: print_dir+60Ej
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002C9A
		sub	esp, 0Ch
		push	offset aClosingDirecto ; "closing directory %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+name]	; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h

loc_8002C9A:				; CODE XREF: print_dir+624j
		call	sort_files
		movzx	eax, ds:recursive
		test	al, al
		jz	short loc_8002CC3
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 8
		push	eax		; command_line_arg
		push	[ebp+name]	; dirname
		call	extract_dirs_from_files
		add	esp, 10h

loc_8002CC3:				; CODE XREF: print_dir+660j
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8002CDB
		movzx	eax, ds:print_block_size
		test	al, al
		jz	loc_8002DFC

loc_8002CDB:				; CODE XREF: print_dir+682j
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8002D0A
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_8009DB1 ; "	"
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 2
		mov	ds:dired_pos, eax

loc_8002D0A:				; CODE XREF: print_dir+69Cj
		sub	esp, 0Ch
		push	offset aTotal	; "total"
		call	gettext
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		push	[ebp+p]
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:dired_pos
		add	eax, edx
		mov	ds:dired_pos, eax
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	ecx, ds:human_output_opts
		push	edx
		push	eax
		push	0
		push	200h
		push	ecx
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+total_blocks+4]
		push	dword ptr [ebp+total_blocks]
		call	human_readable
		add	esp, 20h
		mov	[ebp+p], eax
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		push	[ebp+p]
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:dired_pos
		add	eax, edx
		mov	ds:dired_pos, eax
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax

loc_8002DFC:				; CODE XREF: print_dir+68Dj
		mov	eax, ds:cwd_n_used
		test	eax, eax
		jz	short loc_8002E0A
		call	print_current_files

loc_8002E0A:				; CODE XREF: print_dir+9Bj
					; print_dir+146j ...
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002E1B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002E1B:				; CODE XREF: print_dir+7CCj
		mov	ebx, [ebp+var_4]
		leave
		retn
print_dir	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_ignore_pattern(const	char *pattern)
add_ignore_pattern proc	near		; CODE XREF: decode_switches+613p
					; decode_switches+623p	...

ignore		= dword	ptr -0Ch
pattern		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	8		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+ignore], eax
		mov	eax, [ebp+ignore]
		mov	edx, [ebp+pattern]
		mov	[eax], edx
		mov	edx, ds:ignore_patterns
		mov	eax, [ebp+ignore]
		mov	[eax+4], edx
		mov	eax, [ebp+ignore]
		mov	ds:ignore_patterns, eax
		nop
		leave
		retn
add_ignore_pattern endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	patterns_match(const ignore_pattern *patterns, const char *file)
patterns_match	proc near		; CODE XREF: file_ignored+5Dp
					; file_ignored+75p

p		= dword	ptr -0Ch
patterns	= dword	ptr  8
file		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+patterns]
		mov	[ebp+p], eax
		jmp	short loc_8002E8D
; ---------------------------------------------------------------------------

loc_8002E63:				; CODE XREF: patterns_match+3Cj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 4
		push	4		; flags
		push	[ebp+file]	; name
		push	eax		; pattern
		call	fnmatch
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002E84
		mov	eax, 1
		jmp	short locret_8002E98
; ---------------------------------------------------------------------------

loc_8002E84:				; CODE XREF: patterns_match+26j
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+p], eax

loc_8002E8D:				; CODE XREF: patterns_match+Cj
		cmp	[ebp+p], 0
		jnz	short loc_8002E63
		mov	eax, 0

locret_8002E98:				; CODE XREF: patterns_match+2Dj
		leave
		retn
patterns_match	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	file_ignored(const char	*name)
file_ignored	proc near		; CODE XREF: print_dir+4ABp

name		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:ignore_mode
		cmp	eax, 2
		jz	short loc_8002EE2
		mov	eax, [ebp+name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8002EE2
		mov	eax, ds:ignore_mode
		test	eax, eax
		jz	short loc_8002F1B
		mov	eax, [ebp+name]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8002ED1
		mov	edx, 2
		jmp	short loc_8002ED6
; ---------------------------------------------------------------------------

loc_8002ED1:				; CODE XREF: file_ignored+2Ej
		mov	edx, 1

loc_8002ED6:				; CODE XREF: file_ignored+35j
		mov	eax, [ebp+name]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8002F1B

loc_8002EE2:				; CODE XREF: file_ignored+Ej
					; file_ignored+18j
		mov	eax, ds:ignore_mode
		test	eax, eax
		jnz	short loc_8002F03
		mov	eax, ds:hide_patterns
		sub	esp, 8
		push	[ebp+name]	; file
		push	eax		; patterns
		call	patterns_match
		add	esp, 10h
		test	al, al
		jnz	short loc_8002F1B

loc_8002F03:				; CODE XREF: file_ignored+4Fj
		mov	eax, ds:ignore_patterns
		sub	esp, 8
		push	[ebp+name]	; file
		push	eax		; patterns
		call	patterns_match
		add	esp, 10h
		test	al, al
		jz	short loc_8002F22

loc_8002F1B:				; CODE XREF: file_ignored+21j
					; file_ignored+46j ...
		mov	eax, 1
		jmp	short loc_8002F27
; ---------------------------------------------------------------------------

loc_8002F22:				; CODE XREF: file_ignored+7Fj
		mov	eax, 0

loc_8002F27:				; CODE XREF: file_ignored+86j
		and	eax, 1
		leave
		retn
file_ignored	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl unsigned_file_size(off_t size)
unsigned_file_size proc	near		; CODE XREF: gobble_file+B65p
					; print_long_format+5FEp

size		= qword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+size], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+size+4],	eax
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		leave
		retn
unsigned_file_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	has_capability(const char *name)
has_capability	proc near		; CODE XREF: gobble_file+4B4p

name		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, 0
		pop	ebp
		retn
has_capability	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void clear_files()
clear_files	proc near		; CODE XREF: main+413p
					; print_dir:loc_8002AB2p ...

i		= dword	ptr -10h
f		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_8002FB7
; ---------------------------------------------------------------------------

loc_8002F5F:				; CODE XREF: clear_files+6Fj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		cmp	eax, offset UNKNOWN_SECURITY_CONTEXT ; "?"
		jz	short loc_8002FB3
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h

loc_8002FB3:				; CODE XREF: clear_files+4Fj
		add	[ebp+i], 1

loc_8002FB7:				; CODE XREF: clear_files+Dj
		mov	eax, ds:cwd_n_used
		cmp	[ebp+i], eax
		jb	short loc_8002F5F
		mov	ds:cwd_n_used, 0
		mov	ds:any_has_acl,	0
		mov	ds:inode_number_width, 0
		mov	ds:block_size_width, 0
		mov	ds:nlink_width,	0
		mov	ds:owner_width,	0
		mov	ds:group_width,	0
		mov	ds:author_width, 0
		mov	ds:scontext_width, 0
		mov	ds:major_device_number_width, 0
		mov	ds:minor_device_number_width, 0
		mov	ds:file_size_width, 0
		nop
		leave
		retn
clear_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl gobble_file(const char *name, filetype type, ino_t inode, _Bool command_line_arg, const char *dirname)
gobble_file	proc near		; CODE XREF: main+44Fp	main+4A0p ...

dirname		= dword	ptr -37Ch
inode		= qword	ptr -378h
command_line_arg= byte ptr -370h
name		= dword	ptr -36Ch
do_deref	= byte ptr -360h
have_selinux	= byte ptr -35Fh
have_acl	= byte ptr -35Eh
need_lstat	= byte ptr -35Dh
absolute_name	= dword	ptr -35Ch
err		= dword	ptr -358h
f		= dword	ptr -354h
attr_len	= dword	ptr -350h
n		= dword	ptr -34Ch
linkname	= dword	ptr -348h
len		= dword	ptr -344h
len_0		= dword	ptr -340h
len_1		= dword	ptr -33Ch
len_2		= dword	ptr -338h
len_3		= dword	ptr -334h
b_len		= dword	ptr -330h
len_5		= dword	ptr -32Ch
len_4		= dword	ptr -328h
len_6		= dword	ptr -324h
blocks		= qword	ptr -320h
size		= qword	ptr -318h
linkstats	= stat ptr -310h
b		= byte ptr -2ADh
buf		= byte ptr -298h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
type		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 384h
		mov	eax, [ebp+arg_10]
		mov	edx, [ebp+arg_0]
		mov	[ebp+name], edx
		mov	edx, [ebp+arg_8]
		mov	dword ptr [ebp+inode], edx
		mov	edx, [ebp+arg_C]
		mov	dword ptr [ebp+inode+4], edx
		mov	[ebp+command_line_arg],	al
		mov	eax, [ebp+arg_14]
		mov	[ebp+dirname], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	dword ptr [ebp+blocks],	0
		mov	dword ptr [ebp+blocks+4], 0
		cmp	[ebp+command_line_arg],	0
		jz	short loc_80030C1
		mov	eax, dword ptr [ebp+inode+4]
		or	eax, dword ptr [ebp+inode]
		test	eax, eax
		jz	short loc_80030C1
		push	offset __PRETTY_FUNCTION___7323	; "gobble_file"
		push	0AA0h		; line
		push	offset file	; "ls.c"
		push	offset aCommand_line_a ; "! command_line_arg ||	inode == NOT_AN_I"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80030C1:				; CODE XREF: gobble_file+5Dj
					; gobble_file+6Dj
		mov	edx, ds:cwd_n_used
		mov	eax, ds:cwd_n_alloc
		cmp	edx, eax
		jnz	short loc_80030FE
		mov	edx, ds:cwd_n_alloc
		mov	eax, ds:cwd_file
		sub	esp, 4
		push	100h
		push	edx
		push	eax
		call	xnrealloc
		add	esp, 10h
		mov	ds:cwd_file, eax
		mov	eax, ds:cwd_n_alloc
		add	eax, eax
		mov	ds:cwd_n_alloc,	eax

loc_80030FE:				; CODE XREF: gobble_file+95j
		mov	eax, ds:cwd_file
		mov	edx, ds:cwd_n_used
		shl	edx, 7
		add	eax, edx
		mov	[ebp+f], eax
		sub	esp, 4
		push	80h		; n
		push	0		; c
		push	[ebp+f]		; s
		call	memset
		add	esp, 10h
		mov	ecx, [ebp+f]
		mov	eax, dword ptr [ebp+inode]
		mov	edx, dword ptr [ebp+inode+4]
		mov	[ecx+60h], eax
		mov	[ecx+64h], edx
		mov	eax, [ebp+f]
		mov	edx, [ebp+type]
		mov	[eax+68h], edx
		cmp	[ebp+command_line_arg],	0
		jnz	loc_800328E
		movzx	eax, ds:format_needs_stat
		test	al, al
		jnz	loc_800328E
		cmp	[ebp+type], 3
		jnz	short loc_8003181
		movzx	eax, ds:print_with_color
		test	al, al
		jnz	loc_800328E

loc_8003181:				; CODE XREF: gobble_file+137j
		movzx	eax, ds:print_inode
		test	al, al
		jnz	short loc_8003197
		movzx	eax, ds:format_needs_type
		test	al, al
		jz	short loc_80031E6

loc_8003197:				; CODE XREF: gobble_file+151j
		cmp	[ebp+type], 6
		jz	short loc_80031A3
		cmp	[ebp+type], 0
		jnz	short loc_80031E6

loc_80031A3:				; CODE XREF: gobble_file+162j
		mov	eax, ds:dereference
		cmp	eax, 5
		jz	loc_800328E
		cmp	[ebp+command_line_arg],	0
		jz	short loc_80031C8
		mov	eax, ds:dereference
		cmp	eax, 2
		jnz	loc_800328E

loc_80031C8:				; CODE XREF: gobble_file+17Fj
		movzx	eax, ds:color_symlink_as_referent
		test	al, al
		jnz	loc_800328E
		movzx	eax, ds:check_symlink_color
		test	al, al
		jnz	loc_800328E

loc_80031E6:				; CODE XREF: gobble_file+15Cj
					; gobble_file+168j
		movzx	eax, ds:print_inode
		test	al, al
		jz	short loc_8003205
		mov	eax, dword ptr [ebp+inode+4]
		or	eax, dword ptr [ebp+inode]
		test	eax, eax
		jz	loc_800328E

loc_8003205:				; CODE XREF: gobble_file+1B6j
		movzx	eax, ds:format_needs_type
		test	al, al
		jz	loc_8003C14
		cmp	[ebp+type], 0
		jz	short loc_800328E
		cmp	[ebp+command_line_arg],	0
		jnz	short loc_800328E
		cmp	[ebp+type], 5
		jnz	loc_8003C14
		mov	eax, ds:indicator_style_0
		cmp	eax, 3
		jz	short loc_800328E
		movzx	eax, ds:print_with_color
		test	al, al
		jz	loc_8003C14
		sub	esp, 0Ch
		push	0Eh		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jnz	short loc_800328E
		sub	esp, 0Ch
		push	10h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jnz	short loc_800328E
		sub	esp, 0Ch
		push	11h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jnz	short loc_800328E
		sub	esp, 0Ch
		push	15h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	loc_8003C14

loc_800328E:				; CODE XREF: gobble_file+11Ej
					; gobble_file+12Dj ...
		mov	eax, [ebp+name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_80032A8
		mov	eax, [ebp+dirname]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80032B6

loc_80032A8:				; CODE XREF: gobble_file+260j
		mov	eax, [ebp+name]
		mov	[ebp+absolute_name], eax
		jmp	short loc_800332B
; ---------------------------------------------------------------------------

loc_80032B6:				; CODE XREF: gobble_file+26Dj
		sub	esp, 0Ch
		push	[ebp+name]	; s
		call	strlen
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+dirname]	; s
		call	strlen
		add	esp, 10h
		add	eax, ebx
		add	eax, 2
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ebx, 10h
		mov	edx, 0
		div	ebx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+absolute_name], eax
		sub	esp, 4
		push	[ebp+name]	; name
		push	[ebp+dirname]	; dirname
		push	[ebp+absolute_name] ; dest
		call	attach
		add	esp, 10h

loc_800332B:				; CODE XREF: gobble_file+27Bj
		mov	eax, ds:dereference
		cmp	eax, 3
		jb	loc_80033F1
		cmp	eax, 4
		jbe	short loc_8003374
		cmp	eax, 5
		jnz	loc_80033F1
		mov	eax, [ebp+f]
		add	eax, 8
		sub	esp, 8
		push	eax
		push	[ebp+absolute_name]
		call	stat64
		add	esp, 10h
		mov	[ebp+err], eax
		mov	[ebp+do_deref],	1
		jmp	loc_800341F
; ---------------------------------------------------------------------------

loc_8003374:				; CODE XREF: gobble_file+303j
		cmp	[ebp+command_line_arg],	0
		jz	short loc_80033F1
		mov	eax, [ebp+f]
		add	eax, 8
		sub	esp, 8
		push	eax
		push	[ebp+absolute_name]
		call	stat64
		add	esp, 10h
		mov	[ebp+err], eax
		mov	[ebp+do_deref],	1
		mov	eax, ds:dereference
		cmp	eax, 3
		jz	short loc_800341B
		cmp	[ebp+err], 0
		jns	short loc_80033C7
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		setz	al
		jmp	short loc_80033DD
; ---------------------------------------------------------------------------

loc_80033C7:				; CODE XREF: gobble_file+37Dj
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 4000h
		setnz	al

loc_80033DD:				; CODE XREF: gobble_file+38Cj
		mov	[ebp+need_lstat], al
		movzx	eax, [ebp+need_lstat]
		xor	eax, 1
		test	al, al
		jnz	short loc_800341E

loc_80033F1:				; CODE XREF: gobble_file+2FAj
					; gobble_file+308j ...
		mov	eax, [ebp+f]
		add	eax, 8
		sub	esp, 8
		push	eax
		push	[ebp+absolute_name]
		call	lstat64
		add	esp, 10h
		mov	[ebp+err], eax
		mov	[ebp+do_deref],	0
		jmp	short loc_800341F
; ---------------------------------------------------------------------------

loc_800341B:				; CODE XREF: gobble_file+374j
		nop
		jmp	short loc_800341F
; ---------------------------------------------------------------------------

loc_800341E:				; CODE XREF: gobble_file+3B6j
		nop

loc_800341F:				; CODE XREF: gobble_file+336j
					; gobble_file+3E0j ...
		cmp	[ebp+err], 0
		jz	short loc_80034A3
		sub	esp, 0Ch
		push	offset aCannotAccessS ;	"cannot	access %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+absolute_name] ; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h
		cmp	[ebp+command_line_arg],	0
		jz	short loc_800346C
		mov	eax, 0
		mov	edx, 0
		jmp	loc_8003C9D
; ---------------------------------------------------------------------------

loc_800346C:				; CODE XREF: gobble_file+422j
		sub	esp, 0Ch
		push	[ebp+name]	; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	[eax], edx
		mov	eax, ds:cwd_n_used
		add	eax, 1
		mov	ds:cwd_n_used, eax
		mov	eax, 0
		mov	edx, 0
		jmp	loc_8003C9D
; ---------------------------------------------------------------------------

loc_80034A3:				; CODE XREF: gobble_file+3EDj
		mov	eax, [ebp+f]
		mov	byte ptr [eax+74h], 1
		cmp	[ebp+type], 5
		jz	short loc_80034C8
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8003500

loc_80034C8:				; CODE XREF: gobble_file+478j
		movzx	eax, ds:print_with_color
		test	al, al
		jz	short loc_8003500
		sub	esp, 0Ch
		push	15h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8003500
		sub	esp, 0Ch
		push	[ebp+absolute_name] ; name
		call	has_capability
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	[eax+7Ch], dl

loc_8003500:				; CODE XREF: gobble_file+48Dj
					; gobble_file+498j ...
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8003518
		movzx	eax, ds:print_scontext
		test	al, al
		jz	loc_80036DF

loc_8003518:				; CODE XREF: gobble_file+4CEj
		mov	[ebp+have_selinux], 0
		mov	[ebp+have_acl],	0
		cmp	[ebp+do_deref],	0
		jz	short loc_800354C
		mov	eax, [ebp+f]
		add	eax, 70h
		sub	esp, 8
		push	eax		; con
		push	[ebp+absolute_name] ; file
		call	getfilecon
		add	esp, 10h
		jmp	short loc_8003567
; ---------------------------------------------------------------------------

loc_800354C:				; CODE XREF: gobble_file+4F4j
		mov	eax, [ebp+f]
		add	eax, 70h
		sub	esp, 8
		push	eax		; con
		push	[ebp+absolute_name] ; file
		call	lgetfilecon
		add	esp, 10h

loc_8003567:				; CODE XREF: gobble_file+511j
		mov	[ebp+attr_len],	eax
		mov	eax, [ebp+attr_len]
		shr	eax, 1Fh
		movzx	eax, al
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jnz	short loc_80035AF
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		sub	esp, 8
		push	eax		; s2
		push	offset aUnlabeled ; "unlabeled"
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+have_selinux], al
		jmp	short loc_80035EA
; ---------------------------------------------------------------------------

loc_80035AF:				; CODE XREF: gobble_file+54Dj
		mov	eax, [ebp+f]
		mov	dword ptr [eax+70h], offset UNKNOWN_SECURITY_CONTEXT ; "?"
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 5Fh
		jz	short loc_80035E0
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 5Fh
		jz	short loc_80035E0
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 3Dh
		jnz	short loc_80035EA

loc_80035E0:				; CODE XREF: gobble_file+58Dj
					; gobble_file+599j
		mov	[ebp+err], 0

loc_80035EA:				; CODE XREF: gobble_file+574j
					; gobble_file+5A5j
		cmp	[ebp+err], 0
		jnz	short loc_800363F
		mov	eax, ds:format_0
		test	eax, eax
		jnz	short loc_800363F
		mov	eax, [ebp+f]
		add	eax, 8
		sub	esp, 8
		push	eax
		push	[ebp+absolute_name]
		call	file_has_acl
		add	esp, 10h
		mov	[ebp+n], eax
		mov	eax, [ebp+n]
		shr	eax, 1Fh
		movzx	eax, al
		mov	[ebp+err], eax
		cmp	[ebp+n], 0
		setnle	al
		mov	[ebp+have_acl],	al

loc_800363F:				; CODE XREF: gobble_file+5B8j
					; gobble_file+5C1j
		cmp	[ebp+have_selinux], 0
		jnz	short loc_8003651
		cmp	[ebp+have_acl],	0
		jz	short loc_8003676

loc_8003651:				; CODE XREF: gobble_file+60Dj
		cmp	[ebp+have_selinux], 0
		jz	short loc_800366F
		movzx	eax, [ebp+have_acl]
		xor	eax, 1
		test	al, al
		jz	short loc_800366F
		mov	eax, 1
		jmp	short loc_800367B
; ---------------------------------------------------------------------------

loc_800366F:				; CODE XREF: gobble_file+61Fj
					; gobble_file+62Dj
		mov	eax, 2
		jmp	short loc_800367B
; ---------------------------------------------------------------------------

loc_8003676:				; CODE XREF: gobble_file+616j
		mov	eax, 0

loc_800367B:				; CODE XREF: gobble_file+634j
					; gobble_file+63Bj
		mov	edx, [ebp+f]
		mov	[edx+78h], eax
		movzx	eax, ds:any_has_acl
		movzx	edx, al
		mov	eax, [ebp+f]
		mov	eax, [eax+78h]
		test	eax, eax
		setnz	al
		movzx	eax, al
		or	eax, edx
		test	eax, eax
		setnz	al
		mov	ds:any_has_acl,	al
		cmp	[ebp+err], 0
		jz	short loc_80036DF
		sub	esp, 0Ch
		push	[ebp+absolute_name]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80036DF:				; CODE XREF: gobble_file+4D9j
					; gobble_file+679j
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	loc_80037DD
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_8003710
		movzx	eax, ds:check_symlink_color
		test	al, al
		jz	loc_80037DD

loc_8003710:				; CODE XREF: gobble_file+6C6j
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	eax		; command_line_arg
		push	[ebp+f]		; f
		push	[ebp+absolute_name] ; filename
		call	get_link_name
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		sub	esp, 8
		push	eax		; linkname
		push	[ebp+absolute_name] ; name
		call	make_link_name
		add	esp, 10h
		mov	[ebp+linkname],	eax
		cmp	[ebp+linkname],	0
		jz	short loc_80037CC
		mov	eax, ds:indicator_style_0
		cmp	eax, 1
		ja	short loc_800376E
		movzx	eax, ds:check_symlink_color
		test	al, al
		jz	short loc_80037CC

loc_800376E:				; CODE XREF: gobble_file+728j
		sub	esp, 8
		lea	eax, [ebp+linkstats]
		push	eax
		push	[ebp+linkname]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80037CC
		mov	eax, [ebp+f]
		mov	byte ptr [eax+75h], 1
		movzx	eax, [ebp+command_line_arg]
		xor	eax, 1
		test	al, al
		jnz	short loc_80037BD
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_80037BD
		mov	eax, [ebp+linkstats.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_80037CC

loc_80037BD:				; CODE XREF: gobble_file+767j
					; gobble_file+770j
		mov	edx, [ebp+linkstats.st_mode]
		mov	eax, [ebp+f]
		mov	[eax+6Ch], edx

loc_80037CC:				; CODE XREF: gobble_file+71Ej
					; gobble_file+733j ...
		sub	esp, 0Ch
		push	[ebp+linkname]	; ptr
		call	free
		add	esp, 10h

loc_80037DD:				; CODE XREF: gobble_file+6B9j
					; gobble_file+6D1j
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_800380A
		movzx	eax, ds:check_symlink_color
		xor	eax, 1
		test	al, al
		jz	short loc_800380A
		mov	eax, [ebp+f]
		mov	byte ptr [eax+75h], 1

loc_800380A:				; CODE XREF: gobble_file+7B7j
					; gobble_file+7C5j
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_800382E
		mov	eax, [ebp+f]
		mov	dword ptr [eax+68h], 6
		jmp	short loc_8003885
; ---------------------------------------------------------------------------

loc_800382E:				; CODE XREF: gobble_file+7E4j
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_8003878
		cmp	[ebp+command_line_arg],	0
		jz	short loc_8003869
		movzx	eax, ds:immediate_dirs
		xor	eax, 1
		test	al, al
		jz	short loc_8003869
		mov	eax, [ebp+f]
		mov	dword ptr [eax+68h], 9
		jmp	short loc_8003885
; ---------------------------------------------------------------------------

loc_8003869:				; CODE XREF: gobble_file+811j
					; gobble_file+81Fj
		mov	eax, [ebp+f]
		mov	dword ptr [eax+68h], 3
		jmp	short loc_8003885
; ---------------------------------------------------------------------------

loc_8003878:				; CODE XREF: gobble_file+808j
		mov	eax, [ebp+f]
		mov	dword ptr [eax+68h], 5

loc_8003885:				; CODE XREF: gobble_file+7F3j
					; gobble_file+82Ej ...
		mov	eax, [ebp+f]
		mov	edx, [eax+44h]
		mov	eax, [eax+40h]
		mov	dword ptr [ebp+blocks],	eax
		mov	dword ptr [ebp+blocks+4], edx
		mov	eax, ds:format_0
		test	eax, eax
		jz	short loc_80038B1
		movzx	eax, ds:print_block_size
		test	al, al
		jz	short loc_8003913

loc_80038B1:				; CODE XREF: gobble_file+86Bj
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	ecx, ds:human_output_opts
		push	edx
		push	eax
		push	0
		push	200h
		push	ecx
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+blocks+4]
		push	dword ptr [ebp+blocks]
		call	human_readable
		add	esp, 20h
		sub	esp, 8
		push	0
		push	eax
		call	gnu_mbswidth
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, ds:block_size_width
		cmp	eax, [ebp+len]
		jge	short loc_8003913
		mov	eax, [ebp+len]
		mov	ds:block_size_width, eax

loc_8003913:				; CODE XREF: gobble_file+876j
					; gobble_file+8CDj
		mov	eax, ds:format_0
		test	eax, eax
		jnz	loc_80039DA
		movzx	eax, print_owner
		test	al, al
		jz	short loc_800395E
		mov	eax, [ebp+f]
		mov	eax, [eax+20h]
		sub	esp, 0Ch
		push	eax		; u
		call	format_user_width
		add	esp, 10h
		mov	[ebp+len_0], eax
		mov	eax, ds:owner_width
		cmp	eax, [ebp+len_0]
		jge	short loc_800395E
		mov	eax, [ebp+len_0]
		mov	ds:owner_width,	eax

loc_800395E:				; CODE XREF: gobble_file+8F0j
					; gobble_file+918j
		movzx	eax, print_group
		test	al, al
		jz	short loc_800399C
		mov	eax, [ebp+f]
		mov	eax, [eax+24h]
		sub	esp, 0Ch
		push	eax		; g
		call	format_group_width
		add	esp, 10h
		mov	[ebp+len_1], eax
		mov	eax, ds:group_width
		cmp	eax, [ebp+len_1]
		jge	short loc_800399C
		mov	eax, [ebp+len_1]
		mov	ds:group_width,	eax

loc_800399C:				; CODE XREF: gobble_file+92Ej
					; gobble_file+956j
		movzx	eax, ds:print_author
		test	al, al
		jz	short loc_80039DA
		mov	eax, [ebp+f]
		mov	eax, [eax+20h]
		sub	esp, 0Ch
		push	eax		; u
		call	format_user_width
		add	esp, 10h
		mov	[ebp+len_2], eax
		mov	eax, ds:author_width
		cmp	eax, [ebp+len_2]
		jge	short loc_80039DA
		mov	eax, [ebp+len_2]
		mov	ds:author_width, eax

loc_80039DA:				; CODE XREF: gobble_file+8E1j
					; gobble_file+96Cj ...
		movzx	eax, ds:print_scontext
		test	al, al
		jz	short loc_8003A18
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len_3], eax
		mov	eax, ds:scontext_width
		cmp	eax, [ebp+len_3]
		jge	short loc_8003A18
		mov	eax, [ebp+len_3]
		mov	ds:scontext_width, eax

loc_8003A18:				; CODE XREF: gobble_file+9AAj
					; gobble_file+9D2j
		mov	eax, ds:format_0
		test	eax, eax
		jnz	loc_8003C14
		mov	eax, [ebp+f]
		mov	eax, [eax+1Ch]
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+b]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+b_len], eax
		mov	eax, ds:nlink_width
		cmp	eax, [ebp+b_len]
		jge	short loc_8003A71
		mov	eax, [ebp+b_len]
		mov	ds:nlink_width,	eax

loc_8003A71:				; CODE XREF: gobble_file+A2Bj
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 2000h
		jz	short loc_8003A9F
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 6000h
		jnz	loc_8003B8D

loc_8003A9F:				; CODE XREF: gobble_file+A4Bj
		mov	eax, [ebp+f]
		mov	edx, [eax+2Ch]
		mov	eax, [eax+28h]
		sub	esp, 8
		push	edx
		push	eax		; dev
		call	gnu_dev_major
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len_4], eax
		mov	eax, ds:major_device_number_width
		cmp	eax, [ebp+len_4]
		jge	short loc_8003AFB
		mov	eax, [ebp+len_4]
		mov	ds:major_device_number_width, eax

loc_8003AFB:				; CODE XREF: gobble_file+AB5j
		mov	eax, [ebp+f]
		mov	edx, [eax+2Ch]
		mov	eax, [eax+28h]
		sub	esp, 8
		push	edx
		push	eax		; dev
		call	gnu_dev_minor
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len_4], eax
		mov	eax, ds:minor_device_number_width
		cmp	eax, [ebp+len_4]
		jge	short loc_8003B57
		mov	eax, [ebp+len_4]
		mov	ds:minor_device_number_width, eax

loc_8003B57:				; CODE XREF: gobble_file+B11j
		mov	eax, ds:major_device_number_width
		lea	edx, [eax+2]
		mov	eax, ds:minor_device_number_width
		add	eax, edx
		mov	[ebp+len_4], eax
		mov	eax, ds:file_size_width
		cmp	eax, [ebp+len_4]
		jge	loc_8003C13
		mov	eax, [ebp+len_4]
		mov	ds:file_size_width, eax
		jmp	loc_8003C13
; ---------------------------------------------------------------------------

loc_8003B8D:				; CODE XREF: gobble_file+A60j
		mov	eax, [ebp+f]
		mov	edx, [eax+38h]
		mov	eax, [eax+34h]
		sub	esp, 8
		push	edx
		push	eax		; size
		call	unsigned_file_size
		add	esp, 10h
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, dword ptr file_output_block_size
		mov	edx, dword ptr file_output_block_size+4
		mov	ecx, ds:human_output_opts
		push	edx
		push	eax
		push	0
		push	1
		push	ecx
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+size+4]
		push	dword ptr [ebp+size]
		call	human_readable
		add	esp, 20h
		sub	esp, 8
		push	0
		push	eax
		call	gnu_mbswidth
		add	esp, 10h
		mov	[ebp+len_5], eax
		mov	eax, ds:file_size_width
		cmp	eax, [ebp+len_5]
		jge	short loc_8003C14
		mov	eax, [ebp+len_5]
		mov	ds:file_size_width, eax
		jmp	short loc_8003C14
; ---------------------------------------------------------------------------

loc_8003C13:				; CODE XREF: gobble_file+B3Ej
					; gobble_file+B4Fj
		nop

loc_8003C14:				; CODE XREF: gobble_file+1D5j
					; gobble_file+1EEj ...
		movzx	eax, ds:print_inode
		test	al, al
		jz	short loc_8003C69
		mov	eax, [ebp+f]
		mov	edx, [eax+64h]
		mov	eax, [eax+60h]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len_6], eax
		mov	eax, ds:inode_number_width
		cmp	eax, [ebp+len_6]
		jge	short loc_8003C69
		mov	eax, [ebp+len_6]
		mov	ds:inode_number_width, eax

loc_8003C69:				; CODE XREF: gobble_file+BE4j
					; gobble_file+C23j
		sub	esp, 0Ch
		push	[ebp+name]	; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	[eax], edx
		mov	eax, ds:cwd_n_used
		add	eax, 1
		mov	ds:cwd_n_used, eax
		mov	eax, dword ptr [ebp+blocks]
		mov	edx, dword ptr [ebp+blocks+4]

loc_8003C9D:				; CODE XREF: gobble_file+42Ej
					; gobble_file+465j
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8003CAE
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003CAE:				; CODE XREF: gobble_file+C6Ej
		mov	ebx, [ebp+var_4]
		leave
		retn
gobble_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_directory(const fileinfo *f)
is_directory	proc near		; CODE XREF: extract_dirs_from_files+5Cp
					; xstrcoll_df_ctime+9p	...

f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		cmp	eax, 3
		jz	short loc_8003CCC
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		cmp	eax, 9
		jnz	short loc_8003CD3

loc_8003CCC:				; CODE XREF: is_directory+Cj
		mov	eax, 1
		jmp	short loc_8003CD8
; ---------------------------------------------------------------------------

loc_8003CD3:				; CODE XREF: is_directory+17j
		mov	eax, 0

loc_8003CD8:				; CODE XREF: is_directory+1Ej
		and	eax, 1
		pop	ebp
		retn
is_directory	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl get_link_name(const char	*filename, fileinfo *f,	_Bool command_line_arg)
get_link_name	proc near		; CODE XREF: gobble_file+6EEp

command_line_arg= byte ptr -0Ch
filename	= dword	ptr  8
f		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[ebp+command_line_arg],	al
		mov	eax, [ebp+f]
		mov	edx, [eax+38h]
		mov	eax, [eax+34h]
		sub	esp, 8
		push	eax
		push	[ebp+filename]
		call	areadlink_with_size
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	[eax+4], edx
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8003D39
		sub	esp, 0Ch
		push	offset aCannotReadSymb ; "cannot read symbolic link %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		movzx	eax, [ebp+command_line_arg]
		sub	esp, 4
		push	[ebp+filename]	; file
		push	edx		; message
		push	eax		; serious
		call	file_failure
		add	esp, 10h

loc_8003D39:				; CODE XREF: get_link_name+34j
		nop
		leave
		retn
get_link_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	make_link_name(const char *name, const char *linkname)
make_link_name	proc near		; CODE XREF: gobble_file+709p

linkbuf		= dword	ptr -10h
bufsiz		= dword	ptr -0Ch
name		= dword	ptr  8
linkname	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		cmp	[ebp+linkname],	0
		jnz	short loc_8003D52
		mov	eax, 0
		jmp	locret_8003DFD
; ---------------------------------------------------------------------------

loc_8003D52:				; CODE XREF: make_link_name+Aj
		mov	eax, [ebp+linkname]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jnz	short loc_8003D6F
		sub	esp, 0Ch
		push	[ebp+linkname]	; char *
		call	xstrdup
		add	esp, 10h
		jmp	locret_8003DFD
; ---------------------------------------------------------------------------

loc_8003D6F:				; CODE XREF: make_link_name+1Ej
		sub	esp, 8
		push	2Fh		; c
		push	[ebp+name]	; s
		call	strrchr
		add	esp, 10h
		mov	[ebp+linkbuf], eax
		cmp	[ebp+linkbuf], 0
		jnz	short loc_8003D98
		sub	esp, 0Ch
		push	[ebp+linkname]	; char *
		call	xstrdup
		add	esp, 10h
		jmp	short locret_8003DFD
; ---------------------------------------------------------------------------

loc_8003D98:				; CODE XREF: make_link_name+4Aj
		mov	edx, [ebp+linkbuf]
		mov	eax, [ebp+name]
		sub	edx, eax
		mov	eax, edx
		add	eax, 1
		mov	[ebp+bufsiz], eax
		sub	esp, 0Ch
		push	[ebp+linkname]	; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+bufsiz]
		add	eax, edx
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+linkbuf], eax
		sub	esp, 4
		push	[ebp+bufsiz]	; n
		push	[ebp+name]	; src
		push	[ebp+linkbuf]	; dest
		call	strncpy
		add	esp, 10h
		mov	edx, [ebp+linkbuf]
		mov	eax, [ebp+bufsiz]
		add	eax, edx
		sub	esp, 8
		push	[ebp+linkname]	; src
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		mov	eax, [ebp+linkbuf]

locret_8003DFD:				; CODE XREF: make_link_name+11j
					; make_link_name+2Ej ...
		leave
		retn
make_link_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	basename_is_dot_or_dotdot(const	char *name)
basename_is_dot_or_dotdot proc near	; CODE XREF: extract_dirs_from_files+80p

base		= dword	ptr -0Ch
name		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	[ebp+name]
		call	last_component
		add	esp, 10h
		mov	[ebp+base], eax
		sub	esp, 0Ch
		push	[ebp+base]	; file_name
		call	dot_or_dotdot
		add	esp, 10h
		leave
		retn
basename_is_dot_or_dotdot endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl extract_dirs_from_files(const char *dirname, _Bool command_line_arg)
extract_dirs_from_files	proc near	; CODE XREF: main+4D5p	print_dir+673p

command_line_arg= byte ptr -2Ch
ignore_dot_and_dot_dot=	byte ptr -1Dh
i		= dword	ptr -1Ch
j		= dword	ptr -18h
f		= dword	ptr -14h
name		= dword	ptr -10h
f_0		= dword	ptr -0Ch
dirname		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_4]
		mov	[ebp+command_line_arg],	al
		cmp	[ebp+dirname], 0
		setnz	al
		mov	[ebp+ignore_dot_and_dot_dot], al
		cmp	[ebp+dirname], 0
		jz	short loc_8003E5D
		mov	eax, ds:active_dir_set
		test	eax, eax
		jz	short loc_8003E5D
		sub	esp, 4
		push	0		; command_line_arg
		push	[ebp+dirname]	; realname
		push	0		; name
		call	queue_directory
		add	esp, 10h

loc_8003E5D:				; CODE XREF: extract_dirs_from_files+1Aj
					; extract_dirs_from_files+23j
		mov	eax, ds:cwd_n_used
		mov	[ebp+i], eax
		jmp	loc_8003F47
; ---------------------------------------------------------------------------

loc_8003E6A:				; CODE XREF: extract_dirs_from_files+12Cj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	is_directory
		add	esp, 10h
		test	al, al
		jz	loc_8003F47
		movzx	eax, [ebp+ignore_dot_and_dot_dot]
		xor	eax, 1
		test	al, al
		jnz	short loc_8003EB9
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; name
		call	basename_is_dot_or_dotdot
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	loc_8003F47

loc_8003EB9:				; CODE XREF: extract_dirs_from_files+75j
		cmp	[ebp+dirname], 0
		jz	short loc_8003ECB
		mov	eax, [ebp+f]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jnz	short loc_8003EEA

loc_8003ECB:				; CODE XREF: extract_dirs_from_files+97j
		movzx	ecx, [ebp+command_line_arg]
		mov	eax, [ebp+f]
		mov	edx, [eax+4]
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 4
		push	ecx		; command_line_arg
		push	edx		; realname
		push	eax		; name
		call	queue_directory
		add	esp, 10h
		jmp	short loc_8003F2B
; ---------------------------------------------------------------------------

loc_8003EEA:				; CODE XREF: extract_dirs_from_files+A3j
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 4
		push	0
		push	eax
		push	[ebp+dirname]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+name], eax
		movzx	edx, [ebp+command_line_arg]
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		sub	esp, 4
		push	edx		; command_line_arg
		push	eax		; realname
		push	[ebp+name]	; name
		call	queue_directory
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+name]	; ptr
		call	free
		add	esp, 10h

loc_8003F2B:				; CODE XREF: extract_dirs_from_files+C2j
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		cmp	eax, 9
		jnz	short loc_8003F47
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h

loc_8003F47:				; CODE XREF: extract_dirs_from_files+3Fj
					; extract_dirs_from_files+66j ...
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	[ebp+i], edx
		test	eax, eax
		jnz	loc_8003E6A
		mov	[ebp+i], 0
		mov	[ebp+j], 0
		jmp	short loc_8003FA2
; ---------------------------------------------------------------------------

loc_8003F68:				; CODE XREF: extract_dirs_from_files+184j
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f_0], eax
		mov	eax, ds:sorted_file
		mov	edx, [ebp+j]
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+f_0]
		mov	[edx], eax
		mov	eax, [ebp+f_0]
		mov	eax, [eax+68h]
		cmp	eax, 9
		setnz	al
		movzx	eax, al
		add	[ebp+j], eax
		add	[ebp+i], 1

loc_8003FA2:				; CODE XREF: extract_dirs_from_files+140j
		mov	eax, ds:cwd_n_used
		cmp	[ebp+i], eax
		jb	short loc_8003F68
		mov	eax, [ebp+j]
		mov	ds:cwd_n_used, eax
		nop
		leave
		retn
extract_dirs_from_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll(const char *a, const char *b)
xstrcoll	proc near		; DATA XREF: xstrcoll_ctime+9o
					; rev_xstrcoll_ctime+9o ...

diff		= dword	ptr -1Ch
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 1Ch
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 8
		push	[ebp+b]		; s2
		push	[ebp+a]		; s1
		call	strcoll
		add	esp, 10h
		mov	[ebp+diff], eax
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8004054
		sub	esp, 8
		push	[ebp+b]
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+a]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCompareF ; "cannot compare file names %s and %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; serious
		call	set_exit_status
		add	esp, 10h
		sub	esp, 8
		push	1		; val
		push	offset failed_strcoll ;	env
		call	longjmp
; ---------------------------------------------------------------------------

loc_8004054:				; CODE XREF: xstrcoll+31j
		mov	eax, [ebp+diff]
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
xstrcoll	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_ctime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
cmp_ctime	proc near		; CODE XREF: xstrcoll_ctime+14p
					; strcmp_ctime+14p ...

cmp		= dword	ptr -34h
b		= dword	ptr -30h
a		= dword	ptr -2Ch
diff		= dword	ptr -20h
var_1C		= timespec ptr -1Ch
var_14		= timespec ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+a], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+b], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+cmp], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+a]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1C]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_ctime
		add	esp, 4
		mov	eax, [ebp+b]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_14]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_ctime
		add	esp, 4
		push	[ebp+var_1C.tv_nsec]
		push	[ebp+var_1C.tv_sec] ; b
		push	[ebp+var_14.tv_nsec]
		push	[ebp+var_14.tv_sec] ; a
		call	timespec_cmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_80040DE
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		jmp	short loc_80040E1
; ---------------------------------------------------------------------------

loc_80040DE:				; CODE XREF: cmp_ctime+64j
		mov	eax, [ebp+diff]

loc_80040E1:				; CODE XREF: cmp_ctime+7Dj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80040F2
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80040F2:				; CODE XREF: cmp_ctime+8Cj
		leave
		retn
cmp_ctime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_mtime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
cmp_mtime	proc near		; CODE XREF: xstrcoll_mtime+14p
					; strcmp_mtime+14p ...

cmp		= dword	ptr -34h
b		= dword	ptr -30h
a		= dword	ptr -2Ch
diff		= dword	ptr -20h
var_1C		= timespec ptr -1Ch
var_14		= timespec ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+a], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+b], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+cmp], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+a]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1C]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 4
		mov	eax, [ebp+b]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_14]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 4
		push	[ebp+var_1C.tv_nsec]
		push	[ebp+var_1C.tv_sec] ; b
		push	[ebp+var_14.tv_nsec]
		push	[ebp+var_14.tv_sec] ; a
		call	timespec_cmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8004173
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		jmp	short loc_8004176
; ---------------------------------------------------------------------------

loc_8004173:				; CODE XREF: cmp_mtime+64j
		mov	eax, [ebp+diff]

loc_8004176:				; CODE XREF: cmp_mtime+7Dj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8004187
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8004187:				; CODE XREF: cmp_mtime+8Cj
		leave
		retn
cmp_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_atime(const fileinfo *a, const fileinfo *b, int (*cmp)(const char *, const char *))
cmp_atime	proc near		; CODE XREF: xstrcoll_atime+14p
					; strcmp_atime+14p ...

cmp		= dword	ptr -34h
b		= dword	ptr -30h
a		= dword	ptr -2Ch
diff		= dword	ptr -20h
var_1C		= timespec ptr -1Ch
var_14		= timespec ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+a], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+b], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+cmp], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+a]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1C]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 4
		mov	eax, [ebp+b]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_14]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 4
		push	[ebp+var_1C.tv_nsec]
		push	[ebp+var_1C.tv_sec] ; b
		push	[ebp+var_14.tv_nsec]
		push	[ebp+var_14.tv_sec] ; a
		call	timespec_cmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8004208
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		jmp	short loc_800420B
; ---------------------------------------------------------------------------

loc_8004208:				; CODE XREF: cmp_atime+64j
		mov	eax, [ebp+diff]

loc_800420B:				; CODE XREF: cmp_atime+7Dj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_800421C
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_800421C:				; CODE XREF: cmp_atime+8Cj
		leave
		retn
cmp_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_size(const fileinfo *a, const	fileinfo *b, int (*cmp)(const char *, const char *))
cmp_size	proc near		; CODE XREF: xstrcoll_size+14p
					; strcmp_size+14p ...

var_19		= byte ptr -19h
diff		= dword	ptr -0Ch
var_4		= dword	ptr -4
a		= dword	ptr  8
b		= dword	ptr  0Ch
cmp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+b]
		mov	ecx, [eax+34h]
		mov	ebx, [eax+38h]
		mov	eax, [ebp+a]
		mov	edx, [eax+38h]
		mov	eax, [eax+34h]
		cmp	ebx, edx
		jl	short loc_800426F
		cmp	ebx, edx
		jg	short loc_8004243
		cmp	ecx, eax
		jb	short loc_800426F

loc_8004243:				; CODE XREF: cmp_size+1Fj
		mov	eax, [ebp+b]
		mov	ecx, [eax+34h]
		mov	ebx, [eax+38h]
		mov	eax, [ebp+a]
		mov	edx, [eax+38h]
		mov	eax, [eax+34h]
		mov	[ebp+var_19], 1
		cmp	ebx, edx
		jg	short loc_8004269
		cmp	ebx, edx
		jl	short loc_8004265
		cmp	ecx, eax
		ja	short loc_8004269

loc_8004265:				; CODE XREF: cmp_size+41j
		mov	[ebp+var_19], 0

loc_8004269:				; CODE XREF: cmp_size+3Dj cmp_size+45j
		movzx	eax, [ebp+var_19]
		jmp	short loc_8004274
; ---------------------------------------------------------------------------

loc_800426F:				; CODE XREF: cmp_size+1Bj cmp_size+23j
		mov	eax, 0FFFFFFFFh

loc_8004274:				; CODE XREF: cmp_size+4Fj
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8004296
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		jmp	short loc_8004299
; ---------------------------------------------------------------------------

loc_8004296:				; CODE XREF: cmp_size+5Dj
		mov	eax, [ebp+diff]

loc_8004299:				; CODE XREF: cmp_size+76j
		mov	ebx, [ebp+var_4]
		leave
		retn
cmp_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_name(const fileinfo *a, const	fileinfo *b, int (*cmp)(const char *, const char *))
cmp_name	proc near		; CODE XREF: xstrcoll_name+14p
					; strcmp_name+14p ...

a		= dword	ptr  8
b		= dword	ptr  0Ch
cmp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		leave
		retn
cmp_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_extension(const fileinfo *a, const fileinfo *b, int (*cmp)(const char	*, const char *))
cmp_extension	proc near		; CODE XREF: xstrcoll_extension+14p
					; strcmp_extension+14p	...

base1		= dword	ptr -14h
base2		= dword	ptr -10h
diff		= dword	ptr -0Ch
a		= dword	ptr  8
b		= dword	ptr  0Ch
cmp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	2Eh		; c
		push	eax		; s
		call	strrchr
		add	esp, 10h
		mov	[ebp+base1], eax
		mov	eax, [ebp+b]
		mov	eax, [eax]
		sub	esp, 8
		push	2Eh		; c
		push	eax		; s
		call	strrchr
		add	esp, 10h
		mov	[ebp+base2], eax
		cmp	[ebp+base2], 0
		jz	short loc_80042FA
		mov	edx, [ebp+base2]
		jmp	short loc_80042FF
; ---------------------------------------------------------------------------

loc_80042FA:				; CODE XREF: cmp_extension+36j
		mov	edx, offset locale

loc_80042FF:				; CODE XREF: cmp_extension+3Bj
		cmp	[ebp+base1], 0
		jz	short loc_800430A
		mov	eax, [ebp+base1]
		jmp	short loc_800430F
; ---------------------------------------------------------------------------

loc_800430A:				; CODE XREF: cmp_extension+46j
		mov	eax, offset locale

loc_800430F:				; CODE XREF: cmp_extension+4Bj
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_800433E
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		mov	eax, [ebp+cmp]
		call	eax
		add	esp, 10h
		jmp	short locret_8004341
; ---------------------------------------------------------------------------

loc_800433E:				; CODE XREF: cmp_extension+66j
		mov	eax, [ebp+diff]

locret_8004341:				; CODE XREF: cmp_extension+7Fj
		leave
		retn
cmp_extension	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_ctime(V a, V b)
xstrcoll_ctime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_ctime
		add	esp, 10h
		leave
		retn
xstrcoll_ctime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_ctime(V a,	V b)
strcmp_ctime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_ctime
		add	esp, 10h
		leave
		retn
strcmp_ctime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_ctime(V a, V	b)
rev_xstrcoll_ctime proc	near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_ctime
		add	esp, 10h
		leave
		retn
rev_xstrcoll_ctime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_ctime(V a, V b)
rev_strcmp_ctime proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_ctime
		add	esp, 10h
		leave
		retn
rev_strcmp_ctime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_ctime(V a, V b)
xstrcoll_df_ctime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_80043F5
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80043F5
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004423
; ---------------------------------------------------------------------------

loc_80043F5:				; CODE XREF: xstrcoll_df_ctime+26j
					; xstrcoll_df_ctime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800440D
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800440D
		mov	eax, 1
		jmp	short locret_8004423
; ---------------------------------------------------------------------------

loc_800440D:				; CODE XREF: xstrcoll_df_ctime+43j
					; xstrcoll_df_ctime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_ctime
		add	esp, 10h

locret_8004423:				; CODE XREF: xstrcoll_df_ctime+38j
					; xstrcoll_df_ctime+50j
		leave
		retn
xstrcoll_df_ctime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_ctime(V	a, V b)
strcmp_df_ctime	proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_800445F
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800445F
		mov	eax, 0FFFFFFFFh
		jmp	short locret_800448D
; ---------------------------------------------------------------------------

loc_800445F:				; CODE XREF: strcmp_df_ctime+26j
					; strcmp_df_ctime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004477
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004477
		mov	eax, 1
		jmp	short locret_800448D
; ---------------------------------------------------------------------------

loc_8004477:				; CODE XREF: strcmp_df_ctime+43j
					; strcmp_df_ctime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_ctime
		add	esp, 10h

locret_800448D:				; CODE XREF: strcmp_df_ctime+38j
					; strcmp_df_ctime+50j
		leave
		retn
strcmp_df_ctime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_ctime(V a, V b)
rev_xstrcoll_df_ctime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_80044C9
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80044C9
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80044F7
; ---------------------------------------------------------------------------

loc_80044C9:				; CODE XREF: rev_xstrcoll_df_ctime+26j
					; rev_xstrcoll_df_ctime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80044E1
		cmp	[ebp+b_is_dir],	0
		jz	short loc_80044E1
		mov	eax, 1
		jmp	short locret_80044F7
; ---------------------------------------------------------------------------

loc_80044E1:				; CODE XREF: rev_xstrcoll_df_ctime+43j
					; rev_xstrcoll_df_ctime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_ctime
		add	esp, 10h

locret_80044F7:				; CODE XREF: rev_xstrcoll_df_ctime+38j
					; rev_xstrcoll_df_ctime+50j
		leave
		retn
rev_xstrcoll_df_ctime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_ctime(V a, V b)
rev_strcmp_df_ctime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004533
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004533
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004561
; ---------------------------------------------------------------------------

loc_8004533:				; CODE XREF: rev_strcmp_df_ctime+26j
					; rev_strcmp_df_ctime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800454B
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800454B
		mov	eax, 1
		jmp	short locret_8004561
; ---------------------------------------------------------------------------

loc_800454B:				; CODE XREF: rev_strcmp_df_ctime+43j
					; rev_strcmp_df_ctime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_ctime
		add	esp, 10h

locret_8004561:				; CODE XREF: rev_strcmp_df_ctime+38j
					; rev_strcmp_df_ctime+50j
		leave
		retn
rev_strcmp_df_ctime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_mtime(V a, V b)
xstrcoll_mtime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_mtime
		add	esp, 10h
		leave
		retn
xstrcoll_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_mtime(V a,	V b)
strcmp_mtime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_mtime
		add	esp, 10h
		leave
		retn
strcmp_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_mtime(V a, V	b)
rev_xstrcoll_mtime proc	near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_mtime
		add	esp, 10h
		leave
		retn
rev_xstrcoll_mtime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_mtime(V a, V b)
rev_strcmp_mtime proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_mtime
		add	esp, 10h
		leave
		retn
rev_strcmp_mtime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_mtime(V a, V b)
xstrcoll_df_mtime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004615
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004615
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004643
; ---------------------------------------------------------------------------

loc_8004615:				; CODE XREF: xstrcoll_df_mtime+26j
					; xstrcoll_df_mtime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800462D
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800462D
		mov	eax, 1
		jmp	short locret_8004643
; ---------------------------------------------------------------------------

loc_800462D:				; CODE XREF: xstrcoll_df_mtime+43j
					; xstrcoll_df_mtime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_mtime
		add	esp, 10h

locret_8004643:				; CODE XREF: xstrcoll_df_mtime+38j
					; xstrcoll_df_mtime+50j
		leave
		retn
xstrcoll_df_mtime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_mtime(V	a, V b)
strcmp_df_mtime	proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_800467F
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800467F
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80046AD
; ---------------------------------------------------------------------------

loc_800467F:				; CODE XREF: strcmp_df_mtime+26j
					; strcmp_df_mtime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004697
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004697
		mov	eax, 1
		jmp	short locret_80046AD
; ---------------------------------------------------------------------------

loc_8004697:				; CODE XREF: strcmp_df_mtime+43j
					; strcmp_df_mtime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_mtime
		add	esp, 10h

locret_80046AD:				; CODE XREF: strcmp_df_mtime+38j
					; strcmp_df_mtime+50j
		leave
		retn
strcmp_df_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_mtime(V a, V b)
rev_xstrcoll_df_mtime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_80046E9
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80046E9
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004717
; ---------------------------------------------------------------------------

loc_80046E9:				; CODE XREF: rev_xstrcoll_df_mtime+26j
					; rev_xstrcoll_df_mtime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004701
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004701
		mov	eax, 1
		jmp	short locret_8004717
; ---------------------------------------------------------------------------

loc_8004701:				; CODE XREF: rev_xstrcoll_df_mtime+43j
					; rev_xstrcoll_df_mtime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_mtime
		add	esp, 10h

locret_8004717:				; CODE XREF: rev_xstrcoll_df_mtime+38j
					; rev_xstrcoll_df_mtime+50j
		leave
		retn
rev_xstrcoll_df_mtime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_mtime(V a, V b)
rev_strcmp_df_mtime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004753
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004753
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004781
; ---------------------------------------------------------------------------

loc_8004753:				; CODE XREF: rev_strcmp_df_mtime+26j
					; rev_strcmp_df_mtime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800476B
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800476B
		mov	eax, 1
		jmp	short locret_8004781
; ---------------------------------------------------------------------------

loc_800476B:				; CODE XREF: rev_strcmp_df_mtime+43j
					; rev_strcmp_df_mtime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_mtime
		add	esp, 10h

locret_8004781:				; CODE XREF: rev_strcmp_df_mtime+38j
					; rev_strcmp_df_mtime+50j
		leave
		retn
rev_strcmp_df_mtime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_atime(V a, V b)
xstrcoll_atime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_atime
		add	esp, 10h
		leave
		retn
xstrcoll_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_atime(V a,	V b)
strcmp_atime	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_atime
		add	esp, 10h
		leave
		retn
strcmp_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_atime(V a, V	b)
rev_xstrcoll_atime proc	near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_atime
		add	esp, 10h
		leave
		retn
rev_xstrcoll_atime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_atime(V a, V b)
rev_strcmp_atime proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_atime
		add	esp, 10h
		leave
		retn
rev_strcmp_atime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_atime(V a, V b)
xstrcoll_df_atime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004835
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004835
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004863
; ---------------------------------------------------------------------------

loc_8004835:				; CODE XREF: xstrcoll_df_atime+26j
					; xstrcoll_df_atime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800484D
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800484D
		mov	eax, 1
		jmp	short locret_8004863
; ---------------------------------------------------------------------------

loc_800484D:				; CODE XREF: xstrcoll_df_atime+43j
					; xstrcoll_df_atime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_atime
		add	esp, 10h

locret_8004863:				; CODE XREF: xstrcoll_df_atime+38j
					; xstrcoll_df_atime+50j
		leave
		retn
xstrcoll_df_atime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_atime(V	a, V b)
strcmp_df_atime	proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_800489F
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800489F
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80048CD
; ---------------------------------------------------------------------------

loc_800489F:				; CODE XREF: strcmp_df_atime+26j
					; strcmp_df_atime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80048B7
		cmp	[ebp+b_is_dir],	0
		jz	short loc_80048B7
		mov	eax, 1
		jmp	short locret_80048CD
; ---------------------------------------------------------------------------

loc_80048B7:				; CODE XREF: strcmp_df_atime+43j
					; strcmp_df_atime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_atime
		add	esp, 10h

locret_80048CD:				; CODE XREF: strcmp_df_atime+38j
					; strcmp_df_atime+50j
		leave
		retn
strcmp_df_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_atime(V a, V b)
rev_xstrcoll_df_atime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004909
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004909
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004937
; ---------------------------------------------------------------------------

loc_8004909:				; CODE XREF: rev_xstrcoll_df_atime+26j
					; rev_xstrcoll_df_atime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004921
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004921
		mov	eax, 1
		jmp	short locret_8004937
; ---------------------------------------------------------------------------

loc_8004921:				; CODE XREF: rev_xstrcoll_df_atime+43j
					; rev_xstrcoll_df_atime+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_atime
		add	esp, 10h

locret_8004937:				; CODE XREF: rev_xstrcoll_df_atime+38j
					; rev_xstrcoll_df_atime+50j
		leave
		retn
rev_xstrcoll_df_atime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_atime(V a, V b)
rev_strcmp_df_atime proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004973
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004973
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80049A1
; ---------------------------------------------------------------------------

loc_8004973:				; CODE XREF: rev_strcmp_df_atime+26j
					; rev_strcmp_df_atime+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800498B
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800498B
		mov	eax, 1
		jmp	short locret_80049A1
; ---------------------------------------------------------------------------

loc_800498B:				; CODE XREF: rev_strcmp_df_atime+43j
					; rev_strcmp_df_atime+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_atime
		add	esp, 10h

locret_80049A1:				; CODE XREF: rev_strcmp_df_atime+38j
					; rev_strcmp_df_atime+50j
		leave
		retn
rev_strcmp_df_atime endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_size(V a, V b)
xstrcoll_size	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_size
		add	esp, 10h
		leave
		retn
xstrcoll_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_size(V a, V b)
strcmp_size	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_size
		add	esp, 10h
		leave
		retn
strcmp_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_size(V a, V b)
rev_xstrcoll_size proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_size
		add	esp, 10h
		leave
		retn
rev_xstrcoll_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_size(V	a, V b)
rev_strcmp_size	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_size
		add	esp, 10h
		leave
		retn
rev_strcmp_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_size(V a, V b)
xstrcoll_df_size proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004A55
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004A55
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004A83
; ---------------------------------------------------------------------------

loc_8004A55:				; CODE XREF: xstrcoll_df_size+26j
					; xstrcoll_df_size+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004A6D
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004A6D
		mov	eax, 1
		jmp	short locret_8004A83
; ---------------------------------------------------------------------------

loc_8004A6D:				; CODE XREF: xstrcoll_df_size+43j
					; xstrcoll_df_size+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_size
		add	esp, 10h

locret_8004A83:				; CODE XREF: xstrcoll_df_size+38j
					; xstrcoll_df_size+50j
		leave
		retn
xstrcoll_df_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_size(V a, V b)
strcmp_df_size	proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004ABF
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004ABF
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004AED
; ---------------------------------------------------------------------------

loc_8004ABF:				; CODE XREF: strcmp_df_size+26j
					; strcmp_df_size+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004AD7
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004AD7
		mov	eax, 1
		jmp	short locret_8004AED
; ---------------------------------------------------------------------------

loc_8004AD7:				; CODE XREF: strcmp_df_size+43j
					; strcmp_df_size+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_size
		add	esp, 10h

locret_8004AED:				; CODE XREF: strcmp_df_size+38j
					; strcmp_df_size+50j
		leave
		retn
strcmp_df_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_size(V a,	V b)
rev_xstrcoll_df_size proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004B29
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004B29
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004B57
; ---------------------------------------------------------------------------

loc_8004B29:				; CODE XREF: rev_xstrcoll_df_size+26j
					; rev_xstrcoll_df_size+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004B41
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004B41
		mov	eax, 1
		jmp	short locret_8004B57
; ---------------------------------------------------------------------------

loc_8004B41:				; CODE XREF: rev_xstrcoll_df_size+43j
					; rev_xstrcoll_df_size+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_size
		add	esp, 10h

locret_8004B57:				; CODE XREF: rev_xstrcoll_df_size+38j
					; rev_xstrcoll_df_size+50j
		leave
		retn
rev_xstrcoll_df_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_size(V a, V	b)
rev_strcmp_df_size proc	near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004B93
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004B93
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004BC1
; ---------------------------------------------------------------------------

loc_8004B93:				; CODE XREF: rev_strcmp_df_size+26j
					; rev_strcmp_df_size+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004BAB
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004BAB
		mov	eax, 1
		jmp	short locret_8004BC1
; ---------------------------------------------------------------------------

loc_8004BAB:				; CODE XREF: rev_strcmp_df_size+43j
					; rev_strcmp_df_size+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_size
		add	esp, 10h

locret_8004BC1:				; CODE XREF: rev_strcmp_df_size+38j
					; rev_strcmp_df_size+50j
		leave
		retn
rev_strcmp_df_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_name(V a, V b)
xstrcoll_name	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_name
		add	esp, 10h
		leave
		retn
xstrcoll_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_name(V a, V b)
strcmp_name	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_name
		add	esp, 10h
		leave
		retn
strcmp_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_name(V a, V b)
rev_xstrcoll_name proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_name
		add	esp, 10h
		leave
		retn
rev_xstrcoll_name endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_name(V	a, V b)
rev_strcmp_name	proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_name
		add	esp, 10h
		leave
		retn
rev_strcmp_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_name(V a, V b)
xstrcoll_df_name proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004C75
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004C75
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004CA3
; ---------------------------------------------------------------------------

loc_8004C75:				; CODE XREF: xstrcoll_df_name+26j
					; xstrcoll_df_name+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004C8D
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004C8D
		mov	eax, 1
		jmp	short locret_8004CA3
; ---------------------------------------------------------------------------

loc_8004C8D:				; CODE XREF: xstrcoll_df_name+43j
					; xstrcoll_df_name+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_name
		add	esp, 10h

locret_8004CA3:				; CODE XREF: xstrcoll_df_name+38j
					; xstrcoll_df_name+50j
		leave
		retn
xstrcoll_df_name endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_name(V a, V b)
strcmp_df_name	proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004CDF
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004CDF
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004D0D
; ---------------------------------------------------------------------------

loc_8004CDF:				; CODE XREF: strcmp_df_name+26j
					; strcmp_df_name+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004CF7
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004CF7
		mov	eax, 1
		jmp	short locret_8004D0D
; ---------------------------------------------------------------------------

loc_8004CF7:				; CODE XREF: strcmp_df_name+43j
					; strcmp_df_name+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_name
		add	esp, 10h

locret_8004D0D:				; CODE XREF: strcmp_df_name+38j
					; strcmp_df_name+50j
		leave
		retn
strcmp_df_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_name(V a,	V b)
rev_xstrcoll_df_name proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004D49
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004D49
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004D77
; ---------------------------------------------------------------------------

loc_8004D49:				; CODE XREF: rev_xstrcoll_df_name+26j
					; rev_xstrcoll_df_name+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004D61
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004D61
		mov	eax, 1
		jmp	short locret_8004D77
; ---------------------------------------------------------------------------

loc_8004D61:				; CODE XREF: rev_xstrcoll_df_name+43j
					; rev_xstrcoll_df_name+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_name
		add	esp, 10h

locret_8004D77:				; CODE XREF: rev_xstrcoll_df_name+38j
					; rev_xstrcoll_df_name+50j
		leave
		retn
rev_xstrcoll_df_name endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_name(V a, V	b)
rev_strcmp_df_name proc	near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004DB3
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004DB3
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004DE1
; ---------------------------------------------------------------------------

loc_8004DB3:				; CODE XREF: rev_strcmp_df_name+26j
					; rev_strcmp_df_name+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004DCB
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004DCB
		mov	eax, 1
		jmp	short locret_8004DE1
; ---------------------------------------------------------------------------

loc_8004DCB:				; CODE XREF: rev_strcmp_df_name+43j
					; rev_strcmp_df_name+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_name
		add	esp, 10h

locret_8004DE1:				; CODE XREF: rev_strcmp_df_name+38j
					; rev_strcmp_df_name+50j
		leave
		retn
rev_strcmp_df_name endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_extension(V a, V	b)
xstrcoll_extension proc	near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_extension
		add	esp, 10h
		leave
		retn
xstrcoll_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_extension(V a, V b)
strcmp_extension proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_extension
		add	esp, 10h
		leave
		retn
strcmp_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_extension(V a, V b)
rev_xstrcoll_extension proc near	; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_extension
		add	esp, 10h
		leave
		retn
rev_xstrcoll_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_extension(V a,	V b)
rev_strcmp_extension proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_extension
		add	esp, 10h
		leave
		retn
rev_strcmp_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_extension(V a, V b)
xstrcoll_df_extension proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004E95
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004E95
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004EC3
; ---------------------------------------------------------------------------

loc_8004E95:				; CODE XREF: xstrcoll_df_extension+26j
					; xstrcoll_df_extension+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004EAD
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004EAD
		mov	eax, 1
		jmp	short locret_8004EC3
; ---------------------------------------------------------------------------

loc_8004EAD:				; CODE XREF: xstrcoll_df_extension+43j
					; xstrcoll_df_extension+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_extension
		add	esp, 10h

locret_8004EC3:				; CODE XREF: xstrcoll_df_extension+38j
					; xstrcoll_df_extension+50j
		leave
		retn
xstrcoll_df_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strcmp_df_extension(V a, V b)
strcmp_df_extension proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004EFF
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004EFF
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004F2D
; ---------------------------------------------------------------------------

loc_8004EFF:				; CODE XREF: strcmp_df_extension+26j
					; strcmp_df_extension+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004F17
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004F17
		mov	eax, 1
		jmp	short locret_8004F2D
; ---------------------------------------------------------------------------

loc_8004F17:				; CODE XREF: strcmp_df_extension+43j
					; strcmp_df_extension+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_extension
		add	esp, 10h

locret_8004F2D:				; CODE XREF: strcmp_df_extension+38j
					; strcmp_df_extension+50j
		leave
		retn
strcmp_df_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_extension(V a, V b)
rev_xstrcoll_df_extension proc near	; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004F69
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004F69
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8004F97
; ---------------------------------------------------------------------------

loc_8004F69:				; CODE XREF: rev_xstrcoll_df_extension+26j
					; rev_xstrcoll_df_extension+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004F81
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004F81
		mov	eax, 1
		jmp	short locret_8004F97
; ---------------------------------------------------------------------------

loc_8004F81:				; CODE XREF: rev_xstrcoll_df_extension+43j
					; rev_xstrcoll_df_extension+49j
		sub	esp, 4
		push	offset xstrcoll	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_extension
		add	esp, 10h

locret_8004F97:				; CODE XREF: rev_xstrcoll_df_extension+38j
					; rev_xstrcoll_df_extension+50j
		leave
		retn
rev_xstrcoll_df_extension endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_strcmp_df_extension(V	a, V b)
rev_strcmp_df_extension	proc near	; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_8004FD3
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004FD3
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8005001
; ---------------------------------------------------------------------------

loc_8004FD3:				; CODE XREF: rev_strcmp_df_extension+26j
					; rev_strcmp_df_extension+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8004FEB
		cmp	[ebp+b_is_dir],	0
		jz	short loc_8004FEB
		mov	eax, 1
		jmp	short locret_8005001
; ---------------------------------------------------------------------------

loc_8004FEB:				; CODE XREF: rev_strcmp_df_extension+43j
					; rev_strcmp_df_extension+49j
		sub	esp, 4
		push	offset strcmp	; cmp
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_extension
		add	esp, 10h

locret_8005001:				; CODE XREF: rev_strcmp_df_extension+38j
					; rev_strcmp_df_extension+50j
		leave
		retn
rev_strcmp_df_extension	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_version(const	fileinfo *a, const fileinfo *b)
cmp_version	proc near		; CODE XREF: xstrcoll_version+Fp
					; rev_xstrcoll_version+Fp ...

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		call	filevercmp
		add	esp, 10h
		leave
		retn
cmp_version	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_version(V a, V b)
xstrcoll_version proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 8
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_version
		add	esp, 10h
		leave
		retn
xstrcoll_version endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_version(V a,	V b)
rev_xstrcoll_version proc near		; DATA XREF: .rodata:sort_functionso

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 8
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_version
		add	esp, 10h
		leave
		retn
rev_xstrcoll_version endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl xstrcoll_df_version(V a, V b)
xstrcoll_df_version proc near		; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_800508E
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800508E
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80050B7
; ---------------------------------------------------------------------------

loc_800508E:				; CODE XREF: xstrcoll_df_version+26j
					; xstrcoll_df_version+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80050A6
		cmp	[ebp+b_is_dir],	0
		jz	short loc_80050A6
		mov	eax, 1
		jmp	short locret_80050B7
; ---------------------------------------------------------------------------

loc_80050A6:				; CODE XREF: xstrcoll_df_version+43j
					; xstrcoll_df_version+49j
		sub	esp, 8
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	cmp_version
		add	esp, 10h

locret_80050B7:				; CODE XREF: xstrcoll_df_version+38j
					; xstrcoll_df_version+50j
		leave
		retn
xstrcoll_df_version endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl rev_xstrcoll_df_version(V	a, V b)
rev_xstrcoll_df_version	proc near	; DATA XREF: .rodata:sort_functionso

a_is_dir	= byte ptr -0Ah
b_is_dir	= byte ptr -9
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		push	[ebp+a]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+a_is_dir],	al
		push	[ebp+b]		; f
		call	is_directory
		add	esp, 4
		mov	[ebp+b_is_dir],	al
		cmp	[ebp+a_is_dir],	0
		jz	short loc_80050F3
		movzx	eax, [ebp+b_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_80050F3
		mov	eax, 0FFFFFFFFh
		jmp	short locret_800511C
; ---------------------------------------------------------------------------

loc_80050F3:				; CODE XREF: rev_xstrcoll_df_version+26j
					; rev_xstrcoll_df_version+31j
		movzx	eax, [ebp+a_is_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_800510B
		cmp	[ebp+b_is_dir],	0
		jz	short loc_800510B
		mov	eax, 1
		jmp	short locret_800511C
; ---------------------------------------------------------------------------

loc_800510B:				; CODE XREF: rev_xstrcoll_df_version+43j
					; rev_xstrcoll_df_version+49j
		sub	esp, 8
		push	[ebp+a]		; b
		push	[ebp+b]		; a
		call	cmp_version
		add	esp, 10h

locret_800511C:				; CODE XREF: rev_xstrcoll_df_version+38j
					; rev_xstrcoll_df_version+50j
		leave
		retn
rev_xstrcoll_df_version	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void initialize_ordering_vector()
initialize_ordering_vector proc	near	; CODE XREF: sort_files:loc_80051B5p
					; sort_files:loc_8005209p

i		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_800514E
; ---------------------------------------------------------------------------

loc_800512D:				; CODE XREF: initialize_ordering_vector+38j
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	edx, ds:cwd_file
		mov	ecx, [ebp+i]
		shl	ecx, 7
		add	edx, ecx
		mov	[eax], edx
		add	[ebp+i], 1

loc_800514E:				; CODE XREF: initialize_ordering_vector+Dj
		mov	eax, ds:cwd_n_used
		cmp	[ebp+i], eax
		jb	short loc_800512D
		nop
		leave
		retn
initialize_ordering_vector endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void sort_files()
sort_files	proc near		; CODE XREF: main+4BBp	print_dir+5B1p	...

use_strcmp	= byte ptr -9
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:cwd_n_used
		shr	eax, 1
		mov	edx, eax
		mov	eax, ds:cwd_n_used
		add	edx, eax
		mov	eax, ds:sorted_file_alloc
		cmp	edx, eax
		jbe	short loc_80051B5
		mov	eax, ds:sorted_file
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:cwd_n_used
		sub	esp, 8
		push	0Ch
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	ds:sorted_file,	eax
		mov	edx, ds:cwd_n_used
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		mov	ds:sorted_file_alloc, eax

loc_80051B5:				; CODE XREF: sort_files+1Ej
		call	initialize_ordering_vector
		mov	eax, ds:sort_type_0
		cmp	eax, 0FFFFFFFFh
		jz	loc_8005273
		sub	esp, 0Ch
		push	offset failed_strcoll ;	env
		call	_setjmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80051E2
		mov	[ebp+use_strcmp], 0
		jmp	short loc_800520E
; ---------------------------------------------------------------------------

loc_80051E2:				; CODE XREF: sort_files+7Fj
		mov	[ebp+use_strcmp], 1
		mov	eax, ds:sort_type_0
		cmp	eax, 3
		jnz	short loc_8005209
		push	offset __PRETTY_FUNCTION___7728	; "sort_files"
		push	0D44h		; line
		push	offset file	; "ls.c"
		push	offset aSort_typeSort_ ; "sort_type != sort_version"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8005209:				; CODE XREF: sort_files+93j
		call	initialize_ordering_vector

loc_800520E:				; CODE XREF: sort_files+85j
		mov	eax, ds:sort_type_0
		cmp	eax, 4
		jnz	short loc_800521F
		mov	eax, ds:time_type_0
		jmp	short loc_8005224
; ---------------------------------------------------------------------------

loc_800521F:				; CODE XREF: sort_files+BBj
		mov	eax, 0

loc_8005224:				; CODE XREF: sort_files+C2j
		mov	edx, ds:sort_type_0
		lea	ebx, [eax+edx]
		movzx	ecx, [ebp+use_strcmp]
		movzx	eax, ds:sort_reverse
		movzx	edx, al
		movzx	eax, ds:directories_first
		movzx	eax, al
		add	ebx, ebx
		add	ecx, ebx
		add	ecx, ecx
		add	edx, ecx
		add	edx, edx
		add	eax, edx
		mov	ecx, ds:sort_functions[eax*4]
		mov	edx, ds:cwd_n_used
		mov	eax, ds:sorted_file
		sub	esp, 4
		push	ecx
		push	edx
		push	eax
		call	mpsort
		add	esp, 10h
		jmp	short loc_8005274
; ---------------------------------------------------------------------------

loc_8005273:				; CODE XREF: sort_files+67j
		nop

loc_8005274:				; CODE XREF: sort_files+116j
		mov	ebx, [ebp+var_4]
		leave
		retn
sort_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_current_files()
print_current_files proc near		; CODE XREF: main+4E6p	print_dir+5B6p	...

i		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:format_0
		cmp	eax, 4		; switch 5 cases
		ja	loc_800533B	; jumptable 08005294 default case
		mov	eax, ds:off_8009FBC[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8005296:				; CODE XREF: print_current_files+1Bj
					; DATA XREF: .rodata:off_8009FBCo
		mov	[ebp+i], 0	; jumptable 08005294 case 1
		jmp	short loc_80052CD
; ---------------------------------------------------------------------------

loc_800529F:				; CODE XREF: print_current_files+5Cj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	0		; start_col
		push	eax		; f
		call	print_file_name_and_frills
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		add	[ebp+i], 1

loc_80052CD:				; CODE XREF: print_current_files+24j
		mov	eax, ds:cwd_n_used
		cmp	[ebp+i], eax
		jb	short loc_800529F
		jmp	short loc_800533B ; jumptable 08005294 default case
; ---------------------------------------------------------------------------

loc_80052D9:				; CODE XREF: print_current_files+1Bj
					; DATA XREF: .rodata:off_8009FBCo
		call	print_many_per_line ; jumptable	08005294 case 2
		jmp	short loc_800533B ; jumptable 08005294 default case
; ---------------------------------------------------------------------------

loc_80052E0:				; CODE XREF: print_current_files+1Bj
					; DATA XREF: .rodata:off_8009FBCo
		call	print_horizontal ; jumptable 08005294 case 3
		jmp	short loc_800533B ; jumptable 08005294 default case
; ---------------------------------------------------------------------------

loc_80052E7:				; CODE XREF: print_current_files+1Bj
					; DATA XREF: .rodata:off_8009FBCo
		call	print_with_commas ; jumptable 08005294 case 4
		jmp	short loc_800533B ; jumptable 08005294 default case
; ---------------------------------------------------------------------------

loc_80052EE:				; CODE XREF: print_current_files+1Bj
					; DATA XREF: .rodata:off_8009FBCo
		mov	[ebp+i], 0	; jumptable 08005294 case 0
		jmp	short loc_8005330
; ---------------------------------------------------------------------------

loc_80052F7:				; CODE XREF: print_current_files+BFj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; f
		call	print_long_format
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax
		add	[ebp+i], 1

loc_8005330:				; CODE XREF: print_current_files+7Cj
		mov	eax, ds:cwd_n_used
		cmp	[ebp+i], eax
		jb	short loc_80052F7
		nop

loc_800533B:				; CODE XREF: print_current_files+Ej
					; print_current_files+5Ej ...
		nop			; jumptable 08005294 default case
		leave
		retn
print_current_files endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl align_nstrftime(char *buf, size_t size, const char *fmt, const	tm *tm,	int __utc, int __ns)
align_nstrftime	proc near		; CODE XREF: long_time_expected_width+6Bp
					; print_long_format+7D5p

tm		= dword	ptr -134h
fmt		= dword	ptr -130h
buf		= dword	ptr -12Ch
nfmt		= dword	ptr -124h
pb		= dword	ptr -120h
pfmt		= dword	ptr -11Ch
ret		= dword	ptr -118h
rpl_fmt		= byte ptr -111h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
size		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
__utc		= dword	ptr  18h
__ns		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 138h
		mov	eax, [ebp+arg_0]
		mov	[ebp+buf], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+fmt], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+tm], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+fmt]
		mov	[ebp+nfmt], eax
		mov	eax, ds:required_mon_width
		test	eax, eax
		jz	loc_8005456
		sub	esp, 8
		push	offset needle	; "%b"
		push	[ebp+fmt]	; haystack
		call	strstr
		add	esp, 10h
		mov	[ebp+pb], eax
		cmp	[ebp+pb], 0
		jz	loc_8005456
		sub	esp, 0Ch
		push	[ebp+fmt]	; s
		call	strlen
		add	esp, 10h
		cmp	eax, 65h
		ja	loc_8005456
		lea	eax, [ebp+rpl_fmt]
		mov	[ebp+pfmt], eax
		lea	eax, [ebp+rpl_fmt]
		mov	[ebp+nfmt], eax
		mov	edx, [ebp+pb]
		mov	eax, [ebp+fmt]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax
		push	[ebp+fmt]
		push	[ebp+pfmt]
		call	mempcpy
		add	esp, 10h
		mov	[ebp+pfmt], eax
		mov	eax, [ebp+tm]
		mov	eax, [eax+10h]
		imul	eax, 0A1h
		add	eax, offset abmon
		sub	esp, 8
		push	eax
		push	[ebp+pfmt]
		call	stpcpy
		add	esp, 10h
		mov	[ebp+pfmt], eax
		mov	eax, [ebp+pb]
		add	eax, 2
		sub	esp, 8
		push	eax		; src
		push	[ebp+pfmt]	; dest
		call	strcpy
		add	esp, 10h

loc_8005456:				; CODE XREF: align_nstrftime+42j
					; align_nstrftime+6Bj ...
		sub	esp, 8
		push	[ebp+__ns]
		push	[ebp+__utc]
		push	[ebp+tm]
		push	[ebp+nfmt]
		push	[ebp+size]
		push	[ebp+buf]
		call	nstrftime
		add	esp, 20h
		mov	[ebp+ret], eax
		mov	eax, [ebp+ret]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8005499
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8005499:				; CODE XREF: align_nstrftime+154j
		leave
		retn
align_nstrftime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int long_time_expected_width()
long_time_expected_width proc near	; CODE XREF: print_long_format:loc_8006059p

epoch		= dword	ptr -404h
tm		= dword	ptr -400h
len		= dword	ptr -3FCh
buf		= byte ptr -3F5h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 408h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, width_7761
		test	eax, eax
		jns	loc_800554F
		mov	[ebp+epoch], 0
		sub	esp, 0Ch
		lea	eax, [ebp+epoch]
		push	eax		; timer
		call	localtime
		add	esp, 10h
		mov	[ebp+tm], eax
		cmp	[ebp+tm], 0
		jz	short loc_800553C
		mov	eax, long_time_format
		sub	esp, 8
		push	0		; __ns
		push	0		; __utc
		push	[ebp+tm]	; tm
		push	eax		; fmt
		push	3E9h		; size
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	align_nstrftime
		add	esp, 20h
		mov	[ebp+len], eax
		cmp	[ebp+len], 0
		jz	short loc_800553C
		sub	esp, 4
		push	0
		push	[ebp+len]
		lea	eax, [ebp+buf]
		push	eax
		call	mbsnwidth
		add	esp, 10h
		mov	width_7761, eax

loc_800553C:				; CODE XREF: long_time_expected_width+4Aj
					; long_time_expected_width+80j
		mov	eax, width_7761
		test	eax, eax
		jns	short loc_800554F
		mov	width_7761, 0

loc_800554F:				; CODE XREF: long_time_expected_width+1Bj
					; long_time_expected_width+A8j
		mov	eax, width_7761
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8005565
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8005565:				; CODE XREF: long_time_expected_width+C3j
		leave
		retn
long_time_expected_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_user_or_group(const char *name, unsigned int id, int width)
format_user_or_group proc near		; CODE XREF: format_user+48p
					; format_group+48p ...

len		= dword	ptr -14h
pad		= dword	ptr -10h
width_gap	= dword	ptr -0Ch
name		= dword	ptr  8
id		= dword	ptr  0Ch
width		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		cmp	[ebp+name], 0
		jz	short loc_80055E5
		sub	esp, 8
		push	0
		push	[ebp+name]
		call	gnu_mbswidth
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+width]
		sub	eax, edx
		mov	[ebp+width_gap], eax
		mov	eax, 0
		cmp	[ebp+width_gap], 0
		cmovns	eax, [ebp+width_gap]
		mov	[ebp+pad], eax
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		push	[ebp+name]
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+name]	; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+pad]
		add	eax, edx
		mov	[ebp+len], eax

loc_80055C9:				; CODE XREF: format_user_or_group+7Aj
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, [ebp+pad]
		lea	edx, [eax-1]
		mov	[ebp+pad], edx
		test	eax, eax
		jnz	short loc_80055C9
		jmp	short loc_8005601
; ---------------------------------------------------------------------------

loc_80055E5:				; CODE XREF: format_user_or_group+Aj
		sub	esp, 4
		push	[ebp+id]
		push	[ebp+width]
		push	offset aLu	; "%*lu	"
		call	printf
		add	esp, 10h
		mov	eax, [ebp+width]
		mov	[ebp+len], eax

loc_8005601:				; CODE XREF: format_user_or_group+7Cj
		mov	edx, ds:dired_pos
		mov	eax, [ebp+len]
		add	eax, edx
		add	eax, 1
		mov	ds:dired_pos, eax
		nop
		leave
		retn
format_user_or_group endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_user(uid_t u, int	width, _Bool stat_ok)
format_user	proc near		; CODE XREF: print_long_format+407p
					; print_long_format+471p

stat_ok		= byte ptr -0Ch
u		= dword	ptr  8
width		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[ebp+stat_ok], al
		movzx	eax, [ebp+stat_ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8005635
		mov	eax, offset a?	; "?"
		jmp	short loc_8005655
; ---------------------------------------------------------------------------

loc_8005635:				; CODE XREF: format_user+15j
		movzx	eax, ds:numeric_ids
		test	al, al
		jz	short loc_8005647
		mov	eax, 0
		jmp	short loc_8005655
; ---------------------------------------------------------------------------

loc_8005647:				; CODE XREF: format_user+27j
		sub	esp, 0Ch
		push	[ebp+u]
		call	getuser
		add	esp, 10h

loc_8005655:				; CODE XREF: format_user+1Cj
					; format_user+2Ej
		sub	esp, 4
		push	[ebp+width]	; width
		push	[ebp+u]		; id
		push	eax		; name
		call	format_user_or_group
		add	esp, 10h
		nop
		leave
		retn
format_user	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_group(gid_t g, int width,	_Bool stat_ok)
format_group	proc near		; CODE XREF: print_long_format+43Cp

stat_ok		= byte ptr -0Ch
g		= dword	ptr  8
width		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[ebp+stat_ok], al
		movzx	eax, [ebp+stat_ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8005688
		mov	eax, offset a?	; "?"
		jmp	short loc_80056A8
; ---------------------------------------------------------------------------

loc_8005688:				; CODE XREF: format_group+15j
		movzx	eax, ds:numeric_ids
		test	al, al
		jz	short loc_800569A
		mov	eax, 0
		jmp	short loc_80056A8
; ---------------------------------------------------------------------------

loc_800569A:				; CODE XREF: format_group+27j
		sub	esp, 0Ch
		push	[ebp+g]
		call	getgroup
		add	esp, 10h

loc_80056A8:				; CODE XREF: format_group+1Cj
					; format_group+2Ej
		sub	esp, 4
		push	[ebp+width]	; width
		push	[ebp+g]		; id
		push	eax		; name
		call	format_user_or_group
		add	esp, 10h
		nop
		leave
		retn
format_group	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl format_user_or_group_width(const char *name, unsigned int	id)
format_user_or_group_width proc	near	; CODE XREF: format_user_width+2Dp
					; format_group_width+2Dp

name		= dword	ptr -2Ch
len		= dword	ptr -1Ch
buf		= byte ptr -17h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
id		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		cmp	[ebp+name], 0
		jz	short loc_80056FC
		sub	esp, 8
		push	0
		push	[ebp+name]
		call	gnu_mbswidth
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, 0
		cmp	[ebp+len], 0
		cmovns	eax, [ebp+len]
		jmp	short loc_8005722
; ---------------------------------------------------------------------------

loc_80056FC:				; CODE XREF: format_user_or_group_width+1Bj
		sub	esp, 4
		push	[ebp+id]
		push	offset aLu_0	; "%lu"
		lea	eax, [ebp+buf]
		push	eax		; s
		call	sprintf
		add	esp, 10h
		sub	esp, 0Ch
		lea	eax, [ebp+buf]
		push	eax		; s
		call	strlen
		add	esp, 10h

loc_8005722:				; CODE XREF: format_user_or_group_width+3Dj
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8005733
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8005733:				; CODE XREF: format_user_or_group_width+6Fj
		leave
		retn
format_user_or_group_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl format_user_width(uid_t u)
format_user_width proc near		; CODE XREF: gobble_file+8FFp
					; gobble_file+97Bp

u		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, ds:numeric_ids
		test	al, al
		jz	short loc_800574D
		mov	eax, 0
		jmp	short loc_800575B
; ---------------------------------------------------------------------------

loc_800574D:				; CODE XREF: format_user_width+Fj
		sub	esp, 0Ch
		push	[ebp+u]
		call	getuser
		add	esp, 10h

loc_800575B:				; CODE XREF: format_user_width+16j
		sub	esp, 8
		push	[ebp+u]		; id
		push	eax		; name
		call	format_user_or_group_width
		add	esp, 10h
		leave
		retn
format_user_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl format_group_width(gid_t g)
format_group_width proc	near		; CODE XREF: gobble_file+93Dp

g		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, ds:numeric_ids
		test	al, al
		jz	short loc_8005784
		mov	eax, 0
		jmp	short loc_8005792
; ---------------------------------------------------------------------------

loc_8005784:				; CODE XREF: format_group_width+Fj
		sub	esp, 0Ch
		push	[ebp+g]
		call	getgroup
		add	esp, 10h

loc_8005792:				; CODE XREF: format_group_width+16j
		sub	esp, 8
		push	[ebp+g]		; id
		push	eax		; name
		call	format_user_or_group_width
		add	esp, 10h
		leave
		retn
format_group_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	format_inode(char *buf,	size_t buflen, const fileinfo *f)
format_inode	proc near		; CODE XREF: print_long_format+1AEp
					; print_file_name_and_frills+3Fp

buf		= dword	ptr  8
buflen		= dword	ptr  0Ch
f		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+buflen], 14h
		ja	short loc_80057C8
		push	offset __PRETTY_FUNCTION___7803	; "format_inode"
		push	0E0Eh		; line
		push	offset file	; "ls.c"
		push	offset aInt_bufsize_bo ; "INT_BUFSIZE_BOUND (uintmax_t)	<= buflen"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80057C8:				; CODE XREF: format_inode+Aj
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		test	al, al
		jz	short loc_80057FD
		mov	eax, [ebp+f]
		mov	edx, [eax+64h]
		mov	eax, [eax+60h]
		or	eax, edx
		test	eax, eax
		jz	short loc_80057FD
		mov	eax, [ebp+f]
		mov	edx, [eax+64h]
		mov	eax, [eax+60h]
		sub	esp, 4
		push	[ebp+buf]
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		jmp	short locret_8005802
; ---------------------------------------------------------------------------

loc_80057FD:				; CODE XREF: format_inode+2Ej
					; format_inode+3Dj
		mov	eax, offset a?	; "?"

locret_8005802:				; CODE XREF: format_inode+58j
		leave
		retn
format_inode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_long_format(const fileinfo	*f)
print_long_format proc near		; CODE XREF: print_current_files+91p

var_1158	= timespec ptr -1158h
f		= dword	ptr -114Ch
recent		= byte ptr -113Dh
s		= dword	ptr -113Ch
p		= dword	ptr -1138h
blocks		= dword	ptr -1134h
pad		= dword	ptr -1130h
size		= dword	ptr -112Ch
pad_0		= dword	ptr -1128h
blanks_width	= dword	ptr -1124h
when_local	= dword	ptr -1120h
fmt		= dword	ptr -111Ch
w		= dword	ptr -1118h
when_timespec	= timespec ptr -1114h
six_months_ago	= timespec ptr -110Ch
modebuf		= byte ptr -1104h
majorbuf	= byte ptr -10F8h
hbuf		= byte ptr -10E3h
buf		= byte ptr -0E57h
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 114Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		test	al, al
		jz	short loc_8005850
		mov	eax, [ebp+f]
		lea	edx, [eax+8]
		sub	esp, 8
		lea	eax, [ebp+modebuf]
		push	eax
		push	edx
		call	filemodestring
		add	esp, 10h
		jmp	short loc_8005886
; ---------------------------------------------------------------------------

loc_8005850:				; CODE XREF: print_long_format+2Cj
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		movzx	eax, byte ptr ds:filetype_letter[eax] ;	"?pcdb-lswd"
		mov	[ebp+modebuf], al
		lea	eax, [ebp+modebuf]
		add	eax, 1
		sub	esp, 4
		push	0Ah		; n
		push	3Fh		; c
		push	eax		; s
		call	memset
		add	esp, 10h
		mov	[ebp+modebuf+0Bh], 0

loc_8005886:				; CODE XREF: print_long_format+4Aj
		movzx	eax, ds:any_has_acl
		xor	eax, 1
		test	al, al
		jz	short loc_800589D
		mov	[ebp+modebuf+0Ah], 0
		jmp	short loc_80058C9
; ---------------------------------------------------------------------------

loc_800589D:				; CODE XREF: print_long_format+8Ej
		mov	eax, [ebp+f]
		mov	eax, [eax+78h]
		cmp	eax, 1
		jnz	short loc_80058B4
		mov	[ebp+modebuf+0Ah], 2Eh
		jmp	short loc_80058C9
; ---------------------------------------------------------------------------

loc_80058B4:				; CODE XREF: print_long_format+A5j
		mov	eax, [ebp+f]
		mov	eax, [eax+78h]
		cmp	eax, 2
		jnz	short loc_80058C9
		mov	[ebp+modebuf+0Ah], 2Bh

loc_80058C9:				; CODE XREF: print_long_format+97j
					; print_long_format+AEj ...
		mov	eax, ds:time_type_0
		cmp	eax, 1
		jz	short loc_80058E2
		cmp	eax, 1
		jb	short loc_8005918
		cmp	eax, 2
		jz	short loc_800594E
		jmp	loc_8005984
; ---------------------------------------------------------------------------

loc_80058E2:				; CODE XREF: print_long_format+CDj
		mov	eax, [ebp+f]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1158]
		sub	esp, 8
		push	edx		; st
		push	eax		; retstr
		call	get_stat_ctime
		add	esp, 0Ch
		mov	eax, [ebp+var_1158.tv_sec]
		mov	edx, [ebp+var_1158.tv_nsec]
		mov	[ebp+when_timespec.tv_sec], eax
		mov	[ebp+when_timespec.tv_nsec], edx
		jmp	short loc_8005989
; ---------------------------------------------------------------------------

loc_8005918:				; CODE XREF: print_long_format+D2j
		mov	eax, [ebp+f]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1158]
		sub	esp, 8
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_1158.tv_sec]
		mov	edx, [ebp+var_1158.tv_nsec]
		mov	[ebp+when_timespec.tv_sec], eax
		mov	[ebp+when_timespec.tv_nsec], edx
		jmp	short loc_8005989
; ---------------------------------------------------------------------------

loc_800594E:				; CODE XREF: print_long_format+D7j
		mov	eax, [ebp+f]
		lea	edx, [eax+8]
		lea	eax, [ebp+var_1158]
		sub	esp, 8
		push	edx		; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 0Ch
		mov	eax, [ebp+var_1158.tv_sec]
		mov	edx, [ebp+var_1158.tv_nsec]
		mov	[ebp+when_timespec.tv_sec], eax
		mov	[ebp+when_timespec.tv_nsec], edx
		jmp	short loc_8005989
; ---------------------------------------------------------------------------

loc_8005984:				; CODE XREF: print_long_format+D9j
		call	abort
; ---------------------------------------------------------------------------

loc_8005989:				; CODE XREF: print_long_format+112j
					; print_long_format+148j ...
		lea	eax, [ebp+buf]
		mov	[ebp+p], eax
		movzx	eax, ds:print_inode
		test	al, al
		jz	short loc_80059ED
		sub	esp, 4
		push	[ebp+f]		; f
		push	15h		; buflen
		lea	eax, [ebp+hbuf]
		push	eax		; buf
		call	format_inode
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:inode_number_width
		push	edx
		push	eax
		push	offset aS_0	; "%*s "
		push	[ebp+p]		; s
		call	sprintf
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		add	[ebp+p], eax

loc_80059ED:				; CODE XREF: print_long_format+19Aj
		movzx	eax, ds:print_block_size
		test	al, al
		jz	loc_8005AD2
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_8005A14
		mov	eax, offset a?	; "?"
		jmp	short loc_8005A4C
; ---------------------------------------------------------------------------

loc_8005A14:				; CODE XREF: print_long_format+207j
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	esi, ds:human_output_opts
		mov	ecx, [ebp+f]
		mov	ebx, [ecx+44h]
		mov	ecx, [ecx+40h]
		push	edx
		push	eax
		push	0
		push	200h
		push	esi
		lea	eax, [ebp+hbuf]
		push	eax
		push	ebx
		push	ecx
		call	human_readable
		add	esp, 20h

loc_8005A4C:				; CODE XREF: print_long_format+20Ej
		mov	[ebp+blocks], eax
		mov	ebx, ds:block_size_width
		sub	esp, 8
		push	0
		push	[ebp+blocks]
		call	gnu_mbswidth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+pad], eax
		jmp	short loc_8005A90
; ---------------------------------------------------------------------------

loc_8005A77:				; CODE XREF: print_long_format+293j
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	20h
		sub	[ebp+pad], 1

loc_8005A90:				; CODE XREF: print_long_format+271j
		cmp	[ebp+pad], 0
		jg	short loc_8005A77
		jmp	short loc_8005A9C
; ---------------------------------------------------------------------------

loc_8005A9B:				; CODE XREF: print_long_format+2C0j
		nop

loc_8005A9C:				; CODE XREF: print_long_format+295j
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	edx, [ebp+blocks]
		lea	ecx, [edx+1]
		mov	[ebp+blocks], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8005A9B
		mov	eax, [ebp+p]
		sub	eax, 1
		mov	byte ptr [eax],	20h

loc_8005AD2:				; CODE XREF: print_long_format+1F2j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_8005AEA
		mov	edx, offset a?	; "?"
		jmp	short loc_8005B0E
; ---------------------------------------------------------------------------

loc_8005AEA:				; CODE XREF: print_long_format+2DDj
		mov	eax, [ebp+f]
		mov	eax, [eax+1Ch]
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+hbuf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax

loc_8005B0E:				; CODE XREF: print_long_format+2E4j
		mov	eax, ds:nlink_width
		sub	esp, 0Ch
		push	edx
		push	eax
		lea	eax, [ebp+modebuf]
		push	eax
		push	offset aSS	; "%s %*s "
		push	[ebp+p]		; s
		call	sprintf
		add	esp, 20h
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		add	[ebp+p], eax
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8005B78
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_8009DB1 ; "	"
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 2
		mov	ds:dired_pos, eax

loc_8005B78:				; CODE XREF: print_long_format+34Ej
		movzx	eax, print_owner
		test	al, al
		jnz	short loc_8005BA8
		movzx	eax, print_group
		test	al, al
		jnz	short loc_8005BA8
		movzx	eax, ds:print_author
		test	al, al
		jnz	short loc_8005BA8
		movzx	eax, ds:print_scontext
		test	al, al
		jz	loc_8005CB2

loc_8005BA8:				; CODE XREF: print_long_format+37Dj
					; print_long_format+388j ...
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		lea	eax, [ebp+buf]
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	edx, [ebp+p]
		lea	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, ds:dired_pos
		add	eax, edx
		mov	ds:dired_pos, eax
		movzx	eax, print_owner
		test	al, al
		jz	short loc_8005C13
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	ecx, al
		mov	edx, ds:owner_width
		mov	eax, [ebp+f]
		mov	eax, [eax+20h]
		sub	esp, 4
		push	ecx		; stat_ok
		push	edx		; width
		push	eax		; u
		call	format_user
		add	esp, 10h

loc_8005C13:				; CODE XREF: print_long_format+3E3j
		movzx	eax, print_group
		test	al, al
		jz	short loc_8005C48
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	ecx, al
		mov	edx, ds:group_width
		mov	eax, [ebp+f]
		mov	eax, [eax+24h]
		sub	esp, 4
		push	ecx		; stat_ok
		push	edx		; width
		push	eax		; g
		call	format_group
		add	esp, 10h

loc_8005C48:				; CODE XREF: print_long_format+418j
		movzx	eax, ds:print_author
		test	al, al
		jz	short loc_8005C7D
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	ecx, al
		mov	edx, ds:author_width
		mov	eax, [ebp+f]
		mov	eax, [eax+20h]
		sub	esp, 4
		push	ecx		; stat_ok
		push	edx		; width
		push	eax		; u
		call	format_user
		add	esp, 10h

loc_8005C7D:				; CODE XREF: print_long_format+44Dj
		movzx	eax, ds:print_scontext
		test	al, al
		jz	short loc_8005CA6
		mov	edx, ds:scontext_width
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		sub	esp, 4
		push	edx		; width
		push	0		; id
		push	eax		; name
		call	format_user_or_group
		add	esp, 10h

loc_8005CA6:				; CODE XREF: print_long_format+482j
		lea	eax, [ebp+buf]
		mov	[ebp+p], eax

loc_8005CB2:				; CODE XREF: print_long_format+39Ej
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		test	al, al
		jz	loc_8005DC7
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 2000h
		jz	short loc_8005CF2
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]
		and	eax, 0F000h
		cmp	eax, 6000h
		jnz	loc_8005DC7

loc_8005CF2:				; CODE XREF: print_long_format+4D3j
		mov	eax, ds:file_size_width
		mov	edx, ds:major_device_number_width
		lea	ecx, [edx+2]
		mov	edx, ds:minor_device_number_width
		add	edx, ecx
		sub	eax, edx
		mov	[ebp+blanks_width], eax
		mov	eax, [ebp+f]
		mov	edx, [eax+2Ch]
		mov	eax, [eax+28h]
		sub	esp, 8
		push	edx
		push	eax		; dev
		call	gnu_dev_minor
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+hbuf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:minor_device_number_width
		mov	eax, [ebp+f]
		mov	edx, [eax+2Ch]
		mov	eax, [eax+28h]
		sub	esp, 8
		push	edx
		push	eax		; dev
		call	gnu_dev_major
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+majorbuf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	ecx, eax
		mov	eax, 0
		cmp	[ebp+blanks_width], 0
		cmovns	eax, [ebp+blanks_width]
		mov	edx, eax
		mov	eax, ds:major_device_number_width
		add	eax, edx
		sub	esp, 8
		push	esi
		push	ebx
		push	ecx
		push	eax
		push	offset aSS_0	; "%*s,	%*s "
		push	[ebp+p]		; s
		call	sprintf
		add	esp, 20h
		mov	eax, ds:file_size_width
		add	eax, 1
		add	[ebp+p], eax
		jmp	loc_8005EA8
; ---------------------------------------------------------------------------

loc_8005DC7:				; CODE XREF: print_long_format+4BAj
					; print_long_format+4E8j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_8005DDF
		mov	eax, offset a?	; "?"
		jmp	short loc_8005E22
; ---------------------------------------------------------------------------

loc_8005DDF:				; CODE XREF: print_long_format+5D2j
		mov	ebx, dword ptr file_output_block_size
		mov	esi, dword ptr file_output_block_size+4
		mov	edi, ds:human_output_opts
		mov	eax, [ebp+f]
		mov	edx, [eax+38h]
		mov	eax, [eax+34h]
		sub	esp, 8
		push	edx
		push	eax		; size
		call	unsigned_file_size
		add	esp, 10h
		push	esi
		push	ebx
		push	0
		push	1
		push	edi
		lea	ecx, [ebp+hbuf]
		push	ecx
		push	edx
		push	eax
		call	human_readable
		add	esp, 20h

loc_8005E22:				; CODE XREF: print_long_format+5D9j
		mov	[ebp+size], eax
		mov	ebx, ds:file_size_width
		sub	esp, 8
		push	0
		push	[ebp+size]
		call	gnu_mbswidth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+pad_0], eax
		jmp	short loc_8005E66
; ---------------------------------------------------------------------------

loc_8005E4D:				; CODE XREF: print_long_format+669j
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	20h
		sub	[ebp+pad_0], 1

loc_8005E66:				; CODE XREF: print_long_format+647j
		cmp	[ebp+pad_0], 0
		jg	short loc_8005E4D
		jmp	short loc_8005E72
; ---------------------------------------------------------------------------

loc_8005E71:				; CODE XREF: print_long_format+696j
		nop

loc_8005E72:				; CODE XREF: print_long_format+66Bj
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	edx, [ebp+size]
		lea	ecx, [edx+1]
		mov	[ebp+size], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8005E71
		mov	eax, [ebp+p]
		sub	eax, 1
		mov	byte ptr [eax],	20h

loc_8005EA8:				; CODE XREF: print_long_format+5BEj
		sub	esp, 0Ch
		lea	eax, [ebp+when_timespec]
		push	eax		; timer
		call	localtime
		add	esp, 10h
		mov	[ebp+when_local], eax
		mov	[ebp+s], 0
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		test	al, al
		jz	loc_8005FE7
		cmp	[ebp+when_local], 0
		jz	loc_8005FE7
		push	[ebp+when_timespec.tv_nsec]
		push	[ebp+when_timespec.tv_sec] ; b
		push	ds:current_time.tv_nsec
		push	ds:current_time.tv_sec ; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8005F26
		sub	esp, 0Ch
		push	offset current_time
		call	gettime
		add	esp, 10h

loc_8005F26:				; CODE XREF: print_long_format+710j
		mov	eax, ds:current_time.tv_sec
		sub	eax, 0F0C2ACh
		mov	[ebp+six_months_ago.tv_sec], eax
		mov	eax, ds:current_time.tv_nsec
		mov	[ebp+six_months_ago.tv_nsec], eax
		push	[ebp+when_timespec.tv_nsec]
		push	[ebp+when_timespec.tv_sec] ; b
		push	[ebp+six_months_ago.tv_nsec]
		push	[ebp+six_months_ago.tv_sec] ; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8005F90
		push	ds:current_time.tv_nsec
		push	ds:current_time.tv_sec ; b
		push	[ebp+when_timespec.tv_nsec]
		push	[ebp+when_timespec.tv_sec] ; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8005F90
		mov	eax, 1
		jmp	short loc_8005F95
; ---------------------------------------------------------------------------

loc_8005F90:				; CODE XREF: print_long_format+75Fj
					; print_long_format+783j
		mov	eax, 0

loc_8005F95:				; CODE XREF: print_long_format+78Aj
		mov	[ebp+recent], al
		and	[ebp+recent], 1
		movzx	eax, [ebp+recent]
		mov	eax, long_time_format[eax*4]
		mov	[ebp+fmt], eax
		mov	eax, [ebp+when_timespec.tv_nsec]
		sub	esp, 8
		push	eax		; __ns
		push	0		; __utc
		push	[ebp+when_local] ; tm
		push	[ebp+fmt]	; fmt
		push	3E9h		; size
		push	[ebp+p]		; buf
		call	align_nstrftime
		add	esp, 20h
		mov	[ebp+s], eax

loc_8005FE7:				; CODE XREF: print_long_format+6DBj
					; print_long_format+6E8j
		cmp	[ebp+s], 0
		jnz	short loc_8005FFD
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8006026

loc_8005FFD:				; CODE XREF: print_long_format+7EAj
		mov	eax, [ebp+s]
		add	[ebp+p], eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	20h
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	0
		jmp	short loc_800608A
; ---------------------------------------------------------------------------

loc_8006026:				; CODE XREF: print_long_format+7F7j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_800603E
		mov	ebx, offset a?	; "?"
		jmp	short loc_8006059
; ---------------------------------------------------------------------------

loc_800603E:				; CODE XREF: print_long_format+831j
		mov	eax, [ebp+when_timespec.tv_sec]
		sub	esp, 8
		lea	edx, [ebp+hbuf]
		push	edx		; buf
		push	eax		; t
		call	timetostr
		add	esp, 10h
		mov	ebx, eax

loc_8006059:				; CODE XREF: print_long_format+838j
		call	long_time_expected_width
		push	ebx
		push	eax
		push	offset aS_0	; "%*s "
		push	[ebp+p]		; s
		call	sprintf
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		add	[ebp+p], eax

loc_800608A:				; CODE XREF: print_long_format+820j
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		lea	eax, [ebp+buf]
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	edx, [ebp+p]
		lea	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, ds:dired_pos
		add	eax, edx
		mov	ds:dired_pos, eax
		mov	edx, [ebp+p]
		lea	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		push	eax		; start_col
		push	offset dired_obstack ; stack
		push	0		; symlink_target
		push	[ebp+f]		; f
		call	print_name_with_quoting
		add	esp, 10h
		mov	[ebp+w], eax
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		cmp	eax, 6
		jnz	loc_8006187
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		test	eax, eax
		jz	loc_80061BD
		mov	eax, ds:stdout
		push	eax		; stream
		push	4		; n
		push	1		; size
		push	offset asc_800A01B ; " -> "
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 4
		mov	ds:dired_pos, eax
		mov	edx, [ebp+p]
		lea	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+w]
		add	eax, edx
		add	eax, 4
		push	eax		; start_col
		push	0		; stack
		push	1		; symlink_target
		push	[ebp+f]		; f
		call	print_name_with_quoting
		add	esp, 10h
		mov	eax, ds:indicator_style_0
		test	eax, eax
		jz	short loc_80061BD
		mov	eax, [ebp+f]
		mov	eax, [eax+6Ch]
		sub	esp, 4
		push	0		; type
		push	eax		; mode
		push	1		; stat_ok
		call	print_type_indicator
		add	esp, 10h
		jmp	short loc_80061BD
; ---------------------------------------------------------------------------

loc_8006187:				; CODE XREF: print_long_format+8F4j
		mov	eax, ds:indicator_style_0
		test	eax, eax
		jz	short loc_80061BD
		mov	eax, [ebp+f]
		mov	ecx, [eax+68h]
		mov	eax, [ebp+f]
		mov	edx, [eax+18h]
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	eax, al
		sub	esp, 4
		push	ecx		; type
		push	edx		; mode
		push	eax		; stat_ok
		call	print_type_indicator
		add	esp, 10h

loc_80061BD:				; CODE XREF: print_long_format+905j
					; print_long_format+966j ...
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_80061CF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80061CF:				; CODE XREF: print_long_format+9C4j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
print_long_format endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl quote_name(FILE *out, const char *name, const quoting_options *options, size_t	*width)
quote_name	proc near		; CODE XREF: print_dir+39Dp
					; print_name_with_quoting+DAp ...

width		= dword	ptr -2058h
options		= dword	ptr -2054h
name		= dword	ptr -2050h
out		= dword	ptr -204Ch
wc		= dword	ptr -2048h
len		= dword	ptr -2044h
buf		= dword	ptr -2040h
displayed_width	= dword	ptr -203Ch
p		= dword	ptr -2038h
q		= dword	ptr -2034h
bytes		= dword	ptr -2030h
p_0		= dword	ptr -202Ch
p_1		= dword	ptr -2028h
plimit		= dword	ptr -2024h
w		= dword	ptr -2020h
plimit_0	= dword	ptr -201Ch
plimit_1	= dword	ptr -2018h
mbstate		= mbstate_t ptr	-2014h
smallbuf	= byte ptr -200Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 2054h
		mov	eax, [ebp+arg_0]
		mov	[ebp+out], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+name], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+options], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+width], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+options]
		push	0FFFFFFFFh
		push	[ebp+name]
		push	2000h
		lea	eax, [ebp+smallbuf]
		push	eax
		call	quotearg_buffer
		add	esp, 20h
		mov	[ebp+len], eax
		cmp	[ebp+len], 1FFFh
		ja	short loc_8006255
		lea	eax, [ebp+smallbuf]
		mov	[ebp+buf], eax
		jmp	short loc_80062B6
; ---------------------------------------------------------------------------

loc_8006255:				; CODE XREF: quote_name+6Ej
		mov	eax, [ebp+len]
		add	eax, 1
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ebx, 10h
		mov	edx, 0
		div	ebx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+buf], eax
		mov	eax, [ebp+len]
		add	eax, 1
		sub	esp, 0Ch
		push	[ebp+options]
		push	0FFFFFFFFh
		push	[ebp+name]
		push	eax
		push	[ebp+buf]
		call	quotearg_buffer
		add	esp, 20h

loc_80062B6:				; CODE XREF: quote_name+7Cj
		movzx	eax, ds:qmark_funny_chars
		test	al, al
		jz	loc_8006583
		call	__ctype_get_mb_cur_max
		cmp	eax, 1
		jbe	loc_80064FD
		mov	eax, [ebp+buf]
		mov	[ebp+p], eax
		mov	edx, [ebp+buf]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	[ebp+plimit], eax
		mov	eax, [ebp+buf]
		mov	[ebp+q], eax
		mov	[ebp+displayed_width], 0
		jmp	loc_80064D0
; ---------------------------------------------------------------------------

loc_800630E:				; CODE XREF: quote_name+305j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 3Fh
		jg	short loc_800632E
		cmp	eax, 25h
		jge	short loc_8006340
		sub	eax, 20h
		cmp	eax, 3
		ja	short loc_800636F
		jmp	short loc_8006340
; ---------------------------------------------------------------------------

loc_800632E:				; CODE XREF: quote_name+146j
		cmp	eax, 41h
		jl	short loc_800636F
		cmp	eax, 5Fh
		jle	short loc_8006340
		sub	eax, 61h
		cmp	eax, 1Dh
		ja	short loc_800636F

loc_8006340:				; CODE XREF: quote_name+14Bj
					; quote_name+155j ...
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	edx, [ebp+p]
		lea	ecx, [edx+1]
		mov	[ebp+p], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		add	[ebp+displayed_width], 1
		jmp	loc_80064D0
; ---------------------------------------------------------------------------

loc_800636F:				; CODE XREF: quote_name+153j
					; quote_name+15Aj ...
		mov	[ebp+mbstate.__count], 0
		mov	dword ptr [ebp+mbstate.__value], 0

loc_8006383:				; CODE XREF: quote_name+2F2j
		mov	edx, [ebp+plimit]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		lea	eax, [ebp+mbstate]
		push	eax		; p
		push	edx		; n
		push	[ebp+p]		; s
		lea	eax, [ebp+wc]
		push	eax		; pwc
		call	mbrtowc
		add	esp, 10h
		mov	[ebp+bytes], eax
		cmp	[ebp+bytes], 0FFFFFFFFh
		jnz	short loc_80063E6
		add	[ebp+p], 1
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	byte ptr [eax],	3Fh
		add	[ebp+displayed_width], 1
		jmp	loc_80064CF
; ---------------------------------------------------------------------------

loc_80063E6:				; CODE XREF: quote_name+1E8j
		cmp	[ebp+bytes], 0FFFFFFFEh
		jnz	short loc_8006419
		mov	eax, [ebp+plimit]
		mov	[ebp+p], eax
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	byte ptr [eax],	3Fh
		add	[ebp+displayed_width], 1
		jmp	loc_80064CF
; ---------------------------------------------------------------------------

loc_8006419:				; CODE XREF: quote_name+216j
		cmp	[ebp+bytes], 0
		jnz	short loc_800642C
		mov	[ebp+bytes], 1

loc_800642C:				; CODE XREF: quote_name+249j
		mov	eax, [ebp+wc]
		sub	esp, 0Ch
		push	eax
		call	wcwidth
		add	esp, 10h
		mov	[ebp+w], eax
		cmp	[ebp+w], 0
		js	short loc_8006490
		jmp	short loc_8006479
; ---------------------------------------------------------------------------

loc_800644F:				; CODE XREF: quote_name+2A9j
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	edx, [ebp+p]
		lea	ecx, [edx+1]
		mov	[ebp+p], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		sub	[ebp+bytes], 1

loc_8006479:				; CODE XREF: quote_name+276j
		cmp	[ebp+bytes], 0
		jnz	short loc_800644F
		mov	eax, [ebp+w]
		add	[ebp+displayed_width], eax
		jmp	short loc_80064B5
; ---------------------------------------------------------------------------

loc_8006490:				; CODE XREF: quote_name+274j
		mov	eax, [ebp+bytes]
		add	[ebp+p], eax
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		mov	byte ptr [eax],	3Fh
		add	[ebp+displayed_width], 1

loc_80064B5:				; CODE XREF: quote_name+2B7j
		sub	esp, 0Ch
		lea	eax, [ebp+mbstate]
		push	eax		; ps
		call	mbsinit
		add	esp, 10h
		test	eax, eax
		jz	loc_8006383

loc_80064CF:				; CODE XREF: quote_name+20Aj
					; quote_name+23Dj
		nop

loc_80064D0:				; CODE XREF: quote_name+132j
					; quote_name+193j
		mov	eax, [ebp+p]
		cmp	eax, [ebp+plimit]
		jb	loc_800630E
		mov	edx, [ebp+q]
		mov	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+len], eax
		jmp	loc_8006638
; ---------------------------------------------------------------------------

loc_80064FD:				; CODE XREF: quote_name+F6j
		mov	eax, [ebp+buf]
		mov	[ebp+p_0], eax
		mov	edx, [ebp+buf]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	[ebp+plimit_0],	eax
		jmp	short loc_8006564
; ---------------------------------------------------------------------------

loc_800651F:				; CODE XREF: quote_name+399j
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p_0]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jnz	short loc_800655D
		mov	eax, [ebp+p_0]
		mov	byte ptr [eax],	3Fh

loc_800655D:				; CODE XREF: quote_name+37Bj
		add	[ebp+p_0], 1

loc_8006564:				; CODE XREF: quote_name+346j
		mov	eax, [ebp+p_0]
		cmp	eax, [ebp+plimit_0]
		jb	short loc_800651F
		mov	eax, [ebp+len]
		mov	[ebp+displayed_width], eax
		jmp	loc_8006638
; ---------------------------------------------------------------------------

loc_8006583:				; CODE XREF: quote_name+E8j
		cmp	[ebp+width], 0
		jz	loc_8006638
		call	__ctype_get_mb_cur_max
		cmp	eax, 1
		jbe	short loc_80065BB
		sub	esp, 4
		push	0
		push	[ebp+len]
		push	[ebp+buf]
		call	mbsnwidth
		add	esp, 10h
		mov	[ebp+displayed_width], eax
		jmp	short loc_8006638
; ---------------------------------------------------------------------------

loc_80065BB:				; CODE XREF: quote_name+3C1j
		mov	eax, [ebp+buf]
		mov	[ebp+p_1], eax
		mov	edx, [ebp+buf]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	[ebp+plimit_1],	eax
		mov	[ebp+displayed_width], 0
		jmp	short loc_800662A
; ---------------------------------------------------------------------------

loc_80065E7:				; CODE XREF: quote_name+45Fj
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p_1]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8006623
		add	[ebp+displayed_width], 1

loc_8006623:				; CODE XREF: quote_name+443j
		add	[ebp+p_1], 1

loc_800662A:				; CODE XREF: quote_name+40Ej
		mov	eax, [ebp+p_1]
		cmp	eax, [ebp+plimit_1]
		jb	short loc_80065E7

loc_8006638:				; CODE XREF: quote_name+321j
					; quote_name+3A7j ...
		cmp	[ebp+out], 0
		jz	short loc_800665D
		push	[ebp+out]	; stream
		push	[ebp+len]	; n
		push	1		; size
		push	[ebp+buf]	; ptr
		call	fwrite_unlocked
		add	esp, 10h

loc_800665D:				; CODE XREF: quote_name+468j
		cmp	[ebp+width], 0
		jz	short loc_8006674
		mov	eax, [ebp+width]
		mov	edx, [ebp+displayed_width]
		mov	[eax], edx

loc_8006674:				; CODE XREF: quote_name+48Dj
		mov	eax, [ebp+len]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800668B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800668B:				; CODE XREF: quote_name+4ADj
		mov	ebx, [ebp+var_4]
		leave
		retn
quote_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl print_name_with_quoting(const fileinfo	*f, _Bool symlink_target, obstack *stack, size_t start_col)
print_name_with_quoting	proc near	; CODE XREF: print_long_format+8DAp
					; print_long_format+957p ...

symlink_target	= byte ptr -2Ch
used_color_this_time= byte ptr -21h
name		= dword	ptr -20h
__o		= dword	ptr -1Ch
__len		= dword	ptr -18h
width		= dword	ptr -14h
__o_0		= dword	ptr -10h
__len_0		= dword	ptr -0Ch
var_4		= dword	ptr -4
f		= dword	ptr  8
arg_4		= dword	ptr  0Ch
stack		= dword	ptr  10h
start_col	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	[ebp+symlink_target], al
		cmp	[ebp+symlink_target], 0
		jz	short loc_80066AB
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		jmp	short loc_80066B0
; ---------------------------------------------------------------------------

loc_80066AB:				; CODE XREF: print_name_with_quoting+11j
		mov	eax, [ebp+f]
		mov	eax, [eax]

loc_80066B0:				; CODE XREF: print_name_with_quoting+19j
		mov	[ebp+name], eax
		movzx	eax, ds:print_with_color
		test	al, al
		jz	short loc_80066DC
		movzx	eax, [ebp+symlink_target]
		sub	esp, 8
		push	eax		; symlink_target
		push	[ebp+f]		; f
		call	print_color_indicator
		add	esp, 10h
		test	al, al
		jz	short loc_80066DC
		mov	eax, 1
		jmp	short loc_80066E1
; ---------------------------------------------------------------------------

loc_80066DC:				; CODE XREF: print_name_with_quoting+2Cj
					; print_name_with_quoting+43j
		mov	eax, 0

loc_80066E1:				; CODE XREF: print_name_with_quoting+4Aj
		mov	[ebp+used_color_this_time], al
		and	[ebp+used_color_this_time], 1
		cmp	[ebp+stack], 0
		jz	short loc_8006758
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_8006758
		mov	eax, [ebp+stack]
		mov	[ebp+__o], eax
		mov	[ebp+__len], 4
		mov	eax, [ebp+__o]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len]
		add	edx, eax
		mov	eax, [ebp+__o]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jbe	short loc_800672C
		sub	esp, 8
		push	[ebp+__len]	; int
		push	[ebp+__o]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_800672C:				; CODE XREF: print_name_with_quoting+89j
		mov	edx, [ebp+__len]
		mov	eax, [ebp+__o]
		mov	eax, [eax+0Ch]
		sub	esp, 4
		push	edx		; n
		push	offset dired_pos ; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+__o]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len]
		add	edx, eax
		mov	eax, [ebp+__o]
		mov	[eax+0Ch], edx

loc_8006758:				; CODE XREF: print_name_with_quoting+5Cj
					; print_name_with_quoting+67j
		mov	edx, ds:filename_quoting_options
		mov	eax, ds:stdout
		push	0		; width
		push	edx		; options
		push	[ebp+name]	; name
		push	eax		; out
		call	quote_name
		add	esp, 10h
		mov	[ebp+width], eax
		mov	edx, ds:dired_pos
		mov	eax, [ebp+width]
		add	eax, edx
		mov	ds:dired_pos, eax
		cmp	[ebp+stack], 0
		jz	short loc_80067F5
		movzx	eax, ds:dired
		test	al, al
		jz	short loc_80067F5
		mov	eax, [ebp+stack]
		mov	[ebp+__o_0], eax
		mov	[ebp+__len_0], 4
		mov	eax, [ebp+__o_0]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_0]
		add	edx, eax
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jbe	short loc_80067C9
		sub	esp, 8
		push	[ebp+__len_0]	; int
		push	[ebp+__o_0]	; struct obstack *
		call	_obstack_newchunk
		add	esp, 10h

loc_80067C9:				; CODE XREF: print_name_with_quoting+126j
		mov	edx, [ebp+__len_0]
		mov	eax, [ebp+__o_0]
		mov	eax, [eax+0Ch]
		sub	esp, 4
		push	edx		; n
		push	offset dired_pos ; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+__o_0]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+__len_0]
		add	edx, eax
		mov	eax, [ebp+__o_0]
		mov	[eax+0Ch], edx

loc_80067F5:				; CODE XREF: print_name_with_quoting+F9j
					; print_name_with_quoting+104j
		cmp	[ebp+used_color_this_time], 0
		jz	short loc_8006843
		call	process_signals
		call	prep_non_filename_text
		mov	ebx, ds:line_length
		mov	eax, [ebp+start_col]
		mov	edx, 0
		div	ebx
		mov	ecx, eax
		mov	edx, [ebp+start_col]
		mov	eax, [ebp+width]
		add	eax, edx
		sub	eax, 1
		mov	ebx, ds:line_length
		mov	edx, 0
		div	ebx
		cmp	ecx, eax
		jz	short loc_8006843
		sub	esp, 0Ch
		push	offset stru_8007E38 ; ind
		call	put_indicator
		add	esp, 10h

loc_8006843:				; CODE XREF: print_name_with_quoting+169j
					; print_name_with_quoting+1A1j
		mov	eax, [ebp+width]
		mov	ebx, [ebp+var_4]
		leave
		retn
print_name_with_quoting	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void prep_non_filename_text()
prep_non_filename_text proc near	; CODE XREF: print_name_with_quoting+170p
					; put_indicator+1Bp
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, stru_8007D90.string
		test	eax, eax
		jz	short loc_800686C
		sub	esp, 0Ch
		push	offset stru_8007D90 ; ind
		call	put_indicator
		add	esp, 10h
		jmp	short loc_800689C
; ---------------------------------------------------------------------------

loc_800686C:				; CODE XREF: prep_non_filename_text+Dj
		sub	esp, 0Ch
		push	offset color_indicator ; ind
		call	put_indicator
		add	esp, 10h
		sub	esp, 0Ch
		push	offset stru_8007D98 ; ind
		call	put_indicator
		add	esp, 10h
		sub	esp, 0Ch
		push	offset ind	; ind
		call	put_indicator
		add	esp, 10h

loc_800689C:				; CODE XREF: prep_non_filename_text+1Fj
		nop
		leave
		retn
prep_non_filename_text endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl print_file_name_and_frills(const fileinfo *f, size_t start_col)
print_file_name_and_frills proc	near	; CODE XREF: print_current_files+3Bp
					; print_many_per_line+C0p ...

f		= dword	ptr -2ACh
width		= dword	ptr -29Ch
buf		= byte ptr -298h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
start_col	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2B0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		movzx	eax, ds:print_inode
		test	al, al
		jz	short loc_8006910
		sub	esp, 4
		push	[ebp+f]		; f
		push	28Ch		; buflen
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	format_inode
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:format_0
		cmp	eax, 4
		jz	short loc_80068F9
		mov	eax, ds:inode_number_width
		jmp	short loc_80068FE
; ---------------------------------------------------------------------------

loc_80068F9:				; CODE XREF: print_file_name_and_frills+51j
		mov	eax, 0

loc_80068FE:				; CODE XREF: print_file_name_and_frills+58j
		sub	esp, 4
		push	edx
		push	eax
		push	offset aS_0	; "%*s "
		call	printf
		add	esp, 10h

loc_8006910:				; CODE XREF: print_file_name_and_frills+28j
		movzx	eax, ds:print_block_size
		test	al, al
		jz	short loc_8006995
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_8006933
		mov	edx, offset a?	; "?"
		jmp	short loc_800696D
; ---------------------------------------------------------------------------

loc_8006933:				; CODE XREF: print_file_name_and_frills+8Bj
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	esi, ds:human_output_opts
		mov	ecx, [ebp+f]
		mov	ebx, [ecx+44h]
		mov	ecx, [ecx+40h]
		push	edx
		push	eax
		push	0
		push	200h
		push	esi
		lea	eax, [ebp+buf]
		push	eax
		push	ebx
		push	ecx
		call	human_readable
		add	esp, 20h
		mov	edx, eax

loc_800696D:				; CODE XREF: print_file_name_and_frills+92j
		mov	eax, ds:format_0
		cmp	eax, 4
		jz	short loc_800697E
		mov	eax, ds:block_size_width
		jmp	short loc_8006983
; ---------------------------------------------------------------------------

loc_800697E:				; CODE XREF: print_file_name_and_frills+D6j
		mov	eax, 0

loc_8006983:				; CODE XREF: print_file_name_and_frills+DDj
		sub	esp, 4
		push	edx
		push	eax
		push	offset aS_0	; "%*s "
		call	printf
		add	esp, 10h

loc_8006995:				; CODE XREF: print_file_name_and_frills+7Aj
		movzx	eax, ds:print_scontext
		test	al, al
		jz	short loc_80069D1
		mov	eax, [ebp+f]
		mov	edx, [eax+70h]
		mov	eax, ds:format_0
		cmp	eax, 4
		jz	short loc_80069BA
		mov	eax, ds:scontext_width
		jmp	short loc_80069BF
; ---------------------------------------------------------------------------

loc_80069BA:				; CODE XREF: print_file_name_and_frills+112j
		mov	eax, 0

loc_80069BF:				; CODE XREF: print_file_name_and_frills+119j
		sub	esp, 4
		push	edx
		push	eax
		push	offset aS_0	; "%*s "
		call	printf
		add	esp, 10h

loc_80069D1:				; CODE XREF: print_file_name_and_frills+FFj
		push	[ebp+start_col]	; start_col
		push	0		; stack
		push	0		; symlink_target
		push	[ebp+f]		; f
		call	print_name_with_quoting
		add	esp, 10h
		mov	[ebp+width], eax
		mov	eax, ds:indicator_style_0
		test	eax, eax
		jz	short loc_8006A2B
		mov	eax, [ebp+f]
		mov	ecx, [eax+68h]
		mov	eax, [ebp+f]
		mov	edx, [eax+18h]
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	eax, al
		sub	esp, 4
		push	ecx		; type
		push	edx		; mode
		push	eax		; stat_ok
		call	print_type_indicator
		add	esp, 10h
		movzx	eax, al
		add	[ebp+width], eax

loc_8006A2B:				; CODE XREF: print_file_name_and_frills+154j
		mov	eax, [ebp+width]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8006A42
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8006A42:				; CODE XREF: print_file_name_and_frills+19Cj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
print_file_name_and_frills endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char __cdecl get_type_indicator(_Bool	stat_ok, mode_t	mode, filetype type)
get_type_indicator proc	near		; CODE XREF: print_type_indicator+17p
					; length_of_file_name_and_frills+199p

stat_ok		= byte ptr -14h
c		= byte ptr -1
arg_0		= dword	ptr  8
mode		= dword	ptr  0Ch
type		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	[ebp+stat_ok], al
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006A6D
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		setz	al
		jmp	short loc_8006A74
; ---------------------------------------------------------------------------

loc_8006A6D:				; CODE XREF: get_type_indicator+10j
		cmp	[ebp+type], 5
		setz	al

loc_8006A74:				; CODE XREF: get_type_indicator+22j
		test	al, al
		jz	short loc_8006AA4
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006A9B
		mov	eax, ds:indicator_style_0
		cmp	eax, 3
		jnz	short loc_8006A9B
		mov	eax, [ebp+mode]
		and	eax, 49h
		test	eax, eax
		jz	short loc_8006A9B
		mov	[ebp+c], 2Ah
		jmp	loc_8006B73
; ---------------------------------------------------------------------------

loc_8006A9B:				; CODE XREF: get_type_indicator+33j
					; get_type_indicator+3Dj ...
		mov	[ebp+c], 0
		jmp	loc_8006B73
; ---------------------------------------------------------------------------

loc_8006AA4:				; CODE XREF: get_type_indicator+2Dj
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006ABC
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		setz	al
		jmp	short loc_8006AD7
; ---------------------------------------------------------------------------

loc_8006ABC:				; CODE XREF: get_type_indicator+5Fj
		cmp	[ebp+type], 3
		jz	short loc_8006AC8
		cmp	[ebp+type], 9
		jnz	short loc_8006ACF

loc_8006AC8:				; CODE XREF: get_type_indicator+77j
		mov	eax, 1
		jmp	short loc_8006AD4
; ---------------------------------------------------------------------------

loc_8006ACF:				; CODE XREF: get_type_indicator+7Dj
		mov	eax, 0

loc_8006AD4:				; CODE XREF: get_type_indicator+84j
		and	eax, 1

loc_8006AD7:				; CODE XREF: get_type_indicator+71j
		test	al, al
		jz	short loc_8006AE4
		mov	[ebp+c], 2Fh
		jmp	loc_8006B73
; ---------------------------------------------------------------------------

loc_8006AE4:				; CODE XREF: get_type_indicator+90j
		mov	eax, ds:indicator_style_0
		cmp	eax, 1
		jnz	short loc_8006AF4
		mov	[ebp+c], 0
		jmp	short loc_8006B73
; ---------------------------------------------------------------------------

loc_8006AF4:				; CODE XREF: get_type_indicator+A3j
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006B0C
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		setz	al
		jmp	short loc_8006B13
; ---------------------------------------------------------------------------

loc_8006B0C:				; CODE XREF: get_type_indicator+AFj
		cmp	[ebp+type], 6
		setz	al

loc_8006B13:				; CODE XREF: get_type_indicator+C1j
		test	al, al
		jz	short loc_8006B1D
		mov	[ebp+c], 40h
		jmp	short loc_8006B73
; ---------------------------------------------------------------------------

loc_8006B1D:				; CODE XREF: get_type_indicator+CCj
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006B35
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		setz	al
		jmp	short loc_8006B3C
; ---------------------------------------------------------------------------

loc_8006B35:				; CODE XREF: get_type_indicator+D8j
		cmp	[ebp+type], 1
		setz	al

loc_8006B3C:				; CODE XREF: get_type_indicator+EAj
		test	al, al
		jz	short loc_8006B46
		mov	[ebp+c], 7Ch
		jmp	short loc_8006B73
; ---------------------------------------------------------------------------

loc_8006B46:				; CODE XREF: get_type_indicator+F5j
		cmp	[ebp+stat_ok], 0
		jz	short loc_8006B5E
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		setz	al
		jmp	short loc_8006B65
; ---------------------------------------------------------------------------

loc_8006B5E:				; CODE XREF: get_type_indicator+101j
		cmp	[ebp+type], 7
		setz	al

loc_8006B65:				; CODE XREF: get_type_indicator+113j
		test	al, al
		jz	short loc_8006B6F
		mov	[ebp+c], 3Dh
		jmp	short loc_8006B73
; ---------------------------------------------------------------------------

loc_8006B6F:				; CODE XREF: get_type_indicator+11Ej
		mov	[ebp+c], 0

loc_8006B73:				; CODE XREF: get_type_indicator+4Dj
					; get_type_indicator+56j ...
		movzx	eax, [ebp+c]
		leave
		retn
get_type_indicator endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	print_type_indicator(_Bool stat_ok, mode_t mode, filetype type)
print_type_indicator proc near		; CODE XREF: print_long_format+979p
					; print_long_format+9B1p ...

stat_ok		= byte ptr -1Ch
c		= byte ptr -9
arg_0		= dword	ptr  8
mode		= dword	ptr  0Ch
type		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+stat_ok], al
		movzx	eax, [ebp+stat_ok]
		push	[ebp+type]	; type
		push	[ebp+mode]	; mode
		push	eax		; stat_ok
		call	get_type_indicator
		add	esp, 0Ch
		mov	[ebp+c], al
		cmp	[ebp+c], 0
		jz	short loc_8006BBE
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:dired_pos
		add	eax, 1
		mov	ds:dired_pos, eax

loc_8006BBE:				; CODE XREF: print_type_indicator+26j
		cmp	[ebp+c], 0
		setnz	al
		leave
		retn
print_type_indicator endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	print_color_indicator(const fileinfo *f, _Bool symlink_target)
print_color_indicator proc near		; CODE XREF: print_name_with_quoting+39p

symlink_target	= byte ptr -2Ch
type		= dword	ptr -24h
ext		= dword	ptr -20h
name		= dword	ptr -1Ch
mode		= dword	ptr -18h
linkok		= dword	ptr -14h
len		= dword	ptr -10h
s		= dword	ptr -0Ch
var_4		= dword	ptr -4
f		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	[ebp+symlink_target], al
		cmp	[ebp+symlink_target], 0
		jz	short loc_8006BFE
		mov	eax, [ebp+f]
		mov	eax, [eax+4]
		mov	[ebp+name], eax
		mov	eax, [ebp+f]
		mov	eax, [eax+6Ch]
		mov	[ebp+mode], eax
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+75h]
		movzx	eax, al
		sub	eax, 1
		mov	[ebp+linkok], eax
		jmp	short loc_8006C3A
; ---------------------------------------------------------------------------

loc_8006BFE:				; CODE XREF: print_color_indicator+11j
		mov	eax, [ebp+f]
		mov	eax, [eax]
		mov	[ebp+name], eax
		movzx	eax, ds:color_symlink_as_referent
		test	al, al
		jz	short loc_8006C24
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+75h]
		test	al, al
		jz	short loc_8006C24
		mov	eax, [ebp+f]
		mov	eax, [eax+6Ch]
		jmp	short loc_8006C2A
; ---------------------------------------------------------------------------

loc_8006C24:				; CODE XREF: print_color_indicator+48j
					; print_color_indicator+53j
		mov	eax, [ebp+f]
		mov	eax, [eax+18h]

loc_8006C2A:				; CODE XREF: print_color_indicator+5Bj
		mov	[ebp+mode], eax
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+75h]
		movzx	eax, al
		mov	[ebp+linkok], eax

loc_8006C3A:				; CODE XREF: print_color_indicator+35j
		cmp	[ebp+linkok], 0FFFFFFFFh
		jnz	short loc_8006C55
		mov	eax, dword_8007DE4
		test	eax, eax
		jz	short loc_8006C55
		mov	[ebp+type], 0Ch
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006C55:				; CODE XREF: print_color_indicator+77j
					; print_color_indicator+80j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_8006C78
		mov	eax, [ebp+f]
		mov	eax, [eax+68h]
		mov	eax, filetype_indicator_8019[eax*4]
		mov	[ebp+type], eax
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006C78:				; CODE XREF: print_color_indicator+9Aj
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8006D63
		mov	[ebp+type], 5
		mov	eax, [ebp+mode]
		and	eax, 800h
		test	eax, eax
		jz	short loc_8006CBB
		sub	esp, 0Ch
		push	10h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006CBB
		mov	[ebp+type], 10h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006CBB:				; CODE XREF: print_color_indicator+D5j
					; print_color_indicator+E6j
		mov	eax, [ebp+mode]
		and	eax, 400h
		test	eax, eax
		jz	short loc_8006CE4
		sub	esp, 0Ch
		push	11h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006CE4
		mov	[ebp+type], 11h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006CE4:				; CODE XREF: print_color_indicator+FEj
					; print_color_indicator+10Fj
		sub	esp, 0Ch
		push	15h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006D0C
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+7Ch]
		test	al, al
		jz	short loc_8006D0C
		mov	[ebp+type], 15h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006D0C:				; CODE XREF: print_color_indicator+12Cj
					; print_color_indicator+137j
		mov	eax, [ebp+mode]
		and	eax, 49h
		test	eax, eax
		jz	short loc_8006D33
		sub	esp, 0Ch
		push	0Eh		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006D33
		mov	[ebp+type], 0Eh
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006D33:				; CODE XREF: print_color_indicator+14Dj
					; print_color_indicator+15Ej
		mov	eax, [ebp+f]
		mov	eax, [eax+1Ch]
		cmp	eax, 1
		jbe	loc_8006EBA
		sub	esp, 0Ch
		push	16h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	loc_8006EBA
		mov	[ebp+type], 16h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006D63:				; CODE XREF: print_color_indicator+BEj
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	loc_8006E08
		mov	[ebp+type], 6
		mov	eax, [ebp+mode]
		and	eax, 200h
		test	eax, eax
		jz	short loc_8006DB0
		mov	eax, [ebp+mode]
		and	eax, 2
		test	eax, eax
		jz	short loc_8006DB0
		sub	esp, 0Ch
		push	14h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006DB0
		mov	[ebp+type], 14h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006DB0:				; CODE XREF: print_color_indicator+1C0j
					; print_color_indicator+1CAj ...
		mov	eax, [ebp+mode]
		and	eax, 2
		test	eax, eax
		jz	short loc_8006DD7
		sub	esp, 0Ch
		push	13h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	short loc_8006DD7
		mov	[ebp+type], 13h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006DD7:				; CODE XREF: print_color_indicator+1F1j
					; print_color_indicator+202j
		mov	eax, [ebp+mode]
		and	eax, 200h
		test	eax, eax
		jz	loc_8006EBA
		sub	esp, 0Ch
		push	12h		; type
		call	is_colored
		add	esp, 10h
		test	al, al
		jz	loc_8006EBA
		mov	[ebp+type], 12h
		jmp	loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006E08:				; CODE XREF: print_color_indicator+1A9j
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8006E53
		cmp	[ebp+linkok], 0
		jnz	short loc_8006E49
		mov	eax, s1
		sub	esp, 4
		push	6		; n
		push	offset aTarget	; "target"
		push	eax		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8006E42
		mov	eax, dword_8007DEC
		test	eax, eax
		jz	short loc_8006E49

loc_8006E42:				; CODE XREF: print_color_indicator+270j
		mov	eax, 0Dh
		jmp	short loc_8006E4E
; ---------------------------------------------------------------------------

loc_8006E49:				; CODE XREF: print_color_indicator+254j
					; print_color_indicator+279j
		mov	eax, 7

loc_8006E4E:				; CODE XREF: print_color_indicator+280j
		mov	[ebp+type], eax
		jmp	short loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006E53:				; CODE XREF: print_color_indicator+24Ej
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jnz	short loc_8006E6B
		mov	[ebp+type], 8
		jmp	short loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006E6B:				; CODE XREF: print_color_indicator+299j
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jnz	short loc_8006E83
		mov	[ebp+type], 9
		jmp	short loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006E83:				; CODE XREF: print_color_indicator+2B1j
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 6000h
		jnz	short loc_8006E9B
		mov	[ebp+type], 0Ah
		jmp	short loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006E9B:				; CODE XREF: print_color_indicator+2C9j
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jnz	short loc_8006EB3
		mov	[ebp+type], 0Bh
		jmp	short loc_8006EBA
; ---------------------------------------------------------------------------

loc_8006EB3:				; CODE XREF: print_color_indicator+2E1j
		mov	[ebp+type], 0Dh

loc_8006EBA:				; CODE XREF: print_color_indicator+89j
					; print_color_indicator+ACj ...
		mov	[ebp+ext], 0
		cmp	[ebp+type], 5
		jnz	short loc_8006F2F
		sub	esp, 0Ch
		push	[ebp+name]	; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, [ebp+len]
		add	[ebp+name], eax
		mov	eax, ds:color_ext_list
		mov	[ebp+ext], eax
		jmp	short loc_8006F26
; ---------------------------------------------------------------------------

loc_8006EE8:				; CODE XREF: print_color_indicator+363j
		mov	eax, [ebp+ext]
		mov	eax, [eax]
		cmp	eax, [ebp+len]
		ja	short loc_8006F1D
		mov	eax, [ebp+ext]
		mov	edx, [eax]
		mov	eax, [ebp+ext]
		mov	eax, [eax+4]
		mov	ecx, [ebp+ext]
		mov	ecx, [ecx]
		mov	ebx, ecx
		neg	ebx
		mov	ecx, [ebp+name]
		add	ecx, ebx
		sub	esp, 4
		push	edx		; n
		push	eax		; s2
		push	ecx		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8006F2E

loc_8006F1D:				; CODE XREF: print_color_indicator+329j
		mov	eax, [ebp+ext]
		mov	eax, [eax+10h]
		mov	[ebp+ext], eax

loc_8006F26:				; CODE XREF: print_color_indicator+31Fj
		cmp	[ebp+ext], 0
		jnz	short loc_8006EE8
		jmp	short loc_8006F2F
; ---------------------------------------------------------------------------

loc_8006F2E:				; CODE XREF: print_color_indicator+354j
		nop

loc_8006F2F:				; CODE XREF: print_color_indicator+2FEj
					; print_color_indicator+365j
		cmp	[ebp+ext], 0
		jz	short loc_8006F3D
		mov	eax, [ebp+ext]
		add	eax, 8
		jmp	short loc_8006F48
; ---------------------------------------------------------------------------

loc_8006F3D:				; CODE XREF: print_color_indicator+36Cj
		mov	eax, [ebp+type]
		shl	eax, 3
		add	eax, offset color_indicator

loc_8006F48:				; CODE XREF: print_color_indicator+374j
		mov	[ebp+s], eax
		mov	eax, [ebp+s]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_8006F8A
		sub	esp, 0Ch
		push	offset color_indicator ; ind
		call	put_indicator
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+s]		; ind
		call	put_indicator
		add	esp, 10h
		sub	esp, 0Ch
		push	offset ind	; ind
		call	put_indicator
		add	esp, 10h
		mov	eax, 1
		jmp	short loc_8006F8F
; ---------------------------------------------------------------------------

loc_8006F8A:				; CODE XREF: print_color_indicator+38Cj
		mov	eax, 0

loc_8006F8F:				; CODE XREF: print_color_indicator+3C1j
		mov	ebx, [ebp+var_4]
		leave
		retn
print_color_indicator endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl put_indicator(const bin_str *ind)
put_indicator	proc near		; CODE XREF: restore_default_color+Ep
					; restore_default_color+1Ep ...

ind		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, ds:used_color
		xor	eax, 1
		test	al, al
		jz	short loc_8006FB4
		mov	ds:used_color, 1
		call	prep_non_filename_text

loc_8006FB4:				; CODE XREF: put_indicator+12j
		mov	ecx, ds:stdout
		mov	eax, [ebp+ind]
		mov	edx, [eax]
		mov	eax, [ebp+ind]
		mov	eax, [eax+4]
		push	ecx		; stream
		push	1		; n
		push	edx		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		nop
		leave
		retn
put_indicator	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl length_of_file_name_and_frills(const fileinfo *f)
length_of_file_name_and_frills proc near ; CODE	XREF: print_many_per_line+93p
					; print_horizontal+47p	...

f		= dword	ptr -2ACh
c		= byte ptr -2A1h
name_width	= dword	ptr -2A0h
len		= dword	ptr -29Ch
buf		= byte ptr -298h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2B0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+len], 0
		movzx	eax, ds:print_inode
		test	al, al
		jz	short loc_8007052
		mov	eax, ds:format_0
		cmp	eax, 4
		jnz	short loc_8007044
		mov	eax, [ebp+f]
		mov	edx, [eax+64h]
		mov	eax, [eax+60h]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		jmp	short loc_800704C
; ---------------------------------------------------------------------------

loc_8007044:				; CODE XREF: length_of_file_name_and_frills+3Cj
		mov	eax, ds:inode_number_width
		add	eax, 1

loc_800704C:				; CODE XREF: length_of_file_name_and_frills+6Dj
		add	[ebp+len], eax

loc_8007052:				; CODE XREF: length_of_file_name_and_frills+32j
		movzx	eax, ds:print_block_size
		test	al, al
		jz	short loc_80070D6
		mov	eax, ds:format_0
		cmp	eax, 4
		jnz	short loc_80070C8
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		xor	eax, 1
		test	al, al
		jz	short loc_800707F
		mov	eax, offset a?	; "?"
		jmp	short loc_80070B7
; ---------------------------------------------------------------------------

loc_800707F:				; CODE XREF: length_of_file_name_and_frills+A1j
		mov	eax, dword ptr ds:output_block_size
		mov	edx, dword ptr ds:output_block_size+4
		mov	esi, ds:human_output_opts
		mov	ecx, [ebp+f]
		mov	ebx, [ecx+44h]
		mov	ecx, [ecx+40h]
		push	edx
		push	eax
		push	0
		push	200h
		push	esi
		lea	eax, [ebp+buf]
		push	eax
		push	ebx
		push	ecx
		call	human_readable
		add	esp, 20h

loc_80070B7:				; CODE XREF: length_of_file_name_and_frills+A8j
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		jmp	short loc_80070D0
; ---------------------------------------------------------------------------

loc_80070C8:				; CODE XREF: length_of_file_name_and_frills+90j
		mov	eax, ds:block_size_width
		add	eax, 1

loc_80070D0:				; CODE XREF: length_of_file_name_and_frills+F1j
		add	[ebp+len], eax

loc_80070D6:				; CODE XREF: length_of_file_name_and_frills+86j
		movzx	eax, ds:print_scontext
		test	al, al
		jz	short loc_8007113
		mov	eax, ds:format_0
		cmp	eax, 4
		jnz	short loc_8007105
		mov	eax, [ebp+f]
		mov	eax, [eax+70h]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		jmp	short loc_800710D
; ---------------------------------------------------------------------------

loc_8007105:				; CODE XREF: length_of_file_name_and_frills+114j
		mov	eax, ds:scontext_width
		add	eax, 1

loc_800710D:				; CODE XREF: length_of_file_name_and_frills+12Ej
		add	[ebp+len], eax

loc_8007113:				; CODE XREF: length_of_file_name_and_frills+10Aj
		mov	edx, ds:filename_quoting_options
		mov	eax, [ebp+f]
		mov	eax, [eax]
		lea	ecx, [ebp+name_width]
		push	ecx		; width
		push	edx		; options
		push	eax		; name
		push	0		; out
		call	quote_name
		add	esp, 10h
		mov	eax, [ebp+name_width]
		add	[ebp+len], eax
		mov	eax, ds:indicator_style_0
		test	eax, eax
		jz	short loc_800718F
		mov	eax, [ebp+f]
		mov	ecx, [eax+68h]
		mov	eax, [ebp+f]
		mov	edx, [eax+18h]
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+74h]
		movzx	eax, al
		sub	esp, 4
		push	ecx		; type
		push	edx		; mode
		push	eax		; stat_ok
		call	get_type_indicator
		add	esp, 10h
		mov	[ebp+c], al
		cmp	[ebp+c], 0
		setnz	al
		movzx	eax, al
		add	[ebp+len], eax

loc_800718F:				; CODE XREF: length_of_file_name_and_frills+172j
		mov	eax, [ebp+len]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_80071A6
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80071A6:				; CODE XREF: length_of_file_name_and_frills+1CAj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
length_of_file_name_and_frills endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_many_per_line()
print_many_per_line proc near		; CODE XREF: print_current_files:loc_80052D9p

row		= dword	ptr -30h
col		= dword	ptr -2Ch
filesno		= dword	ptr -28h
pos		= dword	ptr -24h
cols		= dword	ptr -20h
line_fmt	= dword	ptr -1Ch
rows		= dword	ptr -18h
f		= dword	ptr -14h
name_length	= dword	ptr -10h
max_name_length	= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		sub	esp, 0Ch
		push	1		; by_columns
		call	calculate_columns
		add	esp, 10h
		mov	[ebp+cols], eax
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+cols]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		sub	eax, 0Ch
		add	eax, ecx
		mov	[ebp+line_fmt],	eax
		mov	eax, ds:cwd_n_used
		mov	edx, 0
		div	[ebp+cols]
		mov	ecx, eax
		mov	eax, ds:cwd_n_used
		mov	edx, 0
		div	[ebp+cols]
		mov	eax, edx
		test	eax, eax
		setnz	al
		movzx	eax, al
		add	eax, ecx
		mov	[ebp+rows], eax
		mov	[ebp+row], 0
		jmp	loc_80072BF
; ---------------------------------------------------------------------------

loc_8007214:				; CODE XREF: print_many_per_line+118j
		mov	[ebp+col], 0
		mov	eax, [ebp+row]
		mov	[ebp+filesno], eax
		mov	[ebp+pos], 0

loc_8007228:				; CODE XREF: print_many_per_line+FBj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+filesno]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	length_of_file_name_and_frills
		add	esp, 10h
		mov	[ebp+name_length], eax
		mov	eax, [ebp+line_fmt]
		mov	ecx, [eax+8]
		mov	eax, [ebp+col]
		lea	edx, [eax+1]
		mov	[ebp+col], edx
		shl	eax, 2
		add	eax, ecx
		mov	eax, [eax]
		mov	[ebp+max_name_length], eax
		sub	esp, 8
		push	[ebp+pos]	; start_col
		push	[ebp+f]		; f
		call	print_file_name_and_frills
		add	esp, 10h
		mov	eax, [ebp+rows]
		add	[ebp+filesno], eax
		mov	eax, ds:cwd_n_used
		cmp	[ebp+filesno], eax
		jnb	short loc_80072AD
		mov	edx, [ebp+pos]
		mov	eax, [ebp+max_name_length]
		add	edx, eax
		mov	ecx, [ebp+pos]
		mov	eax, [ebp+name_length]
		add	eax, ecx
		sub	esp, 8
		push	edx		; to
		push	eax		; from
		call	indent
		add	esp, 10h
		mov	eax, [ebp+max_name_length]
		add	[ebp+pos], eax
		jmp	loc_8007228
; ---------------------------------------------------------------------------

loc_80072AD:				; CODE XREF: print_many_per_line+D6j
		nop
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		add	[ebp+row], 1

loc_80072BF:				; CODE XREF: print_many_per_line+62j
		mov	eax, [ebp+row]
		cmp	eax, [ebp+rows]
		jb	loc_8007214
		nop
		leave
		retn
print_many_per_line endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_horizontal()
print_horizontal proc near		; CODE XREF: print_current_files:loc_80052E0p

filesno		= dword	ptr -28h
pos		= dword	ptr -24h
name_length	= dword	ptr -20h
max_name_length	= dword	ptr -1Ch
cols		= dword	ptr -18h
line_fmt	= dword	ptr -14h
f		= dword	ptr -10h
col		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+pos], 0
		sub	esp, 0Ch
		push	0		; by_columns
		call	calculate_columns
		add	esp, 10h
		mov	[ebp+cols], eax
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+cols]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		sub	eax, 0Ch
		add	eax, ecx
		mov	[ebp+line_fmt],	eax
		mov	eax, ds:sorted_file
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	length_of_file_name_and_frills
		add	esp, 10h
		mov	[ebp+name_length], eax
		mov	eax, [ebp+line_fmt]
		mov	eax, [eax+8]
		mov	eax, [eax]
		mov	[ebp+max_name_length], eax
		sub	esp, 8
		push	0		; start_col
		push	[ebp+f]		; f
		call	print_file_name_and_frills
		add	esp, 10h
		mov	[ebp+filesno], 1
		jmp	loc_80073DF
; ---------------------------------------------------------------------------

loc_8007347:				; CODE XREF: print_horizontal+119j
		mov	eax, [ebp+filesno]
		mov	edx, 0
		div	[ebp+cols]
		mov	[ebp+col], edx
		cmp	[ebp+col], 0
		jnz	short loc_8007371
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	[ebp+pos], 0
		jmp	short loc_8007394
; ---------------------------------------------------------------------------

loc_8007371:				; CODE XREF: print_horizontal+8Bj
		mov	edx, [ebp+pos]
		mov	eax, [ebp+max_name_length]
		add	edx, eax
		mov	ecx, [ebp+pos]
		mov	eax, [ebp+name_length]
		add	eax, ecx
		sub	esp, 8
		push	edx		; to
		push	eax		; from
		call	indent
		add	esp, 10h
		mov	eax, [ebp+max_name_length]
		add	[ebp+pos], eax

loc_8007394:				; CODE XREF: print_horizontal+A1j
		mov	eax, ds:sorted_file
		mov	edx, [ebp+filesno]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 8
		push	[ebp+pos]	; start_col
		push	[ebp+f]		; f
		call	print_file_name_and_frills
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	length_of_file_name_and_frills
		add	esp, 10h
		mov	[ebp+name_length], eax
		mov	eax, [ebp+line_fmt]
		mov	eax, [eax+8]
		mov	edx, [ebp+col]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+max_name_length], eax
		add	[ebp+filesno], 1

loc_80073DF:				; CODE XREF: print_horizontal+74j
		mov	eax, ds:cwd_n_used
		cmp	[ebp+filesno], eax
		jb	loc_8007347
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		leave
		retn
print_horizontal endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_with_commas()
print_with_commas proc near		; CODE XREF: print_current_files:loc_80052E7p

separator	= byte ptr -19h
filesno		= dword	ptr -18h
pos		= dword	ptr -14h
f		= dword	ptr -10h
len		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+pos], 0
		mov	[ebp+filesno], 0
		jmp	loc_80074A0
; ---------------------------------------------------------------------------

loc_8007416:				; CODE XREF: print_with_commas+ABj
		mov	eax, ds:sorted_file
		mov	edx, [ebp+filesno]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	length_of_file_name_and_frills
		add	esp, 10h
		mov	[ebp+len], eax
		cmp	[ebp+filesno], 0
		jz	short loc_8007485
		mov	edx, [ebp+pos]
		mov	eax, [ebp+len]
		add	eax, edx
		lea	edx, [eax+2]
		mov	eax, ds:line_length
		cmp	edx, eax
		jnb	short loc_800745D
		add	[ebp+pos], 2
		mov	[ebp+separator], 20h
		jmp	short loc_8007468
; ---------------------------------------------------------------------------

loc_800745D:				; CODE XREF: print_with_commas+54j
		mov	[ebp+pos], 0
		mov	[ebp+separator], 0Ah

loc_8007468:				; CODE XREF: print_with_commas+5Ej
		sub	esp, 0Ch
		push	2Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		movsx	eax, [ebp+separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8007485:				; CODE XREF: print_with_commas+40j
		sub	esp, 8
		push	[ebp+pos]	; start_col
		push	[ebp+f]		; f
		call	print_file_name_and_frills
		add	esp, 10h
		mov	eax, [ebp+len]
		add	[ebp+pos], eax
		add	[ebp+filesno], 1

loc_80074A0:				; CODE XREF: print_with_commas+14j
		mov	eax, ds:cwd_n_used
		cmp	[ebp+filesno], eax
		jb	loc_8007416
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		leave
		retn
print_with_commas endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl indent(size_t from, size_t to)
indent		proc near		; CODE XREF: print_many_per_line+EDp
					; print_horizontal+B8p

var_4		= dword	ptr -4
from		= dword	ptr  8
to		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		jmp	short loc_8007538
; ---------------------------------------------------------------------------

loc_80074C7:				; CODE XREF: indent+80j
		mov	eax, ds:tabsize
		test	eax, eax
		jz	short loc_8007527
		mov	ebx, ds:tabsize
		mov	eax, [ebp+to]
		mov	edx, 0
		div	ebx
		mov	ecx, eax
		mov	eax, [ebp+from]
		add	eax, 1
		mov	ebx, ds:tabsize
		mov	edx, 0
		div	ebx
		cmp	ecx, eax
		jbe	short loc_8007527
		sub	esp, 0Ch
		push	9		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ecx, ds:tabsize
		mov	ebx, ds:tabsize
		mov	eax, [ebp+from]
		mov	edx, 0
		div	ebx
		mov	eax, edx
		sub	ecx, eax
		mov	eax, ecx
		add	[ebp+from], eax
		jmp	short loc_8007538
; ---------------------------------------------------------------------------

loc_8007527:				; CODE XREF: indent+10j indent+39j
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		add	[ebp+from], 1

loc_8007538:				; CODE XREF: indent+7j	indent+67j
		mov	eax, [ebp+from]
		cmp	eax, [ebp+to]
		jb	short loc_80074C7
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
indent		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl attach(char *dest, const	char *dirname, const char *name)
attach		proc near		; CODE XREF: gobble_file+2EAp

dirnamep	= dword	ptr -4
dest		= dword	ptr  8
dirname		= dword	ptr  0Ch
name		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+dirname]
		mov	[ebp+dirnamep],	eax
		mov	eax, [ebp+dirname]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8007582
		mov	eax, [ebp+dirname]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80075C6
		jmp	short loc_8007582
; ---------------------------------------------------------------------------

loc_800756B:				; CODE XREF: attach+44j
		mov	eax, [ebp+dest]
		lea	edx, [eax+1]
		mov	[ebp+dest], edx
		mov	edx, [ebp+dirnamep]
		lea	ecx, [edx+1]
		mov	[ebp+dirnamep],	ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl

loc_8007582:				; CODE XREF: attach+14j attach+23j
		mov	eax, [ebp+dirnamep]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_800756B
		mov	eax, [ebp+dirnamep]
		cmp	eax, [ebp+dirname]
		jbe	short loc_80075C6
		mov	eax, [ebp+dirnamep]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_80075C6
		mov	eax, [ebp+dest]
		lea	edx, [eax+1]
		mov	[ebp+dest], edx
		mov	byte ptr [eax],	2Fh
		jmp	short loc_80075C6
; ---------------------------------------------------------------------------

loc_80075AF:				; CODE XREF: attach+88j
		mov	eax, [ebp+dest]
		lea	edx, [eax+1]
		mov	[ebp+dest], edx
		mov	edx, [ebp+name]
		lea	ecx, [edx+1]
		mov	[ebp+name], ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl

loc_80075C6:				; CODE XREF: attach+21j attach+4Cj ...
		mov	eax, [ebp+name]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80075AF
		mov	eax, [ebp+dest]
		mov	byte ptr [eax],	0
		nop
		leave
		retn
attach		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void init_column_info()
init_column_info proc near		; CODE XREF: calculate_columns+21p

i		= dword	ptr -28h
new_column_info_alloc= dword ptr -24h
p		= dword	ptr -20h
j		= dword	ptr -1Ch
max_cols	= dword	ptr -18h
column_info_growth= dword ptr -14h
s		= dword	ptr -10h
t		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, ds:cwd_n_used
		mov	eax, ds:max_idx
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+max_cols],	eax
		mov	eax, ds:column_info_alloc_8101
		cmp	eax, [ebp+max_cols]
		jnb	loc_80076FA
		mov	eax, ds:max_idx
		shr	eax, 1
		cmp	eax, [ebp+max_cols]
		jbe	short loc_8007631
		mov	eax, ds:column_info_0
		sub	esp, 4
		push	18h
		push	[ebp+max_cols]
		push	eax
		call	xnrealloc
		add	esp, 10h
		mov	ds:column_info_0, eax
		mov	eax, [ebp+max_cols]
		add	eax, eax
		mov	[ebp+new_column_info_alloc], eax
		jmp	short loc_8007658
; ---------------------------------------------------------------------------

loc_8007631:				; CODE XREF: init_column_info+31j
		mov	edx, ds:max_idx
		mov	eax, ds:column_info_0
		sub	esp, 4
		push	0Ch
		push	edx
		push	eax
		call	xnrealloc
		add	esp, 10h
		mov	ds:column_info_0, eax
		mov	eax, ds:max_idx
		mov	[ebp+new_column_info_alloc], eax

loc_8007658:				; CODE XREF: init_column_info+56j
		mov	eax, ds:column_info_alloc_8101
		mov	edx, [ebp+new_column_info_alloc]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+column_info_growth], eax
		mov	edx, ds:column_info_alloc_8101
		mov	eax, [ebp+new_column_info_alloc]
		add	eax, edx
		add	eax, 1
		mov	[ebp+s], eax
		mov	eax, [ebp+s]
		imul	eax, [ebp+column_info_growth]
		mov	[ebp+t], eax
		mov	eax, [ebp+s]
		cmp	eax, [ebp+new_column_info_alloc]
		jb	short loc_800769A
		mov	eax, [ebp+t]
		mov	edx, 0
		div	[ebp+column_info_growth]
		cmp	eax, [ebp+s]
		jz	short loc_800769F

loc_800769A:				; CODE XREF: init_column_info+AFj
		call	xalloc_die

loc_800769F:				; CODE XREF: init_column_info+BFj
		mov	eax, [ebp+t]
		shr	eax, 1
		sub	esp, 8
		push	4
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, ds:column_info_alloc_8101
		mov	[ebp+i], eax
		jmp	short loc_80076EA
; ---------------------------------------------------------------------------

loc_80076BF:				; CODE XREF: init_column_info+117j
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, [ecx+eax]
		mov	eax, [ebp+p]
		mov	[edx+8], eax
		mov	eax, [ebp+i]
		add	eax, 1
		shl	eax, 2
		add	[ebp+p], eax
		add	[ebp+i], 1

loc_80076EA:				; CODE XREF: init_column_info+E4j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+new_column_info_alloc]
		jb	short loc_80076BF
		mov	eax, [ebp+new_column_info_alloc]
		mov	ds:column_info_alloc_8101, eax

loc_80076FA:				; CODE XREF: init_column_info+21j
		mov	[ebp+i], 0
		jmp	short loc_800777B
; ---------------------------------------------------------------------------

loc_8007703:				; CODE XREF: init_column_info+1A8j
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ecx
		mov	byte ptr [eax],	1
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	ecx, eax
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		mov	[ecx+4], eax
		mov	[ebp+j], 0
		jmp	short loc_800776F
; ---------------------------------------------------------------------------

loc_8007746:				; CODE XREF: init_column_info+19Cj
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ecx
		mov	eax, [eax+8]
		mov	edx, [ebp+j]
		shl	edx, 2
		add	eax, edx
		mov	dword ptr [eax], 3
		add	[ebp+j], 1

loc_800776F:				; CODE XREF: init_column_info+16Bj
		mov	eax, [ebp+j]
		cmp	eax, [ebp+i]
		jbe	short loc_8007746
		add	[ebp+i], 1

loc_800777B:				; CODE XREF: init_column_info+128j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+max_cols]
		jb	short loc_8007703
		nop
		leave
		retn
init_column_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl calculate_columns(_Bool by_columns)
calculate_columns proc near		; CODE XREF: print_many_per_line+Bp
					; print_horizontal+12p

by_columns	= byte ptr -2Ch
filesno		= dword	ptr -28h
cols		= dword	ptr -24h
i		= dword	ptr -20h
max_cols	= dword	ptr -1Ch
f		= dword	ptr -18h
name_length	= dword	ptr -14h
idx		= dword	ptr -10h
real_length	= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+by_columns], al
		mov	edx, ds:cwd_n_used
		mov	eax, ds:max_idx
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+max_cols],	eax
		call	init_column_info
		mov	[ebp+filesno], 0
		jmp	loc_8007954
; ---------------------------------------------------------------------------

loc_80077B8:				; CODE XREF: calculate_columns+1D6j
		mov	eax, ds:sorted_file
		mov	edx, [ebp+filesno]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+f], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	length_of_file_name_and_frills
		add	esp, 10h
		mov	[ebp+name_length], eax
		mov	[ebp+i], 0
		jmp	loc_8007944
; ---------------------------------------------------------------------------

loc_80077E7:				; CODE XREF: calculate_columns+1C4j
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	loc_8007940
		cmp	[ebp+by_columns], 0
		jz	short loc_8007832
		mov	edx, ds:cwd_n_used
		mov	eax, [ebp+i]
		add	eax, edx
		mov	edx, [ebp+i]
		lea	esi, [edx+1]
		mov	edx, 0
		div	esi
		mov	esi, eax
		mov	eax, [ebp+filesno]
		mov	edx, 0
		div	esi
		jmp	short loc_8007844
; ---------------------------------------------------------------------------

loc_8007832:				; CODE XREF: calculate_columns+84j
		mov	eax, [ebp+i]
		lea	ecx, [eax+1]
		mov	eax, [ebp+filesno]
		mov	edx, 0
		div	ecx
		mov	eax, edx

loc_8007844:				; CODE XREF: calculate_columns+AAj
		mov	[ebp+idx], eax
		mov	eax, [ebp+idx]
		cmp	eax, [ebp+i]
		jnz	short loc_8007856
		mov	edx, 0
		jmp	short loc_800785B
; ---------------------------------------------------------------------------

loc_8007856:				; CODE XREF: calculate_columns+C7j
		mov	edx, 2

loc_800785B:				; CODE XREF: calculate_columns+CEj
		mov	eax, [ebp+name_length]
		add	eax, edx
		mov	[ebp+real_length], eax
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ecx
		mov	eax, [eax+8]
		mov	edx, [ebp+idx]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		cmp	eax, [ebp+real_length]
		jnb	loc_8007940
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	ecx, eax
		mov	ebx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ebx
		mov	ebx, [eax+4]
		mov	esi, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, esi
		mov	eax, [eax+8]
		mov	edx, [ebp+idx]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	edx, [ebp+real_length]
		sub	edx, eax
		mov	eax, edx
		add	eax, ebx
		mov	[ecx+4], eax
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ecx
		mov	eax, [eax+8]
		mov	edx, [ebp+idx]
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+real_length]
		mov	[edx], eax
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	ecx, eax
		mov	ebx, ds:column_info_0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, ebx
		mov	edx, [eax+4]
		mov	eax, ds:line_length
		cmp	edx, eax
		setb	al
		mov	[ecx], al

loc_8007940:				; CODE XREF: calculate_columns+7Aj
					; calculate_columns+101j
		add	[ebp+i], 1

loc_8007944:				; CODE XREF: calculate_columns+5Cj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+max_cols]
		jb	loc_80077E7
		add	[ebp+filesno], 1

loc_8007954:				; CODE XREF: calculate_columns+2Dj
		mov	eax, ds:cwd_n_used
		cmp	[ebp+filesno], eax
		jb	loc_80077B8
		mov	eax, [ebp+max_cols]
		mov	[ebp+cols], eax
		jmp	short loc_800798C
; ---------------------------------------------------------------------------

loc_800796A:				; CODE XREF: calculate_columns+20Aj
		mov	ecx, ds:column_info_0
		mov	edx, [ebp+cols]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		sub	eax, 0Ch
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8007994
		sub	[ebp+cols], 1

loc_800798C:				; CODE XREF: calculate_columns+1E2j
		cmp	[ebp+cols], 1
		ja	short loc_800796A
		jmp	short loc_8007995
; ---------------------------------------------------------------------------

loc_8007994:				; CODE XREF: calculate_columns+200j
		nop

loc_8007995:				; CODE XREF: calculate_columns+20Cj
		mov	eax, [ebp+cols]
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
calculate_columns endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: decode_switches+A7Dp
					; decode_switches+AE3p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80079DC
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8007D51
; ---------------------------------------------------------------------------

loc_80079DC:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aListInformatio ; "List information about the FILEs (the	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAAllDoNotIgnor ; "  -a,	--all		       do not ign"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBlockSizeSizeU ; "	--block-size=SIZE      use SIZE-b"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCListEntriesBy ; "  -C			       list entri"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFDoNotSortEnab ; "  -f			       do not sor"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGLikeLButDoNot ; "  -g			       like -l,	b"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGroupDirectori ; "	--group-directories-first\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGNoGroupInALon ; "  -G,	--no-group	       in a long "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHDereferenceCo ; "  -H,	--dereference-command-line\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIndicatorSty_0 ; "	--indicator-style=WORD	append in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLUseALongListi ; "  -l			       use a long"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNNumericUidGid ; "  -n,	--numeric-uid-gid      like -l,	b"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aQHideControlCh ; "  -q,	--hide-control-chars   print ? in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRReverseRevers ; "  -r,	--reverse	       reverse or"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSSortByFileSiz ; "  -S			       sort by fi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTimeStyleStyle ; "	--time-style=STYLE     with -l,	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTSortByModific ; "  -t			       sort by mo"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUWithLtSortByA ; "  -u			       with -lt: "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWWidthColsAssu ; "  -w,	--width=COLS	       assume scr"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_size_note
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUsingColorToDi ; "\nUsing color	to distinguish file types"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aExitStatus0IfO ; "\nExit status:\n 0  if OK,\n 1  if mino"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8007D51:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status

loc_8007D57:				; DATA XREF: .eh_frame:0800BBC8o
					; .eh_frame:0800BBE8o ...
		call	exit
usage		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 8007D60h
; char UNKNOWN_SECURITY_CONTEXT[2]
UNKNOWN_SECURITY_CONTEXT db '?',0       ; DATA XREF: clear_files+4Ao
					; gobble_file+57Co
; _Bool	print_owner
print_owner	db 1			; DATA XREF: decode_switches+43Fw
					; gobble_file+8E7r ...
; _Bool	print_group
print_group	db 1			; DATA XREF: decode_switches+507w
					; decode_switches:loc_80016C2w	...
		align 8
; uintmax_t file_output_block_size
file_output_block_size dq 1		; DATA XREF: decode_switches+1FAw
					; decode_switches+474w	...
		align 20h
; bin_str color_indicator[24]
color_indicator	dd 2			; DATA XREF: is_colored+9r
					; restore_default_color+9o ...
off_8007D84	dd offset byte_8008C24	; DATA XREF: is_colored+16r
					; parse_ls_color+1CFw
; bin_str ind
ind		bin_str	<1, offset byte_8008C27> ; DATA	XREF: restore_default_color+19o
					; prep_non_filename_text+44o ...
; bin_str stru_8007D90
stru_8007D90	bin_str	<0>		; DATA XREF: prep_non_filename_text+12o
					; prep_non_filename_text+6r
; bin_str stru_8007D98
stru_8007D98	bin_str	<1, offset byte_8008C29> ; DATA	XREF: prep_non_filename_text+34o
		dd 4 dup(0)
		dd 5
		dd offset a0134		; "01;34"
dword_8007DB8	dd 5			; DATA XREF: parse_ls_color:loc_8002503r
; char *s1
s1		dd offset a0136		; DATA XREF: parse_ls_color+324r
					; print_color_indicator+256r
					; "01;36"
		dd 2
		dd offset a33		; "33"
		dd 5
		dd offset a0135		; "01;35"
		dd 5
		dd offset a0133		; "01;33"
		dd 5
		dd offset a0133		; "01;33"
		dd 0
dword_8007DE4	dd 2 dup(0)		; DATA XREF: print_color_indicator+79r
dword_8007DEC	dd 0			; DATA XREF: print_color_indicator+272r
		dd 5
		dd offset a0132		; "01;32"
		dd 5
		dd offset a0135		; "01;35"
		dd 5
		dd offset a3741		; "37;41"
		dd 5
		dd offset a3043		; "30;43"
		dd 5
		dd offset a3744		; "37;44"
		dd 5
		dd offset a3442		; "34;42"
		dd 5
		dd offset a3042		; "30;42"
		dd 5
		dd offset a3041		; "30;41"
		dd 2 dup(0)
; bin_str stru_8007E38
stru_8007E38	bin_str	<3, offset aK>	; DATA XREF: print_name_with_quoting+1A6o
					; "\x1B[K"
; const	char *long_time_format[2]
long_time_format dd offset aBEY, offset	aBEHM ;	DATA XREF: decode_switches+D1Dw
					; decode_switches+D83w	...
					; "%b %e  %Y"
; Function-local static	variable
; _Bool	first_7261
first_7261	db 1			; DATA XREF: print_dir:loc_80028CCr
					; print_dir:loc_80028F4w
		align 4
; Function-local static	variable
; int width_7761
width_7761	dd 0FFFFFFFFh		; DATA XREF: long_time_expected_width+14r
					; long_time_expected_width+9Cw	...
		align 20h
; Function-local static	variable
; indicator_no filetype_indicator_8019[10]
filetype_indicator_8019	dd 0Dh		; DATA XREF: print_color_indicator+A2r
		dd 8, 0Bh, 6, 0Ah, 5, 7, 9, 5, 6
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8007EA0h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; Hash_table *active_dir_set
active_dir_set	dd ?			; DATA XREF: visit_dir+4Br main+2D9w ...
; fileinfo *cwd_file
cwd_file	dd ?			; DATA XREF: main+404w	gobble_file+9Dr ...
; size_t cwd_n_alloc
cwd_n_alloc	dd ?			; DATA XREF: main:loc_8000C7Bw
					; main+3EEr ...
; size_t cwd_n_used
cwd_n_used	dd ?			; DATA XREF: main+409w
					; main:loc_8000D49r ...
; void **sorted_file
sorted_file	dd ?			; DATA XREF: clear_files:loc_8002F5Fr
					; extract_dirs_from_files:loc_8003E6Ar	...
; size_t sorted_file_alloc
sorted_file_alloc dd ?			; DATA XREF: sort_files+17r
					; sort_files+55w
; _Bool	color_symlink_as_referent
color_symlink_as_referent db ?		; DATA XREF: main+11Er
					; parse_ls_color+340w ...
		align 4
; pending *pending_dirs
pending_dirs	dd ?			; DATA XREF: main+A6w main+4EBr ...
; timespec current_time
current_time	timespec <?>		; DATA XREF: main+B0w
					; print_long_format+700r ...
; _Bool	print_scontext
print_scontext	db ?			; DATA XREF: main+327r
					; decode_switches+122w	...
; _Bool	any_has_acl
any_has_acl	db ?			; DATA XREF: clear_files+7Bw
					; gobble_file+64Br ...
		align 4
; int inode_number_width
inode_number_width dd ?			; DATA XREF: clear_files+82w
					; gobble_file+C18r ...
; int block_size_width
block_size_width dd ?			; DATA XREF: clear_files+8Cw
					; gobble_file+8C2r ...
; int nlink_width
nlink_width	dd ?			; DATA XREF: clear_files+96w
					; gobble_file+A20r ...
; int scontext_width
scontext_width	dd ?			; DATA XREF: clear_files+BEw
					; gobble_file+9C7r ...
; int owner_width
owner_width	dd ?			; DATA XREF: clear_files+A0w
					; gobble_file+90Dr ...
; int group_width
group_width	dd ?			; DATA XREF: clear_files+AAw
					; gobble_file+94Br ...
; int author_width
author_width	dd ?			; DATA XREF: clear_files+B4w
					; gobble_file+989r ...
; int major_device_number_width
major_device_number_width dd ?		; DATA XREF: clear_files+C8w
					; gobble_file+AAAr ...
; int minor_device_number_width
minor_device_number_width dd ?		; DATA XREF: clear_files+D2w
					; gobble_file+B06r ...
; int file_size_width
file_size_width	dd ?			; DATA XREF: clear_files+DCw
					; gobble_file+B33r ...
; format format_0
format_0	dd ?			; DATA XREF: main+13Ar	main+296r ...
; time_type time_type_0
time_type_0	dd ?			; DATA XREF: decode_switches:loc_800111Aw
					; decode_switches:loc_800141Dw	...
; sort_type sort_type_0
sort_type_0	dd ?			; DATA XREF: main:loc_8000BA1r
					; main+314r ...
; _Bool	sort_reverse
sort_reverse	db ?			; DATA XREF: decode_switches+C6w
					; decode_switches:loc_8001596w	...
; _Bool	print_author
print_author	db ?			; DATA XREF: decode_switches:loc_80017F8w
					; gobble_file:loc_800399Cr ...
; _Bool	numeric_ids
numeric_ids	db ?			; DATA XREF: decode_switches+CDw
					; decode_switches:loc_800154Fw	...
; _Bool	print_block_size
print_block_size db ?			; DATA XREF: main+332r
					; decode_switches+D4w ...
; int human_output_opts
human_output_opts dd ?			; DATA XREF: decode_switches+1C5o
					; decode_switches:loc_80014B3w	...
; uintmax_t output_block_size
output_block_size dq ?			; DATA XREF: decode_switches+1C0o
					; decode_switches:loc_8001257r	...
; _Bool	dired
dired		db ?			; DATA XREF: main+39Dr
					; main:loc_8000FB4r ...
		align 4
; indicator_style indicator_style_0
indicator_style_0 dd ?			; DATA XREF: main+28Cr	main+375r ...
; _Bool	print_with_color
print_with_color db ?			; DATA XREF: main+DDr
					; main:loc_8000984r ...
; _Bool	used_color
used_color	db ?			; DATA XREF: process_signals:loc_80007BCr
					; main+654r ...
		align 4
; color_ext_type *color_ext_list
color_ext_list	dd ?			; DATA XREF: parse_ls_color+E0r
					; parse_ls_color+EFw ...
; char *color_buf
color_buf	dd ?			; DATA XREF: parse_ls_color+5Ew
					; parse_ls_color+63r ...
; _Bool	check_symlink_color
check_symlink_color db ?		; DATA XREF: main:loc_80009DAw
					; gobble_file+19Er ...
; _Bool	print_inode
print_inode	db ?			; DATA XREF: decode_switches+E5w
					; decode_switches:loc_80014ECw	...
		align 4
; Dereference_symlink dereference
dereference	dd ?			; DATA XREF: main:loc_8000B0Er
					; main:loc_8000B42w ...
; _Bool	recursive
recursive	db ?			; DATA XREF: main:loc_8000B47r
					; main+35Fr ...
; _Bool	immediate_dirs
immediate_dirs	db ?			; DATA XREF: main+281r	main+42Fr ...
; _Bool	directories_first
directories_first db ?			; DATA XREF: main+37Er
					; decode_switches:loc_8001876w	...
		align 10h
; $BC0F73628CF3D7A4B76FB1684D8A42FF ignore_mode
ignore_mode	dd ?			; DATA XREF: decode_switches+104w
					; decode_switches:loc_80013FAw	...
; ignore_pattern *ignore_patterns
ignore_patterns	dd ?			; DATA XREF: decode_switches+10Ew
					; add_ignore_pattern+1Er ...
; ignore_pattern *hide_patterns
hide_patterns	dd ?			; DATA XREF: decode_switches+118w
					; decode_switches+7B7r	...
; _Bool	qmark_funny_chars
qmark_funny_chars db ?			; DATA XREF: decode_switches+23w
					; decode_switches+91w ...
		align 10h
; quoting_options *filename_quoting_options
filename_quoting_options dd ?		; DATA XREF: main+752r
					; decode_switches+B23w	...
; quoting_options *dirname_quoting_options
dirname_quoting_options	dd ?		; DATA XREF: decode_switches+BA7w
					; decode_switches+BACr	...
; size_t tabsize
tabsize		dd ?			; DATA XREF: decode_switches+2D0w
					; decode_switches+2FFw	...
; _Bool	print_dir_name
print_dir_name	db ?			; DATA XREF: main+9Fw main+541w ...
		align 10h
; size_t line_length
line_length	dd ?			; DATA XREF: decode_switches:loc_800126Dw
					; decode_switches+258w	...
; _Bool	format_needs_stat
format_needs_stat db ?			; DATA XREF: main+34Cw	main+351r ...
; _Bool	format_needs_type
format_needs_type db ?			; DATA XREF: main+398w
					; gobble_file+153r ...
		align 10h
; sigset_t caught_signals
caught_signals	sigset_t <?>		; DATA XREF: process_signals+44o
					; main+162o ...
; volatile sig_atomic_t	interrupt_signal
interrupt_signal dd ?			; DATA XREF: sighandler+3r
					; sighandler+Fw ...
; volatile sig_atomic_t	stop_signal_count
stop_signal_count dd ?			; DATA XREF: stophandler+Cr
					; stophandler+14w ...
; int exit_status
exit_status	dd ?			; DATA XREF: main+95w
					; main:loc_800105Ar ...
; column_info *column_info_0
column_info_0	dd ?			; DATA XREF: print_many_per_line+16r
					; print_horizontal+1Dr	...
; size_t max_idx
max_idx		dd ?			; DATA XREF: decode_switches:loc_8001B79w
					; init_column_info+Cr ...
; size_t dired_pos
dired_pos	dd ?			; DATA XREF: main+505r	main+50Dw ...
		align 10h
; obstack dired_obstack
dired_obstack	obstack	<?>		; DATA XREF: main+3B9o	main+72Bo ...
		align 20h
; obstack subdired_obstack
subdired_obstack obstack <?>		; DATA XREF: main+3D7o	main+740o ...
		align 20h
; obstack dev_ino_obstack
dev_ino_obstack	obstack	<?>		; DATA XREF: dev_ino_pop+6o
					; dev_ino_pop:loc_80002F8o ...
		align 20h
; char abmon[1932]
abmon		db 78Ch	dup(?)		; DATA XREF: abmon_init+46o
					; align_nstrftime+E0o
; size_t required_mon_width
required_mon_width dd ?			; DATA XREF: abmon_init+12w
					; abmon_init:loc_8000497r ...
		align 20h
; jmp_buf failed_strcoll
failed_strcoll	__jmp_buf_tag <?>	; DATA XREF: xstrcoll+93o
					; sort_files+70o
; Function-local static	variable
; size_t column_info_alloc_8101
column_info_alloc_8101 dd ?		; DATA XREF: init_column_info+19r
					; init_column_info:loc_8007658r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8008900h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_size_note+10o
		db 'SIZE may be (or may be an integer optionally followed by) one of '
		db 'following:',0Ah
		db 'KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P'
		db ', E, Z, Y.',0Ah,0
; char aReportSBugsToS[]
aReportSBugsToS	db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+5Bo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; decode_switches+AC5o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 10h
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 4
; char filetype_letter[11]
filetype_letter	db '?pcdb-lswd',0       ; DATA XREF: print_long_format+55r
; char s[]
s		db 'full-iso',0         ; DATA XREF: decode_switches+89Bo
					; .rodata:time_style_argso
aLongIso	db 'long-iso',0         ; DATA XREF: .rodata:time_style_argso
aIso		db 'iso',0              ; DATA XREF: .rodata:time_style_argso
; char aLocale[]
aLocale		db 'locale',0           ; DATA XREF: decode_switches+C43o
					; .rodata:time_style_argso
; const	char *const time_style_args[5]
time_style_args	dd offset s, offset aLongIso, offset aIso, offset aLocale
					; DATA XREF: decode_switches+D3Fo
		dd 0			; "full-iso"
; const	time_style time_style_types[4]
time_style_types dd full_iso_time_style, long_iso_time_style, iso_time_style
					; DATA XREF: decode_switches+D3Ao
					; decode_switches+D54r
		dd locale_time_style
aNone		db 'none',0             ; DATA XREF: .rodata:indicator_style_argso
					; .rodata:sort_argso ...
aSlash		db 'slash',0            ; DATA XREF: .rodata:indicator_style_argso
aFileType	db 'file-type',0        ; DATA XREF: .rodata:indicator_style_argso
					; .rodata:long_optionso
aClassify	db 'classify',0         ; DATA XREF: .rodata:indicator_style_argso
					; .rodata:long_optionso
		align 10h
; const	char *const indicator_style_args[5]
indicator_style_args dd	offset aNone, offset aSlash, offset aFileType, offset aClassify
					; DATA XREF: decode_switches+95Ao
		dd 0			; "none"
; const	indicator_style	indicator_style_types[4]
indicator_style_types dd none, slash, file_type, classify ; DATA XREF: decode_switches+955o
					; decode_switches+96Dr
byte_8008B74	db 6Ch,	63h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B77	db 72h			; DATA XREF: .rodata:indicator_nameo
		db 63h,	0
word_8008B7A	dw 6365h		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008B7D	db 72h,	73h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B80	db 6Eh,	6Fh, 0		; DATA XREF: .rodata:indicator_nameo
					; .rodata:color_argso
byte_8008B83	db 66h			; DATA XREF: .rodata:indicator_nameo
		db 69h,	0
word_8008B86	dw 6964h		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008B89	db 6Ch,	6Eh, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B8C	db 70h,	69h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B8F	db 73h			; DATA XREF: .rodata:indicator_nameo
		db 6Fh,	0
word_8008B92	dw 6462h		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008B95	db 63h,	64h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B98	db 6Dh,	69h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008B9B	db 6Fh			; DATA XREF: .rodata:indicator_nameo
		db 72h,	0
word_8008B9E	dw 7865h		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008BA1	db 64h,	6Fh, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008BA4	db 73h,	75h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008BA7	db 73h			; DATA XREF: .rodata:indicator_nameo
		db 67h,	0
word_8008BAA	dw 7473h		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008BAD	db 6Fh,	77h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008BB0	db 74h,	77h, 0		; DATA XREF: .rodata:indicator_nameo
byte_8008BB3	db 63h			; DATA XREF: .rodata:indicator_nameo
		db 61h,	0
word_8008BB6	dw 686Dh		; DATA XREF: .rodata:indicator_nameo
		db 0
byte_8008BB9	db 63h,	6Ch, 0		; DATA XREF: .rodata:indicator_nameo
		align 10h
; const	char *const indicator_name[25]
indicator_name	dd offset byte_8008B74,	offset byte_8008B77, offset word_8008B7A
					; DATA XREF: parse_ls_color+1AEr
					; parse_ls_color+210r
		dd offset byte_8008B7D,	offset byte_8008B80, offset byte_8008B83
		dd offset word_8008B86,	offset byte_8008B89, offset byte_8008B8C
		dd offset byte_8008B8F,	offset word_8008B92, offset byte_8008B95
		dd offset byte_8008B98,	offset byte_8008B9B, offset word_8008B9E
		dd offset byte_8008BA1,	offset byte_8008BA4, offset byte_8008BA7
		dd offset word_8008BAA,	offset byte_8008BAD, offset byte_8008BB0
		dd offset byte_8008BB3,	offset word_8008BB6, offset byte_8008BB9
		dd 0
byte_8008C24	db 1Bh,	5Bh, 0		; DATA XREF: .data:off_8007D84o
byte_8008C27	db 6Dh			; DATA XREF: .data:indo
		db 0
byte_8008C29	db 30h,	0		; DATA XREF: is_colored+32o
					; .data:stru_8007D98o
a0134		db '01;34',0            ; DATA XREF: .data:08007DB4o
a0136		db '01;36',0            ; DATA XREF: .data:s1o
a33		db '33',0               ; DATA XREF: .data:08007DC4o
a0135		db '01;35',0            ; DATA XREF: .data:08007DCCo
					; .data:08007DFCo
a0133		db '01;33',0            ; DATA XREF: .data:08007DD4o
					; .data:08007DDCo
a0132		db '01;32',0            ; DATA XREF: .data:08007DF4o
a3741		db '37;41',0            ; DATA XREF: .data:08007E04o
a3043		db '30;43',0            ; DATA XREF: .data:08007E0Co
a3744		db '37;44',0            ; DATA XREF: .data:08007E14o
a3442		db '34;42',0            ; DATA XREF: .data:08007E1Co
a3042		db '30;42',0            ; DATA XREF: .data:08007E24o
a3041		db '30;41',0            ; DATA XREF: .data:08007E2Co
aK		db 1Bh,'[K',0           ; DATA XREF: .data:stru_8007E38o
aBEY		db '%b %e  %Y',0        ; DATA XREF: .data:long_time_formato
aBEHM		db '%b %e %H:%M',0      ; DATA XREF: .data:long_time_formato
aAll		db 'all',0              ; DATA XREF: .rodata:long_optionso
aEscape		db 'escape',0           ; DATA XREF: .rodata:long_optionso
aDirectory	db 'directory',0        ; DATA XREF: .rodata:long_optionso
aDired_0	db 'dired',0            ; DATA XREF: .rodata:long_optionso
aFullTime	db 'full-time',0        ; DATA XREF: .rodata:long_optionso
aGroupDirecto_0	db 'group-directories-first',0 ; DATA XREF: .rodata:long_optionso
aHumanReadable	db 'human-readable',0   ; DATA XREF: .rodata:long_optionso
aInode		db 'inode',0            ; DATA XREF: .rodata:long_optionso
aNumericUidGid	db 'numeric-uid-gid',0  ; DATA XREF: .rodata:long_optionso
aNoGroup	db 'no-group',0         ; DATA XREF: .rodata:long_optionso
aHideControlCha	db 'hide-control-chars',0 ; DATA XREF: .rodata:long_optionso
aReverse	db 'reverse',0          ; DATA XREF: .rodata:long_optionso
aSize		db 'size',0             ; DATA XREF: .rodata:long_optionso
					; .rodata:sort_argso
aWidth		db 'width',0            ; DATA XREF: .rodata:long_optionso
aAlmostAll	db 'almost-all',0       ; DATA XREF: .rodata:long_optionso
aIgnoreBackups	db 'ignore-backups',0   ; DATA XREF: .rodata:long_optionso
aSi		db 'si',0               ; DATA XREF: .rodata:long_optionso
aDereferenceCom	db 'dereference-command-line',0 ; DATA XREF: .rodata:long_optionso
		align 4
aDereferenceC_0	db 'dereference-command-line-symlink-to-dir',0
					; DATA XREF: .rodata:long_optionso
aHide		db 'hide',0             ; DATA XREF: .rodata:long_optionso
aIgnore		db 'ignore',0           ; DATA XREF: .rodata:long_optionso
aIndicatorSty_1	db 'indicator-style',0  ; DATA XREF: .rodata:long_optionso
aDereference	db 'dereference',0      ; DATA XREF: .rodata:long_optionso
aLiteral	db 'literal',0          ; DATA XREF: .rodata:long_optionso
aQuoteName	db 'quote-name',0       ; DATA XREF: .rodata:long_optionso
aQuotingStyle_0	db 'quoting-style',0    ; DATA XREF: .rodata:long_optionso
aRecursive	db 'recursive',0        ; DATA XREF: .rodata:long_optionso
aFormat_0	db 'format',0           ; DATA XREF: .rodata:long_optionso
aShowControlCha	db 'show-control-chars',0 ; DATA XREF: .rodata:long_optionso
aSort_0		db 'sort',0             ; DATA XREF: .rodata:long_optionso
aTabsize_0	db 'tabsize',0          ; DATA XREF: .rodata:long_optionso
aTime_0		db 'time',0             ; DATA XREF: .rodata:long_optionso
					; .rodata:sort_argso
aTimeStyle_0	db 'time-style',0       ; DATA XREF: .rodata:long_optionso
aColor_0	db 'color',0            ; DATA XREF: .rodata:long_optionso
aBlockSize	db 'block-size',0       ; DATA XREF: .rodata:long_optionso
aContext	db 'context',0          ; DATA XREF: .rodata:long_optionso
aAuthor		db 'author',0           ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
					; .rodata:sort_argso
		align 10h
; const	option long_options[42]
long_options	option <offset aAll, 0,	0, 61h>	; DATA XREF: decode_switches+342o
					; decode_switches+A0Bo
		option <offset aEscape,	0, 0, 62h> ; "file-type"
		option <offset aDirectory, 0, 0, 64h>
		option <offset aDired_0, 0, 0, 44h>
		option <offset aFullTime, 0, 0,	86h>
		option <offset aGroupDirecto_0,	0, 0, 87h>
		option <offset aHumanReadable, 0, 0, 68h>
		option <offset aInode, 0, 0, 69h>
		option <offset aNumericUidGid, 0, 0, 6Eh>
		option <offset aNoGroup, 0, 0, 47h>
		option <offset aHideControlCha,	0, 0, 71h>
		option <offset aReverse, 0, 0, 72h>
		option <offset aSize, 0, 0, 73h>
		option <offset aWidth, 1, 0, 77h>
		option <offset aAlmostAll, 0, 0, 41h>
		option <offset aIgnoreBackups, 0, 0, 42h>
		option <offset aClassify, 0, 0,	46h>
		option <offset aFileType, 0, 0,	84h>
		option <offset aSi, 0, 0, 8Ch>
		option <offset aDereferenceCom,	0, 0, 48h>
		option <offset aDereferenceC_0,	0, 0, 83h>
		option <offset aHide, 1, 0, 88h>
		option <offset aIgnore,	1, 0, 49h>
		option <offset aIndicatorSty_1,	1, 0, 89h>
		option <offset aDereference, 0,	0, 4Ch>
		option <offset aLiteral, 0, 0, 4Eh>
		option <offset aQuoteName, 0, 0, 51h>
		option <offset aQuotingStyle_0,	1, 0, 8Ah>
		option <offset aRecursive, 0, 0, 52h>
		option <offset aFormat_0, 1, 0,	85h>
		option <offset aShowControlCha,	0, 0, 8Bh>
		option <offset aSort_0,	1, 0, 8Dh>
		option <offset aTabsize_0, 1, 0, 54h>
		option <offset aTime_0,	1, 0, 8Eh>
		option <offset aTimeStyle_0, 1,	0, 8Fh>
		option <offset aColor_0, 2, 0, 82h>
		option <offset aBlockSize, 1, 0, 81h>
		option <offset aContext, 0, 0, 5Ah>
		option <offset aAuthor,	0, 0, 80h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:format_argso
aLong		db 'long',0             ; DATA XREF: .rodata:format_argso
aCommas		db 'commas',0           ; DATA XREF: .rodata:format_argso
aHorizontal	db 'horizontal',0       ; DATA XREF: .rodata:format_argso
aAcross		db 'across',0           ; DATA XREF: .rodata:format_argso
aVertical	db 'vertical',0         ; DATA XREF: .rodata:format_argso
aSingleColumn	db 'single-column',0    ; DATA XREF: .rodata:format_argso
		align 10h
; const	char *const format_args[8]
format_args	dd offset aVerbose, offset aLong, offset aCommas, offset aHorizontal
					; DATA XREF: decode_switches+86Ao
		dd offset aAcross, offset aVertical, offset aSingleColumn ; "verbose"
		dd 0
; const	format format_types[7]
format_types	dd 2 dup(long_format), with_commas, 2 dup(horizontal)
					; DATA XREF: decode_switches+865o
					; decode_switches+87Dr
		dd many_per_line, one_per_line
aExtension	db 'extension',0        ; DATA XREF: .rodata:sort_argso
		align 4
; const	char *const sort_args[6]
sort_args	dd offset aNone, offset	aTime_0, offset	aSize, offset aExtension
					; DATA XREF: decode_switches+7E6o
		dd offset aVersion, 0	; "none"
; const	sort_type sort_types[5]
sort_types	dd sort_none, sort_time, sort_size, sort_extension, sort_version
					; DATA XREF: decode_switches+7E1o
					; decode_switches+7F9r
aAtime		db 'atime',0            ; DATA XREF: .rodata:time_argso
aAccess		db 'access',0           ; DATA XREF: .rodata:time_argso
aUse		db 'use',0              ; DATA XREF: .rodata:time_argso
aCtime		db 'ctime',0            ; DATA XREF: .rodata:time_argso
aStatus		db 'status',0           ; DATA XREF: .rodata:time_argso
		align 4
; const	char *const time_args[6]
time_args	dd offset aAtime, offset aAccess, offset aUse, offset aCtime
					; DATA XREF: decode_switches+830o
		dd offset aStatus, 0	; "atime"
; const	time_type time_types[5]
time_types	dd 3 dup(time_atime), 2	dup(time_ctime)	; DATA XREF: decode_switches+82Bo
					; decode_switches+843r
aAlways		db 'always',0           ; DATA XREF: .rodata:color_argso
aYes		db 'yes',0              ; DATA XREF: .rodata:color_argso
aForce		db 'force',0            ; DATA XREF: .rodata:color_argso
aNever		db 'never',0            ; DATA XREF: .rodata:color_argso
aAuto		db 'auto',0             ; DATA XREF: .rodata:color_argso
aTty		db 'tty',0              ; DATA XREF: .rodata:color_argso
aIfTty		db 'if-tty',0           ; DATA XREF: .rodata:color_argso
		align 20h
; const	char *const color_args[10]
color_args	dd offset aAlways, offset aYes,	offset aForce, offset aNever
					; DATA XREF: decode_switches+8CFo
		dd offset byte_8008B80,	offset aNone, offset aAuto, offset aTty	; "none"
		dd offset aIfTty, 0
		align 20h
; const	color_type color_types[9]
color_types	dd 3 dup(color_always),	3 dup(color_never), 3 dup(color_if_tty)
					; DATA XREF: decode_switches+8CAo
					; decode_switches+8E2r
; char file[]
file		db 'ls.c',0             ; DATA XREF: dev_ino_pop+2Eo main+5C1o ...
		align 4
; char assertion[]
assertion	db 'sizeof (struct dev_ino) <= obstack_object_size (&dev_ino_obstack)'
					; DATA XREF: dev_ino_pop+33o
		db 0
; char aLu_1[]
aLu_1		db ' %lu',0             ; DATA XREF: dired_dump_obstack+EDo
; char a00[]
a00		db '00',0               ; DATA XREF: is_colored+49o
; char locale
locale		db 0			; DATA XREF: main+44o main+43Do ...
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+56o
; char name[]
name		db '.',0                ; DATA XREF: main+44Ao main+460o
; char aFound[]
aFound		db 'found',0            ; DATA XREF: main+5C6o
; char prefix[]
prefix		db '//DIRED//',0        ; DATA XREF: main+730o
; char aSubdired[]
aSubdired	db '//SUBDIRED//',0     ; DATA XREF: main+745o
		align 10h
; char aDiredOptionsQu[]
aDiredOptionsQu	db '//DIRED-OPTIONS// --quoting-style=%s',0Ah,0 ; DATA XREF: main+76Eo
		align 4
; char aHash_get_n_ent[]
aHash_get_n_ent	db 'hash_get_n_entries (active_dir_set) == 0',0 ; DATA XREF: main+7A8o
; char aQuoting_style[]
aQuoting_style	db 'QUOTING_STYLE',0    ; DATA XREF: decode_switches+12Co
		align 10h
; char aIgnoringInvali[]
aIgnoringInvali	db 'ignoring invalid value of environment variable QUOTING_STYLE: %s',0
					; DATA XREF: decode_switches+18Fo
; char aLs_block_size[]
aLs_block_size	db 'LS_BLOCK_SIZE',0    ; DATA XREF: decode_switches+1ADo
; char aBlock_size[]
aBlock_size	db 'BLOCK_SIZE',0       ; DATA XREF: decode_switches+1DEo
; char aColumns[]
aColumns	db 'COLUMNS',0          ; DATA XREF: decode_switches+212o
		align 4
; char aIgnoringInva_0[]
aIgnoringInva_0	db 'ignoring invalid width in environment variable COLUMNS: %s',0
					; DATA XREF: decode_switches+272o
; char aTabsize[]
aTabsize	db 'TABSIZE',0          ; DATA XREF: decode_switches+2C0o
		align 4
; char aIgnoringInva_1[]
aIgnoringInva_1	db 'ignoring invalid tab size in environment variable TABSIZE: %s',0
					; DATA XREF: decode_switches+319o
		align 4
; char shortopts[]
shortopts	db 'abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1',0
					; DATA XREF: decode_switches+347o
; char aInvalidLineWid[]
aInvalidLineWid	db 'invalid line width: %s',0 ; DATA XREF: decode_switches+5B7o
; char pattern[]
pattern		db '*~',0               ; DATA XREF: decode_switches+60Eo
; char a__0[]
a__0		db '.*~',0              ; DATA XREF: decode_switches+61Eo
; char aInvalidTabSize[]
aInvalidTabSize	db 'invalid tab size: %s',0 ; DATA XREF: decode_switches+725o
aSort		db '--sort',0           ; DATA XREF: decode_switches+7ECo
aTime		db '--time',0           ; DATA XREF: decode_switches+836o
aFormat		db '--format',0         ; DATA XREF: decode_switches+870o
aColor		db '--color',0          ; DATA XREF: decode_switches+8D5o
aIndicatorStyle	db '--indicator-style',0 ; DATA XREF: decode_switches+960o
aQuotingStyle	db '--quoting-style',0  ; DATA XREF: decode_switches+99Ao
aDir		db 'dir',0              ; DATA XREF: decode_switches+A9Co
aVdir		db 'vdir',0             ; DATA XREF: decode_switches:loc_8001B0Bo
aLs		db 'ls',0               ; DATA XREF: decode_switches:loc_8001B12o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: decode_switches+ABAo
aRichardM_Stall	db 'Richard M. Stallman',0 ; DATA XREF: decode_switches+ABFo
a@		db '*=>@|',0            ; DATA XREF: decode_switches+B65o
; char aTime_style[]
aTime_style	db 'TIME_STYLE',0       ; DATA XREF: decode_switches+C2Ao
; char aInvalidTimeSty[]
aInvalidTimeSty	db 'invalid time style format %s',0 ; DATA XREF: decode_switches+CF3o
aTimeStyle	db 'time style',0       ; DATA XREF: decode_switches+D47o
aYMDHMS_NZ	db '%Y-%m-%d %H:%M:%S.%N %z',0 ; DATA XREF: decode_switches:loc_8001DDCo
aYMDHM		db '%Y-%m-%d %H:%M',0   ; DATA XREF: decode_switches:case_long_iso_time_styleo
aYMD		db '%Y-%m-%d ',0        ; DATA XREF: decode_switches:loc_8001E0Co
aMDHM		db '%m-%d %H:%M',0      ; DATA XREF: decode_switches+DAEo
; char needle[]
needle		db '%b',0               ; DATA XREF: decode_switches+E1Fo
					; decode_switches+E39o	...
		align 4
; char aErrorInitializ[]
aErrorInitializ	db 'error initializing month strings',0 ; DATA XREF: decode_switches+E57o
		align 4
off_80095C8	dd offset loc_8001AEA, offset loc_8001AE0, offset loc_8001B46
					; DATA XREF: decode_switches+389r
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46 ;	jump table for switch statement
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_80017DC, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001657, offset loc_8001673
		dd offset loc_8001698, offset loc_80016A7, offset loc_8001B46
		dd offset loc_80016B3, offset loc_80016C2, offset loc_80016CE
		dd offset loc_80016EC, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001702, offset loc_8001B46, offset loc_8001711
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001725
		dd offset loc_8001739, offset loc_8001745, offset loc_8001758
		dd offset loc_80017B6, offset loc_8001B46, offset loc_8001B46
		dd offset loc_80017C9, offset loc_8001B46, offset loc_8001AD7
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_80013FA, offset loc_8001409, offset loc_800141D
		dd offset loc_800142C, offset loc_8001B46, offset loc_8001438
		dd offset loc_800149D, offset loc_80014B3, offset loc_80014EC
		dd offset loc_8001B46, offset loc_80014F8, offset loc_8001531
		dd offset loc_8001540, offset loc_800154F, offset loc_8001565
		dd offset loc_800157B, offset loc_800158A, offset loc_8001596
		dd offset loc_80015A2, offset loc_80015AE, offset loc_80015C1
		dd offset loc_80015D0, offset loc_80015E3, offset loc_8001648
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_8001B46, offset loc_8001B46
		dd offset loc_8001B46, offset loc_80017F8, offset loc_8001A42
		dd offset loc_8001918, offset loc_80016DD, offset loc_800148E
		dd offset loc_80018BC, offset loc_80018F6, offset loc_8001876
		dd offset loc_8001804, offset loc_80019AC, offset loc_80019E6
		dd offset loc_8001A36, offset loc_8001A9E, offset loc_8001838
		dd offset loc_8001882, offset loc_8001A29
off_8009A14	dd offset loc_8001F43	; DATA XREF: get_funky_string+43o
		dd offset loc_8001FC0	; jump table for switch	statement
		dd offset loc_8002071
		dd offset loc_80020C5
		dd offset loc_8002159
off_8009A28	dd offset loc_8002035, offset loc_800203E, offset loc_800203E
					; DATA XREF: get_funky_string+D7r
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E ;	jump table for switch statement
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_8001FD7, offset loc_8001FD7, offset loc_8001FD7
		dd offset loc_8001FD7, offset loc_8001FD7, offset loc_8001FD7
		dd offset loc_8001FD7, offset loc_8001FD7, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_8002029, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_8001FEC, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800202F
		dd offset loc_800203E, offset loc_8001FF9, offset loc_8001FFF
		dd offset loc_800203E, offset loc_800203E, offset loc_8002005
		dd offset loc_800200B, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_800203E, offset loc_800203E, offset loc_8002011
		dd offset loc_800203E, offset loc_800203E, offset loc_800203E
		dd offset loc_8002017, offset loc_800203E, offset loc_800201D
		dd offset loc_800203E, offset loc_8002023, offset loc_800203E
		dd offset loc_8001FEC
off_8009C0C	dd offset loc_80020DF, offset loc_80020DF, offset loc_80020DF
					; DATA XREF: get_funky_string+1DFr
		dd offset loc_80020DF, offset loc_80020DF, offset loc_80020DF ;	jump table for switch statement
		dd offset loc_80020DF, offset loc_80020DF, offset loc_80020DF
		dd offset loc_80020DF, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800211D
		dd offset loc_800211D, offset loc_800211D, offset loc_800211D
		dd offset loc_800211D, offset loc_800211D, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_800213C, offset loc_800213C
		dd offset loc_800213C, offset loc_80020FE, offset loc_80020FE
		dd offset loc_80020FE, offset loc_80020FE, offset loc_80020FE
		dd offset loc_80020FE
; char aLs_colors[]
aLs_colors	db 'LS_COLORS',0        ; DATA XREF: parse_ls_color+15o
; char aUnrecognizedPr[]
aUnrecognizedPr	db 'unrecognized prefix: %s',0 ; DATA XREF: parse_ls_color+239o
		align 4
; char aUnparsableValu[]
aUnparsableValu	db 'unparsable value for LS_COLORS environment variable',0
					; DATA XREF: parse_ls_color+2B8o
; char aTarget[]
aTarget		db 'target',0           ; DATA XREF: parse_ls_color+32Eo
					; print_color_indicator+260o
; char aCannotOpenDire[]
aCannotOpenDire	db 'cannot open directory %s',0 ; DATA XREF: print_dir+72o
; char aCannotDetermin[]
aCannotDetermin	db 'cannot determine device and inode of %s',0 ; DATA XREF: print_dir+10Co
; char aSNotListingAlr[]
aSNotListingAlr	db '%s: not listing already-listed directory',0 ; DATA XREF: print_dir+189o
asc_8009DB1	db '  ',0               ; DATA XREF: print_dir+2C8o
					; print_dir+6A8o ...
asc_8009DB4	db ':',0Ah,0            ; DATA XREF: print_dir+450o
; char aReadingDirecto[]
aReadingDirecto	db 'reading directory %s',0 ; DATA XREF: print_dir+5D3o
; char aClosingDirecto[]
aClosingDirecto	db 'closing directory %s',0 ; DATA XREF: print_dir+629o
; char aTotal[]
aTotal		db 'total',0            ; DATA XREF: print_dir+6C5o
		align 4
off_8009DE8	dd offset loc_8002B86	; DATA XREF: print_dir+4D6r
		dd offset loc_8002B4B	; jump table for switch	statement
		dd offset loc_8002B33
		dd offset loc_8002B86
		dd offset loc_8002B3F
		dd offset loc_8002B86
		dd offset loc_8002B27
		dd offset loc_8002B86
		dd offset loc_8002B63
		dd offset loc_8002B86
		dd offset loc_8002B57
		dd offset loc_8002B86
		dd offset loc_8002B6F
		dd offset loc_8002B86
		dd offset loc_8002B7B
; char aCommand_line_a[]
aCommand_line_a	db '! command_line_arg || inode == NOT_AN_INODE_NUMBER',0
					; DATA XREF: gobble_file+7Eo
; char aCannotAccessS[]
aCannotAccessS	db 'cannot access %s',0 ; DATA XREF: gobble_file+3F2o
; char aUnlabeled[]
aUnlabeled	db 'unlabeled',0        ; DATA XREF: gobble_file+55Co
; char aS[]
aS		db '%s',0               ; DATA XREF: gobble_file+696o
; char aCannotReadSymb[]
aCannotReadSymb	db 'cannot read symbolic link %s',0 ; DATA XREF: get_link_name+39o
		align 4
; char aCannotCompareF[]
aCannotCompareF	db 'cannot compare file names %s and %s',0 ; DATA XREF: xstrcoll+5Ao
		align 10h
; const	qsortFunc sort_functions[7][2][2][2]
sort_functions	dd offset xstrcoll_name, offset	xstrcoll_df_name, offset rev_xstrcoll_name
					; DATA XREF: sort_files+F6r
		dd offset rev_xstrcoll_df_name,	offset strcmp_name, offset strcmp_df_name
		dd offset rev_strcmp_name, offset rev_strcmp_df_name, offset xstrcoll_extension
		dd offset xstrcoll_df_extension, offset	rev_xstrcoll_extension
		dd offset rev_xstrcoll_df_extension, offset strcmp_extension
		dd offset strcmp_df_extension, offset rev_strcmp_extension
		dd offset rev_strcmp_df_extension, offset xstrcoll_size
		dd offset xstrcoll_df_size, offset rev_xstrcoll_size, offset rev_xstrcoll_df_size
		dd offset strcmp_size, offset strcmp_df_size, offset rev_strcmp_size
		dd offset rev_strcmp_df_size, offset xstrcoll_version
		dd offset xstrcoll_df_version, offset rev_xstrcoll_version
		dd offset rev_xstrcoll_df_version, 4 dup(0), offset xstrcoll_mtime
		dd offset xstrcoll_df_mtime, offset rev_xstrcoll_mtime
		dd offset rev_xstrcoll_df_mtime, offset	strcmp_mtime, offset strcmp_df_mtime
		dd offset rev_strcmp_mtime, offset rev_strcmp_df_mtime
		dd offset xstrcoll_ctime, offset xstrcoll_df_ctime, offset rev_xstrcoll_ctime
		dd offset rev_xstrcoll_df_ctime, offset	strcmp_ctime, offset strcmp_df_ctime
		dd offset rev_strcmp_ctime, offset rev_strcmp_df_ctime
		dd offset xstrcoll_atime, offset xstrcoll_df_atime, offset rev_xstrcoll_atime
		dd offset rev_xstrcoll_df_atime, offset	strcmp_atime, offset strcmp_df_atime
		dd offset rev_strcmp_atime, offset rev_strcmp_df_atime
; char aSort_typeSort_[]
aSort_typeSort_	db 'sort_type != sort_version',0 ; DATA XREF: sort_files+A4o
		align 4
off_8009FBC	dd offset loc_80052EE	; DATA XREF: print_current_files+14r
		dd offset loc_8005296	; jump table for switch	statement
		dd offset loc_80052D9
		dd offset loc_80052E0
		dd offset loc_80052E7
; char aLu[]
aLu		db '%*lu ',0            ; DATA XREF: format_user_or_group+87o
; char a_[]
a?		db '?',0                ; DATA XREF: format_user+17o
					; format_group+17o ...
; char aLu_0[]
aLu_0		db '%lu',0              ; DATA XREF: format_user_or_group_width+45o
; char aInt_bufsize_bo[]
aInt_bufsize_bo	db 'INT_BUFSIZE_BOUND (uintmax_t) <= buflen',0 ; DATA XREF: format_inode+1Bo
; char aS_0[]
aS_0		db '%*s ',0             ; DATA XREF: print_long_format+1BFo
					; print_long_format+85Co ...
; char aSS[]
aSS		db '%s %*s ',0          ; DATA XREF: print_long_format+31Bo
; char aSS_0[]
aSS_0		db '%*s, %*s ',0        ; DATA XREF: print_long_format+59Do
asc_800A01B	db ' -> ',0             ; DATA XREF: print_long_format+915o
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aListInformatio[]
aListInformatio	db 'List information about the FILEs (the current directory by defaul'
					; DATA XREF: usage+69o
		db 't).',0Ah
		db 'Sort entries alphabetically if none of -cftuvSUX nor --sort.',0Ah
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aAAllDoNotIgnor[]
aAAllDoNotIgnor	db '  -a, --all                  do not ignore entries starting with '
					; DATA XREF: usage+AFo
		db '.',0Ah
		db '  -A, --almost-all           do not list implied . and ..',0Ah
		db '      --author               with -l, print the author of each fi'
		db 'le',0Ah
		db '  -b, --escape               print octal escapes for nongraphic c'
		db 'haracters',0Ah,0
		align 4
; char aBlockSizeSizeU[]
aBlockSizeSizeU	db '      --block-size=SIZE      use SIZE-byte blocks.  See SIZE form'
					; DATA XREF: usage+D2o
		db 'at below',0Ah
		db '  -B, --ignore-backups       do not list implied entries ending w'
		db 'ith ~',0Ah
		db '  -c                         with -lt: sort by, and show, ctime ('
		db 'time of last',0Ah
		db '                               modification of file status inform'
		db 'ation)',0Ah
		db '                               with -l: show ctime and sort by na'
		db 'me',0Ah
		db '                               otherwise: sort by ctime',0Ah,0
; char aCListEntriesBy[]
aCListEntriesBy	db '  -C                         list entries by columns',0Ah
					; DATA XREF: usage+F5o
		db '      --color[=WHEN]         colorize the output.  WHEN defaults '
		db 'to `always',27h,0Ah
		db '                               or can be `never',27h,' or `auto',27h,'.'
		db '  More info below',0Ah
		db '  -d, --directory            list directory entries instead of co'
		db 'ntents,',0Ah
		db '                               and do not dereference symbolic li'
		db 'nks',0Ah
		db '  -D, --dired                generate output designed for Emacs',27h
		db ' dired mode',0Ah,0
		align 4
; char aFDoNotSortEnab[]
aFDoNotSortEnab	db '  -f                         do not sort, enable -aU, disable -ls'
					; DATA XREF: usage+118o
		db ' --color',0Ah
		db '  -F, --classify             append indicator (one of */=>@|) to '
		db 'entries',0Ah
		db '      --file-type            likewise, except do not append `*',27h,0Ah
		db '      --format=WORD          across -x, commas -m, horizontal -x,'
		db ' long -l,',0Ah
		db '                               single-column -1, verbose -l, vert'
		db 'ical -C',0Ah
		db '      --full-time            like -l --time-style=full-iso',0Ah,0
		align 10h
; char aGLikeLButDoNot[]
aGLikeLButDoNot	db '  -g                         like -l, but do not list owner',0Ah,0
					; DATA XREF: usage+13Bo
		align 10h
; char aGroupDirectori[]
aGroupDirectori	db '      --group-directories-first',0Ah ; DATA XREF: usage+15Eo
		db '                             group directories before files.',0Ah
		db '                               augment with a --sort option, but '
		db 'any',0Ah
		db '                               use of --sort=none (-U) disables g'
		db 'rouping',0Ah,0
; char aGNoGroupInALon[]
aGNoGroupInALon	db '  -G, --no-group             in a long listing, don',27h,'t print gr'
					; DATA XREF: usage+181o
		db 'oup names',0Ah
		db '  -h, --human-readable       with -l, print sizes in human readab'
		db 'le format',0Ah
		db '                               (e.g., 1K 234M 2G)',0Ah
		db '      --si                   likewise, but use powers of 1000 not'
		db ' 1024',0Ah,0
		align 4
; char aHDereferenceCo[]
aHDereferenceCo	db '  -H, --dereference-command-line',0Ah ; DATA XREF: usage+1A4o
		db '                             follow symbolic links listed on the '
		db 'command line',0Ah
		db '      --dereference-command-line-symlink-to-dir',0Ah
		db '                             follow each command line symbolic li'
		db 'nk',0Ah
		db '                             that points to a directory',0Ah
		db '      --hide=PATTERN         do not list implied entries matching'
		db ' shell PATTERN',0Ah
		db '                               (overridden by -a or -A)',0Ah,0
; char aIndicatorSty_0[]
aIndicatorSty_0	db '      --indicator-style=WORD  append indicator with style WORD to'
					; DATA XREF: usage+1C7o
		db ' entry names:',0Ah
		db '                               none (default), slash (-p),',0Ah
		db '                               file-type (--file-type), classify '
		db '(-F)',0Ah
		db '  -i, --inode                print the index number of each file',0Ah
		db '  -I, --ignore=PATTERN       do not list implied entries matching'
		db ' shell PATTERN',0Ah
		db '  -k                         like --block-size=1K',0Ah,0
; char aLUseALongListi[]
aLUseALongListi	db '  -l                         use a long listing format',0Ah
					; DATA XREF: usage+1EAo
		db '  -L, --dereference          when showing file information for a '
		db 'symbolic',0Ah
		db '                               link, show information for the fil'
		db 'e the link',0Ah
		db '                               references rather than for the lin'
		db 'k itself',0Ah
		db '  -m                         fill width with a comma separated li'
		db 'st of entries',0Ah,0
		align 4
; char aNNumericUidGid[]
aNNumericUidGid	db '  -n, --numeric-uid-gid      like -l, but list numeric user and g'
					; DATA XREF: usage+20Do
		db 'roup IDs',0Ah
		db '  -N, --literal              print raw entry names (don',27h,'t trea'
		db 't e.g. control',0Ah
		db '                               characters specially)',0Ah
		db '  -o                         like -l, but do not list group infor'
		db 'mation',0Ah
		db '  -p, --indicator-style=slash',0Ah
		db '                             append / indicator to directories',0Ah,0
		align 10h
; char aQHideControlCh[]
aQHideControlCh	db '  -q, --hide-control-chars   print ? instead of non graphic chara'
					; DATA XREF: usage+230o
		db 'cters',0Ah
		db '      --show-control-chars   show non graphic characters as-is (d'
		db 'efault',0Ah
		db '                             unless program is `ls',27h,' and output'
		db ' is a terminal)',0Ah
		db '  -Q, --quote-name           enclose entry names in double quotes'
		db 0Ah
		db '      --quoting-style=WORD   use quoting style WORD for entry nam'
		db 'es:',0Ah
		db '                               literal, locale, shell, shell-alwa'
		db 'ys, c, escape',0Ah,0
; char aRReverseRevers[]
aRReverseRevers	db '  -r, --reverse              reverse order while sorting',0Ah
					; DATA XREF: usage+253o
		db '  -R, --recursive            list subdirectories recursively',0Ah
		db '  -s, --size                 print the allocated size of each fil'
		db 'e, in blocks',0Ah,0
		align 4
; char aSSortByFileSiz[]
aSSortByFileSiz	db '  -S                         sort by file size',0Ah
					; DATA XREF: usage+276o
		db '      --sort=WORD            sort by WORD instead of name: none -'
		db 'U,',0Ah
		db '                             extension -X, size -S, time -t, vers'
		db 'ion -v',0Ah
		db '      --time=WORD            with -l, show time as WORD instead o'
		db 'f modification',0Ah
		db '                             time: atime -u, access -u, use -u, c'
		db 'time -c,',0Ah
		db '                             or status -c; use specified time as '
		db 'sort key',0Ah
		db '                             if --sort=time',0Ah,0
; char aTimeStyleStyle[]
aTimeStyleStyle	db '      --time-style=STYLE     with -l, show times using style STYL'
					; DATA XREF: usage+299o
		db 'E:',0Ah
		db '                             full-iso, long-iso, iso, locale, +FO'
		db 'RMAT.',0Ah
		db '                             FORMAT is interpreted like `date',27h,';'
		db ' if FORMAT is',0Ah
		db '                             FORMAT1<newline>FORMAT2, FORMAT1 app'
		db 'lies to',0Ah
		db '                             non-recent files and FORMAT2 to rece'
		db 'nt files;',0Ah
		db '                             if STYLE is prefixed with `posix-',27h,','
		db ' STYLE',0Ah
		db '                             takes effect only outside the POSIX '
		db 'locale',0Ah,0
; char aTSortByModific[]
aTSortByModific	db '  -t                         sort by modification time',0Ah
					; DATA XREF: usage+2BCo
		db '  -T, --tabsize=COLS         assume tab stops at each COLS instea'
		db 'd of 8',0Ah,0
; char aUWithLtSortByA[]
aUWithLtSortByA	db '  -u                         with -lt: sort by, and show, access '
					; DATA XREF: usage+2DFo
		db 'time',0Ah
		db '                               with -l: show access time and sort'
		db ' by name',0Ah
		db '                               otherwise: sort by access time',0Ah
		db '  -U                         do not sort; list entries in directo'
		db 'ry order',0Ah
		db '  -v                         natural sort of (version) numbers wi'
		db 'thin text',0Ah,0
; char aWWidthColsAssu[]
aWWidthColsAssu	db '  -w, --width=COLS           assume screen width instead of curre'
					; DATA XREF: usage+302o
		db 'nt value',0Ah
		db '  -x                         list entries by lines instead of by '
		db 'columns',0Ah
		db '  -X                         sort alphabetically by entry extensi'
		db 'on',0Ah
		db '  -Z, --context              print any SELinux security context o'
		db 'f each file',0Ah
		db '  -1                         list one file per line',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+325o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+348o
		align 4
; char aUsingColorToDi[]
aUsingColorToDi	db 0Ah			; DATA XREF: usage+370o
		db 'Using color to distinguish file types is disabled both by default'
		db ' and',0Ah
		db 'with --color=never.  With --color=auto, ls emits color codes only'
		db ' when',0Ah
		db 'standard output is connected to a terminal.  The LS_COLORS enviro'
		db 'nment',0Ah
		db 'variable can change the settings.  Use the dircolors command to s'
		db 'et it.',0Ah,0
		align 4
; char aExitStatus0IfO[]
aExitStatus0IfO	db 0Ah			; DATA XREF: usage+393o
		db 'Exit status:',0Ah
		db ' 0  if OK,',0Ah
		db ' 1  if minor problems (e.g., cannot access subdirectory),',0Ah
		db ' 2  if serious trouble (e.g., cannot access command-line argument'
		db ').',0Ah,0
; Function-local static	variable
; const	char _PRETTY_FUNCTION___6896[12]
__PRETTY_FUNCTION___6896 db 'dev_ino_pop',0 ; DATA XREF: dev_ino_pop+24o
; Function-local static	variable
; const	int sig_6984[12]
sig_6984	dd 14h			; DATA XREF: main+181r	main+1AEr ...
		dd 0Eh,	1, 2, 0Dh, 3, 0Fh, 1Dh,	1Bh, 1Ah, 18h, 19h
; Function-local static	variable
; const	char _PRETTY_FUNCTION___6987[5]
__PRETTY_FUNCTION___6987 db 'main',0    ; DATA XREF: main+5B7o main+799o
		align 4
; Function-local static	variable
; const	char posix_prefix_7109[7]
posix_prefix_7109 db 'posix-',0         ; DATA XREF: decode_switches+C7Co
		align 10h
; Function-local static	variable
; const	char _PRETTY_FUNCTION___7323[12]
__PRETTY_FUNCTION___7323 db 'gobble_file',0 ; DATA XREF: gobble_file+6Fo
; Function-local static	variable
; const	char _PRETTY_FUNCTION___7728[11]
__PRETTY_FUNCTION___7728 db 'sort_files',0 ; DATA XREF: sort_files+95o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___7803[13]
__PRETTY_FUNCTION___7803 db 'format_inode',0 ; DATA XREF: format_inode+Co
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 800BBA8h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8007D57-801391Fh
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 3Ch
		dd offset loc_8007D57-8013939h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 5Ch
		dd offset loc_8007D57-8013941h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 7Ch
		dd offset loc_8007D57-8013949h
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 1Ch, 9Ch
		dd offset loc_8007D57-8013955h
		dd 46h,	80E4100h, 0D420285h, 0C5420205h, 4040Ch, 1Ch, 0BCh
		dd offset loc_8007D57-801392Fh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 1Ch, 0DCh
		dd offset loc_8007D57-801393Dh
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 20h, 0FCh
		dd offset loc_8007D57-8013905h
		dd 30h,	80E4100h, 0D420285h, 3834405h, 0CC3C568h, 404h
		dd 20h,	120h
		dd offset loc_8007D57-80138F9h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	144h
		dd offset loc_8007D57-8013801h
		dd 1Ch,	80E4100h, 0D420285h, 0CC55805h,	404h, 1Ch, 164h
		dd offset loc_8007D57-8013805h
		dd 8, 80E4100h,	0D420285h, 0CC54405h, 404h, 1Ch, 184h
		dd offset loc_8007D57-801381Dh
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 1A4h
		dd offset loc_8007D57-8013822h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 1C4h
		dd offset loc_8007D57-8013827h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 1E4h
		dd offset loc_8007D57-801382Ch
		dd 0AAh, 80E4100h, 0D420285h, 0C5A40205h, 4040Ch, 1Ch
		dd 204h
		dd offset loc_8007D57-80137A2h
		dd 116h, 80E4100h, 0D420285h, 1120305h,	4040CC5h, 20h
		dd 224h
		dd offset loc_8007D57-80136ACh
		dd 0E8h, 80E4100h, 0D420285h, 3834405h,	0C3C5E002h, 4040Ch
		dd 20h,	248h
		dd offset loc_8007D57-80135E8h
		dd 2Eh,	80E4100h, 0D420285h, 3834405h, 0CC3C566h, 404h
		dd 24h,	26Ch
		dd offset loc_8007D57-80135DEh
		dd 64h,	80E4100h, 0D420285h, 3864505h, 59020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 294h
		dd offset loc_8007D57-80135A2h
		dd 17h,	80E4100h, 0D420285h, 0CC55305h,	404h, 1Ch, 2B4h
		dd offset loc_8007D57-80135ABh
		dd 93h,	80E4100h, 0D420285h, 0C58F0205h, 4040Ch, 1Ch, 2D4h
		dd offset loc_8007D57-8013538h
		dd 3Ah,	80E4100h, 0D420285h, 0CC57605h,	404h, 1Ch, 2F4h
		dd offset loc_8007D57-801351Eh
		dd 6Eh,	80E4100h, 0D420285h, 0C56A0205h, 4040Ch, 1Ch, 314h
		dd offset loc_8007D57-80134D0h
		dd 29h,	80E4100h, 0D420285h, 0CC56505h,	404h, 1Ch, 334h
		dd offset loc_8007D57-80134C7h
		dd 17h,	80E4100h, 0D420285h, 0CC55305h,	404h, 1Ch, 354h
		dd offset loc_8007D57-80134D0h
		dd 1Ch,	80E4100h, 0D420285h, 0CC55805h,	404h, 1Ch, 374h
		dd offset loc_8007D57-80134D4h
		dd 0F4h, 80E4100h, 0D420285h, 0C5F00205h, 4040Ch, 2Ch
		dd 394h
		dd offset loc_8007D57-8013400h
		dd 7D1h, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h, 20h,	3C4h
		dd offset loc_8007D57-8012C5Fh
		dd 0E8Fh, 80E4100h, 0D420285h, 3834405h, 0C50E8703h, 4040CC3h
		dd 1Ch,	3E8h
		dd offset loc_8007D57-8011DF4h
		dd 2F2h, 80E4100h, 0D420285h, 2EE0305h,	4040CC5h, 20h
		dd 408h
		dd offset loc_8007D57-8011B22h
		dd 360h, 80E4100h, 0D420285h, 3834405h,	0C5035803h, 4040CC3h
		dd 1Ch,	42Ch
		dd offset loc_8007D57-80117E6h
		dd 34h,	80E4100h, 0D420285h, 0CC57005h,	404h, 20h, 44Ch
		dd offset loc_8007D57-80117D2h
		dd 49h,	80E4100h, 0D420285h, 3834405h, 0C3C54102h, 4040Ch
		dd 1Ch,	470h
		dd offset loc_8007D57-80117ADh
		dd 82h,	80E4100h, 0D420285h, 0C57E0205h, 4040Ch, 20h, 490h
		dd offset loc_8007D57-801174Bh
		dd 7D8h, 80E4100h, 0D420285h, 3834705h,	0C507CD03h, 4040CC3h
		dd 1Ch,	4B4h
		dd offset loc_8007D57-8010F97h
		dd 35h,	80E4100h, 0D420285h, 0CC57105h,	404h, 1Ch, 4D4h
		dd offset loc_8007D57-8010F82h
		dd 45h,	80E4100h, 0D420285h, 0C5410205h, 4040Ch, 1Ch, 4F4h
		dd offset loc_8007D57-8010F5Dh
		dd 92h,	80E4100h, 0D420285h, 0C58E0205h, 4040Ch, 1Ch, 514h
		dd offset loc_8007D57-8010EEBh
		dd 1Ah,	80E4100h, 0D420285h, 0CC55605h,	404h, 1Ch, 534h
		dd offset loc_8007D57-8010EF1h
		dd 0Ah,	80E4100h, 0D420285h, 0CC54605h,	404h, 1Ch, 554h
		dd offset loc_8007D57-8010F07h
		dd 0E9h, 80E4100h, 0D420285h, 0C5E50205h, 4040Ch, 20h
		dd 574h
		dd offset loc_8007D57-8010E3Eh
		dd 0C7Ah, 80E4100h, 0D420285h, 3834705h, 0C50C6F03h, 4040CC3h
		dd 1Ch,	598h
		dd offset loc_8007D57-80101E8h
		dd 2Ah,	80E4100h, 0D420285h, 0CC56605h,	404h, 1Ch, 5B8h
		dd offset loc_8007D57-80101DEh
		dd 5Fh,	80E4100h, 0D420285h, 0C55B0205h, 4040Ch, 1Ch, 5D8h
		dd offset loc_8007D57-801019Fh
		dd 0C3h, 80E4100h, 0D420285h, 0C5BF0205h, 4040Ch, 1Ch
		dd 5F8h
		dd offset loc_8007D57-80100FCh
		dd 27h,	80E4100h, 0D420285h, 0CC56305h,	404h, 1Ch, 618h
		dd offset loc_8007D57-80100F5h
		dd 191h, 80E4100h, 0D420285h, 18D0305h,	4040CC5h, 28h
		dd 638h
		dd offset loc_8007D57-800FF84h
		dd 0A8h, 80E4100h, 0D420285h, 3874605h,	5830486h, 41C39B02h
		dd 41C741C6h, 4040CC5h,	1Ch, 664h
		dd offset loc_8007D57-800FF08h
		dd 95h,	80E4100h, 0D420285h, 0C5910205h, 4040Ch, 1Ch, 684h
		dd offset loc_8007D57-800FE93h
		dd 95h,	80E4100h, 0D420285h, 0C5910205h, 4040Ch, 1Ch, 6A4h
		dd offset loc_8007D57-800FE1Eh
		dd 95h,	80E4100h, 0D420285h, 0C5910205h, 4040Ch, 20h, 6C4h
		dd offset loc_8007D57-800FDA9h
		dd 80h,	80E4100h, 0D420285h, 3834405h, 0C3C57802h, 4040Ch
		dd 1Ch,	6E8h
		dd offset loc_8007D57-800FD4Dh
		dd 1Fh,	80E4100h, 0D420285h, 0CC55B05h,	404h, 1Ch, 708h
		dd offset loc_8007D57-800FD4Eh
		dd 86h,	80E4100h, 0D420285h, 0C5820205h, 4040Ch, 1Ch, 728h
		dd offset loc_8007D57-800FCE8h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 748h
		dd offset loc_8007D57-800FCEAh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 768h
		dd offset loc_8007D57-800FCECh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 788h
		dd offset loc_8007D57-800FCEEh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 7A8h
		dd offset loc_8007D57-800FCF0h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 7C8h
		dd offset loc_8007D57-800FCA6h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 7E8h
		dd offset loc_8007D57-800FC5Ch
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 808h
		dd offset loc_8007D57-800FC12h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 828h
		dd offset loc_8007D57-800FBC8h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 848h
		dd offset loc_8007D57-800FBCAh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 868h
		dd offset loc_8007D57-800FBCCh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 888h
		dd offset loc_8007D57-800FBCEh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 8A8h
		dd offset loc_8007D57-800FBD0h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 8C8h
		dd offset loc_8007D57-800FB86h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 8E8h
		dd offset loc_8007D57-800FB3Ch
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 908h
		dd offset loc_8007D57-800FAF2h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 928h
		dd offset loc_8007D57-800FAA8h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 948h
		dd offset loc_8007D57-800FAAAh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 968h
		dd offset loc_8007D57-800FAACh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 988h
		dd offset loc_8007D57-800FAAEh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 9A8h
		dd offset loc_8007D57-800FAB0h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 9C8h
		dd offset loc_8007D57-800FA66h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 9E8h
		dd offset loc_8007D57-800FA1Ch
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0A08h
		dd offset loc_8007D57-800F9D2h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0A28h
		dd offset loc_8007D57-800F988h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0A48h
		dd offset loc_8007D57-800F98Ah
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0A68h
		dd offset loc_8007D57-800F98Ch
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0A88h
		dd offset loc_8007D57-800F98Eh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0AA8h
		dd offset loc_8007D57-800F990h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0AC8h
		dd offset loc_8007D57-800F946h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0AE8h
		dd offset loc_8007D57-800F8FCh
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0B08h
		dd offset loc_8007D57-800F8B2h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0B28h
		dd offset loc_8007D57-800F868h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0B48h
		dd offset loc_8007D57-800F86Ah
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0B68h
		dd offset loc_8007D57-800F86Ch
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0B88h
		dd offset loc_8007D57-800F86Eh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0BA8h
		dd offset loc_8007D57-800F870h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0BC8h
		dd offset loc_8007D57-800F826h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0BE8h
		dd offset loc_8007D57-800F7DCh
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0C08h
		dd offset loc_8007D57-800F792h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0C28h
		dd offset loc_8007D57-800F748h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0C48h
		dd offset loc_8007D57-800F74Ah
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0C68h
		dd offset loc_8007D57-800F74Ch
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0C88h
		dd offset loc_8007D57-800F74Eh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0CA8h
		dd offset loc_8007D57-800F750h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0CC8h
		dd offset loc_8007D57-800F706h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0CE8h
		dd offset loc_8007D57-800F6BCh
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0D08h
		dd offset loc_8007D57-800F672h
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 0D28h
		dd offset loc_8007D57-800F628h
		dd 1Fh,	80E4100h, 0D420285h, 0CC55B05h,	404h, 1Ch, 0D48h
		dd offset loc_8007D57-800F629h
		dd 19h,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 0D68h
		dd offset loc_8007D57-800F630h
		dd 19h,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 0D88h
		dd offset loc_8007D57-800F637h
		dd 65h,	80E4100h, 0D420285h, 0C5610205h, 4040Ch, 1Ch, 0DA8h
		dd offset loc_8007D57-800F5F2h
		dd 65h,	80E4100h, 0D420285h, 0C5610205h, 4040Ch, 1Ch, 0DC8h
		dd offset loc_8007D57-800F5ADh
		dd 3Dh,	80E4100h, 0D420285h, 0CC57905h,	404h, 20h, 0DE8h
		dd offset loc_8007D57-800F590h
		dd 11Eh, 80E4100h, 0D420285h, 3834405h,	0C5011603h, 4040CC3h
		dd 1Ch,	0E0Ch
		dd offset loc_8007D57-800F496h
		dd 0C5h, 80E4100h, 0D420285h, 0C5C10205h, 4040Ch, 1Ch
		dd 0E2Ch
		dd offset loc_8007D57-800F3F1h
		dd 15Dh, 80E4100h, 0D420285h, 1590305h,	4040CC5h, 1Ch
		dd 0E4Ch
		dd offset loc_8007D57-800F2B4h
		dd 0CCh, 80E4100h, 0D420285h, 0C5C80205h, 4040Ch, 1Ch
		dd 0E6Ch
		dd offset loc_8007D57-800F208h
		dd 0B0h, 80E4100h, 0D420285h, 0C5AC0205h, 4040Ch, 1Ch
		dd 0E8Ch
		dd offset loc_8007D57-800F178h
		dd 53h,	80E4100h, 0D420285h, 0C54F0205h, 4040Ch, 1Ch, 0EACh
		dd offset loc_8007D57-800F145h
		dd 53h,	80E4100h, 0D420285h, 0C54F0205h, 4040Ch, 1Ch, 0ECCh
		dd offset loc_8007D57-800F112h
		dd 78h,	80E4100h, 0D420285h, 0C5740205h, 4040Ch, 1Ch, 0EECh
		dd offset loc_8007D57-800F0BAh
		dd 37h,	80E4100h, 0D420285h, 0CC57305h,	404h, 1Ch, 0F0Ch
		dd offset loc_8007D57-800F0A3h
		dd 37h,	80E4100h, 0D420285h, 0CC57305h,	404h, 1Ch, 0F2Ch
		dd offset loc_8007D57-800F08Ch
		dd 61h,	80E4100h, 0D420285h, 0C55D0205h, 4040Ch, 2Ch, 0F4Ch
		dd offset loc_8007D57-800F04Bh
		dd 9D3h, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C309C303h
		dd 0C741C641h, 40CC541h, 4, 20h, 0F7Ch
		dd offset loc_8007D57-800E6A8h
		dd 4B9h, 80E4100h, 0D420285h, 3834705h,	0C504AE03h, 4040CC3h
		dd 20h,	0FA0h
		dd offset loc_8007D57-800E213h
		dd 1BBh, 80E4100h, 0D420285h, 3834405h,	0C501B303h, 4040CC3h
		dd 1Ch,	0FC4h
		dd offset loc_8007D57-800E07Ch
		dd 54h,	80E4100h, 0D420285h, 0C5500205h, 4040Ch, 28h, 0FE4h
		dd offset loc_8007D57-800E048h
		dd 1AAh, 80E4100h, 0D420285h, 3864805h,	9C030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 1010h
		dd offset loc_8007D57-800DECAh
		dd 130h, 80E4100h, 0D420285h, 12C0305h,	4040CC5h, 1Ch
		dd 1030h
		dd offset loc_8007D57-800DDBAh
		dd 4Eh,	80E4100h, 0D420285h, 0C54A0205h, 4040Ch, 20h, 1050h
		dd offset loc_8007D57-800DD8Ch
		dd 3CDh, 80E4100h, 0D420285h, 3834405h,	0C503C503h, 4040CC3h
		dd 1Ch,	1074h
		dd offset loc_8007D57-800D9E3h
		dd 41h,	80E4100h, 0D420285h, 0CC57D05h,	404h, 28h, 1094h
		dd offset loc_8007D57-800D9C2h
		dd 1D8h, 80E4100h, 0D420285h, 3864805h,	0CA030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 10C0h
		dd offset loc_8007D57-800D816h
		dd 121h, 80E4100h, 0D420285h, 11D0305h,	4040CC5h, 1Ch
		dd 10E0h
		dd offset loc_8007D57-800D715h
		dd 12Fh, 80E4100h, 0D420285h, 12B0305h,	4040CC5h, 1Ch
		dd 1100h
		dd offset loc_8007D57-800D606h
		dd 0C1h, 80E4100h, 0D420285h, 0C5BD0205h, 4040Ch, 20h
		dd 1120h
		dd offset loc_8007D57-800D565h
		dd 88h,	80E4100h, 0D420285h, 3834405h, 0C3C58002h, 4040Ch
		dd 1Ch,	1144h
		dd offset loc_8007D57-800D501h
		dd 93h,	80E4100h, 0D420285h, 0C58F0205h, 4040Ch, 1Ch, 1164h
		dd offset loc_8007D57-800D48Eh
		dd 1ADh, 80E4100h, 0D420285h, 1A90305h,	4040CC5h, 28h
		dd 1184h
		dd offset loc_8007D57-800D301h
		dd 219h, 80E4100h, 0D420285h, 3864505h,	0E030483h, 0C641C302h
		dd 40CC541h, 4,	18h, 11B0h
		dd offset loc_8007D57-800D114h
		dd 3BDh, 80E4100h, 0D420285h, 3834405h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: getfilecon+6p
					; lgetfilecon+6p ...
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_size_note+7r
					; emit_ancillary_info+62r ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_size_note+15p
					; emit_ancillary_info+22p ...
		extrn fputs_unlocked:near ; CODE XREF: emit_size_note+22p
					; emit_ancillary_info+7Dp ...
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+4Bp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
					; is_colored+51p ...
		extrn imaxtostr:near	; CODE XREF: timetostr+12p
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: dev_ino_pop+38p
					; main+5CBp ...
; void obstack_newchunk(struct obstack *, int)
		extrn _obstack_newchunk:near ; CODE XREF: dev_ino_pop+6Bp
					; print_dir+20Bp ...
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: dired_dump_obstack+10Bp
					; main+4FDp ...
; char *nl_langinfo(nl_item item)
		extrn nl_langinfo:near	; CODE XREF: abmon_init+58p
		extrn mbsalign:near	; CODE XREF: abmon_init+74p
		extrn __stack_chk_fail:near ; CODE XREF: abmon_init+DEp
					; process_signals+EDp ...
		extrn __umoddi3:near	; CODE XREF: dev_ino_hash+21p
; void free(void *ptr)
		extrn free:near		; CODE XREF: dev_ino_free+Cp
					; visit_dir+85p ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: visit_dir+23p
					; decode_switches+7A1p	...
		extrn hash_insert:near	; CODE XREF: visit_dir+57p
		extrn xalloc_die:near	; CODE XREF: visit_dir+68p main+2E7p ...
; int fflush_unlocked(FILE *stream)
		extrn fflush_unlocked:near ; CODE XREF:	process_signals+32p
					; main+66Dp
; int sigprocmask(int how, const sigset_t *set,	sigset_t *oset)
		extrn sigprocmask:near	; CODE XREF: process_signals+4Bp
					; process_signals+BEp
; __sighandler_t signal(int sig, __sighandler_t	handler)
		extrn signal:near	; CODE XREF: process_signals+97p
					; main+6B6p
; int raise(int	sig)
		extrn raise:near	; CODE XREF: process_signals+A8p
					; main+6E0p ...
		extrn set_program_name:near ; CODE XREF: main+39p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+60p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+70p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+88o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+8Dp
; __pid_t tcgetpgrp(int	fd)
		extrn tcgetpgrp:near	; CODE XREF: main+14Fp
; int sigemptyset(sigset_t *set)
		extrn sigemptyset:near	; CODE XREF: main+167p
; int sigaction_0(int sig, const struct	sigaction *act,	struct sigaction *oact)
		extrn sigaction_0:near	; CODE XREF: main+195p	main+25Fp
; int sigaddset(sigset_t *set, int signo)
		extrn sigaddset:near	; CODE XREF: main+1BEp
; int sigismember(const	sigset_t *set, int signo)
		extrn sigismember:near	; CODE XREF: main+215p	main+697p
		extrn hash_initialize:near ; CODE XREF:	main+2D1p
; void *malloc(size_t size)
		extrn malloc		; DATA XREF: main+2F4o	main+3B0o ...
; int obstack_begin(struct obstack *, int, int,	void *(*)(__int32), void (*)(void *))
		extrn _obstack_begin:near ; CODE XREF: main+302p main+3BEp ...
		extrn xnmalloc:near	; CODE XREF: main+3FCp	sort_files+3Cp	...
		extrn hash_delete:near	; CODE XREF: main+5A0p
		extrn get_quoting_style:near ; CODE XREF: main+75Bp
					; decode_switches+B31p
		extrn quoting_style_args:dword ; DATA XREF: main+763r
					; decode_switches+149o	...
		extrn hash_get_n_entries:near ;	CODE XREF: main+78Dp
		extrn hash_free:near	; CODE XREF: main+7BBp
; void exit(int	status)
		extrn exit:near		; CODE XREF: main+7CCp
					; decode_switches+AD9p	...
		extrn ls_mode:dword	; DATA XREF: decode_switches+2Ar
					; decode_switches+A88r	...
		extrn set_quoting_style:near ; CODE XREF: decode_switches+51p
					; decode_switches+6Cp ...
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: decode_switches+7Bp
					; decode_switches+3F6p	...
; void abort(void)
		extrn abort:near	; CODE XREF: decode_switches:loc_8001115p
					; get_funky_string:loc_80021B9p ...
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: decode_switches+131p
					; decode_switches+1B2p	...
		extrn quoting_style_vals:dword ; DATA XREF: decode_switches+144o
					; decode_switches+165r	...
		extrn argmatch:near	; CODE XREF: decode_switches+151p
		extrn quotearg:near	; CODE XREF: decode_switches+182p
					; decode_switches+265p	...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: decode_switches+1A2p
					; decode_switches+285p	...
		extrn human_options:near ; CODE	XREF: decode_switches+1CDp
					; decode_switches+9EDp
		extrn xstrtoul:near	; CODE XREF: decode_switches+242p
					; decode_switches+2F0p	...
; int ioctl(int	fd, unsigned __int32 request, ...)
		extrn ioctl:near	; CODE XREF: decode_switches+29Bp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: decode_switches+352p
; char *optarg
		extrn optarg:dword	; DATA XREF: decode_switches:loc_80015E3r
					; decode_switches:loc_8001609r	...
		extrn argmatch_die:dword ; DATA	XREF: decode_switches:loc_8001838r
					; decode_switches:loc_8001882r	...
		extrn __xargmatch_internal:near	; CODE XREF: decode_switches+7F1p
					; decode_switches+83Bp	...
		extrn xstrtol_fatal:near ; CODE	XREF: decode_switches+A16p
		extrn Version:dword	; DATA XREF: decode_switches:loc_8001AEAr
		extrn version_etc:near	; CODE XREF: decode_switches+ACCp
		extrn clone_quoting_options:near ; CODE	XREF: decode_switches+B1Bp
					; decode_switches+B9Fp
		extrn set_char_quoting:near ; CODE XREF: decode_switches+B4Bp
					; decode_switches+B84p	...
		extrn hard_locale:near	; CODE XREF: decode_switches+C5Ap
					; decode_switches+DBFp
; int optind
		extrn optind:dword	; DATA XREF: decode_switches+C69r
					; decode_switches:loc_8001EDCr
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: decode_switches+CAFp
					; decode_switches+CD4p
		extrn quote:near	; CODE XREF: decode_switches+CE6p
; char *dcgettext(const	char *domainname, const	char *msgid, int category)
		extrn dcgettext:near	; CODE XREF: decode_switches+DE6p
; char *strstr(const char *haystack, const char	*needle)
		extrn strstr:near	; CODE XREF: decode_switches+E25p
					; decode_switches+E3Fp	...
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: parse_ls_color+56p
					; queue_directory+28p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: parse_ls_color+1BDp
					; gobble_file+561p
					; DATA XREF: ...
		extrn quotearg_colon:near ; CODE XREF: file_failure+13p
					; print_dir+17Cp ...
; DIR *opendir(const char *name)
		extrn opendir:near	; CODE XREF: print_dir+58p
; int dirfd(DIR	*dirp)
		extrn dirfd:near	; CODE XREF: print_dir+B6p
		extrn fstat64:near	; CODE XREF: print_dir+DDp
		extrn stat64:near	; CODE XREF: print_dir+FAp
					; gobble_file+321p ...
; int closedir(DIR *dirp)
		extrn closedir:near	; CODE XREF: print_dir+13Ep
					; print_dir+1ADp ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	print_dir+2CDp
					; print_dir+455p ...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: print_dir+353p
					; print_dir+424p ...
		extrn readdir64:near	; CODE XREF: print_dir+483p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: print_dir+6F8p
					; print_dir+784p ...
		extrn human_readable:near ; CODE XREF: print_dir+756p
					; gobble_file+8A6p ...
; int fnmatch(const char *pattern, const char *name, int flags)
		extrn fnmatch:near	; CODE XREF: patterns_match+1Cp
		extrn xnrealloc:near	; CODE XREF: gobble_file+ACp
					; init_column_info+41p	...
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: gobble_file+EBp
					; print_long_format+73p
		extrn lstat64:near	; CODE XREF: gobble_file+3CBp
		extrn file_has_acl:near	; CODE XREF: gobble_file+5D6p
		extrn gnu_mbswidth:near	; CODE XREF: gobble_file+8B4p
					; gobble_file+BB2p ...
		extrn umaxtostr:near	; CODE XREF: gobble_file+A06p
					; gobble_file+A90p ...
; unsigned int gnu_dev_major(unsigned __int64 dev)
		extrn gnu_dev_major:near ; CODE	XREF: gobble_file+A77p
					; print_long_format+557p
; unsigned int gnu_dev_minor(unsigned __int64 dev)
		extrn gnu_dev_minor:near ; CODE	XREF: gobble_file+AD3p
					; print_long_format+51Dp
		extrn areadlink_with_size:near ; CODE XREF: get_link_name+1Cp
; char *strrchr(const char *s, int c)
		extrn strrchr:near	; CODE XREF: make_link_name+3Bp
					; cmp_extension+11p ...
; char *strncpy(char *dest, const char *src, size_t n)
		extrn strncpy:near	; CODE XREF: make_link_name+9Fp
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: make_link_name+B6p
					; align_nstrftime+110p
		extrn file_name_concat:near ; CODE XREF: extract_dirs_from_files+D2p
; int strcoll(const char *s1, const char *s2)
		extrn strcoll:near	; CODE XREF: xstrcoll+1Dp
		extrn quote_n:near	; CODE XREF: xstrcoll+3Bp xstrcoll+4Dp
; void longjmp(struct __jmp_buf_tag *env, int val)
		extrn longjmp:near	; CODE XREF: xstrcoll+98p
		extrn filevercmp:near	; CODE XREF: cmp_version+15p
; int setjmp(jmp_buf env)
		extrn _setjmp:near	; CODE XREF: sort_files+75p
		extrn mpsort:near	; CODE XREF: sort_files+10Ep
		extrn mempcpy:near	; CODE XREF: align_nstrftime+C3p
		extrn stpcpy:near	; CODE XREF: align_nstrftime+EFp
		extrn nstrftime:near	; CODE XREF: align_nstrftime+136p
; struct tm *localtime(const time_t *timer)
		extrn localtime:near	; CODE XREF: long_time_expected_width+35p
					; print_long_format+6AEp
		extrn mbsnwidth:near	; CODE XREF: long_time_expected_width+94p
					; quote_name+3D4p
		extrn getuser:near	; CODE XREF: format_user+36p
					; format_user_width+1Ep
		extrn getgroup:near	; CODE XREF: format_group+36p
					; format_group_width+1Ep
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: format_user_or_group_width+4Ep
					; print_long_format+1CAp ...
		extrn filemodestring:near ; CODE XREF: print_long_format+42p
		extrn gettime:near	; CODE XREF: print_long_format+71Ap
		extrn quotearg_buffer:near ; CODE XREF:	quote_name+56p
					; quote_name+D7p
; size_t _ctype_get_mb_cur_max(void)
		extrn __ctype_get_mb_cur_max:near ; CODE XREF: quote_name+EEp
					; quote_name+3B9p
; size_t mbrtowc(wchar_t *pwc, const char *s, size_t n,	mbstate_t *p)
		extrn mbrtowc:near	; CODE XREF: quote_name+1D3p
		extrn wcwidth:near	; CODE XREF: quote_name+25Fp
; int mbsinit(const mbstate_t *ps)
		extrn mbsinit:near	; CODE XREF: quote_name+2E8p
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: quote_name:loc_800651Fp
					; quote_name:loc_80065E7p
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p


		end
