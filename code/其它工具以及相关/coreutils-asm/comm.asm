;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B5877684FD5A39F82132C69EFD589ECF
; Input	CRC32 :	0B071835

; File Name   :	D:\coreutils-o\comm.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'comm.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+1A0p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1E9p	main+22Bp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_8000157
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002C1
; ---------------------------------------------------------------------------

loc_8000157:				; CODE XREF: usage+9j
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	FILE1 FILE2\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCompareSortedF ; "Compare sorted files FILE1 and FILE2 li"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithNoOptionsP ; "\nWith no options, produce three-column"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset a1SuppressColum ; "\n  -1	      suppress column 1	("...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCheckOrderChec ; "\n  --check-order	check that the in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOutputDelimite ; "  --output-delimiter=STR  separate colu"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoteComparison ; "\nNote, comparisons honor the	rules spe"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aExamplesS12Fil ; "\nExamples:\n	 %s -12	file1 file2  Prin"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_80002C1:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl writeline(const linebuffer *line, FILE *stream, int class)
writeline	proc near		; CODE XREF: compare_files+3C8p
					; compare_files+3F5p ...

line		= dword	ptr  8
stream		= dword	ptr  0Ch
class		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+class]
		cmp	eax, 2
		jz	short loc_80002FF
		cmp	eax, 3
		jz	short loc_8000332
		cmp	eax, 1
		jnz	loc_8000387
		movzx	eax, ds:only_file_1
		xor	eax, 1
		test	al, al
		jz	loc_8000380
		jmp	locret_80003A8
; ---------------------------------------------------------------------------

loc_80002FF:				; CODE XREF: writeline+Cj
		movzx	eax, ds:only_file_2
		xor	eax, 1
		test	al, al
		jnz	loc_80003A4
		movzx	eax, ds:only_file_1
		test	al, al
		jz	short loc_8000383
		mov	eax, ds:delimiter
		sub	esp, 8
		push	[ebp+stream]
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		jmp	short loc_8000383
; ---------------------------------------------------------------------------

loc_8000332:				; CODE XREF: writeline+11j
		movzx	eax, ds:both
		xor	eax, 1
		test	al, al
		jnz	short loc_80003A7
		movzx	eax, ds:only_file_1
		test	al, al
		jz	short loc_800035F
		mov	eax, ds:delimiter
		sub	esp, 8
		push	[ebp+stream]
		push	eax
		call	fputs_unlocked
		add	esp, 10h

loc_800035F:				; CODE XREF: writeline+7Dj
		movzx	eax, ds:only_file_2
		test	al, al
		jz	short loc_8000386
		mov	eax, ds:delimiter
		sub	esp, 8
		push	[ebp+stream]
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		jmp	short loc_8000386
; ---------------------------------------------------------------------------

loc_8000380:				; CODE XREF: writeline+28j
		nop
		jmp	short loc_8000387
; ---------------------------------------------------------------------------

loc_8000383:				; CODE XREF: writeline+4Ej
					; writeline+64j
		nop
		jmp	short loc_8000387
; ---------------------------------------------------------------------------

loc_8000386:				; CODE XREF: writeline+9Cj
					; writeline+B2j
		nop

loc_8000387:				; CODE XREF: writeline+16j
					; writeline+B5j ...
		mov	eax, [ebp+line]
		mov	edx, [eax+4]
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		push	[ebp+stream]	; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short locret_80003A8
; ---------------------------------------------------------------------------

loc_80003A4:				; CODE XREF: writeline+3Fj
		nop
		jmp	short locret_80003A8
; ---------------------------------------------------------------------------

loc_80003A7:				; CODE XREF: writeline+72j
		nop

locret_80003A8:				; CODE XREF: writeline+2Ej
					; writeline+D6j ...
		leave
		retn
writeline	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_order(const linebuffer *prev, const linebuffer *current, int whatfile)
check_order	proc near		; CODE XREF: compare_files+5BCp
					; compare_files+666p

order		= dword	ptr -0Ch
var_4		= dword	ptr -4
prev		= dword	ptr  8
current		= dword	ptr  0Ch
whatfile	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:check_input_order
		cmp	eax, 2
		jz	loc_8000499
		mov	eax, ds:check_input_order
		cmp	eax, 1
		jz	short loc_80003D8
		movzx	eax, ds:seen_unpairable
		test	al, al
		jz	loc_8000499

loc_80003D8:				; CODE XREF: check_order+1Dj
		mov	eax, [ebp+whatfile]
		sub	eax, 1
		movzx	eax, ds:issued_disorder_warning[eax]
		xor	eax, 1
		test	al, al
		jz	loc_8000499
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	short loc_800042A
		mov	eax, [ebp+current]
		mov	eax, [eax+4]
		lea	ebx, [eax-1]
		mov	eax, [ebp+current]
		mov	edx, [eax+8]
		mov	eax, [ebp+prev]
		mov	eax, [eax+4]
		lea	ecx, [eax-1]
		mov	eax, [ebp+prev]
		mov	eax, [eax+8]
		push	ebx
		push	edx
		push	ecx
		push	eax
		call	xmemcoll
		add	esp, 10h
		mov	[ebp+order], eax
		jmp	short loc_8000457
; ---------------------------------------------------------------------------

loc_800042A:				; CODE XREF: check_order+4Fj
		mov	eax, [ebp+current]
		mov	eax, [eax+4]
		lea	ebx, [eax-1]
		mov	eax, [ebp+current]
		mov	edx, [eax+8]
		mov	eax, [ebp+prev]
		mov	eax, [eax+4]
		lea	ecx, [eax-1]
		mov	eax, [ebp+prev]
		mov	eax, [eax+8]
		push	ebx
		push	edx
		push	ecx
		push	eax
		call	memcmp2
		add	esp, 10h
		mov	[ebp+order], eax

loc_8000457:				; CODE XREF: check_order+7Ej
		cmp	[ebp+order], 0
		jle	short loc_8000499
		sub	esp, 0Ch
		push	offset aFileDIsNotInSo ; "file %d is not in sorted order"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:check_input_order
		cmp	eax, 1
		setz	al
		movzx	eax, al
		push	[ebp+whatfile]
		push	edx		; format
		push	0		; errnum
		push	eax		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+whatfile]
		sub	eax, 1
		mov	ds:issued_disorder_warning[eax], 1

loc_8000499:				; CODE XREF: check_order+Fj
					; check_order+28j ...
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
check_order	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl compare_files(char **infiles)
compare_files	proc near		; CODE XREF: main+363p

infiles		= dword	ptr -0CCh
i		= dword	ptr -0C8h
j		= dword	ptr -0C4h
order		= dword	ptr -0C0h
len		= dword	ptr -0BCh
fill_up		= byte ptr -0B6h
thisline	= dword	ptr -0B4h
streams		= dword	ptr -0ACh
alt		= dword	ptr -0A4h
all_line	= dword	ptr -8Ch
lba		= linebuffer ptr -6Ch
var_C		= dword	ptr -0Ch
var_8		= byte ptr -8
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0D4h
		mov	eax, [ebp+arg_0]
		mov	[ebp+infiles], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+i], 0
		jmp	loc_800071C
; ---------------------------------------------------------------------------

loc_80004CC:				; CODE XREF: compare_files+284j
		mov	[ebp+j], 0
		jmp	loc_8000561
; ---------------------------------------------------------------------------

loc_80004DB:				; CODE XREF: compare_files+C9j
		lea	ebx, [ebp+lba]
		mov	eax, [ebp+j]
		mov	edx, eax
		add	edx, edx
		add	edx, eax
		lea	eax, ds:0[edx*4]
		mov	edx, eax
		mov	ecx, [ebp+i]
		mov	eax, ecx
		add	eax, eax
		add	eax, ecx
		shl	eax, 4
		add	eax, edx
		add	eax, ebx
		sub	esp, 0Ch
		push	eax
		call	initbuffer
		add	esp, 10h
		lea	ebx, [ebp+lba]
		mov	eax, [ebp+j]
		mov	edx, eax
		add	edx, edx
		add	edx, eax
		lea	eax, ds:0[edx*4]
		mov	edx, eax
		mov	ecx, [ebp+i]
		mov	eax, ecx
		add	eax, eax
		add	eax, ecx
		shl	eax, 4
		add	eax, edx
		lea	edx, [ebx+eax]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+j]
		add	eax, ecx
		mov	[ebp+eax*4+all_line], edx
		add	[ebp+j], 1

loc_8000561:				; CODE XREF: compare_files+37j
		cmp	[ebp+j], 3
		jle	loc_80004DB
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 9Ch
		mov	dword ptr [eax], 0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 98h
		mov	dword ptr [eax], 0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 94h
		mov	dword ptr [eax], 0
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_800161F ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000621
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset aR	; "r"
		push	eax
		call	fopen_safer
		add	esp, 10h
		jmp	short loc_8000626
; ---------------------------------------------------------------------------

loc_8000621:				; CODE XREF: compare_files+156j
		mov	eax, ds:stdin

loc_8000626:				; CODE XREF: compare_files+180j
		mov	edx, [ebp+i]
		mov	[ebp+edx*4+streams], eax
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+streams]
		test	eax, eax
		jnz	short loc_8000673
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000673:				; CODE XREF: compare_files+1A3j
		mov	eax, [ebp+i]
		mov	ecx, [ebp+eax*4+streams]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 9Ch
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [ebp+eax*4+all_line]
		sub	esp, 8
		push	ecx
		push	eax
		call	readlinebuffer
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i]
		mov	[ebp+eax*4+thisline], edx
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+streams]
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000715
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000715:				; CODE XREF: compare_files+245j
		add	[ebp+i], 1

loc_800071C:				; CODE XREF: compare_files+28j
		cmp	[ebp+i], 1
		jle	loc_80004CC
		jmp	loc_8000B7E
; ---------------------------------------------------------------------------

loc_800072E:				; CODE XREF: compare_files+6E7j
					; compare_files+6F5j
		mov	[ebp+fill_up], 0
		mov	[ebp+fill_up+1], 0
		mov	eax, [ebp+thisline]
		test	eax, eax
		jnz	short loc_8000755
		mov	[ebp+order], 1
		jmp	loc_800084B
; ---------------------------------------------------------------------------

loc_8000755:				; CODE XREF: compare_files+2A5j
		mov	eax, [ebp+thisline+4]
		test	eax, eax
		jnz	short loc_800076E
		mov	[ebp+order], 0FFFFFFFFh
		jmp	loc_800084B
; ---------------------------------------------------------------------------

loc_800076E:				; CODE XREF: compare_files+2BEj
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	short loc_80007BA
		mov	eax, [ebp+thisline+4]
		mov	eax, [eax+4]
		lea	ebx, [eax-1]
		mov	eax, [ebp+thisline+4]
		mov	edx, [eax+8]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+4]
		lea	ecx, [eax-1]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+8]
		push	ebx
		push	edx
		push	ecx
		push	eax
		call	xmemcoll
		add	esp, 10h
		mov	[ebp+order], eax
		jmp	loc_800084B
; ---------------------------------------------------------------------------

loc_80007BA:				; CODE XREF: compare_files+2D8j
		mov	eax, [ebp+thisline+4]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+4]
		cmp	edx, eax
		cmovbe	eax, edx
		sub	eax, 1
		mov	[ebp+len], eax
		mov	eax, [ebp+thisline+4]
		mov	edx, [eax+8]
		mov	eax, [ebp+thisline]
		mov	eax, [eax+8]
		sub	esp, 4
		push	[ebp+len]	; n
		push	edx		; s2
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		mov	[ebp+order], eax
		cmp	[ebp+order], 0
		jnz	short loc_800084B
		mov	eax, [ebp+thisline]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline+4]
		mov	eax, [eax+4]
		cmp	edx, eax
		jb	short loc_8000840
		mov	eax, [ebp+thisline]
		mov	edx, [eax+4]
		mov	eax, [ebp+thisline+4]
		mov	eax, [eax+4]
		cmp	edx, eax
		setnz	al
		movzx	eax, al
		jmp	short loc_8000845
; ---------------------------------------------------------------------------

loc_8000840:				; CODE XREF: compare_files+383j
		mov	eax, 0FFFFFFFFh

loc_8000845:				; CODE XREF: compare_files+39Fj
		mov	[ebp+order], eax

loc_800084B:				; CODE XREF: compare_files+2B1j
					; compare_files+2CAj ...
		cmp	[ebp+order], 0
		jnz	short loc_8000871
		mov	edx, ds:stdout
		mov	eax, [ebp+thisline+4]
		sub	esp, 4
		push	3		; class
		push	edx		; stream
		push	eax		; line
		call	writeline
		add	esp, 10h
		jmp	short loc_80008B9
; ---------------------------------------------------------------------------

loc_8000871:				; CODE XREF: compare_files+3B3j
		mov	ds:seen_unpairable, 1
		cmp	[ebp+order], 0
		jg	short loc_800089E
		mov	edx, ds:stdout
		mov	eax, [ebp+thisline]
		sub	esp, 4
		push	1		; class
		push	edx		; stream
		push	eax		; line
		call	writeline
		add	esp, 10h
		jmp	short loc_80008B9
; ---------------------------------------------------------------------------

loc_800089E:				; CODE XREF: compare_files+3E0j
		mov	edx, ds:stdout
		mov	eax, [ebp+thisline+4]
		sub	esp, 4
		push	2		; class
		push	edx		; stream
		push	eax		; line
		call	writeline
		add	esp, 10h

loc_80008B9:				; CODE XREF: compare_files+3D0j
					; compare_files+3FDj
		cmp	[ebp+order], 0
		js	short loc_80008C9
		mov	[ebp+fill_up+1], 1

loc_80008C9:				; CODE XREF: compare_files+421j
		cmp	[ebp+order], 0
		jg	short loc_80008D9
		mov	[ebp+fill_up], 1

loc_80008D9:				; CODE XREF: compare_files+431j
		mov	[ebp+i], 0
		jmp	loc_8000B71
; ---------------------------------------------------------------------------

loc_80008E8:				; CODE XREF: compare_files+6D9j
		lea	edx, [ebp+fill_up]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	loc_8000B6A
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ecx, [ebp+var_8]
		add	eax, ecx
		sub	eax, 98h
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 94h
		mov	[eax], ecx
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ecx, [ebp+var_8]
		add	eax, ecx
		sub	eax, 9Ch
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 98h
		mov	[eax], ecx
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ecx, [ebp+var_8]
		add	eax, ecx
		sub	eax, 9Ch
		mov	eax, [eax]
		add	eax, 1
		and	eax, 3
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 9Ch
		mov	[eax], ecx
		mov	eax, [ebp+i]
		mov	ecx, [ebp+eax*4+streams]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ebx, [ebp+var_8]
		add	eax, ebx
		sub	eax, 9Ch
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [ebp+eax*4+all_line]
		sub	esp, 8
		push	ecx
		push	eax
		call	readlinebuffer
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i]
		mov	[ebp+eax*4+thisline], edx
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+thisline]
		test	eax, eax
		jz	short loc_8000A68
		mov	eax, [ebp+i]
		lea	ebx, [eax+1]
		mov	eax, [ebp+i]
		mov	ecx, [ebp+eax*4+thisline]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, [ebp+var_8]
		add	eax, edx
		sub	eax, 98h
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [ebp+eax*4+all_line]
		sub	esp, 4
		push	ebx		; whatfile
		push	ecx		; current
		push	eax		; prev
		call	check_order
		add	esp, 10h
		jmp	loc_8000B0D
; ---------------------------------------------------------------------------

loc_8000A68:				; CODE XREF: compare_files+571j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ecx, [ebp+var_8]
		add	eax, ecx
		sub	eax, 94h
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [ebp+eax*4+all_line]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_8000B0D
		mov	eax, [ebp+i]
		lea	ebx, [eax+1]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	ecx, [ebp+var_8]
		add	eax, ecx
		sub	eax, 98h
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	ecx, [ebp+eax*4+all_line]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, [ebp+var_8]
		add	eax, edx
		sub	eax, 94h
		mov	eax, [eax]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [ebp+eax*4+all_line]
		sub	esp, 4
		push	ebx		; whatfile
		push	ecx		; current
		push	eax		; prev
		call	check_order
		add	esp, 10h

loc_8000B0D:				; CODE XREF: compare_files+5C4j
					; compare_files+5FBj
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+streams]
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B59
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B59:				; CODE XREF: compare_files+689j
		lea	edx, [ebp+fill_up]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	byte ptr [eax],	0

loc_8000B6A:				; CODE XREF: compare_files+45Cj
		add	[ebp+i], 1

loc_8000B71:				; CODE XREF: compare_files+444j
		cmp	[ebp+i], 1
		jle	loc_80008E8

loc_8000B7E:				; CODE XREF: compare_files+28Aj
		mov	eax, [ebp+thisline]
		test	eax, eax
		jnz	loc_800072E
		mov	eax, [ebp+thisline+4]
		test	eax, eax
		jnz	loc_800072E
		mov	[ebp+i], 0
		jmp	short loc_8000BF9
; ---------------------------------------------------------------------------

loc_8000BA6:				; CODE XREF: compare_files+761j
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+streams]
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000BF2
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+infiles]
		add	eax, edx
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000BF2:				; CODE XREF: compare_files+722j
		add	[ebp+i], 1

loc_8000BF9:				; CODE XREF: compare_files+705j
		cmp	[ebp+i], 1
		jle	short loc_8000BA6
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8000C14
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000C14:				; CODE XREF: compare_files+76Ej
		mov	ebx, [ebp+var_4]
		leave
		retn
compare_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

c		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 1Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	3
		call	hard_locale
		add	esp, 10h
		mov	ds:hard_LC_COLLATE, al
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:only_file_1,	1
		mov	ds:only_file_2,	1
		mov	ds:both, 1
		mov	ds:seen_unpairable, 0
		mov	ds:issued_disorder_warning+1, 0
		movzx	eax, ds:issued_disorder_warning+1
		mov	ds:issued_disorder_warning, al
		mov	ds:check_input_order, 0
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000CD6:				; CODE XREF: main+253j
		mov	eax, [ebp+c]
		cmp	eax, 32h
		jz	short loc_8000D3A
		cmp	eax, 32h
		jg	short loc_8000D03
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000DFD
		cmp	eax, 31h
		jz	short loc_8000D2E
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000E07
		jmp	loc_8000E3F
; ---------------------------------------------------------------------------

loc_8000D03:				; CODE XREF: main+C8j
		cmp	eax, 80h
		jz	short loc_8000D61
		cmp	eax, 80h
		jg	short loc_8000D1B
		cmp	eax, 33h
		jz	short loc_8000D46
		jmp	loc_8000E3F
; ---------------------------------------------------------------------------

loc_8000D1B:				; CODE XREF: main+F6j
		cmp	eax, 81h
		jz	short loc_8000D52
		cmp	eax, 82h
		jz	short loc_8000D70
		jmp	loc_8000E3F
; ---------------------------------------------------------------------------

loc_8000D2E:				; CODE XREF: main+D8j
		mov	ds:only_file_1,	0
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000D3A:				; CODE XREF: main+C3j
		mov	ds:only_file_2,	0
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000D46:				; CODE XREF: main+FBj
		mov	ds:both, 0
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000D52:				; CODE XREF: main+107j
		mov	ds:check_input_order, 2
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000D61:				; CODE XREF: main+EFj
		mov	ds:check_input_order, 1
		jmp	loc_8000E49
; ---------------------------------------------------------------------------

loc_8000D70:				; CODE XREF: main+10Ej
		mov	eax, ds:delimiter
		test	eax, eax
		jz	short loc_8000DB5
		mov	edx, ds:optarg
		mov	eax, ds:delimiter
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000DB5
		sub	esp, 0Ch
		push	offset aMultipleDelimi ; "multiple delimiters specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000DB5:				; CODE XREF: main+15Ej	main+17Aj
		mov	eax, ds:optarg
		mov	ds:delimiter, eax
		mov	eax, ds:delimiter
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000E49
		sub	esp, 0Ch
		push	offset aOutputDelimi_0 ; "--output-delimiter"
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aEmptySNotAllow ; "empty	%s not allowed"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000E49
; ---------------------------------------------------------------------------

loc_8000DFD:				; CODE XREF: main+CFj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E07:				; CODE XREF: main+DFj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aRichardM_Stall ; "Richard M. Stallman"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aComm	; "comm"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000E3F:				; CODE XREF: main+E5j main+FDj ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E49:				; CODE XREF: main+B8j main+11Cj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "123"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8000CD6
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 1
		jg	short loc_8000EF8
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_8000EAD
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000EEE
; ---------------------------------------------------------------------------

loc_8000EAD:				; CODE XREF: main+270j
		mov	eax, [ebx]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingOpera_0 ; "missing operand after	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000EEE:				; CODE XREF: main+292j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000EF8:				; CODE XREF: main+267j
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 2
		jle	short loc_8000F54
		mov	eax, ds:optind
		add	eax, 2
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F54:				; CODE XREF: main+2EDj
		mov	eax, ds:delimiter
		test	eax, eax
		jnz	short loc_8000F67
		mov	ds:delimiter, offset asc_80016EC ; "\t"

loc_8000F67:				; CODE XREF: main+342j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; infiles
		call	compare_files
		add	esp, 10h
		movzx	eax, ds:issued_disorder_warning
		test	al, al
		jnz	short loc_8000F9A
		movzx	eax, ds:issued_disorder_warning+1
		test	al, al
		jz	short loc_8000FA4

loc_8000F9A:				; CODE XREF: main+374j
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000FA4:				; CODE XREF: main+37Fj
		sub	esp, 0Ch
		push	0		; status

loc_8000FA9:				; DATA XREF: .eh_frame:08001710o
					; .eh_frame:08001734o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8000FB0h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	hard_LC_COLLATE
hard_LC_COLLATE	db ?			; DATA XREF: check_order+46r
					; compare_files:loc_800076Er ...
; _Bool	only_file_1
only_file_1	db ?			; DATA XREF: writeline+1Cr
					; writeline+45r ...
; _Bool	only_file_2
only_file_2	db ?			; DATA XREF: writeline:loc_80002FFr
					; writeline:loc_800035Fr ...
; _Bool	both
both		db ?			; DATA XREF: writeline:loc_8000332r
					; main+8Dw ...
; _Bool	seen_unpairable
seen_unpairable	db ?			; DATA XREF: check_order+1Fr
					; compare_files:loc_8000871w ...
; _Bool	issued_disorder_warning[2]
issued_disorder_warning	db 2 dup(?)	; DATA XREF: check_order+34r
					; check_order+E8w ...
		align 4
; $777E6CB8FEE56A4B24BB97DACA1BB4F3 check_input_order
check_input_order dd ?			; DATA XREF: check_order+7r
					; check_order+15r ...
; const	char *delimiter
delimiter	dd ?			; DATA XREF: writeline+50r
					; writeline+7Fr ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000FC0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+40o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+209o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aCheckOrder	db 'check-order',0      ; DATA XREF: .rodata:long_optionso
aNocheckOrder	db 'nocheck-order',0    ; DATA XREF: .rodata:long_optionso
aOutputDelimi_1	db 'output-delimiter',0 ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[6]
long_options	option <offset aCheckOrder, 0, 0, 80h> ; DATA XREF: main+235o
		option <offset aNocheckOrder, 0, 0, 81h> ; "check-order"
		option <offset aOutputDelimi_1,	1, 0, 82h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... FILE1 FILE2',0Ah,0 ; DATA XREF: usage+44o
		align 4
; char aCompareSortedF[]
aCompareSortedF	db 'Compare sorted files FILE1 and FILE2 line by line.',0Ah,0
					; DATA XREF: usage+67o
; char aWithNoOptionsP[]
aWithNoOptionsP	db 0Ah			; DATA XREF: usage+8Ao
		db 'With no options, produce three-column output.  Column one contain'
		db 's',0Ah
		db 'lines unique to FILE1, column two contains lines unique to FILE2,'
		db 0Ah
		db 'and column three contains lines common to both files.',0Ah,0
		align 10h
; char a1SuppressColum[]
a1SuppressColum	db 0Ah			; DATA XREF: usage+ADo
		db '  -1              suppress column 1 (lines unique to FILE1)',0Ah
		db '  -2              suppress column 2 (lines unique to FILE2)',0Ah
		db '  -3              suppress column 3 (lines that appear in both fi'
		db 'les)',0Ah,0
; char aCheckOrderChec[]
aCheckOrderChec	db 0Ah			; DATA XREF: usage+D0o
		db '  --check-order     check that the input is correctly sorted, eve'
		db 'n',0Ah
		db '                      if all input lines are pairable',0Ah
		db '  --nocheck-order   do not check that the input is correctly sort'
		db 'ed',0Ah,0
		align 10h
; char aOutputDelimite[]
aOutputDelimite	db '  --output-delimiter=STR  separate columns with STR',0Ah,0
					; DATA XREF: usage+F3o
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+116o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+139o
		align 10h
; char aNoteComparison[]
aNoteComparison	db 0Ah			; DATA XREF: usage+15Co
		db 'Note, comparisons honor the rules specified by `LC_COLLATE',27h,'.',0Ah
		db 0
		align 10h
; char aExamplesS12Fil[]
aExamplesS12Fil	db 0Ah			; DATA XREF: usage+185o
		db 'Examples:',0Ah
		db '  %s -12 file1 file2  Print only lines present in both file1 and '
		db 'file2.',0Ah
		db '  %s -3  file1 file2  Print lines in file1 not in file2, and vice'
		db ' versa.',0Ah,0
		align 10h
; char aFileDIsNotInSo[]
aFileDIsNotInSo	db 'file %d is not in sorted order',0 ; DATA XREF: check_order+B6o
; char asc_800161F[]
asc_800161F	db '-',0                ; DATA XREF: compare_files+146o
aR		db 'r',0                ; DATA XREF: compare_files+172o
; char format[]
format		db '%s',0               ; DATA XREF: compare_files+1C4o
					; compare_files+266o ...
; char locale
locale		db 0			; DATA XREF: main+29o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Bo
; char aMultipleDelimi[]
aMultipleDelimi	db 'multiple delimiters specified',0 ; DATA XREF: main+17Fo
aOutputDelimi_0	db '--output-delimiter',0 ; DATA XREF: main+1B5o
; char aEmptySNotAllow[]
aEmptySNotAllow	db 'empty %s not allowed',0 ; DATA XREF: main+1C7o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+1FEo
aRichardM_Stall	db 'Richard M. Stallman',0 ; DATA XREF: main+203o
aComm		db 'comm',0             ; DATA XREF: main+20Eo
; char shortopts[]
shortopts	db '123',0              ; DATA XREF: main+23Ao
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+275o
; char aMissingOpera_0[]
aMissingOpera_0	db 'missing operand after %s',0 ; DATA XREF: main+2BAo
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+316o
asc_80016EC	db 9,0			; DATA XREF: main+344o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80016F0h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8000FA9-80026B9h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset loc_8000FA9-80025C1h
		dd 1B0h, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 60h
		dd offset loc_8000FA9-8002431h
		dd 0DEh, 80E4100h, 0D420285h, 0C5DA0205h, 4040Ch, 20h
		dd 80h
		dd offset loc_8000FA9-8002373h
		dd 0F5h, 80E4100h, 0D420285h, 3834405h,	0C3C5ED02h, 4040Ch
		dd 20h,	0A4h
		dd offset loc_8000FA9-80022A2h
		dd 77Ah, 80E4100h, 0D420285h, 3834705h,	0C5076F03h, 4040CC3h
		dd 28h,	0C8h
		dd offset loc_8000FA9-8001B4Ch
		dd 395h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+5Er ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+79p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+30p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1ABp main+221p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	writeline+CEp
		extrn xmemcoll:near	; CODE XREF: check_order+73p
					; compare_files+308p
		extrn memcmp2:near	; CODE XREF: check_order+A2p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: check_order+DAp
					; compare_files+1CCp ...
		extrn initbuffer:near	; CODE XREF: compare_files+6Bp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: compare_files+14Cp
					; main+170p
		extrn fopen_safer:near	; CODE XREF: compare_files+178p
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: compare_files:loc_8000621r
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: compare_files+1BCp
					; compare_files+25Ep ...
		extrn readlinebuffer:near ; CODE XREF: compare_files+213p
					; compare_files+54Bp
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	compare_files+23Bp
					; compare_files+67Fp
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: compare_files+358p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: compare_files+718p
		extrn __stack_chk_fail:near ; CODE XREF: compare_files+770p
		extrn set_program_name:near ; CODE XREF: main+1Ep
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+45p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+55p
		extrn hard_locale:near	; CODE XREF: main+62p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+72o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+77p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+160r
					; main:loc_8000DB5r
		extrn quote:near	; CODE XREF: main+1BAp	main+2ADp ...
		extrn Version:dword	; DATA XREF: main:loc_8000E07r
		extrn version_etc:near	; CODE XREF: main+214p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+244p
; int optind
		extrn optind:dword	; DATA XREF: main+259r	main+269r ...


		end
