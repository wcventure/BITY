;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	D772FC461ABA93F247E3FFFB2380B0D0
; Input	CRC32 :	ABD0FE4B

; File Name   :	D:\coreutils-o\unexpand.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'unexpand.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: parse_tab_stops+43p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+10Fp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+FFp main+15Dp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000242
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aConvertBlanksI ; "Convert blanks in each FILE to tabs, wr"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAAllConvertAll ; "  -a,	--all	     convert all blanks, "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000242:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_tab_stop(uintmax_t tabval)
add_tab_stop	proc near		; CODE XREF: parse_tab_stops+70p
					; parse_tab_stops+248p	...

tabval		= qword	ptr -20h
prev_column	= qword	ptr -18h
column_width	= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+tabval],	eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+tabval+4], eax
		mov	eax, ds:first_free_tab
		test	eax, eax
		jz	short loc_8000285
		mov	eax, ds:tab_list
		mov	edx, ds:first_free_tab
		add	edx, 1FFFFFFFh
		shl	edx, 3
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		jmp	short loc_800028F
; ---------------------------------------------------------------------------

loc_8000285:				; CODE XREF: add_tab_stop+19j
		mov	eax, 0
		mov	edx, 0

loc_800028F:				; CODE XREF: add_tab_stop+36j
		mov	dword ptr [ebp+prev_column], eax
		mov	dword ptr [ebp+prev_column+4], edx
		mov	eax, dword ptr [ebp+prev_column]
		mov	edx, dword ptr [ebp+prev_column+4]
		cmp	edx, dword ptr [ebp+tabval+4]
		ja	short loc_80002B8
		cmp	edx, dword ptr [ebp+tabval+4]
		jb	short loc_80002AA
		cmp	eax, dword ptr [ebp+tabval]
		ja	short loc_80002B8

loc_80002AA:				; CODE XREF: add_tab_stop+56j
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		sub	eax, dword ptr [ebp+prev_column]
		sbb	edx, dword ptr [ebp+prev_column+4]
		jmp	short loc_80002C2
; ---------------------------------------------------------------------------

loc_80002B8:				; CODE XREF: add_tab_stop+51j
					; add_tab_stop+5Bj
		mov	eax, 0
		mov	edx, 0

loc_80002C2:				; CODE XREF: add_tab_stop+69j
		mov	dword ptr [ebp+column_width], eax
		mov	dword ptr [ebp+column_width+4],	edx
		mov	edx, ds:first_free_tab
		mov	eax, ds:n_tabs_allocated
		cmp	edx, eax
		jnz	short loc_80002F4
		mov	eax, ds:tab_list
		sub	esp, 4
		push	8
		push	offset n_tabs_allocated
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	ds:tab_list, eax

loc_80002F4:				; CODE XREF: add_tab_stop+88j
		mov	ecx, ds:tab_list
		mov	eax, ds:first_free_tab
		lea	edx, [eax+1]
		mov	ds:first_free_tab, edx
		shl	eax, 3
		add	ecx, eax
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, ds:max_column_width
		mov	edx, 0
		cmp	edx, dword ptr [ebp+column_width+4]
		ja	short loc_800035F
		cmp	edx, dword ptr [ebp+column_width+4]
		jb	short loc_8000331
		cmp	eax, dword ptr [ebp+column_width]
		jnb	short loc_800035F

loc_8000331:				; CODE XREF: add_tab_stop+DDj
		cmp	dword ptr [ebp+column_width+4],	0
		jbe	short loc_8000357
		sub	esp, 0Ch
		push	offset aTabsAreTooFarA ; "tabs are too far apart"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000357:				; CODE XREF: add_tab_stop+E8j
		mov	eax, dword ptr [ebp+column_width]
		mov	ds:max_column_width, eax

loc_800035F:				; CODE XREF: add_tab_stop+D8j
					; add_tab_stop+E2j
		nop
		leave
		retn
add_tab_stop	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl parse_tab_stops(const char *stops)
parse_tab_stops	proc near		; CODE XREF: main+120p

stops		= dword	ptr -2Ch
have_tabval	= byte ptr -26h
ok		= byte ptr -25h
num_start	= dword	ptr -24h
len		= dword	ptr -20h
bad_num		= dword	ptr -1Ch
tabval		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	[ebp+stops], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+have_tabval], 0
		mov	[ebp+ok], 1
		jmp	loc_8000576
; ---------------------------------------------------------------------------

loc_8000387:				; CODE XREF: parse_tab_stops+21Cj
		mov	eax, [ebp+stops]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ch
		jz	short loc_80003C1
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+stops]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jz	short loc_80003E3

loc_80003C1:				; CODE XREF: parse_tab_stops+2Dj
		cmp	[ebp+have_tabval], 0
		jz	short loc_80003DA
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		sub	esp, 8
		push	edx
		push	eax		; tabval
		call	add_tab_stop
		add	esp, 10h

loc_80003DA:				; CODE XREF: parse_tab_stops+63j
		mov	[ebp+have_tabval], 0
		jmp	loc_8000572
; ---------------------------------------------------------------------------

loc_80003E3:				; CODE XREF: parse_tab_stops+5Dj
		mov	eax, [ebp+stops]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_800053E
		movzx	eax, [ebp+have_tabval]
		xor	eax, 1
		test	al, al
		jz	short loc_800041B
		mov	dword ptr [ebp+tabval],	0
		mov	dword ptr [ebp+tabval+4], 0
		mov	[ebp+have_tabval], 1
		mov	eax, [ebp+stops]
		mov	[ebp+num_start], eax

loc_800041B:				; CODE XREF: parse_tab_stops+9Fj
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		cmp	edx, 19999999h
		ja	loc_80004B7
		cmp	edx, 19999999h
		jb	short loc_800043C
		cmp	eax, 99999999h
		ja	short loc_80004B7

loc_800043C:				; CODE XREF: parse_tab_stops+D1j
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		imul	ebx, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, ebx
		mov	ebx, 0Ah
		mul	ebx
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+stops]
		movzx	ecx, byte ptr [ecx]
		movsx	ecx, cl
		sub	ecx, 30h
		mov	ebx, ecx
		sar	ebx, 1Fh
		add	ecx, eax
		adc	ebx, edx
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		cmp	ebx, edx
		jb	short loc_80004B7
		cmp	ebx, edx
		ja	short loc_800047C
		cmp	ecx, eax
		jb	short loc_80004B7

loc_800047C:				; CODE XREF: parse_tab_stops+114j
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		imul	ebx, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, ebx
		mov	ebx, 0Ah
		mul	ebx
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+stops]
		movzx	ecx, byte ptr [ecx]
		movsx	ecx, cl
		sub	ecx, 30h
		mov	ebx, ecx
		sar	ebx, 1Fh
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+tabval],	eax
		mov	dword ptr [ebp+tabval+4], edx
		mov	eax, 0
		jmp	short loc_80004BC
; ---------------------------------------------------------------------------

loc_80004B7:				; CODE XREF: parse_tab_stops+C5j
					; parse_tab_stops+D8j ...
		mov	eax, 1

loc_80004BC:				; CODE XREF: parse_tab_stops+153j
		test	al, al
		jz	loc_8000572
		sub	esp, 8
		push	offset accept	; "0123456789"
		push	[ebp+num_start]	; s
		call	strspn
		add	esp, 10h
		mov	[ebp+len], eax
		sub	esp, 8
		push	[ebp+len]	; size_t
		push	[ebp+num_start]	; char *
		call	xstrndup
		add	esp, 10h
		mov	[ebp+bad_num], eax
		sub	esp, 0Ch
		push	[ebp+bad_num]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aTabStopIsTooLa ; "tab stop is too large	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+bad_num]	; ptr
		call	free
		add	esp, 10h
		mov	[ebp+ok], 0
		mov	eax, [ebp+len]
		lea	edx, [eax-1]
		mov	eax, [ebp+num_start]
		add	eax, edx
		mov	[ebp+stops], eax
		jmp	short loc_8000572
; ---------------------------------------------------------------------------

loc_800053E:				; CODE XREF: parse_tab_stops+90j
		sub	esp, 0Ch
		push	[ebp+stops]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aTabSizeContain ; "tab size contains invalid character(s):"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	short loc_8000584
; ---------------------------------------------------------------------------

loc_8000572:				; CODE XREF: parse_tab_stops+7Cj
					; parse_tab_stops+15Cj	...
		add	[ebp+stops], 1

loc_8000576:				; CODE XREF: parse_tab_stops+20j
		mov	eax, [ebp+stops]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000387

loc_8000584:				; CODE XREF: parse_tab_stops+20Ej
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8000599
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000599:				; CODE XREF: parse_tab_stops+22Bj
		cmp	[ebp+have_tabval], 0
		jz	short loc_80005B2
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		sub	esp, 8
		push	edx
		push	eax		; tabval
		call	add_tab_stop
		add	esp, 10h

loc_80005B2:				; CODE XREF: parse_tab_stops+23Bj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_80005C4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80005C4:				; CODE XREF: parse_tab_stops+25Bj
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_tab_stops	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl validate_tab_stops(const	uintmax_t *tabs, size_t	entries)
validate_tab_stops proc	near		; CODE XREF: main+2C7p

i		= dword	ptr -14h
prev_tab	= qword	ptr -10h
tabs		= dword	ptr  8
entries		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	dword ptr [ebp+prev_tab], 0
		mov	dword ptr [ebp+prev_tab+4], 0
		mov	[ebp+i], 0
		jmp	loc_8000684
; ---------------------------------------------------------------------------

loc_80005E9:				; CODE XREF: validate_tab_stops+C1j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+tabs]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		or	eax, edx
		test	eax, eax
		jnz	short loc_8000623
		sub	esp, 0Ch
		push	offset aTabSizeCannotB ; "tab size cannot be 0"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000623:				; CODE XREF: validate_tab_stops+38j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+tabs]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		cmp	edx, dword ptr [ebp+prev_tab+4]
		ja	short loc_8000666
		cmp	edx, dword ptr [ebp+prev_tab+4]
		jb	short loc_8000646
		cmp	eax, dword ptr [ebp+prev_tab]
		ja	short loc_8000666

loc_8000646:				; CODE XREF: validate_tab_stops+76j
		sub	esp, 0Ch
		push	offset aTabSizesMustBe ; "tab sizes must be ascending"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000666:				; CODE XREF: validate_tab_stops+71j
					; validate_tab_stops+7Bj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+tabs]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+prev_tab], eax
		mov	dword ptr [ebp+prev_tab+4], edx
		add	[ebp+i], 1

loc_8000684:				; CODE XREF: validate_tab_stops+1Bj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+entries]
		jb	loc_80005E9
		nop
		leave
		retn
validate_tab_stops endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; FILE *__cdecl	next_file(FILE *fp)
next_file	proc near		; CODE XREF: unexpand+Ep unexpand+8Dp

file		= dword	ptr -0Ch
var_4		= dword	ptr -4
fp		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		cmp	[ebp+fp], 0
		jz	loc_80007C5
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80006DE
		mov	ebx, ds:prev_file_5136
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:exit_status,	1

loc_80006DE:				; CODE XREF: next_file+21j
		mov	eax, ds:prev_file_5136
		sub	esp, 8
		push	offset asc_80010C9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800070B
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	clearerr_unlocked
		add	esp, 10h
		jmp	loc_80007C5
; ---------------------------------------------------------------------------

loc_800070B:				; CODE XREF: next_file+63j
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	loc_80007C5
		mov	ebx, ds:prev_file_5136
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:exit_status,	1
		jmp	short loc_80007C5
; ---------------------------------------------------------------------------

loc_800074B:				; CODE XREF: next_file+149j
		sub	esp, 8
		push	offset asc_80010C9 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000778
		mov	ds:have_read_stdin, 1
		mov	eax, [ebp+file]
		mov	ds:prev_file_5136, eax
		mov	eax, ds:stdin
		jmp	short loc_80007E7
; ---------------------------------------------------------------------------

loc_8000778:				; CODE XREF: next_file+CDj
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+file]
		call	fopen64
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jz	short loc_80007A1
		mov	eax, [ebp+file]
		mov	ds:prev_file_5136, eax
		mov	eax, [ebp+fp]
		jmp	short loc_80007E7
; ---------------------------------------------------------------------------

loc_80007A1:				; CODE XREF: next_file+FFj
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:exit_status,	1

loc_80007C5:				; CODE XREF: next_file+Bj
					; next_file+73j ...
		mov	eax, ds:file_list
		lea	edx, [eax+4]
		mov	ds:file_list, edx
		mov	eax, [eax]
		mov	[ebp+file], eax
		cmp	[ebp+file], 0
		jnz	loc_800074B
		mov	eax, 0

loc_80007E7:				; CODE XREF: next_file+E3j
					; next_file+10Cj
		mov	ebx, [ebp+var_4]
		leave
		retn
next_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void unexpand()
unexpand	proc near		; CODE XREF: main+339p

convert		= byte ptr -48h
one_blank_before_tab_stop= byte	ptr -47h
prev_blank	= byte ptr -46h
blank		= byte ptr -45h
fp		= dword	ptr -44h
c		= dword	ptr -40h
tab_index	= dword	ptr -3Ch
pending		= dword	ptr -38h
pending_blank	= dword	ptr -34h
column		= qword	ptr -30h
next_tab_column	= qword	ptr -28h
tab		= qword	ptr -20h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		sub	esp, 0Ch
		push	0		; fp
		call	next_file
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jz	loc_8000BB1
		mov	eax, ds:max_column_width
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+pending_blank], eax

loc_8000823:				; CODE XREF: unexpand+3C0j
		mov	[ebp+convert], 1
		mov	dword ptr [ebp+column],	0
		mov	dword ptr [ebp+column+4], 0
		mov	dword ptr [ebp+next_tab_column], 0
		mov	dword ptr [ebp+next_tab_column+4], 0
		mov	[ebp+tab_index], 0
		mov	[ebp+one_blank_before_tab_stop], 0
		mov	[ebp+prev_blank], 1
		mov	[ebp+pending], 0
		jmp	short loc_800085C
; ---------------------------------------------------------------------------

loc_800085B:				; CODE XREF: unexpand+9Cj
		nop

loc_800085C:				; CODE XREF: unexpand+6Dj
					; unexpand+3BAj
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0
		jns	short loc_800088A
		sub	esp, 0Ch
		push	[ebp+fp]	; fp
		call	next_file
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jnz	short loc_800085B

loc_800088A:				; CODE XREF: unexpand+85j
		cmp	[ebp+convert], 0
		jz	loc_8000B52
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		setnz	al
		mov	[ebp+blank], al
		cmp	[ebp+blank], 0
		jz	loc_8000A5E
		mov	eax, dword ptr [ebp+next_tab_column]
		mov	edx, dword ptr [ebp+next_tab_column+4]
		cmp	edx, dword ptr [ebp+column+4]
		ja	loc_8000977
		cmp	edx, dword ptr [ebp+column+4]
		jb	short loc_80008DA
		cmp	eax, dword ptr [ebp+column]
		ja	loc_8000977

loc_80008DA:				; CODE XREF: unexpand+E3j
		mov	eax, ds:tab_size
		test	eax, eax
		jz	short loc_8000927
		mov	eax, ds:tab_size
		mov	esi, eax
		mov	edi, 0
		mov	eax, ds:tab_size
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	__umoddi3
		add	esp, 10h
		sub	esi, eax
		sbb	edi, edx
		mov	ecx, esi
		mov	ebx, edi
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+next_tab_column], eax
		mov	dword ptr [ebp+next_tab_column+4], edx
		jmp	short loc_8000977
; ---------------------------------------------------------------------------

loc_8000927:				; CODE XREF: unexpand+F5j
					; unexpand+173j ...
		mov	eax, ds:first_free_tab
		cmp	[ebp+tab_index], eax
		jnz	short loc_8000937
		mov	[ebp+convert], 0
		jmp	short loc_8000977
; ---------------------------------------------------------------------------

loc_8000937:				; CODE XREF: unexpand+143j
		mov	ecx, ds:tab_list
		mov	eax, [ebp+tab_index]
		lea	edx, [eax+1]
		mov	[ebp+tab_index], edx
		shl	eax, 3
		add	eax, ecx
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+tab], eax
		mov	dword ptr [ebp+tab+4], edx
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		cmp	edx, dword ptr [ebp+tab+4]
		ja	short loc_8000927
		cmp	edx, dword ptr [ebp+tab+4]
		jb	short loc_800096B
		cmp	eax, dword ptr [ebp+tab]
		jnb	short loc_8000927

loc_800096B:				; CODE XREF: unexpand+178j
		mov	eax, dword ptr [ebp+tab]
		mov	edx, dword ptr [ebp+tab+4]
		mov	dword ptr [ebp+next_tab_column], eax
		mov	dword ptr [ebp+next_tab_column+4], edx

loc_8000977:				; CODE XREF: unexpand+DAj unexpand+E8j ...
		cmp	[ebp+convert], 0
		jz	loc_8000ACC
		mov	eax, dword ptr [ebp+next_tab_column]
		mov	edx, dword ptr [ebp+next_tab_column+4]
		cmp	edx, dword ptr [ebp+column+4]
		ja	short loc_80009B6
		cmp	edx, dword ptr [ebp+column+4]
		jb	short loc_8000996
		cmp	eax, dword ptr [ebp+column]
		jnb	short loc_80009B6

loc_8000996:				; CODE XREF: unexpand+1A3j
		sub	esp, 0Ch
		push	offset aInputLineIsToo ; "input	line is	too long"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009B6:				; CODE XREF: unexpand+19Ej
					; unexpand+1A8j
		cmp	[ebp+c], 9
		jnz	short loc_80009ED
		mov	eax, dword ptr [ebp+next_tab_column]
		mov	edx, dword ptr [ebp+next_tab_column+4]
		mov	dword ptr [ebp+column],	eax
		mov	dword ptr [ebp+column+4], edx
		cmp	[ebp+pending], 1
		jnz	short loc_80009DD
		movzx	eax, [ebp+one_blank_before_tab_stop]
		xor	eax, 1
		test	al, al
		jz	loc_8000ACC

loc_80009DD:				; CODE XREF: unexpand+1E0j
		mov	[ebp+pending], 0
		mov	[ebp+one_blank_before_tab_stop], 0
		jmp	loc_8000ACC
; ---------------------------------------------------------------------------

loc_80009ED:				; CODE XREF: unexpand+1CEj
		add	dword ptr [ebp+column],	1
		adc	dword ptr [ebp+column+4], 0
		movzx	eax, [ebp+prev_blank]
		xor	eax, 1
		test	al, al
		jnz	short loc_8000A14
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+next_tab_column+4]
		xor	eax, dword ptr [ebp+next_tab_column]
		or	eax, ecx
		test	eax, eax
		jz	short loc_8000A48

loc_8000A14:				; CODE XREF: unexpand+212j
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+next_tab_column+4]
		xor	eax, dword ptr [ebp+next_tab_column]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000A2C
		mov	[ebp+one_blank_before_tab_stop], 1

loc_8000A2C:				; CODE XREF: unexpand+23Aj
		mov	eax, [ebp+pending]
		lea	edx, [eax+1]
		mov	[ebp+pending], edx
		mov	edx, [ebp+pending_blank]
		add	eax, edx
		mov	edx, [ebp+c]
		mov	[eax], dl
		mov	[ebp+prev_blank], 1
		jmp	loc_8000BA2
; ---------------------------------------------------------------------------

loc_8000A48:				; CODE XREF: unexpand+226j
		mov	[ebp+c], 9
		mov	eax, [ebp+pending_blank]
		mov	byte ptr [eax],	9
		movzx	eax, [ebp+one_blank_before_tab_stop]
		mov	[ebp+pending], eax
		jmp	short loc_8000ACC
; ---------------------------------------------------------------------------

loc_8000A5E:				; CODE XREF: unexpand+CBj
		cmp	[ebp+c], 8
		jnz	short loc_8000A9A
		mov	eax, dword ptr [ebp+column]
		or	eax, dword ptr [ebp+column+4]
		test	eax, eax
		setnz	al
		mov	ecx, eax
		movzx	eax, cl
		mov	edx, 0
		sub	dword ptr [ebp+column],	eax
		sbb	dword ptr [ebp+column+4], edx
		mov	eax, dword ptr [ebp+column]
		mov	edx, dword ptr [ebp+column+4]
		mov	dword ptr [ebp+next_tab_column], eax
		mov	dword ptr [ebp+next_tab_column+4], edx
		cmp	[ebp+tab_index], 0
		setnz	al
		movzx	eax, al
		sub	[ebp+tab_index], eax
		jmp	short loc_8000ACC
; ---------------------------------------------------------------------------

loc_8000A9A:				; CODE XREF: unexpand+276j
		add	dword ptr [ebp+column],	1
		adc	dword ptr [ebp+column+4], 0
		mov	eax, dword ptr [ebp+column+4]
		or	eax, dword ptr [ebp+column]
		test	eax, eax
		jnz	short loc_8000ACC
		sub	esp, 0Ch
		push	offset aInputLineIsToo ; "input	line is	too long"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000ACC:				; CODE XREF: unexpand+18Fj
					; unexpand+1EBj ...
		cmp	[ebp+pending], 0
		jz	short loc_8000B20
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+pending]	; n
		push	1		; size
		push	[ebp+pending_blank] ; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+pending]
		jz	short loc_8000B15
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B15:				; CODE XREF: unexpand+2FFj
		mov	[ebp+pending], 0
		mov	[ebp+one_blank_before_tab_stop], 0

loc_8000B20:				; CODE XREF: unexpand+2E4j
		movzx	eax, [ebp+blank]
		mov	[ebp+prev_blank], al
		movzx	edx, [ebp+convert]
		movzx	eax, ds:convert_entire_line
		test	al, al
		jnz	short loc_8000B3C
		cmp	[ebp+blank], 0
		jz	short loc_8000B43

loc_8000B3C:				; CODE XREF: unexpand+348j
		mov	eax, 1
		jmp	short loc_8000B48
; ---------------------------------------------------------------------------

loc_8000B43:				; CODE XREF: unexpand+34Ej
		mov	eax, 0

loc_8000B48:				; CODE XREF: unexpand+355j
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+convert], al

loc_8000B52:				; CODE XREF: unexpand+A2j
		cmp	[ebp+c], 0
		jns	short loc_8000B68
		sub	esp, 0Ch
		push	[ebp+pending_blank] ; ptr
		call	free
		add	esp, 10h
		jmp	short loc_8000BB2
; ---------------------------------------------------------------------------

loc_8000B68:				; CODE XREF: unexpand+36Aj
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	putchar_unlocked
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000BA2
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000BA2:				; CODE XREF: unexpand+257j
					; unexpand+38Cj
		cmp	[ebp+c], 0Ah
		jnz	loc_800085C
		jmp	loc_8000823
; ---------------------------------------------------------------------------

loc_8000BB1:				; CODE XREF: unexpand+1Dj
		nop

loc_8000BB2:				; CODE XREF: unexpand+37Aj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
unexpand	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -3Ch
have_tabval	= byte ptr -2Eh
convert_first_only= byte ptr -2Dh
c		= dword	ptr -2Ch
tabval		= qword	ptr -28h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 3Ch
		mov	esi, ecx
		mov	eax, [esi+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+have_tabval], 0
		mov	[ebp+convert_first_only], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:have_read_stdin, 0
		mov	ds:exit_status,	0
		mov	ds:convert_entire_line,	0
		mov	ds:tab_list, 0
		mov	ds:first_free_tab, 0
		jmp	loc_8000E22
; ---------------------------------------------------------------------------

loc_8000C71:				; CODE XREF: main+28Bj
		mov	eax, [ebp+c]
		cmp	eax, 3Fh
		jz	short loc_8000CB4
		cmp	eax, 3Fh
		jg	short loc_8000C9E
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000D12
		cmp	eax, 2Ch
		jz	short loc_8000CF0
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000D1C
		jmp	loc_8000D4F
; ---------------------------------------------------------------------------

loc_8000C9E:				; CODE XREF: main+C2j
		cmp	eax, 74h
		jz	short loc_8000CCA
		cmp	eax, 80h
		jz	short loc_8000CE7
		cmp	eax, 61h
		jz	short loc_8000CBE
		jmp	loc_8000D4F
; ---------------------------------------------------------------------------

loc_8000CB4:				; CODE XREF: main+BDj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CBE:				; CODE XREF: main+F3j
		mov	ds:convert_entire_line,	1
		jmp	loc_8000E22
; ---------------------------------------------------------------------------

loc_8000CCA:				; CODE XREF: main+E7j
		mov	ds:convert_entire_line,	1
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; stops
		call	parse_tab_stops
		add	esp, 10h
		jmp	loc_8000E22
; ---------------------------------------------------------------------------

loc_8000CE7:				; CODE XREF: main+EEj
		mov	[ebp+convert_first_only], 1
		jmp	loc_8000E22
; ---------------------------------------------------------------------------

loc_8000CF0:				; CODE XREF: main+D2j
		cmp	[ebp+have_tabval], 0
		jz	short loc_8000D09
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		sub	esp, 8
		push	edx
		push	eax		; tabval
		call	add_tab_stop
		add	esp, 10h

loc_8000D09:				; CODE XREF: main+13Aj
		mov	[ebp+have_tabval], 0
		jmp	loc_8000E22
; ---------------------------------------------------------------------------

loc_8000D12:				; CODE XREF: main+C9j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000D1C:				; CODE XREF: main+D9j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aUnexpand ; "unexpand"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000D4F:				; CODE XREF: main+DFj main+F5j
		movzx	eax, [ebp+have_tabval]
		xor	eax, 1
		test	al, al
		jz	short loc_8000D6C
		mov	dword ptr [ebp+tabval],	0
		mov	dword ptr [ebp+tabval+4], 0
		mov	[ebp+have_tabval], 1

loc_8000D6C:				; CODE XREF: main+19Ej
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		cmp	edx, 19999999h
		ja	short loc_8000DF8
		cmp	edx, 19999999h
		jb	short loc_8000D89
		cmp	eax, 99999999h
		ja	short loc_8000DF8

loc_8000D89:				; CODE XREF: main+1C6j
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		imul	ebx, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, ebx
		mov	ebx, 0Ah
		mul	ebx
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+c]
		sub	ecx, 30h
		mov	ebx, ecx
		sar	ebx, 1Fh
		add	ecx, eax
		adc	ebx, edx
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		cmp	ebx, edx
		jb	short loc_8000DF8
		cmp	ebx, edx
		ja	short loc_8000DC3
		cmp	ecx, eax
		jb	short loc_8000DF8

loc_8000DC3:				; CODE XREF: main+203j
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		imul	ebx, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, ebx
		mov	ebx, 0Ah
		mul	ebx
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+c]
		sub	ecx, 30h
		mov	ebx, ecx
		sar	ebx, 1Fh
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+tabval],	eax
		mov	dword ptr [ebp+tabval+4], edx
		mov	eax, 0
		jmp	short loc_8000DFD
; ---------------------------------------------------------------------------

loc_8000DF8:				; CODE XREF: main+1BEj	main+1CDj ...
		mov	eax, 1

loc_8000DFD:				; CODE XREF: main+23Cj
		test	al, al
		jz	short loc_8000E21
		sub	esp, 0Ch
		push	offset aTabStopValueIs ; "tab stop value is too	large"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000E21:				; CODE XREF: main+245j
		nop

loc_8000E22:				; CODE XREF: main+B2j main+10Bj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; ",0123456789at:"
		push	[ebp+argv]	; argv
		push	dword ptr [esi]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8000C71
		cmp	[ebp+convert_first_only], 0
		jz	short loc_8000E58
		mov	ds:convert_entire_line,	0

loc_8000E58:				; CODE XREF: main+295j
		cmp	[ebp+have_tabval], 0
		jz	short loc_8000E71
		mov	eax, dword ptr [ebp+tabval]
		mov	edx, dword ptr [ebp+tabval+4]
		sub	esp, 8
		push	edx
		push	eax		; tabval
		call	add_tab_stop
		add	esp, 10h

loc_8000E71:				; CODE XREF: main+2A2j
		mov	edx, ds:first_free_tab
		mov	eax, ds:tab_list
		sub	esp, 8
		push	edx		; entries
		push	eax		; tabs
		call	validate_tab_stops
		add	esp, 10h
		mov	eax, ds:first_free_tab
		test	eax, eax
		jnz	short loc_8000EA8
		mov	ds:max_column_width, 8
		mov	eax, ds:max_column_width
		mov	ds:tab_size, eax
		jmp	short loc_8000ECD
; ---------------------------------------------------------------------------

loc_8000EA8:				; CODE XREF: main+2D6j
		mov	eax, ds:first_free_tab
		cmp	eax, 1
		jnz	short loc_8000EC3
		mov	eax, ds:tab_list
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ds:tab_size, eax
		jmp	short loc_8000ECD
; ---------------------------------------------------------------------------

loc_8000EC3:				; CODE XREF: main+2F6j
		mov	ds:tab_size, 0

loc_8000ECD:				; CODE XREF: main+2ECj	main+307j
		mov	eax, ds:optind
		cmp	eax, [esi]
		jge	short loc_8000EE9
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		jmp	short loc_8000EEE
; ---------------------------------------------------------------------------

loc_8000EE9:				; CODE XREF: main+31Aj
		mov	eax, offset stdin_argv

loc_8000EEE:				; CODE XREF: main+32Dj
		mov	ds:file_list, eax
		call	unexpand
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_8000F32
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000F32
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_80010C9 ; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000F32:				; CODE XREF: main+347j	main+35Cj
		mov	eax, ds:exit_status
		sub	esp, 0Ch
		push	eax		; status

loc_8000F3B:				; DATA XREF: .eh_frame:08001544o
					; .eh_frame:08001564o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 8000F40h
; char *stdin_argv[2]
stdin_argv	dd offset asc_80010C9, 0 ; DATA	XREF: main:loc_8000EE9o
_data		ends			; "-"

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8000F48h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; _Bool	convert_entire_line
convert_entire_line db ?		; DATA XREF: unexpand+33Fr main+97w ...
		align 4
; size_t tab_size
tab_size	dd ?			; DATA XREF: unexpand:loc_80008DAr
					; unexpand+F7r	...
; size_t max_column_width
max_column_width dd ?			; DATA XREF: add_tab_stop+CBr
					; add_tab_stop+10Dw ...
; uintmax_t *tab_list
tab_list	dd ?			; DATA XREF: add_tab_stop+1Br
					; add_tab_stop+8Ar ...
; size_t n_tabs_allocated
n_tabs_allocated dd ?			; DATA XREF: add_tab_stop+81r
					; add_tab_stop+94o
; size_t first_free_tab
first_free_tab	dd ?			; DATA XREF: add_tab_stop+12r
					; add_tab_stop+20r ...
; char **file_list
file_list	dd ?			; DATA XREF: next_file:loc_80007C5r
					; next_file+13Aw ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: next_file+CFw main+86w ...
		align 4
; int exit_status
exit_status	dd ?			; DATA XREF: next_file+41w
					; next_file+ACw ...
; Function-local static	variable
; char *prev_file_5136
prev_file_5136	dd ?			; DATA XREF: next_file+23r
					; next_file:loc_80006DEr ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000F80h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+59o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+178o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
; char asc_80010C9[]
asc_80010C9	db '-',0                ; DATA XREF: next_file+53o
					; next_file+BBo ...
aTabs		db 'tabs',0             ; DATA XREF: .rodata:longoptso
aAll		db 'all',0              ; DATA XREF: .rodata:longoptso
aFirstOnly	db 'first-only',0       ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[6]
longopts	option <offset aTabs, 1, 0, 74h> ; DATA	XREF: main+26Do
		option <offset aAll, 0,	0, 61h>	; "tabs"
		option <offset aFirstOnly, 0, 0, 80h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aConvertBlanksI[]
aConvertBlanksI	db 'Convert blanks in each FILE to tabs, writing to standard output.',0Ah
					; DATA XREF: usage+69o
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aAAllConvertAll[]
aAAllConvertAll	db '  -a, --all        convert all blanks, instead of just initial bl'
					; DATA XREF: usage+AFo
		db 'anks',0Ah
		db '      --first-only  convert only leading sequences of blanks (ove'
		db 'rrides -a)',0Ah
		db '  -t, --tabs=N     have tabs N characters apart instead of 8 (ena'
		db 'bles -a)',0Ah
		db '  -t, --tabs=LIST  use comma separated LIST of tab positions (ena'
		db 'bles -a)',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+F5o
; char aTabsAreTooFarA[]
aTabsAreTooFarA	db 'tabs are too far apart',0 ; DATA XREF: add_tab_stop+EDo
; char accept[]
accept		db '0123456789',0       ; DATA XREF: parse_tab_stops+165o
; char aTabStopIsTooLa[]
aTabStopIsTooLa	db 'tab stop is too large %s',0 ; DATA XREF: parse_tab_stops+19Fo
		align 10h
; char aTabSizeContain[]
aTabSizeContain	db 'tab size contains invalid character(s): %s',0
					; DATA XREF: parse_tab_stops+1EFo
; char aTabSizeCannotB[]
aTabSizeCannotB	db 'tab size cannot be 0',0 ; DATA XREF: validate_tab_stops+3Do
; char aTabSizesMustBe[]
aTabSizesMustBe	db 'tab sizes must be ascending',0 ; DATA XREF: validate_tab_stops+80o
; char format[]
format		db '%s',0               ; DATA XREF: next_file+31o
					; next_file+9Co ...
aR		db 'r',0                ; DATA XREF: next_file+E8o
; char aInputLineIsToo[]
aInputLineIsToo	db 'input line is too long',0 ; DATA XREF: unexpand+1ADo
					; unexpand+2C3o
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: unexpand+304o
					; unexpand+391o
; char locale
locale		db 0			; DATA XREF: main+42o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+54o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+172o
aUnexpand	db 'unexpand',0         ; DATA XREF: main+17Do
; char aTabStopValueIs[]
aTabStopValueIs	db 'tab stop value is too large',0 ; DATA XREF: main+24Ao
; char shortopts[]
shortopts	db ',0123456789at:',0   ; DATA XREF: main+272o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001524h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000F3B-800247Fh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8000F3B-800248Dh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	60h
		dd offset loc_8000F3B-8002395h
		dd 11Fh, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_8000F3B-8002292h
		dd 115h, 80E4100h, 0D420285h, 1110305h,	4040CC5h, 20h
		dd 9Ch
		dd offset loc_8000F3B-800219Dh
		dd 267h, 80E4100h, 0D420285h, 3834405h,	0C5025F03h, 4040CC3h
		dd 1Ch,	0C0h
		dd offset loc_8000F3B-8001F5Ah
		dd 0CAh, 80E4100h, 0D420285h, 0C5C60205h, 4040Ch, 20h
		dd 0E0h
		dd offset loc_8000F3B-8001EB0h
		dd 159h, 80E4100h, 0D420285h, 3834405h,	0C5015103h, 4040CC3h
		dd 2Ch,	104h
		dd offset loc_8000F3B-8001D7Bh
		dd 3CEh, 80E4100h, 0D420285h, 3874605h,	5830486h, 0C303C103h
		dd 0C741C641h, 40CC541h, 4, 28h, 134h
		dd offset loc_8000F3B-80019DDh
		dd 386h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+49p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+11Ap
					; parse_tab_stops+232p	...
		extrn x2nrealloc:near	; CODE XREF: add_tab_stop+9Ap
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: add_tab_stop+102p
					; parse_tab_stops+1B2p	...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: parse_tab_stops+2Fp
					; unexpand+A8p
; size_t strspn(const char *s, const char *accept)
		extrn strspn:near	; CODE XREF: parse_tab_stops+16Dp
; char *xstrndup(const char *, size_t)
		extrn xstrndup:near	; CODE XREF: parse_tab_stops+181p
		extrn quote:near	; CODE XREF: parse_tab_stops+192p
					; parse_tab_stops+1E2p
; void free(void *ptr)
		extrn free:near		; CODE XREF: parse_tab_stops+1C0p
					; unexpand+372p
		extrn __stack_chk_fail:near ; CODE XREF: parse_tab_stops+25Dp
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	next_file+17p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: next_file+29p
					; next_file+94p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: next_file+59p
					; next_file+C3p
; void clearerr_unlocked(FILE *stream)
		extrn clearerr_unlocked:near ; CODE XREF: next_file+6Bp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: next_file+7Ep main+352p
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: next_file+DEr main+349r
		extrn fopen64:near	; CODE XREF: next_file+F0p
		extrn __umoddi3:near	; CODE XREF: unexpand+119p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: unexpand+2Cp
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: unexpand+76p
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	unexpand+2F4p
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: unexpand+382p
		extrn set_program_name:near ; CODE XREF: main+37p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+5Ep
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+6Ep
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+79o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+7Ep
; char *optarg
		extrn optarg:dword	; DATA XREF: main+117r
		extrn Version:dword	; DATA XREF: main:loc_8000D1Cr
		extrn version_etc:near	; CODE XREF: main+183p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+27Cp
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000ECDr
					; main+31Cr


		end
