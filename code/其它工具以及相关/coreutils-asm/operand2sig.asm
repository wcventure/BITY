;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	1B992D2DC04ED4E010CC21DBAE4E6988
; Input	CRC32 :	61086DAA

; File Name   :	D:\coreutils-o\operand2sig.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'operand2sig.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl operand2sig(const	char *operand, char *signame)
		public operand2sig
operand2sig	proc near

signame		= dword	ptr -40h
operand		= dword	ptr -3Ch
signum		= dword	ptr -2Ch
endp		= dword	ptr -28h
var_24		= dword	ptr -24h
var_20		= dword	ptr -20h
p		= dword	ptr -1Ch
l		= dword	ptr -18h
i		= dword	ptr -14h
upcased		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	eax, [ebp+arg_0]
		mov	[ebp+operand], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+signame], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+operand]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_80000B4
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	0Ah		; base
		lea	eax, [ebp+endp]
		push	eax		; endptr
		push	[ebp+operand]	; nptr
		call	strtol
		add	esp, 10h
		mov	[ebp+l], eax
		mov	eax, [ebp+l]
		mov	[ebp+i], eax
		mov	eax, [ebp+endp]
		cmp	[ebp+operand], eax
		jz	short loc_80000A7
		mov	eax, [ebp+endp]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80000A7
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80000A7
		mov	eax, [ebp+i]
		cmp	eax, [ebp+l]
		jnz	short loc_80000A7
		mov	eax, [ebp+i]
		mov	[ebp+var_24], eax
		mov	eax, [ebp+var_24]
		and	eax, 7Fh
		add	eax, 1
		sar	al, 1
		test	al, al
		jle	short loc_80000A2
		mov	eax, [ebp+i]
		mov	[ebp+var_20], eax
		mov	eax, [ebp+var_20]
		and	eax, 7Fh
		jmp	short loc_80000AC
; ---------------------------------------------------------------------------

loc_80000A2:				; CODE XREF: operand2sig+92j
		mov	eax, [ebp+i]
		jmp	short loc_80000AC
; ---------------------------------------------------------------------------

loc_80000A7:				; CODE XREF: operand2sig+60j
					; operand2sig+6Aj ...
		mov	eax, 0FFFFFFFFh

loc_80000AC:				; CODE XREF: operand2sig+A0j
					; operand2sig+A5j
		mov	[ebp+signum], eax
		jmp	loc_8000172
; ---------------------------------------------------------------------------

loc_80000B4:				; CODE XREF: operand2sig+2Cj
		sub	esp, 0Ch
		push	[ebp+operand]	; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+upcased], eax
		mov	eax, [ebp+upcased]
		mov	[ebp+p], eax
		jmp	short loc_80000FF
; ---------------------------------------------------------------------------

loc_80000CD:				; CODE XREF: operand2sig+107j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset s	; "abcdefghijklmnopqrstuvwxyz"
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000FB
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		sub	eax, 20h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax], dl

loc_80000FB:				; CODE XREF: operand2sig+E9j
		add	[ebp+p], 1

loc_80000FF:				; CODE XREF: operand2sig+CBj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80000CD
		sub	esp, 8
		lea	eax, [ebp+signum]
		push	eax
		push	[ebp+upcased]
		call	str2sig
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000164
		mov	eax, [ebp+upcased]
		movzx	eax, byte ptr [eax]
		cmp	al, 53h
		jnz	short loc_800015D
		mov	eax, [ebp+upcased]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 49h
		jnz	short loc_800015D
		mov	eax, [ebp+upcased]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 47h
		jnz	short loc_800015D
		mov	eax, [ebp+upcased]
		lea	edx, [eax+3]
		sub	esp, 8
		lea	eax, [ebp+signum]
		push	eax
		push	edx
		call	str2sig
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000164

loc_800015D:				; CODE XREF: operand2sig+127j
					; operand2sig+134j ...
		mov	[ebp+signum], 0FFFFFFFFh

loc_8000164:				; CODE XREF: operand2sig+11Dj
					; operand2sig+15Bj
		sub	esp, 0Ch
		push	[ebp+upcased]	; ptr
		call	free
		add	esp, 10h

loc_8000172:				; CODE XREF: operand2sig+AFj
		mov	eax, [ebp+signum]
		test	eax, eax
		js	short loc_800018F
		mov	eax, [ebp+signum]
		sub	esp, 8
		push	[ebp+signame]
		push	eax
		call	sig2str
		add	esp, 10h
		test	eax, eax
		jz	short loc_80001B6

loc_800018F:				; CODE XREF: operand2sig+177j
		sub	esp, 0Ch
		push	offset msgid	; "%s: invalid signal"
		call	gettext
		add	esp, 10h
		push	[ebp+operand]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0FFFFFFFFh
		jmp	short loc_80001B9
; ---------------------------------------------------------------------------

loc_80001B6:				; CODE XREF: operand2sig+18Dj
		mov	eax, [ebp+signum]

loc_80001B9:				; CODE XREF: operand2sig+1B4j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80001CA
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80001CA:				; CODE XREF: operand2sig+1C3j
		leave

locret_80001CB:				; DATA XREF: .eh_frame:0800021Co
		retn
operand2sig	endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	byte public 'CONST' use32
		assume cs:_rodata
		;org 80001CEh
; char s[]
s		db 'abcdefghijklmnopqrstuvwxyz',0 ; DATA XREF: operand2sig+DAo
; char msgid[]
msgid		db '%s: invalid signal',0 ; DATA XREF: operand2sig+192o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80001FCh
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_80001CB-80003E7h
		dd 1CCh, 80E4100h, 0D420285h, 1C80305h,	4040CC5h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: operand2sig+32p
					; operand2sig+6Cp
; __int32 strtol(const char *nptr, char	**endptr, int base)
		extrn strtol:near	; CODE XREF: operand2sig+49p
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: operand2sig+BAp
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: operand2sig+DFp
		extrn str2sig:near	; CODE XREF: operand2sig+113p
					; operand2sig+151p
; void free(void *ptr)
		extrn free:near		; CODE XREF: operand2sig+16Ap
		extrn sig2str:near	; CODE XREF: operand2sig+183p
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: operand2sig+197p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: operand2sig+1A7p
		extrn __stack_chk_fail:near ; CODE XREF: operand2sig+1C5p


		end
