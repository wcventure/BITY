;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4D204B60134FF6C69BC629D787026C9E
; Input	CRC32 :	5AF9A789

; File Name   :	D:\coreutils-o\csplit.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'csplit.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+178p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void cleanup()
cleanup		proc near		; CODE XREF: cleanup_fatal+6p

oldset		= sigset_t ptr -8Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 98h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		call	close_output_file
		sub	esp, 4
		lea	eax, [ebp+oldset]
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; in_signal_handler
		call	delete_all_files
		add	esp, 10h
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+oldset]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000183
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000183:				; CODE XREF: cleanup+60j
		leave
		retn
cleanup		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void cleanup_fatal()
cleanup_fatal	proc near		; CODE XREF: xalloc_die+28p
					; read_input+65p ...
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	cleanup
		sub	esp, 0Ch
		push	1		; status
		call	exit
cleanup_fatal	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void xalloc_die()
		public xalloc_die
xalloc_die	proc near		; CODE XREF: load_buffer+114p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset aMemoryExhauste ; "memory exhausted"
		call	gettext
		add	esp, 10h
		push	eax
		push	offset format	; "%s"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
xalloc_die	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl interrupt_handler(int sig)
interrupt_handler proc near		; DATA XREF: main+409o

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	1		; in_signal_handler
		call	delete_all_files
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+sig]	; sig
		call	raise
		add	esp, 10h
		nop
		leave
		retn
interrupt_handler endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl save_to_hold_area(char *start, size_t num)
save_to_hold_area proc near		; CODE XREF: record_line_starts+CDp

start		= dword	ptr  8
num		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:hold_area
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+start]
		mov	ds:hold_area, eax
		mov	eax, [ebp+num]
		mov	ds:hold_count, eax
		nop
		leave
		retn
save_to_hold_area endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl read_input(char *dest,	size_t max_n_bytes)
read_input	proc near		; CODE XREF: load_buffer+B0p

bytes_read	= dword	ptr -0Ch
var_4		= dword	ptr -4
dest		= dword	ptr  8
max_n_bytes	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		cmp	[ebp+max_n_bytes], 0
		jnz	short loc_8000229
		mov	eax, 0
		jmp	short loc_8000282
; ---------------------------------------------------------------------------

loc_8000229:				; CODE XREF: read_input+Bj
		sub	esp, 4
		push	[ebp+max_n_bytes]
		push	[ebp+dest]
		push	0
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_800024C
		mov	ds:have_read_eof, 1

loc_800024C:				; CODE XREF: read_input+2Ej
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_800027F
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_800027F:				; CODE XREF: read_input+3Bj
		mov	eax, [ebp+bytes_read]

loc_8000282:				; CODE XREF: read_input+12j
		mov	ebx, [ebp+var_4]
		leave
		retn
read_input	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl clear_line_control(line *p)
clear_line_control proc	near		; CODE XREF: new_line_control+2Cp

p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+p]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		nop
		pop	ebp
		retn
clear_line_control endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; line *new_line_control()
new_line_control proc near		; CODE XREF: keep_new_line+11p
					; keep_new_line+3Dp

p		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	290h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	dword ptr [eax+28Ch], 0
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	clear_line_control
		add	esp, 10h
		mov	eax, [ebp+p]
		leave
		retn
new_line_control endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl keep_new_line(buffer_record *b, char *line_start, size_t	line_len)
keep_new_line	proc near		; CODE XREF: record_line_starts+6Cp
					; record_line_starts+A7p

l		= dword	ptr -0Ch
b		= dword	ptr  8
line_start	= dword	ptr  0Ch
line_len	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+b]
		mov	eax, [eax+20h]
		test	eax, eax
		jnz	short loc_800030D
		call	new_line_control
		mov	edx, eax
		mov	eax, [ebp+b]
		mov	[eax+24h], edx
		mov	eax, [ebp+b]
		mov	edx, [eax+24h]
		mov	eax, [ebp+b]
		mov	[eax+20h], edx

loc_800030D:				; CODE XREF: keep_new_line+Fj
		mov	eax, [ebp+b]
		mov	eax, [eax+24h]
		mov	eax, [eax]
		cmp	eax, 50h
		jnz	short loc_800033D
		mov	eax, [ebp+b]
		mov	ebx, [eax+24h]
		call	new_line_control
		mov	[ebx+28Ch], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+24h]
		mov	edx, [eax+28Ch]
		mov	eax, [ebp+b]
		mov	[eax+24h], edx

loc_800033D:				; CODE XREF: keep_new_line+35j
		mov	eax, [ebp+b]
		mov	eax, [eax+24h]
		mov	[ebp+l], eax
		mov	eax, [ebp+l]
		mov	edx, [eax+4]
		mov	eax, [ebp+l]
		mov	ecx, [ebp+line_start]
		mov	[eax+edx*8+10h], ecx
		mov	eax, [ebp+l]
		mov	edx, [eax+4]
		mov	eax, [ebp+l]
		mov	ecx, [ebp+line_len]
		mov	[eax+edx*8+0Ch], ecx
		mov	eax, [ebp+l]
		mov	eax, [eax]
		lea	edx, [eax+1]
		mov	eax, [ebp+l]
		mov	[eax], edx
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		lea	edx, [eax+1]
		mov	eax, [ebp+l]
		mov	[eax+4], edx
		nop
		add	esp, 14h
		pop	ebx
		pop	ebp
		retn
keep_new_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl record_line_starts(buffer_record *b)
record_line_starts proc	near		; CODE XREF: load_buffer+CEp

line_start	= dword	ptr -1Ch
bytes_left	= dword	ptr -18h
lines		= dword	ptr -14h
line_end	= dword	ptr -10h
line_length	= dword	ptr -0Ch
var_4		= dword	ptr -4
b		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+b]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_80003A4
		mov	eax, 0
		jmp	loc_80004B8
; ---------------------------------------------------------------------------

loc_80003A4:				; CODE XREF: record_line_starts+Fj
		mov	[ebp+lines], 0
		mov	eax, [ebp+b]
		mov	eax, [eax+1Ch]
		mov	[ebp+line_start], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+4]
		mov	[ebp+bytes_left], eax

loc_80003BD:				; CODE XREF: record_line_starts+87j
		sub	esp, 4
		push	[ebp+bytes_left] ; size_t
		push	0Ah		; c
		push	[ebp+line_start] ; s
		call	memchr
		add	esp, 10h
		mov	[ebp+line_end],	eax
		cmp	[ebp+line_end],	0
		jz	short loc_8000412
		mov	edx, [ebp+line_end]
		mov	eax, [ebp+line_start]
		sub	edx, eax
		mov	eax, edx
		add	eax, 1
		mov	[ebp+line_length], eax
		sub	esp, 4
		push	[ebp+line_length] ; line_len
		push	[ebp+line_start] ; line_start
		push	[ebp+b]		; b
		call	keep_new_line
		add	esp, 10h
		mov	eax, [ebp+line_length]
		sub	[ebp+bytes_left], eax
		mov	eax, [ebp+line_end]
		add	eax, 1
		mov	[ebp+line_start], eax
		add	[ebp+lines], 1
		jmp	short loc_80003BD
; ---------------------------------------------------------------------------

loc_8000412:				; CODE XREF: record_line_starts+4Ej
		nop
		cmp	[ebp+bytes_left], 0
		jz	short loc_800045E
		movzx	eax, ds:have_read_eof
		test	al, al
		jz	short loc_800043E
		sub	esp, 4
		push	[ebp+bytes_left] ; line_len
		push	[ebp+line_start] ; line_start
		push	[ebp+b]		; b
		call	keep_new_line
		add	esp, 10h
		add	[ebp+lines], 1
		jmp	short loc_800045E
; ---------------------------------------------------------------------------

loc_800043E:				; CODE XREF: record_line_starts+99j
		sub	esp, 8
		push	[ebp+bytes_left] ; size_t
		push	[ebp+line_start] ; void	*
		call	xmemdup
		add	esp, 10h
		sub	esp, 8
		push	[ebp+bytes_left] ; num
		push	eax		; start
		call	save_to_hold_area
		add	esp, 10h

loc_800045E:				; CODE XREF: record_line_starts+8Ej
					; record_line_starts+B3j
		mov	eax, [ebp+b]
		mov	edx, [ebp+lines]
		mov	[eax+18h], edx
		mov	eax, dword ptr ds:last_line_number
		mov	edx, dword ptr ds:last_line_number+4
		add	eax, 1
		adc	edx, 0
		mov	ecx, [ebp+b]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		mov	eax, [ebp+b]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, [ebp+b]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	ecx, [ebp+lines]
		mov	ebx, 0
		mov	eax, dword ptr ds:last_line_number
		mov	edx, dword ptr ds:last_line_number+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:last_line_number, eax
		mov	dword ptr ds:last_line_number+4, edx
		mov	eax, [ebp+lines]

loc_80004B8:				; CODE XREF: record_line_starts+16j
		mov	ebx, [ebp+var_4]
		leave
		retn
record_line_starts endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; buffer_record	*__cdecl create_new_buffer(size_t size)
create_new_buffer proc near		; CODE XREF: get_new_buffer+34p

new_buffer	= dword	ptr -0Ch
size		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	2Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new_buffer], eax
		mov	eax, [ebp+size]
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+new_buffer]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+new_buffer]
		mov	edx, [ebp+size]
		mov	[eax], edx
		mov	eax, [ebp+new_buffer]
		mov	dword ptr [eax+24h], 0
		mov	eax, [ebp+new_buffer]
		mov	edx, [eax+24h]
		mov	eax, [ebp+new_buffer]
		mov	[eax+20h], edx
		mov	eax, [ebp+new_buffer]
		leave
		retn
create_new_buffer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; buffer_record	*__cdecl get_new_buffer(size_t min_size)
get_new_buffer	proc near		; CODE XREF: load_buffer+3Ap

alloc_size	= dword	ptr -14h
s		= dword	ptr -10h
new_buffer	= dword	ptr -0Ch
min_size	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+alloc_size], 1FFFh
		mov	eax, [ebp+alloc_size]
		cmp	eax, [ebp+min_size]
		jnb	short loc_800053E
		mov	eax, [ebp+min_size]
		sub	eax, [ebp+alloc_size]
		add	eax, 7FFh
		mov	[ebp+s], eax
		mov	eax, [ebp+s]
		and	eax, 0FFFFF800h
		add	[ebp+alloc_size], eax

loc_800053E:				; CODE XREF: get_new_buffer+13j
		sub	esp, 0Ch
		push	[ebp+alloc_size] ; size
		call	create_new_buffer
		add	esp, 10h
		mov	[ebp+new_buffer], eax
		mov	eax, [ebp+new_buffer]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+new_buffer]
		mov	dword ptr [eax+4], 0
		mov	eax, dword ptr ds:last_line_number
		mov	edx, dword ptr ds:last_line_number+4
		add	eax, 1
		adc	edx, 0
		mov	ecx, [ebp+new_buffer]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, [ebp+new_buffer]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	ecx, [ebp+new_buffer]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		mov	eax, [ebp+new_buffer]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+new_buffer]
		leave
		retn
get_new_buffer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl free_buffer(buffer_record *buf)
free_buffer	proc near		; CODE XREF: load_buffer+E5p
					; load_buffer+129p ...

buf		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+buf]
		mov	eax, [eax+1Ch]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+buf]
		mov	dword ptr [eax+1Ch], 0
		nop
		leave
		retn
free_buffer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl save_buffer(buffer_record *buf)
save_buffer	proc near		; CODE XREF: load_buffer+150p

p		= dword	ptr -4
buf		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+buf]
		mov	dword ptr [eax+28h], 0
		mov	eax, [ebp+buf]
		mov	edx, [eax+20h]
		mov	eax, [ebp+buf]
		mov	[eax+24h], edx
		mov	eax, ds:head
		test	eax, eax
		jnz	short loc_80005F2
		mov	eax, [ebp+buf]
		mov	ds:head, eax
		jmp	short loc_8000618
; ---------------------------------------------------------------------------

loc_80005F2:				; CODE XREF: save_buffer+23j
		mov	eax, ds:head
		mov	[ebp+p], eax
		jmp	short loc_8000605
; ---------------------------------------------------------------------------

loc_80005FC:				; CODE XREF: save_buffer+4Aj
		mov	eax, [ebp+p]
		mov	eax, [eax+28h]
		mov	[ebp+p], eax

loc_8000605:				; CODE XREF: save_buffer+37j
		mov	eax, [ebp+p]
		mov	eax, [eax+28h]
		test	eax, eax
		jnz	short loc_80005FC
		mov	eax, [ebp+p]
		mov	edx, [ebp+buf]
		mov	[eax+28h], edx

loc_8000618:				; CODE XREF: save_buffer+2Dj
		nop
		leave
		retn
save_buffer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	load_buffer()
load_buffer	proc near		; CODE XREF: get_first_line_in_buffer+10p
					; remove_line+34p ...

bytes_wanted	= dword	ptr -1Ch
bytes_avail	= dword	ptr -18h
p		= dword	ptr -14h
b		= dword	ptr -10h
lines_found	= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+bytes_wanted], 1FFFh
		movzx	eax, ds:have_read_eof
		test	al, al
		jz	short loc_800063D
		mov	eax, 0
		jmp	locret_800078A
; ---------------------------------------------------------------------------

loc_800063D:				; CODE XREF: load_buffer+16j
		mov	eax, ds:hold_count
		cmp	[ebp+bytes_wanted], eax
		jnb	short loc_800064F
		mov	eax, ds:hold_count
		mov	[ebp+bytes_wanted], eax

loc_800064F:				; CODE XREF: load_buffer+2Aj
					; load_buffer+13Fj
		sub	esp, 0Ch
		push	[ebp+bytes_wanted] ; min_size
		call	get_new_buffer
		add	esp, 10h
		mov	[ebp+b], eax
		mov	eax, [ebp+b]
		mov	eax, [eax]
		mov	[ebp+bytes_avail], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+1Ch]
		mov	[ebp+p], eax
		mov	eax, ds:hold_count
		test	eax, eax
		jz	short loc_80006C2
		mov	edx, ds:hold_count
		mov	eax, ds:hold_area
		sub	esp, 4
		push	edx		; n
		push	eax		; src
		push	[ebp+p]		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, ds:hold_count
		add	[ebp+p], eax
		mov	eax, [ebp+b]
		mov	edx, [eax+4]
		mov	eax, ds:hold_count
		add	edx, eax
		mov	eax, [ebp+b]
		mov	[eax+4], edx
		mov	eax, ds:hold_count
		sub	[ebp+bytes_avail], eax
		mov	ds:hold_count, 0

loc_80006C2:				; CODE XREF: load_buffer+5Dj
		sub	esp, 8
		push	[ebp+bytes_avail] ; max_n_bytes
		push	[ebp+p]		; dest
		call	read_input
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+b]
		mov	eax, [eax+4]
		add	edx, eax
		mov	eax, [ebp+b]
		mov	[eax+4], edx
		sub	esp, 0Ch
		push	[ebp+b]		; b
		call	record_line_starts
		add	esp, 10h
		mov	[ebp+lines_found], eax
		cmp	[ebp+lines_found], 0
		jnz	short loc_8000708
		sub	esp, 0Ch
		push	[ebp+b]		; buf
		call	free_buffer
		add	esp, 10h

loc_8000708:				; CODE XREF: load_buffer+DDj
		cmp	[ebp+lines_found], 0
		jnz	short loc_800075F
		movzx	eax, ds:have_read_eof
		test	al, al
		jnz	short loc_800075F
		mov	eax, [ebp+b]
		mov	ecx, [eax]
		mov	eax, 0FFFFFFFFh
		mov	edx, 0
		div	ecx
		cmp	eax, 1
		ja	short loc_8000734
		call	xalloc_die
; ---------------------------------------------------------------------------

loc_8000734:				; CODE XREF: load_buffer+112j
		mov	eax, [ebp+b]
		mov	eax, [eax]
		add	eax, eax
		mov	[ebp+bytes_wanted], eax
		sub	esp, 0Ch
		push	[ebp+b]		; buf
		call	free_buffer
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+b]		; ptr
		call	free
		add	esp, 10h
		jmp	loc_800064F
; ---------------------------------------------------------------------------

loc_800075F:				; CODE XREF: load_buffer+F1j
					; load_buffer+FCj
		cmp	[ebp+lines_found], 0
		jz	short loc_8000775
		sub	esp, 0Ch
		push	[ebp+b]		; buf
		call	save_buffer
		add	esp, 10h
		jmp	short loc_8000783
; ---------------------------------------------------------------------------

loc_8000775:				; CODE XREF: load_buffer+148j
		sub	esp, 0Ch
		push	[ebp+b]		; ptr
		call	free
		add	esp, 10h

loc_8000783:				; CODE XREF: load_buffer+158j
		cmp	[ebp+lines_found], 0
		setnz	al

locret_800078A:				; CODE XREF: load_buffer+1Dj
		leave
		retn
load_buffer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t get_first_line_in_buffer()
get_first_line_in_buffer proc near	; CODE XREF: write_to_file+19p
					; process_line_count+4Ep

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	eax, ds:head
		test	eax, eax
		jnz	short loc_80007D0
		call	load_buffer
		xor	eax, 1
		test	al, al
		jz	short loc_80007D0
		sub	esp, 0Ch
		push	offset aInputDisappear ; "input	disappeared"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007D0:				; CODE XREF: get_first_line_in_buffer+Ej
					; get_first_line_in_buffer+1Aj
		mov	eax, ds:head
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	ebx, [ebp+var_4]
		leave
		retn
get_first_line_in_buffer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; cstring *remove_line()
remove_line	proc near		; CODE XREF: write_to_file:loc_8000B2Ap
					; dump_rest_of_file:loc_8000BBCp ...

l		= dword	ptr -10h
line		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:prev_buf_5391
		test	eax, eax
		jz	short loc_800080B
		mov	eax, ds:prev_buf_5391
		sub	esp, 0Ch
		push	eax		; buf
		call	free_buffer
		add	esp, 10h
		mov	ds:prev_buf_5391, 0

loc_800080B:				; CODE XREF: remove_line+Ej
		mov	eax, ds:head
		test	eax, eax
		jnz	short loc_800082A
		call	load_buffer
		xor	eax, 1
		test	al, al
		jz	short loc_800082A
		mov	eax, 0
		jmp	loc_8000900
; ---------------------------------------------------------------------------

loc_800082A:				; CODE XREF: remove_line+32j
					; remove_line+3Ej
		mov	eax, ds:head
		mov	ecx, [eax+10h]
		mov	ebx, [eax+14h]
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		cmp	ebx, edx
		jb	short loc_8000862
		cmp	ebx, edx
		ja	short loc_800084C
		cmp	ecx, eax
		jbe	short loc_8000862

loc_800084C:				; CODE XREF: remove_line+66j
		mov	eax, ds:head
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	dword ptr ds:current_line, eax
		mov	dword ptr ds:current_line+4, edx

loc_8000862:				; CODE XREF: remove_line+62j
					; remove_line+6Aj
		mov	ecx, ds:head
		mov	eax, [ecx+10h]
		mov	edx, [ecx+14h]
		add	eax, 1
		adc	edx, 0
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		mov	eax, ds:head
		mov	eax, [eax+24h]
		mov	[ebp+l], eax
		mov	eax, [ebp+l]
		mov	eax, [eax+8]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+l]
		add	eax, edx
		add	eax, 0Ch
		mov	[ebp+line], eax
		mov	eax, [ebp+l]
		mov	eax, [eax+8]
		lea	edx, [eax+1]
		mov	eax, [ebp+l]
		mov	[eax+8], edx
		mov	eax, [ebp+l]
		mov	edx, [eax+8]
		mov	eax, [ebp+l]
		mov	eax, [eax]
		cmp	edx, eax
		jnz	short loc_80008FD
		mov	eax, ds:head
		mov	edx, [ebp+l]
		mov	edx, [edx+28Ch]
		mov	[eax+24h], edx
		mov	eax, ds:head
		mov	eax, [eax+24h]
		test	eax, eax
		jz	short loc_80008E6
		mov	eax, ds:head
		mov	eax, [eax+24h]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80008FD

loc_80008E6:				; CODE XREF: remove_line+F6j
		mov	eax, ds:head
		mov	ds:prev_buf_5391, eax
		mov	eax, ds:head
		mov	eax, [eax+28h]
		mov	ds:head, eax

loc_80008FD:				; CODE XREF: remove_line+D9j
					; remove_line+104j
		mov	eax, [ebp+line]

loc_8000900:				; CODE XREF: remove_line+45j
		mov	ebx, [ebp+var_4]
		leave
		retn
remove_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; cstring *__cdecl find_line(uintmax_t linenum)
find_line	proc near		; CODE XREF: no_more_lines+1Cp
					; process_regexp+69p ...

linenum		= qword	ptr -20h
b		= dword	ptr -14h
l		= dword	ptr -10h
offset		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+linenum], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+linenum+4], eax
		mov	eax, ds:head
		test	eax, eax
		jnz	short loc_8000937
		call	load_buffer
		xor	eax, 1
		test	al, al
		jz	short loc_8000937
		mov	eax, 0
		jmp	loc_80009FD
; ---------------------------------------------------------------------------

loc_8000937:				; CODE XREF: find_line+1Aj
					; find_line+26j
		mov	eax, ds:head
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		cmp	edx, dword ptr [ebp+linenum+4]
		jb	short loc_800095B
		cmp	edx, dword ptr [ebp+linenum+4]
		ja	short loc_8000951
		cmp	eax, dword ptr [ebp+linenum]
		jbe	short loc_800095B

loc_8000951:				; CODE XREF: find_line+45j
		mov	eax, 0
		jmp	loc_80009FD
; ---------------------------------------------------------------------------

loc_800095B:				; CODE XREF: find_line+40j
					; find_line+4Aj
		mov	eax, ds:head
		mov	[ebp+b], eax

loc_8000963:				; CODE XREF: find_line+F3j
		mov	eax, [ebp+b]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, [ebp+b]
		mov	ecx, [ecx+18h]
		mov	ebx, 0
		add	eax, ecx
		adc	edx, ebx
		cmp	edx, dword ptr [ebp+linenum+4]
		jb	short loc_80009D2
		cmp	edx, dword ptr [ebp+linenum+4]
		ja	short loc_800098A
		cmp	eax, dword ptr [ebp+linenum]
		jbe	short loc_80009D2

loc_800098A:				; CODE XREF: find_line+7Ej
		mov	eax, [ebp+b]
		mov	eax, [eax+20h]
		mov	[ebp+l], eax
		mov	ecx, dword ptr [ebp+linenum]
		mov	eax, [ebp+b]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		sub	ecx, eax
		mov	eax, ecx
		mov	[ebp+offset], eax
		jmp	short loc_80009B8
; ---------------------------------------------------------------------------

loc_80009A8:				; CODE XREF: find_line+B7j
		mov	eax, [ebp+l]
		mov	eax, [eax+28Ch]
		mov	[ebp+l], eax
		sub	[ebp+offset], 50h

loc_80009B8:				; CODE XREF: find_line+A1j
		cmp	[ebp+offset], 4Fh
		ja	short loc_80009A8
		mov	eax, [ebp+offset]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+l]
		add	eax, edx
		add	eax, 0Ch
		jmp	short loc_80009FD
; ---------------------------------------------------------------------------

loc_80009D2:				; CODE XREF: find_line+79j
					; find_line+83j
		mov	eax, [ebp+b]
		mov	eax, [eax+28h]
		test	eax, eax
		jnz	short loc_80009EF
		call	load_buffer
		xor	eax, 1
		test	al, al
		jz	short loc_80009EF
		mov	eax, 0
		jmp	short loc_80009FD
; ---------------------------------------------------------------------------

loc_80009EF:				; CODE XREF: find_line+D5j
					; find_line+E1j
		mov	eax, [ebp+b]
		mov	eax, [eax+28h]
		mov	[ebp+b], eax
		jmp	loc_8000963
; ---------------------------------------------------------------------------

loc_80009FD:				; CODE XREF: find_line+2Dj
					; find_line+51j ...
		add	esp, 24h
		pop	ebx
		pop	ebp
		retn
find_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	no_more_lines()
no_more_lines	proc near		; CODE XREF: process_line_count+B2p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		add	eax, 1
		adc	edx, 0
		sub	esp, 8
		push	edx
		push	eax		; linenum
		call	find_line
		add	esp, 10h
		test	eax, eax
		setz	al
		leave
		retn
no_more_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_input_file(const char *name)
set_input_file	proc near		; CODE XREF: main+371p

name		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 8
		push	offset asc_80029F1 ; "-"
		push	[ebp+name]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000A95
		push	0
		push	0
		push	[ebp+name]
		push	0
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000A95
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000A95:				; CODE XREF: set_input_file+1Aj
					; set_input_file+2Fj
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
set_input_file	endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_to_file(uintmax_t last_line, _Bool	ignore,	int argnum)
write_to_file	proc near		; CODE XREF: process_regexp+28Fp

ignore		= byte ptr -34h
last_line	= qword	ptr -30h
line		= dword	ptr -24h
i		= qword	ptr -20h
first_line	= qword	ptr -18h
lines		= qword	ptr -10h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
argnum		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	dword ptr [ebp+last_line], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+last_line+4], edx
		mov	[ebp+ignore], al
		call	get_first_line_in_buffer
		mov	dword ptr [ebp+first_line], eax
		mov	dword ptr [ebp+first_line+4], edx
		mov	eax, dword ptr [ebp+first_line]
		mov	edx, dword ptr [ebp+first_line+4]
		cmp	edx, dword ptr [ebp+last_line+4]
		jb	short loc_8000B08
		cmp	edx, dword ptr [ebp+last_line+4]
		ja	short loc_8000AD6
		cmp	eax, dword ptr [ebp+last_line]
		jbe	short loc_8000B08

loc_8000AD6:				; CODE XREF: write_to_file+32j
		mov	eax, ds:global_argv
		mov	edx, [ebp+argnum]
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSLineNumberOut ; "%s: line number out of range"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_8000B08:				; CODE XREF: write_to_file+2Dj
					; write_to_file+37j
		mov	eax, dword ptr [ebp+last_line]
		mov	edx, dword ptr [ebp+last_line+4]
		sub	eax, dword ptr [ebp+first_line]
		sbb	edx, dword ptr [ebp+first_line+4]
		mov	dword ptr [ebp+lines], eax
		mov	dword ptr [ebp+lines+4], edx
		mov	dword ptr [ebp+i], 0
		mov	dword ptr [ebp+i+4], 0
		jmp	short loc_8000B8B
; ---------------------------------------------------------------------------

loc_8000B2A:				; CODE XREF: write_to_file+F7j
					; write_to_file+101j
		call	remove_line
		mov	[ebp+line], eax
		cmp	[ebp+line], 0
		jnz	short loc_8000B6A
		mov	eax, ds:global_argv
		mov	edx, [ebp+argnum]
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSLineNumberOut ; "%s: line number out of range"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_8000B6A:				; CODE XREF: write_to_file+99j
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_8000B83
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	save_line_to_file
		add	esp, 10h

loc_8000B83:				; CODE XREF: write_to_file+D6j
		add	dword ptr [ebp+i], 1
		adc	dword ptr [ebp+i+4], 0

loc_8000B8B:				; CODE XREF: write_to_file+8Bj
		mov	eax, dword ptr [ebp+i]
		mov	edx, dword ptr [ebp+i+4]
		cmp	edx, dword ptr [ebp+lines+4]
		jb	short loc_8000B2A
		cmp	edx, dword ptr [ebp+lines+4]
		ja	short loc_8000BA0
		cmp	eax, dword ptr [ebp+lines]
		jb	short loc_8000B2A

loc_8000BA0:				; CODE XREF: write_to_file+FCj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
write_to_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void dump_rest_of_file()
dump_rest_of_file proc near		; CODE XREF: regexp_error+DBp
					; process_regexp+90p ...

line		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		jmp	short loc_8000BBC
; ---------------------------------------------------------------------------

loc_8000BAE:				; CODE XREF: dump_rest_of_file+22j
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	save_line_to_file
		add	esp, 10h

loc_8000BBC:				; CODE XREF: dump_rest_of_file+6j
		call	remove_line
		mov	[ebp+line], eax
		cmp	[ebp+line], 0
		jnz	short loc_8000BAE
		nop
		leave
		retn
dump_rest_of_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl handle_line_error(const control *p, uintmax_t repetition)
handle_line_error proc near		; CODE XREF: process_line_count+75p
					; process_line_count+C7p

repetition	= qword	ptr -38h
p		= dword	ptr -2Ch
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+p], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+repetition], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+repetition+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+p]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSSLineNumberOu ; "%s: %s: line number out of range"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	eax, dword ptr [ebp+repetition+4]
		or	eax, dword ptr [ebp+repetition]
		test	eax, eax
		jz	short loc_8000C8B
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition]
		call	umaxtostr
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aOnRepetitionS ;	" on repetition	%s\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	short loc_8000C9E
; ---------------------------------------------------------------------------

loc_8000C8B:				; CODE XREF: handle_line_error+7Ej
		mov	eax, ds:stderr
		sub	esp, 8
		push	eax		; stream
		push	0Ah		; c
		call	fputc
		add	esp, 10h

loc_8000C9E:				; CODE XREF: handle_line_error+BCj
		call	cleanup_fatal
handle_line_error endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl process_line_count(const	control	*p, uintmax_t repetition)
process_line_count proc	near		; CODE XREF: split_file+BEp

repetition	= qword	ptr -40h
line		= dword	ptr -2Ch
linenum		= qword	ptr -28h
last_line_to_save= qword ptr -20h
p		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+repetition], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+repetition+4], eax
		mov	eax, [ebp+p]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, dword ptr [ebp+repetition]
		mov	ebx, dword ptr [ebp+repetition+4]
		add	ecx, 1
		adc	ebx, 0
		mov	edi, edx
		imul	edi, ecx
		mov	esi, ebx
		imul	esi, eax
		add	esi, edi
		mul	ecx
		lea	ecx, [esi+edx]
		mov	edx, ecx
		mov	dword ptr [ebp+last_line_to_save], eax
		mov	dword ptr [ebp+last_line_to_save+4], edx
		mov	dword ptr [ebp+last_line_to_save], eax
		mov	dword ptr [ebp+last_line_to_save+4], edx
		call	create_output_file
		call	get_first_line_in_buffer
		mov	dword ptr [ebp+linenum], eax
		mov	dword ptr [ebp+linenum+4], edx
		jmp	short loc_8000D2B
; ---------------------------------------------------------------------------

loc_8000CFE:				; CODE XREF: process_line_count+A1j
					; process_line_count+ABj
		call	remove_line
		mov	[ebp+line], eax
		cmp	[ebp+line], 0
		jnz	short loc_8000D1D
		sub	esp, 4
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition] ; repetition
		push	[ebp+p]		; p
		call	handle_line_error
; ---------------------------------------------------------------------------

loc_8000D1D:				; CODE XREF: process_line_count+67j
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	save_line_to_file
		add	esp, 10h

loc_8000D2B:				; CODE XREF: process_line_count+59j
		mov	eax, dword ptr [ebp+linenum]
		mov	edx, dword ptr [ebp+linenum+4]
		mov	ecx, eax
		mov	ebx, edx
		add	ecx, 1
		adc	ebx, 0
		mov	dword ptr [ebp+linenum], ecx
		mov	dword ptr [ebp+linenum+4], ebx
		cmp	edx, dword ptr [ebp+last_line_to_save+4]
		jb	short loc_8000CFE
		cmp	edx, dword ptr [ebp+last_line_to_save+4]
		ja	short loc_8000D50
		cmp	eax, dword ptr [ebp+last_line_to_save]
		jb	short loc_8000CFE

loc_8000D50:				; CODE XREF: process_line_count+A6j
		call	close_output_file
		call	no_more_lines
		test	al, al
		jz	short loc_8000D6F
		sub	esp, 4
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition] ; repetition
		push	[ebp+p]		; p
		call	handle_line_error
; ---------------------------------------------------------------------------

loc_8000D6F:				; CODE XREF: process_line_count+B9j
		nop
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
process_line_count endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl regexp_error(control *p,	uintmax_t repetition, _Bool ignore)
regexp_error	proc near		; CODE XREF: process_regexp+B2p
					; process_regexp+1D4p

repetition	= qword	ptr -38h
ignore		= byte ptr -30h
p		= dword	ptr -2Ch
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_C]
		mov	edx, [ebp+arg_0]
		mov	[ebp+p], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+repetition], edx
		mov	edx, [ebp+arg_8]
		mov	dword ptr [ebp+repetition+4], edx
		mov	[ebp+ignore], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	edx, ds:global_argv
		mov	eax, [ebp+p]
		mov	eax, [eax+18h]
		shl	eax, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSSMatchNotFoun ; "%s: %s: match	not found"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	eax, dword ptr [ebp+repetition+4]
		or	eax, dword ptr [ebp+repetition]
		test	eax, eax
		jz	short loc_8000E35
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition]
		call	umaxtostr
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aOnRepetitionS ;	" on repetition	%s\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	short loc_8000E48
; ---------------------------------------------------------------------------

loc_8000E35:				; CODE XREF: regexp_error+7Dj
		mov	eax, ds:stderr
		sub	esp, 8
		push	eax		; stream
		push	0Ah		; c
		call	fputc
		add	esp, 10h

loc_8000E48:				; CODE XREF: regexp_error+BBj
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_8000E5D
		call	dump_rest_of_file
		call	close_output_file

loc_8000E5D:				; CODE XREF: regexp_error+D9j
		call	cleanup_fatal
regexp_error	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl process_regexp(control *p, uintmax_t repetition)
process_regexp	proc near		; CODE XREF: split_file+4Ep

repetition	= qword	ptr -30h
ignore		= byte ptr -1Dh
line_len	= dword	ptr -1Ch
line		= dword	ptr -18h
ret		= dword	ptr -14h
break_line	= qword	ptr -10h
var_4		= dword	ptr -4
p		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+repetition], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+repetition+4], eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+1Dh]
		mov	[ebp+ignore], al
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_8000E8F
		call	create_output_file

loc_8000E8F:				; CODE XREF: process_regexp+26j
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [eax]
		test	edx, edx
		js	loc_8000FC1

loc_8000E9F:				; CODE XREF: process_regexp+146j
					; process_regexp+15Aj
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:current_line, eax
		mov	dword ptr ds:current_line+4, edx
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		sub	esp, 8
		push	edx
		push	eax		; linenum
		call	find_line
		add	esp, 10h
		mov	[ebp+line], eax
		cmp	[ebp+line], 0
		jnz	short loc_8000F19
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_8000F06
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_8000EFC
		call	dump_rest_of_file
		call	close_output_file

loc_8000EFC:				; CODE XREF: process_regexp+8Ej
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000F06:				; CODE XREF: process_regexp+83j
		movzx	eax, [ebp+ignore]
		push	eax		; ignore
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition] ; repetition
		push	[ebp+p]		; p
		call	regexp_error
; ---------------------------------------------------------------------------

loc_8000F19:				; CODE XREF: process_regexp+78j
		mov	eax, [ebp+line]
		mov	eax, [eax]
		mov	[ebp+line_len],	eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	edx, [ebp+line_len]
		sub	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 0Ah
		jnz	short loc_8000F3A
		sub	[ebp+line_len],	1

loc_8000F3A:				; CODE XREF: process_regexp+D2j
		mov	ecx, [ebp+line_len]
		mov	edx, [ebp+line_len]
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	ebx, [ebp+p]
		add	ebx, 20h
		sub	esp, 8
		push	0		; regs
		push	ecx		; range
		push	0		; start
		push	edx		; length
		push	eax		; string
		push	ebx		; buffer
		call	re_search
		add	esp, 20h
		mov	[ebp+ret], eax
		cmp	[ebp+ret], 0FFFFFFFEh
		jnz	short loc_8000F8D
		sub	esp, 0Ch
		push	offset aErrorInRegular ; "error	in regular expression search"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_8000F8D:				; CODE XREF: process_regexp+104j
		cmp	[ebp+ret], 0FFFFFFFFh
		jnz	loc_80010BA
		call	remove_line
		mov	[ebp+line], eax
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	loc_8000E9F
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	save_line_to_file
		add	esp, 10h
		jmp	loc_8000E9F
; ---------------------------------------------------------------------------

loc_8000FC1:				; CODE XREF: process_regexp+37j
					; process_regexp+253j
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:current_line, eax
		mov	dword ptr ds:current_line+4, edx
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		sub	esp, 8
		push	edx
		push	eax		; linenum
		call	find_line
		add	esp, 10h
		mov	[ebp+line], eax
		cmp	[ebp+line], 0
		jnz	short loc_800103B
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_8001028
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_800101E
		call	dump_rest_of_file
		call	close_output_file

loc_800101E:				; CODE XREF: process_regexp+1B0j
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001028:				; CODE XREF: process_regexp+1A5j
		movzx	eax, [ebp+ignore]
		push	eax		; ignore
		push	dword ptr [ebp+repetition+4]
		push	dword ptr [ebp+repetition] ; repetition
		push	[ebp+p]		; p
		call	regexp_error
; ---------------------------------------------------------------------------

loc_800103B:				; CODE XREF: process_regexp+19Aj
		mov	eax, [ebp+line]
		mov	eax, [eax]
		mov	[ebp+line_len],	eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	edx, [ebp+line_len]
		sub	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 0Ah
		jnz	short loc_800105C
		sub	[ebp+line_len],	1

loc_800105C:				; CODE XREF: process_regexp+1F4j
		mov	ecx, [ebp+line_len]
		mov	edx, [ebp+line_len]
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	ebx, [ebp+p]
		add	ebx, 20h
		sub	esp, 8
		push	0		; regs
		push	ecx		; range
		push	0		; start
		push	edx		; length
		push	eax		; string
		push	ebx		; buffer
		call	re_search
		add	esp, 20h
		mov	[ebp+ret], eax
		cmp	[ebp+ret], 0FFFFFFFEh
		jnz	short loc_80010AF
		sub	esp, 0Ch
		push	offset aErrorInRegular ; "error	in regular expression search"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_80010AF:				; CODE XREF: process_regexp+226j
		cmp	[ebp+ret], 0FFFFFFFFh
		jnz	short loc_80010BD
		jmp	loc_8000FC1
; ---------------------------------------------------------------------------

loc_80010BA:				; CODE XREF: process_regexp+12Fj
		nop
		jmp	short loc_80010BE
; ---------------------------------------------------------------------------

loc_80010BD:				; CODE XREF: process_regexp+251j
		nop

loc_80010BE:				; CODE XREF: process_regexp+259j
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr ds:current_line
		mov	edx, dword ptr ds:current_line+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+break_line], eax
		mov	dword ptr [ebp+break_line+4], edx
		mov	eax, [ebp+p]
		mov	edx, [eax+18h]
		movzx	eax, [ebp+ignore]
		push	edx		; argnum
		push	eax		; ignore
		push	dword ptr [ebp+break_line+4]
		push	dword ptr [ebp+break_line] ; last_line
		call	write_to_file
		add	esp, 10h
		movzx	eax, [ebp+ignore]
		xor	eax, 1
		test	al, al
		jz	short loc_8001109
		call	close_output_file

loc_8001109:				; CODE XREF: process_regexp+2A0j
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [eax]
		test	edx, edx
		js	short loc_800112F
		test	edx, edx
		jg	short loc_800111E
		cmp	eax, 0
		jbe	short loc_800112F

loc_800111E:				; CODE XREF: process_regexp+2B5j
		mov	eax, dword ptr [ebp+break_line]
		mov	edx, dword ptr [ebp+break_line+4]
		mov	dword ptr ds:current_line, eax
		mov	dword ptr ds:current_line+4, edx

loc_800112F:				; CODE XREF: process_regexp+2B1j
					; process_regexp+2BAj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
process_regexp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void split_file()
split_file	proc near		; CODE XREF: main+492p

i		= dword	ptr -14h
j		= qword	ptr -10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	loc_800123E
; ---------------------------------------------------------------------------

loc_8001147:				; CODE XREF: split_file+111j
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	short loc_80011CC
		mov	dword ptr [ebp+j], 0
		mov	dword ptr [ebp+j+4], 0
		jmp	short loc_8001193
; ---------------------------------------------------------------------------

loc_800116C:				; CODE XREF: split_file+71j
					; split_file+89j ...
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		sub	esp, 4
		push	dword ptr [ebp+j+4]
		push	dword ptr [ebp+j] ; repetition
		push	eax		; p
		call	process_regexp
		add	esp, 10h
		add	dword ptr [ebp+j], 1
		adc	dword ptr [ebp+j+4], 0

loc_8001193:				; CODE XREF: split_file+35j
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jnz	short loc_800116C
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		cmp	edx, dword ptr [ebp+j+4]
		ja	short loc_800116C
		cmp	edx, dword ptr [ebp+j+4]
		jb	short loc_800123A
		cmp	eax, dword ptr [ebp+j]
		jnb	short loc_800116C
		jmp	short loc_800123A
; ---------------------------------------------------------------------------

loc_80011CC:				; CODE XREF: split_file+25j
		mov	dword ptr [ebp+j], 0
		mov	dword ptr [ebp+j+4], 0
		jmp	short loc_8001203
; ---------------------------------------------------------------------------

loc_80011DC:				; CODE XREF: split_file+E1j
					; split_file+F9j ...
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		sub	esp, 4
		push	dword ptr [ebp+j+4]
		push	dword ptr [ebp+j] ; repetition
		push	eax		; p
		call	process_line_count
		add	esp, 10h
		add	dword ptr [ebp+j], 1
		adc	dword ptr [ebp+j+4], 0

loc_8001203:				; CODE XREF: split_file+A5j
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jnz	short loc_80011DC
		mov	eax, ds:controls
		mov	edx, [ebp+i]
		shl	edx, 6
		add	eax, edx
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		cmp	edx, dword ptr [ebp+j+4]
		ja	short loc_80011DC
		cmp	edx, dword ptr [ebp+j+4]
		jb	short loc_800123A
		cmp	eax, dword ptr [ebp+j]
		jnb	short loc_80011DC

loc_800123A:				; CODE XREF: split_file+8Ej
					; split_file+95j ...
		add	[ebp+i], 1

loc_800123E:				; CODE XREF: split_file+Dj
		mov	eax, ds:control_used
		cmp	[ebp+i], eax
		jb	loc_8001147
		call	create_output_file
		call	dump_rest_of_file
		call	close_output_file
		nop
		leave
		retn
split_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	make_filename(unsigned int num)
make_filename	proc near		; CODE XREF: create_output_file+1Dp
					; delete_all_files+29p

num		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	edx, ds:prefix
		mov	eax, ds:filename_space
		sub	esp, 8
		push	edx		; src
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		mov	eax, ds:suffix
		test	eax, eax
		jz	short loc_80012B5
		mov	ebx, ds:suffix
		mov	esi, ds:filename_space
		mov	eax, ds:prefix
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, esi
		sub	esp, 4
		push	[ebp+num]
		push	ebx		; format
		push	eax		; s
		call	sprintf
		add	esp, 10h
		jmp	short loc_80012E6
; ---------------------------------------------------------------------------

loc_80012B5:				; CODE XREF: make_filename+24j
		mov	ebx, digits
		mov	esi, ds:filename_space
		mov	eax, ds:prefix
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, esi
		push	[ebp+num]
		push	ebx
		push	offset a0U	; "%0*u"
		push	eax		; s
		call	sprintf
		add	esp, 10h

loc_80012E6:				; CODE XREF: make_filename+55j
		mov	eax, ds:filename_space
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
make_filename	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void create_output_file()
create_output_file proc	near		; CODE XREF: process_line_count+49p
					; process_regexp+28p ...

fopen_ok	= byte ptr -91h
fopen_errno	= dword	ptr -90h
oldset		= sigset_t ptr -8Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 98h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:files_created
		sub	esp, 0Ch
		push	eax		; num
		call	make_filename
		add	esp, 10h
		mov	ds:output_filename, eax
		sub	esp, 4
		lea	eax, [ebp+oldset]
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		mov	eax, ds:output_filename
		sub	esp, 8
		push	offset aW	; "w"
		push	eax
		call	fopen_safer
		add	esp, 10h
		mov	ds:output_stream, eax
		mov	eax, ds:output_stream
		test	eax, eax
		setnz	al
		mov	[ebp+fopen_ok],	al
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+fopen_errno], eax
		movzx	edx, [ebp+fopen_ok]
		mov	eax, ds:files_created
		add	eax, edx
		mov	ds:files_created, eax
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+oldset]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h
		movzx	eax, [ebp+fopen_ok]
		xor	eax, 1
		test	al, al
		jz	short loc_80013C4
		mov	eax, ds:output_filename
		push	eax
		push	offset format	; "%s"
		push	[ebp+fopen_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_80013C4:				; CODE XREF: create_output_file+B0j
		mov	dword ptr ds:bytes_written, 0
		mov	dword ptr ds:bytes_written+4, 0
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80013EA
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80013EA:				; CODE XREF: create_output_file+F1j
		leave
		retn
create_output_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl delete_all_files(_Bool in_signal_handler)
delete_all_files proc near		; CODE XREF: cleanup+37p
					; interrupt_handler+Bp

in_signal_handler= byte	ptr -1Ch
i		= dword	ptr -10h
name		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+in_signal_handler], al
		movzx	eax, ds:remove_files
		xor	eax, 1
		test	al, al
		jnz	short loc_8001471
		mov	[ebp+i], 0
		jmp	short loc_800145B
; ---------------------------------------------------------------------------

loc_800140F:				; CODE XREF: delete_all_files+77j
		sub	esp, 0Ch
		push	[ebp+i]		; num
		call	make_filename
		add	esp, 10h
		mov	[ebp+name], eax
		sub	esp, 0Ch
		push	[ebp+name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001457
		movzx	eax, [ebp+in_signal_handler]
		xor	eax, 1
		test	al, al
		jz	short loc_8001457
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001457:				; CODE XREF: delete_all_files+44j
					; delete_all_files+4Fj
		add	[ebp+i], 1

loc_800145B:				; CODE XREF: delete_all_files+21j
		mov	eax, ds:files_created
		cmp	[ebp+i], eax
		jb	short loc_800140F
		mov	ds:files_created, 0
		jmp	short locret_8001472
; ---------------------------------------------------------------------------

loc_8001471:				; CODE XREF: delete_all_files+18j
		nop

locret_8001472:				; CODE XREF: delete_all_files+83j
		leave
		retn
delete_all_files endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void close_output_file()
close_output_file proc near		; CODE XREF: cleanup+14p
					; process_line_count:loc_8000D50p ...

unlink_ok	= byte ptr -0A9h
unlink_errno	= dword	ptr -0A8h
oldset		= sigset_t ptr -0A4h
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0B4h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:output_stream
		test	eax, eax
		jz	loc_800163A
		mov	eax, ds:output_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80014EB
		mov	eax, ds:output_filename
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWriteErrorForS ; "write	error for %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:output_stream, 0
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_80014EB:				; CODE XREF: close_output_file+35j
		mov	eax, ds:output_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_800152D
		mov	ebx, ds:output_filename
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:output_stream, 0
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_800152D:				; CODE XREF: close_output_file+8Aj
		mov	eax, dword ptr ds:bytes_written
		mov	edx, dword ptr ds:bytes_written+4
		or	eax, edx
		test	eax, eax
		jnz	loc_80015EA
		movzx	eax, ds:elide_empty_files
		test	al, al
		jz	loc_80015EA
		sub	esp, 4
		lea	eax, [ebp+oldset]
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		mov	eax, ds:output_filename
		sub	esp, 0Ch
		push	eax		; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+unlink_ok], al
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+unlink_errno], eax
		mov	edx, ds:files_created
		movzx	eax, [ebp+unlink_ok]
		sub	edx, eax
		mov	eax, edx
		mov	ds:files_created, eax
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+oldset]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h
		movzx	eax, [ebp+unlink_ok]
		xor	eax, 1
		test	al, al
		jz	short loc_800162F
		mov	eax, ds:output_filename
		push	eax
		push	offset format	; "%s"
		push	[ebp+unlink_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_800162F
; ---------------------------------------------------------------------------

loc_80015EA:				; CODE XREF: close_output_file+C8j
					; close_output_file+D7j
		movzx	eax, ds:suppress_count
		xor	eax, 1
		test	al, al
		jz	short loc_8001630
		mov	eax, dword ptr ds:bytes_written
		mov	edx, dword ptr ds:bytes_written+4
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stdout
		sub	esp, 4
		push	edx
		push	offset aS_0	; "%s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	short loc_8001630
; ---------------------------------------------------------------------------

loc_800162F:				; CODE XREF: close_output_file+157j
					; close_output_file+174j
		nop

loc_8001630:				; CODE XREF: close_output_file+182j
					; close_output_file+1B9j
		mov	ds:output_stream, 0

loc_800163A:				; CODE XREF: close_output_file+1Cj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_800164C
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800164C:				; CODE XREF: close_output_file+1D1j
		mov	ebx, [ebp+var_4]
		leave
		retn
close_output_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl save_line_to_file(const cstring *line)
save_line_to_file proc near		; CODE XREF: write_to_file+DEp
					; dump_rest_of_file+Ep	...

var_4		= dword	ptr -4
line		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ecx, ds:output_stream
		mov	eax, [ebp+line]
		mov	edx, [eax]
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, [ebp+line]
		mov	eax, [eax]
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr ds:bytes_written
		mov	edx, dword ptr ds:bytes_written+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:bytes_written, eax
		mov	dword ptr ds:bytes_written+4, edx
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
save_line_to_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; control *new_control_record()
new_control_record proc	near		; CODE XREF: extract_regexp+6Ep
					; parse_patterns:loc_8001A6Cp

p		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, ds:control_used
		mov	eax, ds:control_allocated_5514
		cmp	edx, eax
		jnz	short loc_80016D4
		mov	eax, ds:controls
		sub	esp, 4
		push	40h
		push	offset control_allocated_5514
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	ds:controls, eax

loc_80016D4:				; CODE XREF: new_control_record+13j
		mov	ecx, ds:controls
		mov	eax, ds:control_used
		lea	edx, [eax+1]
		mov	ds:control_used, edx
		shl	eax, 6
		add	eax, ecx
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	byte ptr [eax+1Eh], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+10h], 0
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+p]
		mov	byte ptr [eax+1Ch], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+p]
		leave
		retn
new_control_record endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_for_offset(control	*p, const char *str, const char	*num)
check_for_offset proc near		; CODE XREF: extract_regexp+13Dp

p		= dword	ptr  8
str		= dword	ptr  0Ch
num		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+p]
		sub	esp, 0Ch
		push	offset locale
		push	eax
		push	0Ah
		push	0
		push	[ebp+num]
		call	xstrtoimax
		add	esp, 20h
		test	eax, eax
		jz	short loc_800177A
		sub	esp, 0Ch
		push	offset aSIntegerExpect ; "%s: integer expected after delimiter"
		call	gettext
		add	esp, 10h
		push	[ebp+str]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800177A:				; CODE XREF: check_for_offset+23j
		nop
		leave
		retn
check_for_offset endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl parse_repeat_count(int argnum, control *p, char *str)
parse_repeat_count proc	near		; CODE XREF: parse_patterns+27Dp

str		= dword	ptr -30h
p		= dword	ptr -2Ch
end		= dword	ptr -1Ch
val		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argnum		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	[ebp+p], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+str], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+str]	; s
		call	strlen
		add	esp, 10h
		lea	edx, [eax-1]
		mov	eax, [ebp+str]
		add	eax, edx
		mov	[ebp+end], eax
		mov	eax, [ebp+end]
		movzx	eax, byte ptr [eax]
		cmp	al, 7Dh
		jz	short loc_80017DE
		sub	esp, 0Ch
		push	offset aSIsRequiredInR ; "%s: `}' is required in repeat count"
		call	gettext
		add	esp, 10h
		push	[ebp+str]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80017DE:				; CODE XREF: parse_repeat_count+3Fj
		mov	eax, [ebp+end]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+str]
		lea	edx, [eax+1]
		mov	eax, [ebp+end]
		sub	eax, 1
		cmp	edx, eax
		jnz	short loc_800180A
		mov	eax, [ebp+str]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ah
		jnz	short loc_800180A
		mov	eax, [ebp+p]
		mov	byte ptr [eax+1Ch], 1
		jmp	short loc_8001869
; ---------------------------------------------------------------------------

loc_800180A:				; CODE XREF: parse_repeat_count+75j
					; parse_repeat_count+82j
		mov	eax, [ebp+str]
		lea	edx, [eax+1]
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+val]
		push	eax
		push	0Ah
		push	0
		push	edx
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jz	short loc_800185A
		mov	eax, ds:global_argv
		mov	edx, [ebp+argnum]
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSIntegerRequir ; "%s}: integer required	between	`{' and `"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800185A:				; CODE XREF: parse_repeat_count+AEj
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	ecx, [ebp+p]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx

loc_8001869:				; CODE XREF: parse_repeat_count+8Bj
		mov	eax, [ebp+end]
		mov	byte ptr [eax],	7Dh
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001881
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001881:				; CODE XREF: parse_repeat_count+FDj
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_repeat_count endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; control *__cdecl extract_regexp(int argnum, _Bool ignore, const char *str)
extract_regexp	proc near		; CODE XREF: parse_patterns+89p

ignore		= byte ptr -2Ch
delim		= byte ptr -19h
closing_delim	= dword	ptr -18h
len		= dword	ptr -14h
p		= dword	ptr -10h
err		= dword	ptr -0Ch
var_4		= dword	ptr -4
argnum		= dword	ptr  8
arg_4		= dword	ptr  0Ch
str		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	[ebp+ignore], al
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		mov	[ebp+delim], al
		movsx	eax, [ebp+delim]
		mov	edx, [ebp+str]
		add	edx, 1
		sub	esp, 8
		push	eax		; c
		push	edx		; s
		call	strrchr
		add	esp, 10h
		mov	[ebp+closing_delim], eax
		cmp	[ebp+closing_delim], 0
		jnz	short loc_80018E4
		movsx	ebx, [ebp+delim]
		sub	esp, 0Ch
		push	offset aSClosingDelimi ; "%s: closing delimiter	`%c' missing"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	[ebp+str]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80018E4:				; CODE XREF: extract_regexp+34j
		mov	edx, [ebp+closing_delim]
		mov	eax, [ebp+str]
		sub	edx, eax
		mov	eax, edx
		sub	eax, 1
		mov	[ebp+len], eax
		call	new_control_record
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [ebp+argnum]
		mov	[eax+18h], edx
		mov	eax, [ebp+p]
		movzx	edx, [ebp+ignore]
		mov	[eax+1Dh], dl
		mov	eax, [ebp+p]
		mov	byte ptr [eax+1Eh], 1
		mov	eax, [ebp+p]
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+24h], 0
		sub	esp, 0Ch
		push	100h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+30h], edx
		mov	eax, [ebp+p]
		mov	dword ptr [eax+34h], 0
		mov	ds:re_syntax_options, 2C6h
		mov	eax, [ebp+p]
		lea	edx, [eax+20h]
		mov	eax, [ebp+str]
		add	eax, 1
		sub	esp, 4
		push	edx		; buffer
		push	[ebp+len]	; length
		push	eax		; pattern
		call	re_compile_pattern
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_80019A6
		sub	esp, 0Ch
		push	offset aSInvalidRegula ; "%s: invalid regular expression: %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+err]
		push	[ebp+str]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_80019A6:				; CODE XREF: extract_regexp+F3j
		mov	eax, [ebp+closing_delim]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80019CB
		mov	eax, [ebp+closing_delim]
		add	eax, 1
		sub	esp, 4
		push	eax		; num
		push	[ebp+str]	; str
		push	[ebp+p]		; p
		call	check_for_offset
		add	esp, 10h

loc_80019CB:				; CODE XREF: extract_regexp+12Bj
		mov	eax, [ebp+p]
		mov	ebx, [ebp+var_4]
		leave
		retn
extract_regexp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl parse_patterns(int argc,	int start, char	**argv)
parse_patterns	proc near		; CODE XREF: main+38Ap

argv		= dword	ptr -3Ch
i		= dword	ptr -38h
p		= dword	ptr -34h
val		= qword	ptr -30h
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
argc		= dword	ptr  8
start		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 40h
		mov	eax, [ebp+arg_8]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+start]
		mov	[ebp+i], eax
		jmp	loc_8001C5C
; ---------------------------------------------------------------------------

loc_80019F7:				; CODE XREF: parse_patterns+28Fj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_8001A27
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_8001A6C

loc_8001A27:				; CODE XREF: parse_patterns+3Aj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, ecx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		setz	al
		movzx	eax, al
		sub	esp, 4
		push	edx		; str
		push	eax		; ignore
		push	[ebp+i]		; argnum
		call	extract_regexp
		add	esp, 10h
		mov	[ebp+p], eax
		jmp	loc_8001C0B
; ---------------------------------------------------------------------------

loc_8001A6C:				; CODE XREF: parse_patterns+52j
		call	new_control_record
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [ebp+i]
		mov	[eax+18h], edx
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+val]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jz	short loc_8001ADA
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSInvalidPatter ; "%s: invalid pattern"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001ADA:				; CODE XREF: parse_patterns+D6j
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		or	eax, edx
		test	eax, eax
		jnz	short loc_8001B15
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSLineNumberMus ; "%s: line number must be greater than ze"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001B15:				; CODE XREF: parse_patterns+111j
		mov	ecx, dword ptr [ebp+val]
		mov	ebx, dword ptr [ebp+val+4]
		mov	eax, ds:last_val_5549
		mov	edx, ds:dword_800276C
		cmp	ebx, edx
		ja	short loc_8001B91
		cmp	ebx, edx
		jb	short loc_8001B32
		cmp	ecx, eax
		jnb	short loc_8001B91

loc_8001B32:				; CODE XREF: parse_patterns+159j
		mov	eax, ds:last_val_5549
		mov	edx, ds:dword_800276C
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aLineNumberSIsS ; "line number %s is smaller than precedin"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_8001B91:				; CODE XREF: parse_patterns+155j
					; parse_patterns+15Dj
		mov	ecx, dword ptr [ebp+val]
		mov	ebx, dword ptr [ebp+val+4]
		mov	eax, ds:last_val_5549
		mov	edx, ds:dword_800276C
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8001BEB
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWarningLineNum ; "warning: line	number %s is the same as "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001BEB:				; CODE XREF: parse_patterns+1D9j
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	ds:last_val_5549, eax
		mov	ds:dword_800276C, edx
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	ecx, [ebp+p]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx

loc_8001C0B:				; CODE XREF: parse_patterns+94j
		mov	eax, [ebp+i]
		add	eax, 1
		cmp	eax, [ebp+argc]
		jge	short loc_8001C58
		mov	eax, [ebp+i]
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 7Bh
		jnz	short loc_8001C58
		add	[ebp+i], 1
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		push	eax		; str
		push	[ebp+p]		; p
		push	[ebp+i]		; argnum
		call	parse_repeat_count
		add	esp, 10h

loc_8001C58:				; CODE XREF: parse_patterns+241j
					; parse_patterns+25Cj
		add	[ebp+i], 1

loc_8001C5C:				; CODE XREF: parse_patterns+1Fj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+argc]
		jl	loc_80019F7
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001C7A
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001C7A:				; CODE XREF: parse_patterns+2A0j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
parse_patterns	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl get_format_flags(char **format_ptr)
get_format_flags proc near		; CODE XREF: max_out+79p

count		= dword	ptr -4
format_ptr	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+count], 0
		jmp	short loc_8001CD7
; ---------------------------------------------------------------------------

loc_8001C90:				; CODE XREF: get_format_flags+60j
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 23h
		jz	short loc_8001CBE
		cmp	eax, 23h
		jg	short loc_8001CAC
		cmp	eax, 20h
		jz	short loc_8001CB8
		jmp	short loc_8001CC4
; ---------------------------------------------------------------------------

loc_8001CAC:				; CODE XREF: get_format_flags+22j
		cmp	eax, 2Bh
		jz	short loc_8001CB8
		cmp	eax, 2Dh
		jz	short loc_8001CC9
		jmp	short loc_8001CC4
; ---------------------------------------------------------------------------

loc_8001CB8:				; CODE XREF: get_format_flags+27j
					; get_format_flags+2Ej
		or	[ebp+count], 1
		jmp	short loc_8001CCA
; ---------------------------------------------------------------------------

loc_8001CBE:				; CODE XREF: get_format_flags+1Dj
		or	[ebp+count], 2
		jmp	short loc_8001CCA
; ---------------------------------------------------------------------------

loc_8001CC4:				; CODE XREF: get_format_flags+29j
					; get_format_flags+35j
		mov	eax, [ebp+count]
		jmp	short locret_8001CE6
; ---------------------------------------------------------------------------

loc_8001CC9:				; CODE XREF: get_format_flags+33j
		nop

loc_8001CCA:				; CODE XREF: get_format_flags+3Bj
					; get_format_flags+41j
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		lea	edx, [eax+1]
		mov	eax, [ebp+format_ptr]
		mov	[eax], edx

loc_8001CD7:				; CODE XREF: get_format_flags+Dj
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8001C90
		mov	eax, [ebp+count]

locret_8001CE6:				; CODE XREF: get_format_flags+46j
		leave
		retn
get_format_flags endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl get_format_width(char **format_ptr)
get_format_width proc near		; CODE XREF: max_out+8Bp

format_ptr	= dword	ptr -1Ch
val		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+format_ptr], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+val], 0
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_8001D59
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+val]
		push	edx
		push	0Ah
		push	[ebp+format_ptr]
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jz	short loc_8001D59
		sub	esp, 0Ch
		push	offset aInvalidFormatW ; "invalid format width"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D59:				; CODE XREF: get_format_width+2Fj
					; get_format_width+4Fj
		mov	eax, [ebp+val]
		mov	edx, 0Bh
		cmp	eax, 0Bh
		cmovb	eax, edx
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8001D78
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001D78:				; CODE XREF: get_format_width+89j
		leave
		retn
get_format_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl get_format_prec(char **format_ptr)
get_format_prec	proc near		; CODE XREF: max_out+9Dp

format_ptr	= dword	ptr -1Ch
val		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+format_ptr], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jz	short loc_8001DA4
		mov	eax, 0
		jmp	short loc_8001E0E
; ---------------------------------------------------------------------------

loc_8001DA4:				; CODE XREF: get_format_prec+21j
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		lea	edx, [eax+1]
		mov	eax, [ebp+format_ptr]
		mov	[eax], edx
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8001DCB
		mov	eax, 0
		jmp	short loc_8001E0E
; ---------------------------------------------------------------------------

loc_8001DCB:				; CODE XREF: get_format_prec+48j
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+val]
		push	edx
		push	0Ah
		push	[ebp+format_ptr]
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jz	short loc_8001E0B
		sub	esp, 0Ch
		push	offset aInvalidFormatP ; "invalid format precision"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001E0B:				; CODE XREF: get_format_prec+6Fj
		mov	eax, [ebp+val]

loc_8001E0E:				; CODE XREF: get_format_prec+28j
					; get_format_prec+4Fj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8001E1F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001E1F:				; CODE XREF: get_format_prec+9Ej
		leave
		retn
get_format_prec	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl get_format_conv_type(char **format_ptr)
get_format_conv_type proc near		; CODE XREF: max_out+BCp

ch_0		= byte ptr -9
var_4		= dword	ptr -4
format_ptr	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+format_ptr]
		mov	eax, [eax]
		lea	ecx, [eax+1]
		mov	edx, [ebp+format_ptr]
		mov	[edx], ecx
		movzx	eax, byte ptr [eax]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		cmp	eax, 69h
		jz	loc_8001F0A
		cmp	eax, 69h
		jg	short loc_8001E65
		cmp	eax, 58h
		jz	loc_8001F0A
		cmp	eax, 64h
		jz	loc_8001F0A
		test	eax, eax
		jz	short loc_8001E82
		jmp	short loc_8001EA4
; ---------------------------------------------------------------------------

loc_8001E65:				; CODE XREF: get_format_conv_type+2Aj
		cmp	eax, 75h
		jz	loc_8001F0A
		cmp	eax, 78h
		jz	loc_8001F0A
		cmp	eax, 6Fh
		jz	loc_8001F0A
		jmp	short loc_8001EA4
; ---------------------------------------------------------------------------

loc_8001E82:				; CODE XREF: get_format_conv_type+40j
		sub	esp, 0Ch
		push	offset aMissingConvers ; "missing conversion specifier in suffix"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001F0B
; ---------------------------------------------------------------------------

loc_8001EA4:				; CODE XREF: get_format_conv_type+42j
					; get_format_conv_type+5Fj
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+ch_0]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8001EE6
		movzx	ebx, [ebp+ch_0]
		sub	esp, 0Ch
		push	offset aInvalidConvers ; "invalid conversion specifier in suffix:"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001F0B
; ---------------------------------------------------------------------------

loc_8001EE6:				; CODE XREF: get_format_conv_type+9Fj
		movzx	ebx, [ebp+ch_0]
		sub	esp, 0Ch
		push	offset aInvalidConve_0 ; "invalid conversion specifier in suffix:"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001F0B
; ---------------------------------------------------------------------------

loc_8001F0A:				; CODE XREF: get_format_conv_type+21j
					; get_format_conv_type+2Fj ...
		nop

loc_8001F0B:				; CODE XREF: get_format_conv_type+81j
					; get_format_conv_type+C3j ...
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
get_format_conv_type endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl max_out(char *format)
max_out		proc near		; CODE XREF: main+300p

percent		= byte ptr -15h
out_count	= dword	ptr -14h
width		= dword	ptr -10h
prec		= dword	ptr -0Ch
format		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+out_count], 0
		mov	[ebp+percent], 0
		jmp	loc_8001FD5
; ---------------------------------------------------------------------------

loc_8001F27:				; CODE XREF: max_out+CCj
		mov	eax, [ebp+format]
		lea	edx, [eax+1]
		mov	[ebp+format], edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jz	short loc_8001F40
		add	[ebp+out_count], 1
		jmp	loc_8001FD5
; ---------------------------------------------------------------------------

loc_8001F40:				; CODE XREF: max_out+24j
		mov	eax, [ebp+format]
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_8001F59
		mov	eax, [ebp+format]
		add	eax, 1
		mov	[ebp+format], eax
		add	[ebp+out_count], 1
		jmp	short loc_8001FD5
; ---------------------------------------------------------------------------

loc_8001F59:				; CODE XREF: max_out+37j
		cmp	[ebp+percent], 0
		jz	short loc_8001F7F
		sub	esp, 0Ch
		push	offset aTooManyConvers ; "too many %% conversion specifications	i"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001F7F:				; CODE XREF: max_out+4Cj
		mov	[ebp+percent], 1
		sub	esp, 0Ch
		lea	eax, [ebp+format]
		push	eax		; format_ptr
		call	get_format_flags
		add	esp, 10h
		add	[ebp+out_count], eax
		sub	esp, 0Ch
		lea	eax, [ebp+format]
		push	eax		; format_ptr
		call	get_format_width
		add	esp, 10h
		mov	[ebp+width], eax
		sub	esp, 0Ch
		lea	eax, [ebp+format]
		push	eax		; format_ptr
		call	get_format_prec
		add	esp, 10h
		mov	[ebp+prec], eax
		mov	eax, [ebp+width]
		cmp	[ebp+prec], eax
		cmovnb	eax, [ebp+prec]
		add	[ebp+out_count], eax
		sub	esp, 0Ch
		lea	eax, [ebp+format]
		push	eax		; format_ptr
		call	get_format_conv_type
		add	esp, 10h

loc_8001FD5:				; CODE XREF: max_out+11j max_out+2Aj ...
		mov	eax, [ebp+format]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001F27
		movzx	eax, [ebp+percent]
		xor	eax, 1
		test	al, al
		jz	short loc_800200E
		sub	esp, 0Ch
		push	offset aMissingConve_0 ; "missing %% conversion	specification in "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800200E:				; CODE XREF: max_out+DBj
		mov	eax, [ebp+out_count]
		leave
		retn
max_out		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0BCh
val		= dword	ptr -0B4h
i		= dword	ptr -0B0h
optc		= dword	ptr -0ACh
act		= sigaction ptr	-0A8h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0B8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, [ebp+argv]
		mov	ds:global_argv,	eax
		mov	ds:controls, 0
		mov	ds:control_used, 0
		mov	ds:suppress_count, 0
		mov	ds:remove_files, 1
		mov	ds:prefix, offset aXx ;	"xx"
		jmp	loc_8002233
; ---------------------------------------------------------------------------

loc_80020D7:				; CODE XREF: main+24Cj
		mov	eax, [ebp+optc]
		cmp	eax, 6Bh
		jz	loc_8002169
		cmp	eax, 6Bh
		jg	short loc_800211C
		cmp	eax, 0FFFFFF7Eh
		jz	loc_80021E7
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_800210D
		cmp	eax, 0FFFFFF7Dh
		jz	loc_80021F1
		jmp	loc_8002229
; ---------------------------------------------------------------------------

loc_800210D:				; CODE XREF: main+E8j
		cmp	eax, 62h
		jz	short loc_800215A
		cmp	eax, 66h
		jz	short loc_800214B
		jmp	loc_8002229
; ---------------------------------------------------------------------------

loc_800211C:				; CODE XREF: main+D6j
		cmp	eax, 71h
		jz	loc_80021D5
		cmp	eax, 71h
		jg	short loc_8002134
		cmp	eax, 6Eh
		jz	short loc_8002175
		jmp	loc_8002229
; ---------------------------------------------------------------------------

loc_8002134:				; CODE XREF: main+115j
		cmp	eax, 73h
		jz	loc_80021D5
		cmp	eax, 7Ah
		jz	loc_80021DE
		jmp	loc_8002229
; ---------------------------------------------------------------------------

loc_800214B:				; CODE XREF: main+102j
		mov	eax, ds:optarg
		mov	ds:prefix, eax
		jmp	loc_8002233
; ---------------------------------------------------------------------------

loc_800215A:				; CODE XREF: main+FDj
		mov	eax, ds:optarg
		mov	ds:suffix, eax
		jmp	loc_8002233
; ---------------------------------------------------------------------------

loc_8002169:				; CODE XREF: main+CDj
		mov	ds:remove_files, 0
		jmp	loc_8002233
; ---------------------------------------------------------------------------

loc_8002175:				; CODE XREF: main+11Aj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+val]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_80021A4
		mov	eax, [ebp+val]
		test	eax, eax
		jns	short loc_80021C8

loc_80021A4:				; CODE XREF: main+185j
		mov	esi, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidNumber ; "%s: invalid number"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80021C8:				; CODE XREF: main+18Fj
		mov	eax, [ebp+val]
		mov	digits,	eax
		jmp	short loc_8002233
; ---------------------------------------------------------------------------

loc_80021D5:				; CODE XREF: main+10Cj	main+124j
		mov	ds:suppress_count, 1
		jmp	short loc_8002233
; ---------------------------------------------------------------------------

loc_80021DE:				; CODE XREF: main+12Dj
		mov	ds:elide_empty_files, 1
		jmp	short loc_8002233
; ---------------------------------------------------------------------------

loc_80021E7:				; CODE XREF: main+DDj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80021F1:				; CODE XREF: main+EFj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aStuartKemp ; "Stuart Kemp"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aCsplit	; "csplit"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002229:				; CODE XREF: main+F5j main+104j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002233:				; CODE XREF: main+BFj main+142j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "f:b:kn:sqz"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80020D7
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 1
		jg	short loc_80022EE
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_80022A0
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_80022E4
; ---------------------------------------------------------------------------

loc_80022A0:				; CODE XREF: main+269j
		mov	eax, [ebx]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingOpera_0 ; "missing operand after	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80022E4:				; CODE XREF: main+28Bj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80022EE:				; CODE XREF: main+260j
		mov	eax, ds:suffix
		test	eax, eax
		jz	short loc_8002333
		mov	eax, ds:prefix
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	esi, eax
		mov	eax, ds:suffix
		sub	esp, 0Ch
		push	eax		; format
		call	max_out
		add	esp, 10h
		add	eax, esi
		add	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:filename_space, eax
		jmp	short loc_8002361
; ---------------------------------------------------------------------------

loc_8002333:				; CODE XREF: main+2E2j
		mov	eax, ds:prefix
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, digits
		add	eax, edx
		add	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:filename_space, eax

loc_8002361:				; CODE XREF: main+31Ej
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; name
		call	set_input_file
		add	esp, 10h
		mov	eax, ds:optind
		sub	esp, 4
		push	[ebp+argv]	; argv
		push	eax		; start
		push	dword ptr [ebx]	; argc
		call	parse_patterns
		add	esp, 10h
		sub	esp, 0Ch
		push	offset caught_signals ;	set
		call	sigemptyset
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8002413
; ---------------------------------------------------------------------------

loc_80023C1:				; CODE XREF: main+407j
		mov	eax, [ebp+i]
		mov	eax, ds:sig_5619[eax*4]
		sub	esp, 4
		lea	edx, [ebp+act]
		push	edx		; oact
		push	0		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h
		mov	eax, dword ptr [ebp+act.__sigaction_handler]
		cmp	eax, 1
		jz	short loc_800240C
		mov	eax, [ebp+i]
		mov	eax, ds:sig_5619[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigaddset
		add	esp, 10h

loc_800240C:				; CODE XREF: main+3D9j
		add	[ebp+i], 1

loc_8002413:				; CODE XREF: main+3ACj
		cmp	[ebp+i], 0Ah
		jle	short loc_80023C1
		mov	dword ptr [ebp+act.__sigaction_handler], offset	interrupt_handler
		lea	eax, [ebp+act.sa_mask]
		mov	ebx, offset caught_signals
		mov	edx, 20h
		mov	edi, eax
		mov	esi, ebx
		mov	ecx, edx
		rep movsd
		mov	[ebp+act.sa_flags], 0C0000000h
		mov	[ebp+i], 0
		jmp	short loc_800249C
; ---------------------------------------------------------------------------

loc_8002451:				; CODE XREF: main+490j
		mov	eax, [ebp+i]
		mov	eax, ds:sig_5619[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002495
		mov	eax, [ebp+i]
		mov	eax, ds:sig_5619[eax*4]
		sub	esp, 4
		push	0		; oact
		lea	edx, [ebp+act]
		push	edx		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h

loc_8002495:				; CODE XREF: main+45Ej
		add	[ebp+i], 1

loc_800249C:				; CODE XREF: main+43Cj
		cmp	[ebp+i], 0Ah
		jle	short loc_8002451
		call	split_file
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_80024E8
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	cleanup_fatal
; ---------------------------------------------------------------------------

loc_80024E8:				; CODE XREF: main+4A6j
		sub	esp, 0Ch
		push	0		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1D9p	main+21Bp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800252F
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800266F
; ---------------------------------------------------------------------------

loc_800252F:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	FILE PATTERN...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOutputPiecesOf ; "Output pieces	of FILE	separated by PATT"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBSuffixFormatF ; "  -b,	--suffix-format=FORMAT	use sprin"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNDigitsDigitsU ; "  -n,	--digits=DIGITS	       use specif"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aReadStandardIn ; "\nRead standard input	if FILE	is -.  Ea"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIntegerCopyUpT ; "\n  INTEGER		 copy up to but	n"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800266F:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status

loc_8002675:				; DATA XREF: .eh_frame:0800332Co
					; .eh_frame:08003350o ...
		call	exit
usage		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 800267Ch
; volatile int digits
digits		dd 2			; DATA XREF: make_filename:loc_80012B5r
					; main+1BBw ...
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8002680h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; buffer_record	*head
head		dd ?			; DATA XREF: save_buffer+1Cr
					; save_buffer+28w ...
; char *hold_area
hold_area	dd ?			; DATA XREF: save_to_hold_area+6r
					; save_to_hold_area+1Aw ...
; size_t hold_count
hold_count	dd ?			; DATA XREF: save_to_hold_area+22w
					; load_buffer:loc_800063Dr ...
		align 10h
; uintmax_t last_line_number
last_line_number dq ?			; DATA XREF: record_line_starts+DEr
					; record_line_starts+112r ...
; uintmax_t current_line
current_line	dq ?			; DATA XREF: remove_line+55r
					; remove_line+77w ...
; _Bool	have_read_eof
have_read_eof	db ?			; DATA XREF: read_input+30w
					; record_line_starts+90r ...
		align 4
; char *volatile filename_space
filename_space	dd ?			; DATA XREF: make_filename+Br
					; make_filename+2Cr ...
; const	char *volatile prefix
prefix		dd ?			; DATA XREF: make_filename+5r
					; make_filename+32r ...
; char *volatile suffix
suffix		dd ?			; DATA XREF: make_filename+1Dr
					; make_filename+26r ...
; volatile unsigned int	files_created
files_created	dd ?			; DATA XREF: create_output_file+14r
					; create_output_file+82r ...
		align 8
; uintmax_t bytes_written
bytes_written	dq ?			; DATA XREF: create_output_file:loc_80013C4w
					; close_output_file:loc_800152Dr ...
; FILE *output_stream
output_stream	dd ?			; DATA XREF: create_output_file+59w
					; create_output_file+5Er ...
; char *output_filename
output_filename	dd ?			; DATA XREF: create_output_file+25w
					; create_output_file+43r ...
; char **global_argv
global_argv	dd ?			; DATA XREF: write_to_file:loc_8000AD6r
					; write_to_file+9Br ...
; _Bool	suppress_count
suppress_count	db ?			; DATA XREF: close_output_file:loc_80015EAr
					; main+A7w ...
; volatile _Bool remove_files
remove_files	db ?			; DATA XREF: delete_all_files+Cr
					; main+AEw ...
; _Bool	elide_empty_files
elide_empty_files db ?			; DATA XREF: close_output_file+CEr
					; main:loc_80021DEw
		align 10h
; control *controls
controls	dd ?			; DATA XREF: split_file:loc_8001147r
					; split_file:loc_800116Cr ...
; size_t control_used
control_used	dd ?			; DATA XREF: split_file:loc_800123Er
					; new_control_record+6r ...
		align 10h
; sigset_t caught_signals
caught_signals	sigset_t <?>		; DATA XREF: cleanup+23o
					; create_output_file+34o ...
; Function-local static	variable
; buffer_record	*prev_buf_5391
prev_buf_5391	dd ?			; DATA XREF: remove_line+7r
					; remove_line+10r ...
; Function-local static	variable
; size_t control_allocated_5514
control_allocated_5514 dd ?		; DATA XREF: new_control_record+Cr
					; new_control_record+1Fo
; Function-local static	variable
; uintmax_t last_val_5549
last_val_5549	dd ?			; DATA XREF: parse_patterns+148r
					; parse_patterns:loc_8001B32r ...
dword_800276C	dd ?			; DATA XREF: parse_patterns+14Dr
					; parse_patterns+164r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8002780h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+5Bo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+1F9o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aDigits		db 'digits',0           ; DATA XREF: .rodata:longoptso
aQuiet		db 'quiet',0            ; DATA XREF: .rodata:longoptso
aSilent		db 'silent',0           ; DATA XREF: .rodata:longoptso
aKeepFiles	db 'keep-files',0       ; DATA XREF: .rodata:longoptso
aElideEmptyFile	db 'elide-empty-files',0 ; DATA XREF: .rodata:longoptso
aPrefix		db 'prefix',0           ; DATA XREF: .rodata:longoptso
aSuffixFormat	db 'suffix-format',0    ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 10h
; const	option longopts[10]
longopts	option <offset aDigits,	1, 0, 6Eh> ; DATA XREF:	main+225o
		option <offset aQuiet, 0, 0, 71h> ; "digits"
		option <offset aSilent,	0, 0, 73h>
		option <offset aKeepFiles, 0, 0, 6Bh>
		option <offset aElideEmptyFile,	0, 0, 7Ah>
		option <offset aPrefix,	1, 0, 66h>
		option <offset aSuffixFormat, 1, 0, 62h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aMemoryExhauste[]
aMemoryExhauste	db 'memory exhausted',0 ; DATA XREF: xalloc_die+9o
; char format[]
format		db '%s',0               ; DATA XREF: xalloc_die+17o
					; create_output_file+B8o ...
; char aReadError[]
aReadError	db 'read error',0       ; DATA XREF: read_input+40o main+4ABo
; char aInputDisappear[]
aInputDisappear	db 'input disappeared',0 ; DATA XREF: get_first_line_in_buffer+1Fo
; char asc_80029F1[]
asc_80029F1	db '-',0                ; DATA XREF: set_input_file+8o
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: set_input_file+44o
; char aSLineNumberOut[]
aSLineNumberOut	db '%s: line number out of range',0 ; DATA XREF: write_to_file+4Bo
					; write_to_file+ADo
		align 4
; char aSSLineNumberOu[]
aSSLineNumberOu	db '%s: %s: line number out of range',0 ; DATA XREF: handle_line_error+56o
; char aOnRepetitionS[]
aOnRepetitionS	db ' on repetition %s',0Ah,0 ; DATA XREF: handle_line_error+9Ao
					; regexp_error+99o
; char aSSMatchNotFoun[]
aSSMatchNotFoun	db '%s: %s: match not found',0 ; DATA XREF: regexp_error+55o
; char aErrorInRegular[]
aErrorInRegular	db 'error in regular expression search',0 ; DATA XREF: process_regexp+109o
					; process_regexp+22Bo
; char a0U[]
a0U		db '%0*u',0             ; DATA XREF: make_filename+7Ao
aW		db 'w',0                ; DATA XREF: create_output_file+4Bo
; char aWriteErrorForS[]
aWriteErrorForS	db 'write error for %s',0 ; DATA XREF: close_output_file+4Do
; char aS_0[]
aS_0		db '%s',0Ah,0           ; DATA XREF: close_output_file+1ABo
; char locale[3]
locale		db 3 dup(0)		; DATA XREF: check_for_offset+Co
					; parse_repeat_count+96o ...
; char aSIntegerExpect[]
aSIntegerExpect	db '%s: integer expected after delimiter',0
					; DATA XREF: check_for_offset+28o
		align 4
; char aSIsRequiredInR[]
aSIsRequiredInR	db '%s: `}',27h,' is required in repeat count',0
					; DATA XREF: parse_repeat_count+44o
; char aSIntegerRequir[]
aSIntegerRequir	db '%s}: integer required between `{',27h,' and `}',27h,0
					; DATA XREF: parse_repeat_count+C2o
		align 4
; char aSClosingDelimi[]
aSClosingDelimi	db '%s: closing delimiter `%c',27h,' missing',0
					; DATA XREF: extract_regexp+3Do
		align 4
; char aSInvalidRegula[]
aSInvalidRegula	db '%s: invalid regular expression: %s',0 ; DATA XREF: extract_regexp+F8o
; char aSInvalidPatter[]
aSInvalidPatter	db '%s: invalid pattern',0 ; DATA XREF: parse_patterns+ECo
		align 10h
; char aSLineNumberMus[]
aSLineNumberMus	db '%s: line number must be greater than zero',0
					; DATA XREF: parse_patterns+127o
		align 4
; char aLineNumberSIsS[]
aLineNumberSIsS	db 'line number %s is smaller than preceding line number, %s',0
					; DATA XREF: parse_patterns+19Fo
		align 4
; char aWarningLineNum[]
aWarningLineNum	db 'warning: line number %s is the same as preceding line number',0
					; DATA XREF: parse_patterns+1FDo
; char aInvalidFormatW[]
aInvalidFormatW	db 'invalid format width',0 ; DATA XREF: get_format_width+54o
; char aInvalidFormatP[]
aInvalidFormatP	db 'invalid format precision',0 ; DATA XREF: get_format_prec+74o
		align 4
; char aMissingConvers[]
aMissingConvers	db 'missing conversion specifier in suffix',0
					; DATA XREF: get_format_conv_type+64o
		align 4
; char aInvalidConvers[]
aInvalidConvers	db 'invalid conversion specifier in suffix: %c',0
					; DATA XREF: get_format_conv_type+A8o
		align 4
; char aInvalidConve_0[]
aInvalidConve_0	db 'invalid conversion specifier in suffix: \%.3o',0
					; DATA XREF: get_format_conv_type+CCo
		align 4
; char aTooManyConvers[]
aTooManyConvers	db 'too many %% conversion specifications in suffix',0
					; DATA XREF: max_out+51o
; char aMissingConve_0[]
aMissingConve_0	db 'missing %% conversion specification in suffix',0
					; DATA XREF: max_out+E0o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+56o
aXx		db 'xx',0               ; DATA XREF: main+B5o
; char aSInvalidNumber[]
aSInvalidNumber	db '%s: invalid number',0 ; DATA XREF: main+19Ao
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+1EEo
aStuartKemp	db 'Stuart Kemp',0      ; DATA XREF: main+1F3o
aCsplit		db 'csplit',0           ; DATA XREF: main+1FEo
; char shortopts[]
shortopts	db 'f:b:kn:sqz',0       ; DATA XREF: main+22Ao
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+26Eo
; char aMissingOpera_0[]
aMissingOpera_0	db 'missing operand after %s',0 ; DATA XREF: main+2B6o
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... FILE PATTERN...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aOutputPiecesOf[]
aOutputPiecesOf	db 'Output pieces of FILE separated by PATTERN(s) to files `xx00',27h,','
					; DATA XREF: usage+69o
		db ' `xx01',27h,', ...,',0Ah
		db 'and output byte counts of each piece to standard output.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 10h
; char aBSuffixFormatF[]
aBSuffixFormatF	db '  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d',0Ah
					; DATA XREF: usage+AFo
		db '  -f, --prefix=PREFIX        use PREFIX instead of `xx',27h,0Ah
		db '  -k, --keep-files           do not remove output files on errors'
		db 0Ah,0
; char aNDigitsDigitsU[]
aNDigitsDigitsU	db '  -n, --digits=DIGITS        use specified number of digits inste'
					; DATA XREF: usage+D2o
		db 'ad of 2',0Ah
		db '  -s, --quiet, --silent      do not print counts of output file s'
		db 'izes',0Ah
		db '  -z, --elide-empty-files    remove empty output files',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+F5o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+118o
		align 4
; char aReadStandardIn[]
aReadStandardIn	db 0Ah			; DATA XREF: usage+13Bo
		db 'Read standard input if FILE is -.  Each PATTERN may be:',0Ah,0
		align 4
; char aIntegerCopyUpT[]
aIntegerCopyUpT	db 0Ah			; DATA XREF: usage+15Eo
		db '  INTEGER            copy up to but not including specified line '
		db 'number',0Ah
		db '  /REGEXP/[OFFSET]   copy up to but not including a matching line'
		db 0Ah
		db '  %REGEXP%[OFFSET]   skip to, but not including a matching line',0Ah
		db '  {INTEGER}          repeat the previous pattern specified number'
		db ' of times',0Ah
		db '  {*}                repeat the previous pattern as many times as'
		db ' possible',0Ah
		db 0Ah
		db 'A line OFFSET is a required `+',27h,' or `-',27h,' followed by a positi'
		db 've integer.',0Ah,0
		align 20h
; Function-local static	variable
; const	int sig_5619[11]
sig_5619	dd 0Eh			; DATA XREF: main+3B4r	main+3E1r ...
		dd 1, 2, 0Dh, 3, 0Fh, 1Dh, 1Bh,	1Ah, 18h, 19h
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 800330Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8002675-80059A1h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset loc_8002675-80058A9h
		dd 69h,	80E4100h, 0D420285h, 0C5650205h, 4040Ch, 18h, 60h
		dd offset loc_8002675-8005860h
		dd 15h,	80E4100h, 0D420285h, 5,	18h, 7Ch
		dd offset loc_8002675-8005867h
		dd 2Dh,	80E4100h, 0D420285h, 5,	1Ch, 98h
		dd offset loc_8002675-8005856h
		dd 24h,	80E4100h, 0D420285h, 0CC56005h,	404h, 1Ch, 0B8h
		dd offset loc_8002675-8005852h
		dd 2Ah,	80E4100h, 0D420285h, 0CC56605h,	404h, 20h, 0D8h
		dd offset loc_8002675-8005848h
		dd 72h,	80E4100h, 0D420285h, 3834405h, 0C3C56A02h, 4040Ch
		dd 1Ch,	0FCh
		dd offset loc_8002675-80057FAh
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 1Ch, 11Ch
		dd offset loc_8002675-80057F7h
		dd 39h,	80E4100h, 0D420285h, 0CC57505h,	404h, 20h, 13Ch
		dd offset loc_8002675-80057DEh
		dd 0A6h, 80E4100h, 0D420285h, 3834405h,	41C39D02h, 4040CC5h
		dd 20h,	160h
		dd offset loc_8002675-800575Ch
		dd 134h, 80E4100h, 0D420285h, 3834405h,	0C5012C03h, 4040CC3h
		dd 1Ch,	184h
		dd offset loc_8002675-800564Ch
		dd 53h,	80E4100h, 0D420285h, 0C54F0205h, 4040Ch, 1Ch, 1A4h
		dd offset loc_8002675-8005619h
		dd 8Eh,	80E4100h, 0D420285h, 0C58A0205h, 4040Ch, 1Ch, 1C4h
		dd offset loc_8002675-80055ABh
		dd 25h,	80E4100h, 0D420285h, 0CC56105h,	404h, 1Ch, 1E4h
		dd offset loc_8002675-80055A6h
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 1Ch, 204h
		dd offset loc_8002675-800556Eh
		dd 171h, 80E4100h, 0D420285h, 16D0305h,	4040CC5h, 20h
		dd 224h
		dd offset loc_8002675-800541Dh
		dd 54h,	80E4100h, 0D420285h, 3834405h, 0C3C54C02h, 4040Ch
		dd 20h,	248h
		dd offset loc_8002675-80053EDh
		dd 125h, 80E4100h, 0D420285h, 3834405h,	0C5011D03h, 4040CC3h
		dd 20h,	26Ch
		dd offset loc_8002675-80052ECh
		dd 0FEh, 80E4100h, 0D420285h, 3834405h,	41C3F502h, 4040CC5h
		dd 1Ch,	290h
		dd offset loc_8002675-8005212h
		dd 2Bh,	80E4100h, 0D420285h, 0CC56705h,	404h, 24h, 2B0h
		dd offset loc_8002675-8005207h
		dd 6Fh,	80E4100h, 0D420285h, 3864205h, 67020483h, 41C641C3h
		dd 4040CC5h, 20h, 2D8h
		dd offset loc_8002675-80051C0h
		dd 109h, 80E4100h, 0D420285h, 3834405h,	0C5010103h, 4040CC3h
		dd 1Ch,	2FCh
		dd offset loc_8002675-80050DBh
		dd 27h,	80E4100h, 0D420285h, 0CC56305h,	404h, 1Ch, 31Ch
		dd offset loc_8002675-80050D4h
		dd 0D6h, 80E4100h, 0D420285h, 3864505h,	483h, 28h, 33Ch
		dd offset loc_8002675-800501Eh
		dd 0D5h, 80E4100h, 0D420285h, 3874605h,	5830486h, 41C3C802h
		dd 41C741C6h, 4040CC5h,	1Ch, 368h
		dd offset loc_8002675-8004F75h
		dd 0EAh, 80E4100h, 0D420285h, 3864505h,	483h, 20h, 388h
		dd offset loc_8002675-8004EABh
		dd 2D3h, 80E4100h, 0D420285h, 3834405h,	0C502CB03h, 4040CC3h
		dd 1Ch,	3ACh
		dd offset loc_8002675-8004BFCh
		dd 129h, 80E4100h, 0D420285h, 1250305h,	4040CC5h, 24h
		dd 3CCh
		dd offset loc_8002675-8004AF3h
		dd 94h,	80E4100h, 0D420285h, 3864205h, 8C020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 3F4h
		dd offset loc_8002675-8004A87h
		dd 0FAh, 80E4100h, 0D420285h, 0C5F60205h, 4040Ch, 1Ch
		dd 414h
		dd offset loc_8002675-80049ADh
		dd 88h,	80E4100h, 0D420285h, 0C5840205h, 4040Ch, 20h, 434h
		dd offset loc_8002675-8004945h
		dd 1DDh, 80E4100h, 0D420285h, 3834705h,	0C501D203h, 4040CC3h
		dd 20h,	458h
		dd offset loc_8002675-800478Ch
		dd 51h,	80E4100h, 0D420285h, 3834405h, 0C3C54902h, 4040Ch
		dd 1Ch,	47Ch
		dd offset loc_8002675-800475Fh
		dd 93h,	80E4100h, 0D420285h, 0C58F0205h, 4040Ch, 1Ch, 49Ch
		dd offset loc_8002675-80046ECh
		dd 48h,	80E4100h, 0D420285h, 0C5440205h, 4040Ch, 20h, 4BCh
		dd offset loc_8002675-80046C4h
		dd 109h, 80E4100h, 0D420285h, 3834405h,	0C5010103h, 4040CC3h
		dd 20h,	4E0h
		dd offset loc_8002675-80045DFh
		dd 14Dh, 80E4100h, 0D420285h, 3834405h,	0C5014503h, 4040CC3h
		dd 28h,	504h
		dd offset loc_8002675-80044B6h
		dd 2AEh, 80E4100h, 0D420285h, 3864505h,	0A3030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 530h
		dd offset loc_8002675-8004234h
		dd 67h,	80E4100h, 0D420285h, 0C5630205h, 4040Ch, 1Ch, 550h
		dd offset loc_8002675-80041EDh
		dd 92h,	80E4100h, 0D420285h, 0C58E0205h, 4040Ch, 1Ch, 570h
		dd offset loc_8002675-800417Bh
		dd 0A7h, 80E4100h, 0D420285h, 0C5A30205h, 4040Ch, 20h
		dd 590h
		dd offset loc_8002675-80040F4h
		dd 0F0h, 80E4100h, 0D420285h, 3834405h,	0C3C5E802h, 4040Ch
		dd 1Ch,	5B4h
		dd offset loc_8002675-8004028h
		dd 102h, 80E4100h, 0D420285h, 0C5FE0205h, 4040Ch, 2Ch
		dd 5D4h
		dd offset loc_8002675-8003F46h
		dd 4DFh, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h, 18h,	604h
		dd offset loc_8002675-8003A97h
		dd 188h, 80E4100h, 0D420285h, 3834405h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; close_output_file+1A2r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+4Bp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; int sigprocmask(int how, const sigset_t *set,	sigset_t *oset)
		extrn sigprocmask:near	; CODE XREF: cleanup+2Ap cleanup+4Dp ...
		extrn __stack_chk_fail:near ; CODE XREF: cleanup+62p
					; create_output_file+F3p ...
; void exit(int	status)
		extrn exit:near		; CODE XREF: cleanup_fatal+10p
					; process_regexp+9Fp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: xalloc_die+20p
					; read_input+5Dp ...
; int raise(int	sig)
		extrn raise:near	; CODE XREF: interrupt_handler+19p
; void free(void *ptr)
		extrn free:near		; CODE XREF: save_to_hold_area+Fp
					; free_buffer+10p ...
		extrn safe_read:near	; CODE XREF: read_input+1Fp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: read_input+4Fp
					; get_first_line_in_buffer+2Ep	...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: new_line_control+Ep
					; create_new_buffer+Bp	...
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: record_line_starts+3Fp
; void *xmemdup(const void *, size_t, size_t)
		extrn xmemdup:near	; CODE XREF: record_line_starts+BEp
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: load_buffer+72p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: set_input_file+10p
		extrn fd_reopen:near	; CODE XREF: set_input_file+25p
		extrn quote:near	; CODE XREF: set_input_file+37p
					; handle_line_error+43p ...
		extrn umaxtostr:near	; CODE XREF: handle_line_error+37p
					; handle_line_error+8Dp ...
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: handle_line_error+65r
					; handle_line_error+A9r ...
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: handle_line_error+6Ep
					; handle_line_error+B4p ...
; int fputc(int	c, FILE	*stream)
		extrn fputc:near	; CODE XREF: handle_line_error+C9p
					; regexp_error+C8p
; int re_search(struct re_pattern_buffer *buffer, const	char *string, int length, int start, int range,	struct re_registers *regs)
		extrn re_search:near	; CODE XREF: process_regexp+F5p
					; process_regexp+217p
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: make_filename+15p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: make_filename+3Bp
					; make_filename+6Cp ...
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: make_filename+4Dp
					; make_filename+80p
		extrn fopen_safer:near	; CODE XREF: create_output_file+51p
; int unlink(const char	*name)
		extrn unlink:near	; CODE XREF: delete_all_files+3Ap
					; close_output_file+FFp
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	close_output_file+2Bp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: close_output_file+80p
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	save_line_to_file+1Dp
		extrn x2nrealloc:near	; CODE XREF: new_control_record+25p
		extrn xstrtoimax:near	; CODE XREF: check_for_offset+19p
		extrn xstrtoumax:near	; CODE XREF: parse_repeat_count+A4p
					; parse_patterns+CCp
; char *strrchr(const char *s, int c)
		extrn strrchr:near	; CODE XREF: extract_regexp+25p
; reg_syntax_t re_syntax_options
		extrn re_syntax_options:dword ;	DATA XREF: extract_regexp+C6w
; const	char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer)
		extrn re_compile_pattern:near ;	CODE XREF: extract_regexp+E4p
		extrn xstrtoul:near	; CODE XREF: get_format_width+45p
					; get_format_prec+65p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: get_format_conv_type:loc_8001EA4p
		extrn set_program_name:near ; CODE XREF: main+39p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+60p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+70p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+7Bo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+80p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_800214Br
					; main:loc_800215Ar ...
		extrn Version:dword	; DATA XREF: main:loc_80021F1r
		extrn version_etc:near	; CODE XREF: main+204p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+237p
; int optind
		extrn optind:dword	; DATA XREF: main+252r	main+262r ...
; int sigemptyset(sigset_t *set)
		extrn sigemptyset:near	; CODE XREF: main+39Ap
; int sigaction_0(int sig, const struct	sigaction *act,	struct sigaction *oact)
		extrn sigaction_0:near	; CODE XREF: main+3C8p	main+47Ap
; int sigaddset(sigset_t *set, int signo)
		extrn sigaddset:near	; CODE XREF: main+3F1p
; int sigismember(const	sigset_t *set, int signo)
		extrn sigismember:near	; CODE XREF: main+454p
; int close(int	fd)
		extrn close:near	; CODE XREF: main+49Cp


		end
