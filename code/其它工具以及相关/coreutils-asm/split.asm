;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	67A4E6CA80074D8C09CCBA3BC1D7676F
; Input	CRC32 :	90FC9958

; File Name   :	D:\coreutils-o\split.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'split.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void *__cdecl	ptr_align(const	void *ptr, size_t alignment)
ptr_align	proc near		; CODE XREF: main+856p

p0		= dword	ptr -8
p1		= dword	ptr -4
ptr		= dword	ptr  8
alignment	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+ptr]
		mov	[ebp+p0], eax
		mov	eax, [ebp+alignment]
		lea	edx, [eax-1]
		mov	eax, [ebp+p0]
		add	eax, edx
		mov	[ebp+p1], eax
		mov	eax, [ebp+p1]
		mov	edx, 0
		div	[ebp+alignment]
		mov	eax, edx
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+p1]
		add	eax, edx
		leave
		retn
ptr_align	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_size_note()
emit_size_note	proc near		; CODE XREF: usage+135p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset msgid	; "\nSIZE may be (or may be an integer opt"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_size_note	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+13Ap

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSBugsToS ; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000148
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000148
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000148:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	bad_cast(const char *s)
bad_cast	proc near		; CODE XREF: main+AFp main+C4p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+s]
		pop	ebp
		retn
bad_cast	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl io_blksize(stat sb)
io_blksize	proc near		; CODE XREF: main+824p

sb		= stat ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+sb.st_blksize]
		test	eax, eax
		jle	short loc_80001C1
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_80001C1
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 7FFFh
		jle	short loc_80001C1
		mov	eax, [ebp+sb.st_blksize]
		test	eax, eax
		jle	short loc_80001BA
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_80001BA
		mov	eax, [ebp+sb.st_blksize]
		jmp	short loc_80001C6
; ---------------------------------------------------------------------------

loc_80001BA:				; CODE XREF: io_blksize+23j
					; io_blksize+2Dj
		mov	eax, 200h
		jmp	short loc_80001C6
; ---------------------------------------------------------------------------

loc_80001C1:				; CODE XREF: io_blksize+8j
					; io_blksize+12j ...
		mov	eax, 8000h

loc_80001C6:				; CODE XREF: io_blksize+32j
					; io_blksize+39j
		pop	ebp
		retn
io_blksize	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1FAp	main+23Dp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000205
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000307
; ---------------------------------------------------------------------------

loc_8000205:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[INPUT [PREFIX]]\"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOutputFixedSiz ; "Output fixed-size pieces of INPUT to PR"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aASuffixLengthN ; "  -a,	--suffix-length=N   use	suffixes "...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stdout
		sub	esp, 4
		push	2
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVerbosePrintAD ; "	--verbose	    print a diagn"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_size_note
		call	emit_ancillary_info

loc_8000307:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void next_file_name()
next_file_name	proc near		; CODE XREF: cwrite:loc_8000509p

i		= dword	ptr -14h
outbase_length	= dword	ptr -10h
outfile_length	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:outfile
		test	eax, eax
		jnz	loc_80003E9
		mov	eax, ds:outbase
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+outbase_length], eax
		mov	edx, suffix_length
		mov	eax, [ebp+outbase_length]
		add	eax, edx
		mov	[ebp+outfile_length], eax
		mov	eax, [ebp+outfile_length]
		add	eax, 1
		cmp	eax, [ebp+outbase_length]
		jnb	short loc_8000358
		call	xalloc_die

loc_8000358:				; CODE XREF: next_file_name+3Fj
		mov	eax, [ebp+outfile_length]
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:outfile, eax
		mov	edx, ds:outfile
		mov	eax, [ebp+outbase_length]
		add	eax, edx
		mov	ds:outfile_mid,	eax
		mov	edx, ds:outbase
		mov	eax, ds:outfile
		sub	esp, 4
		push	[ebp+outbase_length] ; n
		push	edx		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	ecx, suffix_length
		mov	eax, suffix_alphabet
		movzx	eax, byte ptr [eax]
		movsx	edx, al
		mov	eax, ds:outfile_mid
		sub	esp, 4
		push	ecx		; n
		push	edx		; c
		push	eax		; s
		call	memset
		add	esp, 10h
		mov	edx, ds:outfile
		mov	eax, [ebp+outfile_length]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	eax, suffix_length
		sub	esp, 8
		push	4		; size_t
		push	eax		; size_t
		call	xcalloc
		add	esp, 10h
		mov	ds:sufindex_5164, eax
		jmp	loc_80004B1
; ---------------------------------------------------------------------------

loc_80003E9:				; CODE XREF: next_file_name+Ej
		mov	eax, suffix_length
		mov	[ebp+i], eax
		jmp	loc_800047D
; ---------------------------------------------------------------------------

loc_80003F6:				; CODE XREF: next_file_name+176j
		mov	eax, ds:sufindex_5164
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	edx, [eax]
		add	edx, 1
		mov	[eax], edx
		mov	edx, ds:outfile_mid
		mov	eax, [ebp+i]
		add	edx, eax
		mov	ecx, suffix_alphabet
		mov	eax, ds:sufindex_5164
		mov	ebx, [ebp+i]
		shl	ebx, 2
		add	eax, ebx
		mov	eax, [eax]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		mov	[edx], al
		mov	edx, ds:outfile_mid
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80004B0
		mov	eax, ds:sufindex_5164
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	dword ptr [eax], 0
		mov	edx, ds:outfile_mid
		mov	eax, [ebp+i]
		add	edx, eax
		mov	ecx, suffix_alphabet
		mov	eax, ds:sufindex_5164
		mov	ebx, [ebp+i]
		shl	ebx, 2
		add	eax, ebx
		mov	eax, [eax]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		mov	[edx], al

loc_800047D:				; CODE XREF: next_file_name+DFj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	[ebp+i], edx
		test	eax, eax
		jnz	loc_80003F6
		sub	esp, 0Ch
		push	offset aOutputFileSuff ; "output file suffixes exhausted"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_80004B1
; ---------------------------------------------------------------------------

loc_80004B0:				; CODE XREF: next_file_name+12Fj
		nop

loc_80004B1:				; CODE XREF: next_file_name+D2j
					; next_file_name+19Cj
		mov	ebx, [ebp+var_4]
		leave
		retn
next_file_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cwrite(_Bool new_file_flag, const char *bp_0, size_t bytes)
cwrite		proc near		; CODE XREF: bytes_split+94p
					; bytes_split+C4p ...

new_file_flag	= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
bp_0		= dword	ptr  0Ch
bytes		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	[ebp+new_file_flag], al
		cmp	[ebp+new_file_flag], 0
		jz	loc_8000598
		mov	eax, ds:output_desc
		test	eax, eax
		js	short loc_8000509
		mov	eax, ds:output_desc
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000509
		mov	ebx, ds:outfile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000509:				; CODE XREF: cwrite+1Ej cwrite+33j
		call	next_file_name
		movzx	eax, ds:verbose
		test	al, al
		jz	short loc_8000551
		mov	eax, ds:outfile
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCreatingFileS ;	"creating file %s\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stdout
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h

loc_8000551:				; CODE XREF: cwrite+61j
		mov	eax, ds:outfile
		sub	esp, 4
		push	1B6h
		push	241h
		push	eax
		call	open_safer
		add	esp, 10h
		mov	ds:output_desc,	eax
		mov	eax, ds:output_desc
		test	eax, eax
		jns	short loc_8000598
		mov	ebx, ds:outfile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000598:				; CODE XREF: cwrite+11j cwrite+C2j
		mov	eax, ds:output_desc
		sub	esp, 4
		push	[ebp+bytes]
		push	[ebp+bp_0]
		push	eax
		call	full_write
		add	esp, 10h
		cmp	eax, [ebp+bytes]
		jz	short loc_80005D2
		mov	ebx, ds:outfile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80005D2:				; CODE XREF: cwrite+FCj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
cwrite		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl bytes_split(uintmax_t n_bytes, char *buf, size_t	bufsize)
bytes_split	proc near		; CODE XREF: main+8BEp

n_bytes		= qword	ptr -30h
new_file_flag	= byte ptr -21h
to_read		= dword	ptr -20h
bp_out		= dword	ptr -1Ch
n_read		= dword	ptr -18h
w		= dword	ptr -14h
to_write	= qword	ptr -10h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
buf		= dword	ptr  10h
bufsize		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	[ebp+new_file_flag], 1
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		mov	dword ptr [ebp+to_write], eax
		mov	dword ptr [ebp+to_write+4], edx

loc_80005FB:				; CODE XREF: bytes_split+F4j
		sub	esp, 4
		push	[ebp+bufsize]
		push	[ebp+buf]
		push	0
		call	full_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8000635
		mov	ebx, ds:infile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000635:				; CODE XREF: bytes_split+3Dj
		mov	eax, [ebp+buf]
		mov	[ebp+bp_out], eax
		mov	eax, [ebp+n_read]
		mov	[ebp+to_read], eax

loc_8000641:				; CODE XREF: bytes_split+E8j
		mov	eax, [ebp+to_read]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+to_write+4]
		ja	short loc_8000688
		cmp	edx, dword ptr [ebp+to_write+4]
		jb	short loc_8000658
		cmp	eax, dword ptr [ebp+to_write]
		jnb	short loc_8000688

loc_8000658:				; CODE XREF: bytes_split+79j
		cmp	[ebp+to_read], 0
		jz	short loc_80006C5
		movzx	eax, [ebp+new_file_flag]
		sub	esp, 4
		push	[ebp+to_read]	; bytes
		push	[ebp+bp_out]	; bp_0
		push	eax		; new_file_flag
		call	cwrite
		add	esp, 10h
		mov	eax, [ebp+to_read]
		mov	edx, 0
		sub	dword ptr [ebp+to_write], eax
		sbb	dword ptr [ebp+to_write+4], edx
		mov	[ebp+new_file_flag], 0
		jmp	short loc_80006C5
; ---------------------------------------------------------------------------

loc_8000688:				; CODE XREF: bytes_split+74j
					; bytes_split+7Ej
		mov	eax, dword ptr [ebp+to_write]
		mov	[ebp+w], eax
		movzx	eax, [ebp+new_file_flag]
		sub	esp, 4
		push	[ebp+w]		; bytes
		push	[ebp+bp_out]	; bp_0
		push	eax		; new_file_flag
		call	cwrite
		add	esp, 10h
		mov	eax, [ebp+w]
		add	[ebp+bp_out], eax
		mov	eax, [ebp+w]
		sub	[ebp+to_read], eax
		mov	[ebp+new_file_flag], 1
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		mov	dword ptr [ebp+to_write], eax
		mov	dword ptr [ebp+to_write+4], edx
		jmp	loc_8000641
; ---------------------------------------------------------------------------

loc_80006C5:				; CODE XREF: bytes_split+84j
					; bytes_split+AEj
		nop
		mov	eax, [ebp+n_read]
		cmp	eax, [ebp+bufsize]
		jz	loc_80005FB
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
bytes_split	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl lines_split(uintmax_t n_lines, char *buf, size_t	bufsize)
lines_split	proc near		; CODE XREF: main+89Ap

n_lines		= qword	ptr -30h
new_file_flag	= byte ptr -25h
bp_0		= dword	ptr -24h
bp_out		= dword	ptr -20h
n_read		= dword	ptr -1Ch
eob		= dword	ptr -18h
len		= dword	ptr -14h
n		= qword	ptr -10h
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
buf		= dword	ptr  10h
bufsize		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	[ebp+new_file_flag], 1
		mov	dword ptr [ebp+n], 0
		mov	dword ptr [ebp+n+4], 0

loc_80006FD:				; CODE XREF: lines_split+13Fj
		sub	esp, 4
		push	[ebp+bufsize]
		push	[ebp+buf]
		push	0
		call	full_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8000737
		mov	ebx, ds:infile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000737:				; CODE XREF: lines_split+3Fj
		mov	eax, [ebp+buf]
		mov	[ebp+bp_out], eax
		mov	eax, [ebp+bp_out]
		mov	[ebp+bp_0], eax
		mov	edx, [ebp+bp_0]
		mov	eax, [ebp+n_read]
		add	eax, edx
		mov	[ebp+eob], eax
		mov	eax, [ebp+eob]
		mov	byte ptr [eax],	0Ah

loc_8000754:				; CODE XREF: lines_split+EFj
					; lines_split+F9j ...
		mov	edx, [ebp+eob]
		mov	eax, [ebp+bp_0]
		sub	edx, eax
		mov	eax, edx
		add	eax, 1
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+bp_0]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+bp_0], eax
		mov	eax, [ebp+bp_0]
		cmp	eax, [ebp+eob]
		jnz	short loc_80007B2
		mov	eax, [ebp+eob]
		cmp	eax, [ebp+bp_out]
		jz	loc_8000810
		mov	edx, [ebp+eob]
		mov	eax, [ebp+bp_out]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+len], eax
		movzx	eax, [ebp+new_file_flag]
		sub	esp, 4
		push	[ebp+len]	; bytes
		push	[ebp+bp_out]	; bp_0
		push	eax		; new_file_flag
		call	cwrite
		add	esp, 10h
		mov	[ebp+new_file_flag], 0
		jmp	short loc_8000810
; ---------------------------------------------------------------------------

loc_80007B2:				; CODE XREF: lines_split+A3j
		add	[ebp+bp_0], 1
		add	dword ptr [ebp+n], 1
		adc	dword ptr [ebp+n+4], 0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		cmp	edx, dword ptr [ebp+n_lines+4]
		jb	short loc_8000754
		cmp	edx, dword ptr [ebp+n_lines+4]
		ja	short loc_80007D3
		cmp	eax, dword ptr [ebp+n_lines]
		jb	short loc_8000754

loc_80007D3:				; CODE XREF: lines_split+F4j
		mov	edx, [ebp+bp_0]
		mov	eax, [ebp+bp_out]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		movzx	eax, [ebp+new_file_flag]
		sub	esp, 4
		push	edx		; bytes
		push	[ebp+bp_out]	; bp_0
		push	eax		; new_file_flag
		call	cwrite
		add	esp, 10h
		mov	eax, [ebp+bp_0]
		mov	[ebp+bp_out], eax
		mov	[ebp+new_file_flag], 1
		mov	dword ptr [ebp+n], 0
		mov	dword ptr [ebp+n+4], 0
		jmp	loc_8000754
; ---------------------------------------------------------------------------

loc_8000810:				; CODE XREF: lines_split+ABj
					; lines_split+D8j
		nop
		mov	eax, [ebp+n_read]
		cmp	eax, [ebp+bufsize]
		jz	loc_80006FD
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
lines_split	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl line_bytes_split(size_t n_bytes)
line_bytes_split proc near		; CODE XREF: main+8D8p

eof		= byte ptr -19h
bp_0		= dword	ptr -18h
n_buffered	= dword	ptr -14h
buf		= dword	ptr -10h
n_read		= dword	ptr -0Ch
var_4		= dword	ptr -4
n_bytes		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+eof], 0
		mov	[ebp+n_buffered], 0
		sub	esp, 0Ch
		push	[ebp+n_bytes]	; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax

loc_8000846:				; CODE XREF: line_bytes_split+10Fj
		mov	eax, [ebp+n_bytes]
		sub	eax, [ebp+n_buffered]
		mov	ecx, [ebp+buf]
		mov	edx, [ebp+n_buffered]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	0
		call	full_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_800088A
		mov	ebx, ds:infile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800088A:				; CODE XREF: line_bytes_split+47j
		mov	eax, [ebp+n_read]
		add	[ebp+n_buffered], eax
		mov	eax, [ebp+n_buffered]
		cmp	eax, [ebp+n_bytes]
		jz	short loc_80008A6
		cmp	[ebp+n_buffered], 0
		jz	loc_800093A
		mov	[ebp+eof], 1

loc_80008A6:				; CODE XREF: line_bytes_split+73j
		mov	edx, [ebp+buf]
		mov	eax, [ebp+n_buffered]
		add	eax, edx
		mov	[ebp+bp_0], eax
		mov	eax, [ebp+n_buffered]
		cmp	eax, [ebp+n_bytes]
		jnz	short loc_80008D4
		jmp	short loc_80008BF
; ---------------------------------------------------------------------------

loc_80008BB:				; CODE XREF: line_bytes_split+AFj
		sub	[ebp+bp_0], 1

loc_80008BF:				; CODE XREF: line_bytes_split+96j
		mov	eax, [ebp+bp_0]
		cmp	eax, [ebp+buf]
		jbe	short loc_80008D4
		mov	eax, [ebp+bp_0]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 0Ah
		jnz	short loc_80008BB

loc_80008D4:				; CODE XREF: line_bytes_split+94j
					; line_bytes_split+A2j
		mov	eax, [ebp+bp_0]
		cmp	eax, [ebp+buf]
		jnz	short loc_80008E7
		mov	edx, [ebp+buf]
		mov	eax, [ebp+n_buffered]
		add	eax, edx
		mov	[ebp+bp_0], eax

loc_80008E7:				; CODE XREF: line_bytes_split+B7j
		mov	edx, [ebp+bp_0]
		mov	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; bytes
		push	[ebp+buf]	; bp_0
		push	1		; new_file_flag
		call	cwrite
		add	esp, 10h
		mov	edx, [ebp+bp_0]
		mov	eax, [ebp+buf]
		sub	edx, eax
		mov	eax, edx
		sub	[ebp+n_buffered], eax
		cmp	[ebp+n_buffered], 0
		jz	short loc_8000929
		sub	esp, 4
		push	[ebp+n_buffered] ; n
		push	[ebp+bp_0]	; src
		push	[ebp+buf]	; dest
		call	memmove
		add	esp, 10h

loc_8000929:				; CODE XREF: line_bytes_split+F0j
		movzx	eax, [ebp+eof]
		xor	eax, 1
		test	al, al
		jnz	loc_8000846
		jmp	short loc_800093B
; ---------------------------------------------------------------------------

loc_800093A:				; CODE XREF: line_bytes_split+79j
		nop

loc_800093B:				; CODE XREF: line_bytes_split+115j
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
line_bytes_split endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0CCh
split_type	= dword	ptr -0BCh
digits_optind	= dword	ptr -0B8h
page_size	= dword	ptr -0B4h
this_optind	= dword	ptr -0B0h
c		= dword	ptr -0ACh
in_blk_size	= dword	ptr -0A8h
buf		= dword	ptr -0A4h
n_units		= qword	ptr -0A0h
tmp		= dword	ptr -94h
buffer		= byte ptr -31h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0C8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+split_type], 0
		call	getpagesize
		mov	[ebp+page_size], eax
		mov	[ebp+digits_optind], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		sub	esp, 0Ch
		push	offset s	; "-"
		call	bad_cast
		add	esp, 10h
		mov	ds:infile, eax
		sub	esp, 0Ch
		push	offset asc_800198B ; "x"
		call	bad_cast
		add	esp, 10h
		mov	ds:outbase, eax

loc_8000A20:				; CODE XREF: main+635j	main+63Bj ...
		mov	eax, ds:optind
		test	eax, eax
		jz	short loc_8000A30
		mov	eax, ds:optind
		jmp	short loc_8000A35
; ---------------------------------------------------------------------------

loc_8000A30:				; CODE XREF: main+D8j
		mov	eax, 1

loc_8000A35:				; CODE XREF: main+DFj
		mov	[ebp+this_optind], eax
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "0123456789C:a:b:dl:"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jz	loc_8000F9B
		mov	eax, [ebp+c]
		cmp	eax, 43h
		jz	loc_8000CAA
		cmp	eax, 43h
		jg	short loc_8000AB4
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000F24
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_8000AA3
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000F2E
		jmp	loc_8000F79
; ---------------------------------------------------------------------------

loc_8000AA3:				; CODE XREF: main+142j
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_8000F79
		jmp	loc_8000D61
; ---------------------------------------------------------------------------

loc_8000AB4:				; CODE XREF: main+130j
		cmp	eax, 64h
		jz	loc_8000F0F
		cmp	eax, 64h
		jg	short loc_8000AD5
		cmp	eax, 61h
		jz	short loc_8000AEE
		cmp	eax, 62h
		jz	loc_8000B5E
		jmp	loc_8000F79
; ---------------------------------------------------------------------------

loc_8000AD5:				; CODE XREF: main+171j
		cmp	eax, 6Ch
		jz	loc_8000C04
		cmp	eax, 80h
		jz	loc_8000F1B
		jmp	loc_8000F79
; ---------------------------------------------------------------------------

loc_8000AEE:				; CODE XREF: main+176j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000B20
		mov	eax, [ebp+tmp]
		cmp	eax, 3FFFFFFFh
		jbe	short loc_8000B4E

loc_8000B20:				; CODE XREF: main+1C2j
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidSuffix ; "%s: invalid suffix length"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000B4E:				; CODE XREF: main+1CFj
		mov	eax, [ebp+tmp]
		mov	suffix_length, eax
		jmp	loc_8000F96
; ---------------------------------------------------------------------------

loc_8000B5E:				; CODE XREF: main+17Bj
		cmp	[ebp+split_type], 0
		jz	short loc_8000B91
		sub	esp, 0Ch
		push	offset aCannotSplitInM ; "cannot split in more than one	way"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000B91:				; CODE XREF: main+216j
		mov	[ebp+split_type], 1
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset multipliers_5236	; "bEGKkMmPTYZ0"
		lea	edx, [ebp+n_units]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000BD6
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		or	eax, edx
		test	eax, eax
		jnz	loc_8000F83

loc_8000BD6:				; CODE XREF: main+26Fj
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidNumber ; "%s: invalid number of	bytes"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C04:				; CODE XREF: main+189j
		cmp	[ebp+split_type], 0
		jz	short loc_8000C37
		sub	esp, 0Ch
		push	offset aCannotSplitInM ; "cannot split in more than one	way"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C37:				; CODE XREF: main+2BCj
		mov	[ebp+split_type], 3
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+n_units]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000C7C
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		or	eax, edx
		test	eax, eax
		jnz	loc_8000F89

loc_8000C7C:				; CODE XREF: main+315j
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidNumb_0 ; "%s: invalid number of	lines"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CAA:				; CODE XREF: main+127j
		cmp	[ebp+split_type], 0
		jz	short loc_8000CDD
		sub	esp, 0Ch
		push	offset aCannotSplitInM ; "cannot split in more than one	way"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CDD:				; CODE XREF: main+362j
		mov	[ebp+split_type], 2
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset multipliers_5236	; "bEGKkMmPTYZ0"
		lea	edx, [ebp+n_units]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000D33
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		or	eax, edx
		test	eax, eax
		jz	short loc_8000D33
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		cmp	edx, 0
		jbe	loc_8000F8F

loc_8000D33:				; CODE XREF: main+3BBj	main+3CDj
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidNumber ; "%s: invalid number of	bytes"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000D61:				; CODE XREF: main+160j
		cmp	[ebp+split_type], 0
		jnz	short loc_8000D88
		mov	[ebp+split_type], 4
		mov	dword ptr [ebp+n_units], 0
		mov	dword ptr [ebp+n_units+4], 0

loc_8000D88:				; CODE XREF: main+419j
		cmp	[ebp+split_type], 0
		jz	short loc_8000DC4
		cmp	[ebp+split_type], 4
		jz	short loc_8000DC4
		sub	esp, 0Ch
		push	offset aCannotSplitInM ; "cannot split in more than one	way"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000DC4:				; CODE XREF: main+440j	main+449j
		cmp	[ebp+digits_optind], 0
		jz	short loc_8000DEF
		mov	eax, [ebp+digits_optind]
		cmp	eax, [ebp+this_optind]
		jz	short loc_8000DEF
		mov	dword ptr [ebp+n_units], 0
		mov	dword ptr [ebp+n_units+4], 0

loc_8000DEF:				; CODE XREF: main+47Cj	main+48Aj
		mov	eax, [ebp+this_optind]
		mov	[ebp+digits_optind], eax
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		cmp	edx, 19999999h
		ja	loc_8000EB7
		cmp	edx, 19999999h
		jb	short loc_8000E26
		cmp	eax, 99999999h
		ja	loc_8000EB7

loc_8000E26:				; CODE XREF: main+4CAj
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		imul	esi, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, esi
		mov	esi, 0Ah
		mul	esi
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+c]
		sub	ecx, 30h
		mov	esi, ecx
		mov	edi, ecx
		sar	edi, 1Fh
		add	esi, eax
		adc	edi, edx
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		cmp	edi, edx
		jb	short loc_8000EB7
		cmp	edi, edx
		ja	short loc_8000E71
		cmp	esi, eax
		jb	short loc_8000EB7

loc_8000E71:				; CODE XREF: main+51Cj
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		imul	esi, edx, 0Ah
		imul	ecx, eax, 0
		add	ecx, esi
		mov	esi, 0Ah
		mul	esi
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+c]
		sub	ecx, 30h
		mov	esi, ecx
		mov	edi, ecx
		sar	edi, 1Fh
		add	eax, esi
		adc	edx, edi
		mov	dword ptr [ebp+n_units], eax
		mov	dword ptr [ebp+n_units+4], edx
		mov	eax, 0
		jmp	short loc_8000EBC
; ---------------------------------------------------------------------------

loc_8000EB7:				; CODE XREF: main+4BEj	main+4D1j ...
		mov	eax, 1

loc_8000EBC:				; CODE XREF: main+566j
		test	al, al
		jz	loc_8000F95
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		sub	esp, 4
		lea	ecx, [ebp+buffer]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aLineCountOptio ; "line count option -%s%c... is	too large"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+c]
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h
		jmp	loc_8000F95
; ---------------------------------------------------------------------------

loc_8000F0F:				; CODE XREF: main+168j
		mov	suffix_alphabet, offset	a0123456789 ; "0123456789"
		jmp	short loc_8000F96
; ---------------------------------------------------------------------------

loc_8000F1B:				; CODE XREF: main+194j
		mov	ds:verbose, 1
		jmp	short loc_8000F96
; ---------------------------------------------------------------------------

loc_8000F24:				; CODE XREF: main+137j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F2E:				; CODE XREF: main+149j
		sub	esp, 8
		push	offset aTorbjRnGranlun ; "Torbjörn Granlund"
		push	offset aTorbjornGranlu ; "Torbjorn Granlund"
		call	proper_name_utf8
		add	esp, 10h
		mov	ecx, eax
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aRichardM_Stall ; "Richard M. Stallman"
		push	ecx
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aSplit	; "split"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000F79:				; CODE XREF: main+14Fj	main+15Aj ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F83:				; CODE XREF: main+281j
		nop
		jmp	loc_8000A20
; ---------------------------------------------------------------------------

loc_8000F89:				; CODE XREF: main+327j
		nop
		jmp	loc_8000A20
; ---------------------------------------------------------------------------

loc_8000F8F:				; CODE XREF: main+3DEj
		nop
		jmp	loc_8000A20
; ---------------------------------------------------------------------------

loc_8000F95:				; CODE XREF: main+56Fj	main+5BBj
		nop

loc_8000F96:				; CODE XREF: main+20Aj	main+5CAj ...
		jmp	loc_8000A20
; ---------------------------------------------------------------------------

loc_8000F9B:				; CODE XREF: main+118j
		nop
		cmp	[ebp+split_type], 0
		jnz	short loc_8000FC3
		mov	[ebp+split_type], 3
		mov	dword ptr [ebp+n_units], 3E8h
		mov	dword ptr [ebp+n_units+4], 0

loc_8000FC3:				; CODE XREF: main+654j
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		or	eax, edx
		test	eax, eax
		jnz	short loc_8000FFF
		sub	esp, 0Ch
		push	offset aInvalidNumberO ; "invalid number of lines: 0"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000FFF:				; CODE XREF: main+684j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_800102C
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	ds:infile, eax

loc_800102C:				; CODE XREF: main+6B7j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_8001059
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	ds:outbase, eax

loc_8001059:				; CODE XREF: main+6E4j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_80010AE
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80010AE:				; CODE XREF: main+711j
		mov	eax, ds:infile
		sub	esp, 8
		push	offset s	; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001119
		mov	eax, ds:infile
		push	0
		push	0
		push	eax
		push	0
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8001119
		mov	eax, ds:infile
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001119:				; CODE XREF: main+777j	main+78Fj
		mov	ds:output_desc,	0FFFFFFFFh
		sub	esp, 8
		lea	eax, [ebp+tmp]
		push	eax
		push	0
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001159
		mov	ebx, ds:infile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001159:				; CODE XREF: main+7EAj
		sub	esp, 60h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+tmp]
		mov	edx, 18h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	io_blksize
		add	esp, 60h
		mov	[ebp+in_blk_size], eax
		mov	edx, [ebp+in_blk_size]
		mov	eax, [ebp+page_size]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		sub	esp, 8
		push	[ebp+page_size]	; alignment
		push	eax		; ptr
		call	ptr_align
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, [ebp+split_type]
		cmp	eax, 2
		jz	short loc_8001217
		cmp	eax, 2
		ja	short loc_80011CA
		cmp	eax, 1
		jz	short loc_80011F3
		jmp	short loc_8001231
; ---------------------------------------------------------------------------

loc_80011CA:				; CODE XREF: main+872j
		cmp	eax, 4
		ja	short loc_8001231
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		push	[ebp+in_blk_size] ; bufsize
		push	[ebp+buf]	; buf
		push	edx
		push	eax		; n_lines
		call	lines_split
		add	esp, 10h
		jmp	short loc_8001236
; ---------------------------------------------------------------------------

loc_80011F3:				; CODE XREF: main+877j
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		push	[ebp+in_blk_size] ; bufsize
		push	[ebp+buf]	; buf
		push	edx
		push	eax		; n_bytes
		call	bytes_split
		add	esp, 10h
		jmp	short loc_8001236
; ---------------------------------------------------------------------------

loc_8001217:				; CODE XREF: main+86Dj
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		sub	esp, 0Ch
		push	eax		; n_bytes
		call	line_bytes_split
		add	esp, 10h
		jmp	short loc_8001236
; ---------------------------------------------------------------------------

loc_8001231:				; CODE XREF: main+879j	main+87Ej
		call	abort
; ---------------------------------------------------------------------------

loc_8001236:				; CODE XREF: main+8A2j	main+8C6j ...
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001265
		mov	ebx, ds:infile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001265:				; CODE XREF: main+8F6j
		mov	eax, ds:output_desc
		test	eax, eax
		js	short loc_80012A1
		mov	eax, ds:output_desc
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_80012A1
		mov	ebx, ds:outfile
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80012A1:				; CODE XREF: main+91Dj	main+932j
		sub	esp, 0Ch
		push	0		; status

loc_80012A6:				; DATA XREF: .eh_frame:08001B04o
					; .eh_frame:08001B24o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 80012ACh
; size_t suffix_length
suffix_length	dd 2			; DATA XREF: next_file_name+28r
					; next_file_name+88r ...
; const	char *suffix_alphabet
suffix_alphabet	dd offset aAbcdefghijklmn ; DATA XREF: next_file_name+8Er
					; next_file_name+103r ...
_data		ends			; "abcdefghijklmnopqrstuvwxyz"

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 80012B4h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; const	char *outbase
outbase		dd ?			; DATA XREF: next_file_name+14r
					; next_file_name+6Dr ...
; char *outfile
outfile		dd ?			; DATA XREF: next_file_name+7r
					; next_file_name+58w ...
; char *outfile_mid
outfile_mid	dd ?			; DATA XREF: next_file_name+68w
					; next_file_name+99r ...
; char *infile
infile		dd ?			; DATA XREF: bytes_split+3Fr
					; lines_split+41r ...
; int output_desc
output_desc	dd ?			; DATA XREF: cwrite+17r cwrite+20r ...
; _Bool	verbose
verbose		db ?			; DATA XREF: cwrite+58r
					; main:loc_8000F1Bw
		align 4
; Function-local static	variable
; size_t *sufindex_5164
sufindex_5164	dd ?			; DATA XREF: next_file_name+CDw
					; next_file_name:loc_80003F6r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80012E0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_size_note+10o
		db 'SIZE may be (or may be an integer optionally followed by) one of '
		db 'following:',0Ah
		db 'KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P'
		db ', E, Z, Y.',0Ah,0
; char aReportSBugsToS[]
aReportSBugsToS	db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+7Ao ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+60Do
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 10h
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aAbcdefghijklmn	db 'abcdefghijklmnopqrstuvwxyz',0 ; DATA XREF: .data:suffix_alphabeto
aBytes		db 'bytes',0            ; DATA XREF: .rodata:longoptso
aLines		db 'lines',0            ; DATA XREF: .rodata:longoptso
aLineBytes	db 'line-bytes',0       ; DATA XREF: .rodata:longoptso
aSuffixLength	db 'suffix-length',0    ; DATA XREF: .rodata:longoptso
aNumericSuffixe	db 'numeric-suffixes',0 ; DATA XREF: .rodata:longoptso
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[9]
longopts	option <offset aBytes, 1, 0, 62h> ; DATA XREF: main+F1o
		option <offset aLines, 1, 0, 6Ch> ; "bytes"
		option <offset aLineBytes, 1, 0, 43h>
		option <offset aSuffixLength, 1, 0, 61h>
		option <offset aNumericSuffixe,	0, 0, 64h>
		option <offset aVerbose, 0, 0, 80h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [INPUT [PREFIX]]',0Ah,0 ; DATA XREF: usage+46o
; char aOutputFixedSiz[]
aOutputFixedSiz	db 'Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; def'
					; DATA XREF: usage+69o
		db 'ault',0Ah
		db 'size is 1000 lines, and default PREFIX is `x',27h,'.  With no INPUT,'
		db ' or when INPUT',0Ah
		db 'is -, read standard input.',0Ah
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aASuffixLengthN[]
aASuffixLengthN	db '  -a, --suffix-length=N   use suffixes of length N (default %d)',0Ah
					; DATA XREF: usage+A9o
		db '  -b, --bytes=SIZE        put SIZE bytes per output file',0Ah
		db '  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per out'
		db 'put file',0Ah
		db '  -d, --numeric-suffixes  use numeric suffixes instead of alphabe'
		db 'tic',0Ah
		db '  -l, --lines=NUMBER      put NUMBER lines per output file',0Ah,0
; char aVerbosePrintAD[]
aVerbosePrintAD	db '      --verbose           print a diagnostic just before each',0Ah
					; DATA XREF: usage+D5o
		db '                            output file is opened',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+F8o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+11Bo
		align 4
; char aOutputFileSuff[]
aOutputFileSuff	db 'output file suffixes exhausted',0 ; DATA XREF: next_file_name+17Fo
; char format[]
format		db '%s',0               ; DATA XREF: cwrite+43o cwrite+D2o ...
; char aCreatingFileS[]
aCreatingFileS	db 'creating file %s',0Ah,0 ; DATA XREF: cwrite+79o
; char locale
locale		db 0			; DATA XREF: main+63o main+1A7o ...
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+75o
; char s[]
s		db '-',0                ; DATA XREF: main+AAo main+767o
; char asc_800198B[]
asc_800198B	db 'x',0                ; DATA XREF: main+BFo
; char shortopts[]
shortopts	db '0123456789C:a:b:dl:',0 ; DATA XREF: main+F6o
; char aSInvalidSuffix[]
aSInvalidSuffix	db '%s: invalid suffix length',0 ; DATA XREF: main+1DAo
		align 4
; char aCannotSplitInM[]
aCannotSplitInM	db 'cannot split in more than one way',0 ; DATA XREF: main+21Bo
					; main+2C1o ...
; char aSInvalidNumber[]
aSInvalidNumber	db '%s: invalid number of bytes',0 ; DATA XREF: main+290o
					; main+3EDo
; char aSInvalidNumb_0[]
aSInvalidNumb_0	db '%s: invalid number of lines',0 ; DATA XREF: main+336o
		align 4
; char aLineCountOptio[]
aLineCountOptio	db 'line count option -%s%c... is too large',0 ; DATA XREF: main+597o
a0123456789	db '0123456789',0       ; DATA XREF: main:loc_8000F0Fo
aTorbjRnGranlun	db 'Torbjörn Granlund',0 ; DATA XREF: main+5E2o
aTorbjornGranlu	db 'Torbjorn Granlund',0 ; DATA XREF: main+5E7o
aRichardM_Stall	db 'Richard M. Stallman',0 ; DATA XREF: main+606o
aSplit		db 'split',0            ; DATA XREF: main+612o
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of lines: 0',0 ; DATA XREF: main+689o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+73Ao
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: main+7A7o
		align 4
; Function-local static	variable
; const	char multipliers_5236[13]
multipliers_5236 db 'bEGKkMmPTYZ0',0    ; DATA XREF: main+254o main+3A0o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001AE4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80012A6-8002DAAh
		dd 32h,	80E4100h, 0D420285h, 0CC56E05h,	404h, 20h, 3Ch
		dd offset loc_80012A6-8002D98h
		dd 30h,	80E4100h, 0D420285h, 3834405h, 0CC3C568h, 404h
		dd 20h,	60h
		dd offset loc_80012A6-8002D8Ch
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	84h
		dd offset loc_80012A6-8002C94h
		dd 8, 80E4100h,	0D420285h, 0CC54405h, 404h, 1Ch, 0A4h
		dd offset loc_80012A6-8002CACh
		dd 42h,	80E4100h, 0D420285h, 0CC57E05h,	404h, 18h, 0C4h
		dd offset loc_80012A6-8002C8Ah
		dd 14Ah, 80E4100h, 0D420285h, 3834405h,	20h, 0E0h
		dd offset loc_80012A6-8002B5Ch
		dd 1A4h, 80E4100h, 0D420285h, 3834405h,	0C5019C03h, 4040CC3h
		dd 20h,	104h
		dd offset loc_80012A6-80029DCh
		dd 122h, 80E4100h, 0D420285h, 3834405h,	0C5011A03h, 4040CC3h
		dd 20h,	128h
		dd offset loc_80012A6-80028DEh
		dd 100h, 80E4100h, 0D420285h, 3834405h,	0C3C5F802h, 4040Ch
		dd 20h,	14Ch
		dd offset loc_80012A6-8002802h
		dd 14Bh, 80E4100h, 0D420285h, 3834405h,	0C5014303h, 4040CC3h
		dd 20h,	170h
		dd offset loc_80012A6-80026DBh
		dd 12Ch, 80E4100h, 0D420285h, 3834405h,	0C5012403h, 4040CC3h
		dd 2Ch,	194h
		dd offset loc_80012A6-80025D3h
		dd 95Ch, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_size_note+7r
					; emit_ancillary_info+62r ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_size_note+15p
					; emit_ancillary_info+22p ...
		extrn fputs_unlocked:near ; CODE XREF: emit_size_note+22p
					; emit_ancillary_info+7Dp ...
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+6Ap
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p	usage+C4p ...
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+145p main+625p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: next_file_name+1Dp
		extrn xalloc_die:near	; CODE XREF: next_file_name+41p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: next_file_name+50p
					; line_bytes_split+18p	...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: next_file_name+80p
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: next_file_name+A4p
; void *xcalloc(size_t,	size_t)
		extrn xcalloc:near	; CODE XREF: next_file_name+C5p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: next_file_name+194p
					; cwrite+4Bp ...
; int close(int	fd)
		extrn close:near	; CODE XREF: cwrite+29p main+8ECp ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: cwrite+3Bp cwrite+CAp ...
		extrn quote:near	; CODE XREF: cwrite+6Cp main+72Dp ...
		extrn open_safer:near	; CODE XREF: cwrite+AEp
		extrn full_write:near	; CODE XREF: cwrite+F1p
		extrn full_read:near	; CODE XREF: bytes_split+2Ep
					; lines_split+30p ...
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: lines_split+92p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: line_bytes_split+FEp
; void free(void *ptr)
		extrn free:near		; CODE XREF: line_bytes_split+11Ep
; int getpagesize(void)
		extrn getpagesize:near	; CODE XREF: main+37p
		extrn set_program_name:near ; CODE XREF: main+58p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+7Fp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+8Fp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+9Ao
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+9Fp
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000A20r
					; main+DAr ...
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+103p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000AEEr
					; main:loc_8000B20r ...
		extrn xstrtoul:near	; CODE XREF: main+1B8p
		extrn xstrtoumax:near	; CODE XREF: main+265p	main+30Bp ...
		extrn umaxtostr:near	; CODE XREF: main+58Ap
		extrn proper_name_utf8:near ; CODE XREF: main+5ECp
		extrn Version:dword	; DATA XREF: main+5F6r
		extrn version_etc:near	; CODE XREF: main+618p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+76Dp
		extrn fd_reopen:near	; CODE XREF: main+785p
		extrn fstat64:near	; CODE XREF: main+7E0p
; void abort(void)
		extrn abort:near	; CODE XREF: main:loc_8001231p


		end
