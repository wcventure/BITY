;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	AC2C61444C0B46B4212B0A4A14B55FB0
; Input	CRC32 :	436FBCDC

; File Name   :	D:\coreutils-o\shred.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'shred.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+1FFp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; randint __cdecl randint_choose(randint_source	*s, randint choices)
randint_choose	proc near		; CODE XREF: genpattern+E1p
					; genpattern+1A6p

choices		= qword	ptr -10h
s		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+choices], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+choices+4], eax
		mov	eax, dword ptr [ebp+choices]
		mov	edx, dword ptr [ebp+choices+4]
		add	eax, 0FFFFFFFFh
		adc	edx, 0FFFFFFFFh
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+s]
		call	randint_genmax
		add	esp, 10h
		leave
		retn
randint_choose	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+290p	main+2CDp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000189
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000350
; ---------------------------------------------------------------------------

loc_8000189:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	FILE...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOverwriteTheSp ; "Overwrite the	specified FILE(s) repeate"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aFForceChangePe ; "  -f,	--force	   change permissions to "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	3
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aURemoveTruncat ; "  -u,	--remove   truncate and	remove fi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfFileIsShredS ; "\nIf FILE is -, shred	standard output.\"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCautionNoteTha ; "CAUTION: Note	that shred relies on a ve"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLogStructuredO ; "* log-structured or journaled	file syst"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFileSystemsTha ; "* file systems that cache in temporary "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aInTheCaseOfExt ; "In the case of ext3 file systems, the	a"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aInAdditionFile ; "In addition, file system backups and re"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000350:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl fillpattern(int type, unsigned __int8 *r, size_t	size)
fillpattern	proc near		; CODE XREF: dopass+121p

i		= dword	ptr -10h
bits		= dword	ptr -0Ch
type		= dword	ptr  8
r		= dword	ptr  0Ch
size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+type]
		and	eax, 0FFFh
		mov	[ebp+bits], eax
		mov	eax, [ebp+bits]
		shl	eax, 0Ch
		or	[ebp+bits], eax
		mov	eax, [ebp+bits]
		shr	eax, 4
		mov	edx, eax
		mov	eax, [ebp+r]
		mov	[eax], dl
		mov	eax, [ebp+r]
		add	eax, 1
		mov	edx, [ebp+bits]
		shr	edx, 8
		mov	[eax], dl
		mov	eax, [ebp+r]
		add	eax, 2
		mov	edx, [ebp+bits]
		mov	[eax], dl
		mov	[ebp+i], 3
		jmp	short loc_80003C1
; ---------------------------------------------------------------------------

loc_80003A4:				; CODE XREF: fillpattern+6Ej
		mov	edx, [ebp+r]
		mov	eax, [ebp+i]
		add	eax, edx
		sub	esp, 4
		push	[ebp+i]		; n
		push	[ebp+r]		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		shl	[ebp+i], 1

loc_80003C1:				; CODE XREF: fillpattern+47j
		mov	eax, [ebp+size]
		shr	eax, 1
		cmp	eax, [ebp+i]
		ja	short loc_80003A4
		mov	eax, [ebp+i]
		cmp	eax, [ebp+size]
		jnb	short loc_80003F1
		mov	eax, [ebp+size]
		sub	eax, [ebp+i]
		mov	ecx, [ebp+r]
		mov	edx, [ebp+i]
		add	edx, ecx
		sub	esp, 4
		push	eax		; n
		push	[ebp+r]		; src
		push	edx		; dest
		call	memcpy
		add	esp, 10h

loc_80003F1:				; CODE XREF: fillpattern+76j
		mov	eax, [ebp+type]
		and	eax, 1000h
		test	eax, eax
		jz	short loc_800042D
		mov	[ebp+i], 0
		jmp	short loc_8000425
; ---------------------------------------------------------------------------

loc_8000406:				; CODE XREF: fillpattern+D0j
		mov	edx, [ebp+r]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	ecx, [ebp+r]
		mov	edx, [ebp+i]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		xor	edx, 0FFFFFF80h
		mov	[eax], dl
		add	[ebp+i], 200h

loc_8000425:				; CODE XREF: fillpattern+A9j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+size]
		jb	short loc_8000406

loc_800042D:				; CODE XREF: fillpattern+A0j
		nop
		leave
		retn
fillpattern	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl passname(const unsigned __int8 *data, char *name)
passname	proc near		; CODE XREF: dopass+13Ap dopass+150p

data		= dword	ptr  8
name		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+data], 0
		jz	short loc_8000475
		mov	eax, [ebp+data]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		movzx	ecx, al
		mov	eax, [ebp+data]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	eax, [ebp+data]
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 0Ch
		push	ecx
		push	edx
		push	eax
		push	offset format	; "%02x%02x%02x"
		push	[ebp+name]	; s
		call	sprintf
		add	esp, 20h
		jmp	short loc_800048A
; ---------------------------------------------------------------------------

loc_8000475:				; CODE XREF: passname+Aj
		sub	esp, 4
		push	7		; n
		push	offset aRandom	; "random"
		push	[ebp+name]	; dest
		call	memcpy
		add	esp, 10h

loc_800048A:				; CODE XREF: passname+43j
		nop
		leave
		retn
passname	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	ignorable_sync_errno(int errno_val)
ignorable_sync_errno proc near		; CODE XREF: dosync+32p dosync+9Ep

errno_val	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+errno_val], 16h
		jz	short loc_80004A2
		cmp	[ebp+errno_val], 9
		jz	short loc_80004A2
		cmp	[ebp+errno_val], 15h
		jnz	short loc_80004A9

loc_80004A2:				; CODE XREF: ignorable_sync_errno+7j
					; ignorable_sync_errno+Dj
		mov	eax, 1
		jmp	short loc_80004AE
; ---------------------------------------------------------------------------

loc_80004A9:				; CODE XREF: ignorable_sync_errno+13j
		mov	eax, 0

loc_80004AE:				; CODE XREF: ignorable_sync_errno+1Aj
		and	eax, 1
		pop	ebp
		retn
ignorable_sync_errno endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl dosync(int fd, const char	*qname)
dosync		proc near		; CODE XREF: dopass+808p dopass+847p ...

err		= dword	ptr -0Ch
fd		= dword	ptr  8
qname		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	[ebp+fd]	; fildes
		call	fdatasync
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80004D5
		mov	eax, 0
		jmp	locret_800059E
; ---------------------------------------------------------------------------

loc_80004D5:				; CODE XREF: dosync+16j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+err], eax
		sub	esp, 0Ch
		push	[ebp+err]	; errno_val
		call	ignorable_sync_errno
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000528
		sub	esp, 0Ch
		push	offset aSFdatasyncFail ; "%s: fdatasync	failed"
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	[ebp+err]	; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+err]
		mov	[edx], eax
		mov	eax, 0FFFFFFFFh
		jmp	short locret_800059E
; ---------------------------------------------------------------------------

loc_8000528:				; CODE XREF: dosync+3Fj
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	fsync
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000541
		mov	eax, 0
		jmp	short locret_800059E
; ---------------------------------------------------------------------------

loc_8000541:				; CODE XREF: dosync+85j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+err], eax
		sub	esp, 0Ch
		push	[ebp+err]	; errno_val
		call	ignorable_sync_errno
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000594
		sub	esp, 0Ch
		push	offset aSFsyncFailed ; "%s: fsync failed"
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	[ebp+err]	; errnum
		push	0		; status
		call	error
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+err]
		mov	[edx], eax
		mov	eax, 0FFFFFFFFh
		jmp	short locret_800059E
; ---------------------------------------------------------------------------

loc_8000594:				; CODE XREF: dosync+ABj
		call	sync
		mov	eax, 0

locret_800059E:				; CODE XREF: dosync+1Dj dosync+73j ...
		leave
		retn
dosync		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl direct_mode(int fd, _Bool enable)
direct_mode	proc near		; CODE XREF: dopass+35Ap
					; do_wipefd+12Dp

enable		= byte ptr -1Ch
fd_flags	= dword	ptr -10h
new_flags	= dword	ptr -0Ch
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+enable], al
		sub	esp, 8
		push	3
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+fd_flags],	eax
		cmp	[ebp+fd_flags],	0
		jle	short loc_80005F7
		cmp	[ebp+enable], 0
		jz	short loc_80005D3
		mov	eax, [ebp+fd_flags]
		or	ah, 40h
		jmp	short loc_80005D9
; ---------------------------------------------------------------------------

loc_80005D3:				; CODE XREF: direct_mode+29j
		mov	eax, [ebp+fd_flags]
		and	ah, 0BFh

loc_80005D9:				; CODE XREF: direct_mode+31j
		mov	[ebp+new_flags], eax
		mov	eax, [ebp+new_flags]
		cmp	eax, [ebp+fd_flags]
		jz	short loc_80005F7
		sub	esp, 4
		push	[ebp+new_flags]
		push	4
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h

loc_80005F7:				; CODE XREF: direct_mode+23j
					; direct_mode+42j
		nop
		leave
		retn
direct_mode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl dopass(int fd, const char	*qname,	off_t *sizep, int type,	randread_source	*s, unsigned int k, unsigned int n)
dopass		proc near		; CODE XREF: do_wipefd+36Ap
					; do_wipefd+449p

s		= dword	ptr -3824h
sizep		= dword	ptr -3820h
qname		= dword	ptr -381Ch
write_error	= byte ptr -380Ah
first_write	= byte ptr -3809h
thresh		= dword	ptr -3808h
now		= dword	ptr -3804h
lim		= dword	ptr -3800h
soff		= dword	ptr -37FCh
ssize		= dword	ptr -37F8h
previous_human_offset= dword ptr -37F4h
human_offset	= dword	ptr -37F0h
human_progress_opts= dword ptr -37ECh
percent		= dword	ptr -37E8h
human_size	= dword	ptr -37E4h
errnum		= dword	ptr -37E0h
soff1		= dword	ptr -37DCh
size		= qword	ptr -37D8h
offset		= qword	ptr -37D0h
sizeof_r	= qword	ptr -37C8h
off		= qword	ptr -37C0h
r		= dopass::$BFB051292D90B4B008C5D027E8E01862 ptr	-37B8h
pass_string	= byte ptr -7B7h
previous_offset_buf= byte ptr -7B0h
offset_buf	= byte ptr -524h
size_buf	= byte ptr -298h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
type		= dword	ptr  14h
arg_10		= dword	ptr  18h
k		= dword	ptr  1Ch
n		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 3824h
		mov	eax, [ebp+arg_4]
		mov	[ebp+qname], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+sizep], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+sizep]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	[ebp+now], 0
		mov	dword ptr [ebp+sizeof_r], 3000h
		mov	dword ptr [ebp+sizeof_r+4], 0
		mov	[ebp+write_error], 0
		mov	[ebp+first_write], 1
		push	0
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_80006C1
		sub	esp, 0Ch
		push	offset aSCannotRewind ;	"%s: cannot rewind"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0FFFFFFFFh
		jmp	loc_8000E6E
; ---------------------------------------------------------------------------

loc_80006C1:				; CODE XREF: dopass+90j
		cmp	[ebp+type], 0
		js	short loc_800073E
		cmp	dword ptr [ebp+size+4],	0
		js	short loc_80006FC
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		cmp	edx, dword ptr [ebp+sizeof_r+4]
		jg	short loc_80006FC
		cmp	edx, dword ptr [ebp+sizeof_r+4]
		jl	short loc_80006F4
		cmp	eax, dword ptr [ebp+sizeof_r]
		jnb	short loc_80006FC

loc_80006F4:				; CODE XREF: dopass+F0j
		mov	eax, dword ptr [ebp+size]
		jmp	short loc_8000702
; ---------------------------------------------------------------------------

loc_80006FC:				; CODE XREF: dopass+D4j dopass+E8j ...
		mov	eax, dword ptr [ebp+sizeof_r]

loc_8000702:				; CODE XREF: dopass+100j
		mov	[ebp+lim], eax
		sub	esp, 4
		push	[ebp+lim]	; size
		lea	eax, [ebp+r]
		push	eax		; r
		push	[ebp+type]	; type
		call	fillpattern
		add	esp, 10h
		sub	esp, 8
		lea	eax, [ebp+pass_string]
		push	eax		; name
		lea	eax, [ebp+r]
		push	eax		; data
		call	passname
		add	esp, 10h
		jmp	short loc_8000752
; ---------------------------------------------------------------------------

loc_800073E:				; CODE XREF: dopass+CBj
		sub	esp, 8
		lea	eax, [ebp+pass_string]
		push	eax		; name
		push	0		; data
		call	passname
		add	esp, 10h

loc_8000752:				; CODE XREF: dopass+142j
		cmp	[ebp+n], 0
		jz	short loc_80007AD
		sub	esp, 0Ch
		push	offset aSPassLuLuS___ ;	"%s: pass %lu/%lu (%s)..."
		call	gettext
		add	esp, 10h
		mov	edx, eax
		sub	esp, 4
		lea	eax, [ebp+pass_string]
		push	eax
		push	[ebp+n]
		push	[ebp+k]
		push	[ebp+qname]
		push	edx		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; timer
		call	time
		add	esp, 10h
		add	eax, 5
		mov	[ebp+thresh], eax
		mov	[ebp+previous_human_offset], offset locale

loc_80007AD:				; CODE XREF: dopass+15Cj
		mov	dword ptr [ebp+offset],	0
		mov	dword ptr [ebp+offset+4], 0

loc_80007C1:				; CODE XREF: dopass+53Cj dopass+58Ej ...
		mov	[ebp+lim], 3000h
		cmp	dword ptr [ebp+size+4],	0
		js	short loc_8000853
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		sub	eax, dword ptr [ebp+offset]
		sbb	edx, dword ptr [ebp+offset+4]
		cmp	edx, dword ptr [ebp+sizeof_r+4]
		jg	short loc_8000853
		cmp	edx, dword ptr [ebp+sizeof_r+4]
		jl	short loc_8000804
		cmp	eax, dword ptr [ebp+sizeof_r]
		jnb	short loc_8000853

loc_8000804:				; CODE XREF: dopass+200j
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		cmp	edx, dword ptr [ebp+offset+4]
		jg	short loc_8000830
		cmp	edx, dword ptr [ebp+offset+4]
		jl	loc_8000E31
		cmp	eax, dword ptr [ebp+offset]
		jb	loc_8000E31

loc_8000830:				; CODE XREF: dopass+21Cj
		mov	edx, dword ptr [ebp+size]
		mov	eax, dword ptr [ebp+offset]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+lim], eax
		cmp	[ebp+lim], 0
		jz	loc_8000E34

loc_8000853:				; CODE XREF: dopass+1D8j dopass+1F8j ...
		cmp	[ebp+type], 0
		jns	short loc_8000877
		sub	esp, 4
		push	[ebp+lim]
		lea	eax, [ebp+r]
		push	eax
		push	[ebp+s]
		call	randread
		add	esp, 10h

loc_8000877:				; CODE XREF: dopass+25Dj
		mov	[ebp+soff], 0
		jmp	loc_8000AA7
; ---------------------------------------------------------------------------

loc_8000886:				; CODE XREF: dopass+4B9j
		mov	eax, [ebp+lim]
		sub	eax, [ebp+soff]
		lea	ecx, [ebp+r]
		mov	edx, [ebp+soff]
		add	edx, ecx
		sub	esp, 4
		push	eax		; n
		push	edx		; buf
		push	[ebp+fd]	; fd
		call	write
		add	esp, 10h
		mov	[ebp+ssize], eax
		cmp	[ebp+ssize], 0
		jg	loc_8000A94
		cmp	dword ptr [ebp+size+4],	0
		jns	short loc_8000924
		cmp	[ebp+ssize], 0
		jz	short loc_80008E1
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1Ch
		jnz	short loc_8000924

loc_80008E1:				; CODE XREF: dopass+2D9j
		mov	ecx, [ebp+soff]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	ecx, [ebp+sizep]
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	loc_8000AB9
; ---------------------------------------------------------------------------

loc_8000924:				; CODE XREF: dopass+2D0j dopass+2E5j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+errnum], eax
		cmp	[ebp+k], 1
		jnz	short loc_800096B
		cmp	[ebp+first_write], 0
		jz	short loc_800096B
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_800096B
		sub	esp, 8
		push	0		; enable
		push	[ebp+fd]	; fd
		call	direct_mode
		add	esp, 10h
		mov	[ebp+ssize], 0
		jmp	loc_8000A94
; ---------------------------------------------------------------------------

loc_800096B:				; CODE XREF: dopass+33Bj dopass+344j ...
		mov	ecx, [ebp+soff]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		add	eax, ecx
		adc	edx, ebx
		sub	esp, 4
		lea	ecx, [ebp+size_buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSErrorWritingA ; "%s: error writing at offset %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	[ebp+qname]
		push	eax		; format
		push	[ebp+errnum]	; errnum
		push	0		; status
		call	error
		add	esp, 20h
		cmp	[ebp+errnum], 5
		jnz	loc_8000A8A
		cmp	dword ptr [ebp+size+4],	0
		js	loc_8000A8A
		mov	eax, [ebp+soff]
		or	eax, 1FFh
		cmp	eax, [ebp+lim]
		jnb	loc_8000A8A
		mov	eax, [ebp+soff]
		or	eax, 1FFh
		add	eax, 1
		mov	[ebp+soff1], eax
		mov	ecx, [ebp+soff1]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		add	eax, ecx
		adc	edx, ebx
		push	0
		push	edx
		push	eax
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jz	short loc_8000A5F
		mov	eax, [ebp+soff1]
		sub	eax, [ebp+soff]
		mov	[ebp+ssize], eax
		mov	[ebp+write_error], 1
		jmp	short loc_8000A94
; ---------------------------------------------------------------------------

loc_8000A5F:				; CODE XREF: dopass+448j
		sub	esp, 0Ch
		push	offset aSLseekFailed ; "%s: lseek failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000A8A:				; CODE XREF: dopass+3D4j dopass+3E1j ...
		mov	eax, 0FFFFFFFFh
		jmp	loc_8000E6E
; ---------------------------------------------------------------------------

loc_8000A94:				; CODE XREF: dopass+2C3j dopass+36Cj ...
		mov	eax, [ebp+ssize]
		add	[ebp+soff], eax
		mov	[ebp+first_write], 0

loc_8000AA7:				; CODE XREF: dopass+287j
		mov	eax, [ebp+soff]
		cmp	eax, [ebp+lim]
		jb	loc_8000886

loc_8000AB9:				; CODE XREF: dopass+325j
		mov	eax, [ebp+soff]
		mov	edx, 0
		mov	ecx, 0FFFFFFFFh
		mov	ebx, 7FFFFFFFh
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		cmp	edx, dword ptr [ebp+offset+4]
		jg	short loc_8000B1B
		cmp	edx, dword ptr [ebp+offset+4]
		jl	short loc_8000AEE
		cmp	eax, dword ptr [ebp+offset]
		jnb	short loc_8000B1B

loc_8000AEE:				; CODE XREF: dopass+4EAj
		sub	esp, 0Ch
		push	offset aSFileTooLarge ;	"%s: file too large"
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0FFFFFFFFh
		jmp	loc_8000E6E
; ---------------------------------------------------------------------------

loc_8000B1B:				; CODE XREF: dopass+4E2j dopass+4F2j
		mov	eax, [ebp+soff]
		mov	edx, 0
		add	dword ptr [ebp+offset],	eax
		adc	dword ptr [ebp+offset+4], edx
		cmp	[ebp+n], 0
		jz	loc_80007C1
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+size+4]
		xor	eax, dword ptr [ebp+size]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000B69
		mov	eax, [ebp+previous_human_offset]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000B8E

loc_8000B69:				; CODE XREF: dopass+560j
		sub	esp, 0Ch
		push	0		; timer
		call	time
		add	esp, 10h
		mov	[ebp+now], eax
		mov	eax, [ebp+now]
		cmp	eax, [ebp+thresh]
		jl	loc_80007C1

loc_8000B8E:				; CODE XREF: dopass+56Dj
		mov	[ebp+human_progress_opts], 1B0h
		mov	eax, [ebp+human_progress_opts]
		or	eax, 2
		mov	ecx, eax
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		push	0
		push	1
		push	0
		push	1
		push	ecx
		lea	ecx, [ebp+offset_buf]
		push	ecx
		push	edx
		push	eax
		call	human_readable
		add	esp, 20h
		mov	[ebp+human_offset], eax
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+size+4]
		xor	eax, dword ptr [ebp+size]
		or	eax, ecx
		test	eax, eax
		jz	short loc_8000C0E
		sub	esp, 8
		push	[ebp+human_offset] ; s2
		push	[ebp+previous_human_offset] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_80007C1

loc_8000C0E:				; CODE XREF: dopass+5F3j
		cmp	dword ptr [ebp+size+4],	0
		jns	short loc_8000C54
		sub	esp, 0Ch
		push	offset aSPassLuLuS___S ; "%s: pass %lu/%lu (%s)...%s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		push	[ebp+human_offset]
		lea	eax, [ebp+pass_string]
		push	eax
		push	[ebp+n]
		push	[ebp+k]
		push	[ebp+qname]
		push	edx		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	loc_8000DC3
; ---------------------------------------------------------------------------

loc_8000C54:				; CODE XREF: dopass+61Bj
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		mov	dword ptr [ebp+off], eax
		mov	dword ptr [ebp+off+4], edx
		mov	eax, dword ptr [ebp+size+4]
		or	eax, dword ptr [ebp+size]
		test	eax, eax
		jz	loc_8000D14
		cmp	dword ptr [ebp+off+4], 28F5C28h
		ja	short loc_8000CE2
		cmp	dword ptr [ebp+off+4], 28F5C28h
		jb	short loc_8000CA4
		cmp	dword ptr [ebp+off], 0F5C28F5Ch
		ja	short loc_8000CE2

loc_8000CA4:				; CODE XREF: dopass+69Cj
		mov	eax, dword ptr [ebp+off+4]
		imul	edx, eax, 64h
		mov	eax, dword ptr [ebp+off]
		imul	eax, 0
		lea	ecx, [edx+eax]
		mov	eax, 64h
		mul	dword ptr [ebp+off]
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, dword ptr [ebp+size]
		mov	ebx, dword ptr [ebp+size+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	__udivdi3
		add	esp, 10h
		jmp	short loc_8000D19
; ---------------------------------------------------------------------------

loc_8000CE2:				; CODE XREF: dopass+690j dopass+6A8j
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		push	0
		push	64h
		push	edx
		push	eax
		call	__divdi3
		add	esp, 10h
		push	edx
		push	eax
		push	dword ptr [ebp+off+4]
		push	dword ptr [ebp+off]
		call	__udivdi3
		add	esp, 10h
		jmp	short loc_8000D19
; ---------------------------------------------------------------------------

loc_8000D14:				; CODE XREF: dopass+680j
		mov	eax, 64h

loc_8000D19:				; CODE XREF: dopass+6E6j dopass+718j
		mov	[ebp+percent], eax
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		push	0
		push	1
		push	0
		push	1
		push	[ebp+human_progress_opts]
		lea	ecx, [ebp+size_buf]
		push	ecx
		push	edx
		push	eax
		call	human_readable
		add	esp, 20h
		mov	[ebp+human_size], eax
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+size+4]
		xor	eax, dword ptr [ebp+size]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000D7C
		mov	eax, [ebp+human_size]
		mov	[ebp+human_offset], eax

loc_8000D7C:				; CODE XREF: dopass+774j
		sub	esp, 0Ch
		push	offset aSPassLuLuS___0 ; "%s: pass %lu/%lu (%s)...%s/%s	%d%%"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		push	[ebp+percent]
		push	[ebp+human_size]
		push	[ebp+human_offset]
		lea	eax, [ebp+pass_string]
		push	eax
		push	[ebp+n]
		push	[ebp+k]
		push	[ebp+qname]
		push	edx		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 30h

loc_8000DC3:				; CODE XREF: dopass+655j
		sub	esp, 8
		push	[ebp+human_offset] ; src
		lea	eax, [ebp+previous_offset_buf]
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		lea	eax, [ebp+previous_offset_buf]
		mov	[ebp+previous_human_offset], eax
		mov	eax, [ebp+now]
		add	eax, 5
		mov	[ebp+thresh], eax
		sub	esp, 8
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	dosync
		add	esp, 10h
		test	eax, eax
		jz	loc_80007C1
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 5
		jz	short loc_8000E25
		mov	eax, 0FFFFFFFFh
		jmp	short loc_8000E6E
; ---------------------------------------------------------------------------

loc_8000E25:				; CODE XREF: dopass+822j
		mov	[ebp+write_error], 1
		jmp	loc_80007C1
; ---------------------------------------------------------------------------

loc_8000E31:				; CODE XREF: dopass+224j dopass+230j
		nop
		jmp	short loc_8000E35
; ---------------------------------------------------------------------------

loc_8000E34:				; CODE XREF: dopass+253j
		nop

loc_8000E35:				; CODE XREF: dopass+838j
		sub	esp, 8
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	dosync
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000E67
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 5
		jz	short loc_8000E60
		mov	eax, 0FFFFFFFFh
		jmp	short loc_8000E6E
; ---------------------------------------------------------------------------

loc_8000E60:				; CODE XREF: dopass+85Dj
		mov	[ebp+write_error], 1

loc_8000E67:				; CODE XREF: dopass+851j
		movzx	eax, [ebp+write_error]

loc_8000E6E:				; CODE XREF: dopass+C2j dopass+495j ...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8000E7F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000E7F:				; CODE XREF: dopass+87Ej
		mov	ebx, [ebp+var_4]
		leave
		retn
dopass		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl genpattern(int *dest, size_t num, randint_source	*s)
genpattern	proc near		; CODE XREF: do_wipefd+2FEp

randpasses	= dword	ptr -28h
p		= dword	ptr -24h
d		= dword	ptr -20h
n		= dword	ptr -1Ch
accum		= dword	ptr -18h
top		= dword	ptr -14h
k		= dword	ptr -10h
swap		= dword	ptr -0Ch
var_4		= dword	ptr -4
dest		= dword	ptr  8
num		= dword	ptr  0Ch
s		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		cmp	[ebp+num], 0
		jz	loc_800109E
		mov	[ebp+p], offset	patterns
		mov	[ebp+randpasses], 0
		mov	eax, [ebp+dest]
		mov	[ebp+d], eax
		mov	eax, [ebp+num]
		mov	[ebp+n], eax

loc_8000EAF:				; CODE XREF: genpattern+46j
					; genpattern+70j ...
		mov	eax, [ebp+p]
		lea	edx, [eax+4]
		mov	[ebp+p], edx
		mov	eax, [eax]
		mov	[ebp+k], eax
		cmp	[ebp+k], 0
		jnz	short loc_8000ECC
		mov	[ebp+p], offset	patterns
		jmp	short loc_8000EAF
; ---------------------------------------------------------------------------

loc_8000ECC:				; CODE XREF: genpattern+3Dj
		cmp	[ebp+k], 0
		jns	short loc_8000EF6
		neg	[ebp+k]
		mov	eax, [ebp+k]
		cmp	eax, [ebp+n]
		jb	short loc_8000EE8
		mov	eax, [ebp+n]
		add	[ebp+randpasses], eax
		jmp	loc_8000FA3
; ---------------------------------------------------------------------------

loc_8000EE8:				; CODE XREF: genpattern+57j
		mov	eax, [ebp+k]
		add	[ebp+randpasses], eax
		mov	eax, [ebp+k]
		sub	[ebp+n], eax
		jmp	short loc_8000EAF
; ---------------------------------------------------------------------------

loc_8000EF6:				; CODE XREF: genpattern+4Cj
		mov	eax, [ebp+k]
		cmp	eax, [ebp+n]
		ja	short loc_8000F33
		mov	eax, [ebp+k]
		shl	eax, 2
		sub	esp, 4
		push	eax		; n
		push	[ebp+p]		; src
		push	[ebp+d]		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+k]
		shl	eax, 2
		add	[ebp+p], eax
		mov	eax, [ebp+k]
		shl	eax, 2
		add	[ebp+d], eax
		mov	eax, [ebp+k]
		sub	[ebp+n], eax
		jmp	loc_8000EAF
; ---------------------------------------------------------------------------

loc_8000F33:				; CODE XREF: genpattern+78j
		cmp	[ebp+n], 1
		jbe	short loc_8000F49
		mov	edx, [ebp+n]
		mov	eax, edx
		add	eax, eax
		add	edx, eax
		mov	eax, [ebp+k]
		cmp	edx, eax
		jnb	short loc_8000F51

loc_8000F49:				; CODE XREF: genpattern+B3j
		mov	eax, [ebp+n]
		add	[ebp+randpasses], eax
		jmp	short loc_8000FA3
; ---------------------------------------------------------------------------

loc_8000F51:				; CODE XREF: genpattern+C3j
					; genpattern+11Dj
		mov	eax, [ebp+k]
		cmp	[ebp+n], eax
		jz	short loc_8000F85
		mov	eax, [ebp+k]
		cdq
		sub	esp, 4
		push	edx
		push	eax		; choices
		push	[ebp+s]		; s
		call	randint_choose
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+n]
		mov	edx, 0
		cmp	ebx, edx
		ja	short loc_8000F99
		cmp	ebx, edx
		jb	short loc_8000F85
		cmp	ecx, eax
		jnb	short loc_8000F99

loc_8000F85:				; CODE XREF: genpattern+D3j
					; genpattern+FBj
		mov	eax, [ebp+d]
		lea	edx, [eax+4]
		mov	[ebp+d], edx
		mov	edx, [ebp+p]
		mov	edx, [edx]
		mov	[eax], edx
		sub	[ebp+n], 1

loc_8000F99:				; CODE XREF: genpattern+F7j
					; genpattern+FFj
		add	[ebp+p], 4
		cmp	[ebp+n], 0
		jnz	short loc_8000F51

loc_8000FA3:				; CODE XREF: genpattern+5Fj
					; genpattern+CBj
		mov	eax, [ebp+num]
		sub	eax, [ebp+randpasses]
		mov	[ebp+top], eax
		sub	[ebp+randpasses], 1
		mov	eax, [ebp+randpasses]
		mov	[ebp+accum], eax
		mov	[ebp+n], 0
		jmp	loc_8001090
; ---------------------------------------------------------------------------

loc_8000FC2:				; CODE XREF: genpattern+212j
		mov	eax, [ebp+accum]
		cmp	eax, [ebp+randpasses]
		ja	short loc_8001017
		mov	edx, [ebp+num]
		mov	eax, [ebp+accum]
		add	eax, edx
		sub	eax, 1
		mov	[ebp+accum], eax
		mov	eax, [ebp+top]
		lea	edx, [eax+1]
		mov	[ebp+top], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	edx, eax
		mov	eax, [ebp+n]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+n]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	eax, edx
		mov	dword ptr [eax], 0FFFFFFFFh
		jmp	short loc_8001086
; ---------------------------------------------------------------------------

loc_8001017:				; CODE XREF: genpattern+144j
		mov	eax, [ebp+top]
		sub	eax, [ebp+n]
		mov	edx, 0
		sub	esp, 4
		push	edx
		push	eax		; choices
		push	[ebp+s]		; s
		call	randint_choose
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+n]
		add	eax, edx
		mov	[ebp+swap], eax
		mov	eax, [ebp+n]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+k], eax
		mov	eax, [ebp+n]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	edx, eax
		mov	eax, [ebp+swap]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+swap]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+dest]
		add	edx, eax
		mov	eax, [ebp+k]
		mov	[edx], eax

loc_8001086:				; CODE XREF: genpattern+191j
		mov	eax, [ebp+randpasses]
		sub	[ebp+accum], eax
		add	[ebp+n], 1

loc_8001090:				; CODE XREF: genpattern+139j
		mov	eax, [ebp+n]
		cmp	eax, [ebp+num]
		jb	loc_8000FC2
		jmp	short loc_800109F
; ---------------------------------------------------------------------------

loc_800109E:				; CODE XREF: genpattern+Bj
		nop

loc_800109F:				; CODE XREF: genpattern+218j
		mov	ebx, [ebp+var_4]
		leave
		retn
genpattern	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	do_wipefd(int fd, const	char *qname, randint_source *s,	const Options *flags)
do_wipefd	proc near		; CODE XREF: wipefd+8Ep wipefile+AAp

var_B0		= dword	ptr -0B0h
var_AC		= dword	ptr -0ACh
flags		= dword	ptr -0A4h
s		= dword	ptr -0A0h
qname		= dword	ptr -9Ch
ok		= byte ptr -91h
i		= dword	ptr -90h
n		= dword	ptr -8Ch
passarray	= dword	ptr -88h
rs		= dword	ptr -84h
err		= dword	ptr -80h
err_0		= dword	ptr -7Ch
size		= qword	ptr -78h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0B0h
		mov	eax, [ebp+arg_4]
		mov	[ebp+qname], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+s], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+flags], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	[ebp+n], 0
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+11h]
		test	al, al
		jz	short loc_8001112
		mov	eax, [ebp+flags]
		mov	edx, [eax+4]
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+13h]
		movzx	eax, al
		add	eax, edx
		mov	[ebp+n], eax

loc_8001112:				; CODE XREF: do_wipefd+4Ej
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_800115D
		sub	esp, 0Ch
		push	offset aSFstatFailed ; "%s: fstat failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800157E
; ---------------------------------------------------------------------------

loc_800115D:				; CODE XREF: do_wipefd+82j
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jnz	short loc_800117E
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800119C

loc_800117E:				; CODE XREF: do_wipefd+C6j
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jz	short loc_800119C
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jnz	short loc_80011C9

loc_800119C:				; CODE XREF: do_wipefd+D8j
					; do_wipefd+E7j
		sub	esp, 0Ch
		push	offset aSInvalidFileTy ; "%s: invalid file type"
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800157E
; ---------------------------------------------------------------------------

loc_80011C9:				; CODE XREF: do_wipefd+F6j
		sub	esp, 8
		push	1		; enable
		push	[ebp+fd]	; fd
		call	direct_mode
		add	esp, 10h
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		sub	esp, 8
		push	4
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+passarray], eax
		mov	eax, [ebp+flags]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	loc_8001389
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8001272
		mov	eax, dword ptr [ebp+st.st_size]
		mov	edx, dword ptr [ebp+st.st_size+4]
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		test	edx, edx
		jns	short loc_80012AA
		sub	esp, 0Ch
		push	offset aSFileHasNegati ; "%s: file has negative	size"
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800157E
; ---------------------------------------------------------------------------

loc_8001272:				; CODE XREF: do_wipefd+189j
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		test	edx, edx
		jg	short loc_80012AA
		test	edx, edx
		js	short loc_800129C
		cmp	eax, 0
		ja	short loc_80012AA

loc_800129C:				; CODE XREF: do_wipefd+1F1j
		mov	dword ptr [ebp+size], 0FFFFFFFFh
		mov	dword ptr [ebp+size+4],	0FFFFFFFFh

loc_80012AA:				; CODE XREF: do_wipefd+19Fj
					; do_wipefd+1EDj ...
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		test	edx, edx
		js	loc_8001389
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+12h]
		xor	eax, 1
		test	al, al
		jz	loc_8001389
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8001389
		mov	eax, [ebp+st.st_blksize]
		test	eax, eax
		jle	short loc_8001300
		mov	eax, [ebp+st.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_8001300
		mov	eax, [ebp+st.st_blksize]
		sub	eax, 1
		mov	ebx, eax
		mov	esi, eax
		sar	esi, 1Fh
		jmp	short loc_800130A
; ---------------------------------------------------------------------------

loc_8001300:				; CODE XREF: do_wipefd+241j
					; do_wipefd+24Bj
		mov	ebx, 1FFh
		mov	esi, 0

loc_800130A:				; CODE XREF: do_wipefd+25Aj
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		add	eax, 0FFFFFFFFh
		adc	edx, 0FFFFFFFFh
		mov	[ebp+var_B0], eax
		mov	[ebp+var_AC], edx
		mov	eax, [ebp+st.st_blksize]
		test	eax, eax
		jle	short loc_8001339
		mov	eax, [ebp+st.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_8001339
		mov	eax, [ebp+st.st_blksize]
		cdq
		jmp	short loc_8001343
; ---------------------------------------------------------------------------

loc_8001339:				; CODE XREF: do_wipefd+283j
					; do_wipefd+28Dj
		mov	eax, 200h
		mov	edx, 0

loc_8001343:				; CODE XREF: do_wipefd+293j
		push	edx
		push	eax
		push	[ebp+var_AC]
		push	[ebp+var_B0]
		call	__moddi3
		add	esp, 10h
		mov	ecx, ebx
		mov	ebx, esi
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		test	edx, edx
		jns	short loc_8001389
		mov	dword ptr [ebp+size], 0FFFFFFFFh
		mov	dword ptr [ebp+size+4],	7FFFFFFFh

loc_8001389:				; CODE XREF: do_wipefd+176j
					; do_wipefd+20Ej ...
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		sub	esp, 4
		push	[ebp+s]		; s
		push	eax		; num
		push	[ebp+passarray]	; dest
		call	genpattern
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+s]
		call	randint_get_source
		add	esp, 10h
		mov	[ebp+rs], eax
		mov	[ebp+i], 0
		jmp	loc_800146E
; ---------------------------------------------------------------------------

loc_80013D0:				; CODE XREF: do_wipefd+3D9j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+passarray]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 4
		push	[ebp+n]		; n
		push	edx		; k
		push	[ebp+rs]	; s
		push	eax		; type
		lea	eax, [ebp+size]
		push	eax		; sizep
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	dopass
		add	esp, 20h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_8001467
		cmp	[ebp+err], 0
		jns	short loc_8001460
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		shl	eax, 2
		sub	esp, 4
		push	eax		; n
		push	0		; c
		push	[ebp+passarray]	; s
		call	memset
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+passarray]	; ptr
		call	free
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800157E
; ---------------------------------------------------------------------------

loc_8001460:				; CODE XREF: do_wipefd+37Fj
		mov	[ebp+ok], 0

loc_8001467:				; CODE XREF: do_wipefd+379j
		add	[ebp+i], 1

loc_800146E:				; CODE XREF: do_wipefd+327j
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		cmp	eax, [ebp+i]
		ja	loc_80013D0
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		shl	eax, 2
		sub	esp, 4
		push	eax		; n
		push	0		; c
		push	[ebp+passarray]	; s
		call	memset
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+passarray]	; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+13h]
		test	al, al
		jz	short loc_8001512
		mov	eax, [ebp+flags]
		mov	eax, [eax+4]
		add	eax, 1
		sub	esp, 4
		push	[ebp+n]		; n
		push	eax		; k
		push	[ebp+rs]	; s
		push	0		; type
		lea	eax, [ebp+size]
		push	eax		; sizep
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	dopass
		add	esp, 20h
		mov	[ebp+err_0], eax
		cmp	[ebp+err_0], 0
		jz	short loc_8001512
		cmp	[ebp+err_0], 0
		jns	short loc_800150B
		mov	eax, 0
		jmp	short loc_800157E
; ---------------------------------------------------------------------------

loc_800150B:				; CODE XREF: do_wipefd+45Ej
		mov	[ebp+ok], 0

loc_8001512:				; CODE XREF: do_wipefd+41Cj
					; do_wipefd+458j
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+10h]
		test	al, al
		jz	short loc_8001577
		sub	esp, 4
		push	0
		push	0
		push	[ebp+fd]
		call	ftruncate64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001577
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8001577
		sub	esp, 0Ch
		push	offset aSErrorTruncati ; "%s: error truncating"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_800157E
; ---------------------------------------------------------------------------

loc_8001577:				; CODE XREF: do_wipefd+47Aj
					; do_wipefd+490j ...
		movzx	eax, [ebp+ok]

loc_800157E:				; CODE XREF: do_wipefd+B4j
					; do_wipefd+120j ...
		mov	esi, [ebp+var_C]
		xor	esi, large gs:14h
		jz	short loc_800158F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800158F:				; CODE XREF: do_wipefd+4E4j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
do_wipefd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wipefd(int fd, const char *qname, randint_source *s, const Options *flags)
wipefd		proc near		; CODE XREF: main+410p

fd_flags	= dword	ptr -0Ch
var_4		= dword	ptr -4
fd		= dword	ptr  8
qname		= dword	ptr  0Ch
s		= dword	ptr  10h
flags		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 8
		push	3
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+fd_flags],	eax
		cmp	[ebp+fd_flags],	0
		jns	short loc_80015E5
		sub	esp, 0Ch
		push	offset aSFcntlFailed ; "%s: fcntl failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_800162C
; ---------------------------------------------------------------------------

loc_80015E5:				; CODE XREF: wipefd+1Ej
		mov	eax, [ebp+fd_flags]
		and	eax, 400h
		test	eax, eax
		jz	short loc_8001618
		sub	esp, 0Ch
		push	offset aSCannotShredAp ; "%s: cannot shred append-only file descr"...
		call	gettext
		add	esp, 10h
		push	[ebp+qname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_800162C
; ---------------------------------------------------------------------------

loc_8001618:				; CODE XREF: wipefd+59j
		push	[ebp+flags]	; flags
		push	[ebp+s]		; s
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	do_wipefd
		add	esp, 10h

loc_800162C:				; CODE XREF: wipefd+4Dj wipefd+80j
		mov	ebx, [ebp+var_4]
		leave
		retn
wipefd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	incname(char *name, size_t len)
incname		proc near		; CODE XREF: wipename+21Dp

p		= dword	ptr -0Ch
name		= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		jmp	short loc_800168F
; ---------------------------------------------------------------------------

loc_8001639:				; CODE XREF: incname+69j
		mov	edx, [ebp+name]
		mov	eax, [ebp+len]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset nameset	; "0123456789abcdefghijklmnopqrstuvwxyzABC"...
		call	strchr
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001680
		mov	edx, [ebp+name]
		mov	eax, [ebp+len]
		add	edx, eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+1]
		mov	[edx], al
		mov	eax, 1
		jmp	short locret_80016A1
; ---------------------------------------------------------------------------

loc_8001680:				; CODE XREF: incname+35j
		mov	edx, [ebp+name]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	edx, 30h
		mov	[eax], dl

loc_800168F:				; CODE XREF: incname+6j
		mov	eax, [ebp+len]
		lea	edx, [eax-1]
		mov	[ebp+len], edx
		test	eax, eax
		jnz	short loc_8001639
		mov	eax, 0

locret_80016A1:				; CODE XREF: incname+4Dj
		leave
		retn
incname		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wipename(char *oldname,	const char *qoldname, const Options *flags)
wipename	proc near		; CODE XREF: wipefile+110p

flags		= dword	ptr -0A4h
qoldname	= dword	ptr -0A0h
oldname		= dword	ptr -9Ch
first		= byte ptr -8Ah
ok		= byte ptr -89h
len		= dword	ptr -88h
newname		= dword	ptr -84h
base		= dword	ptr -80h
dir		= dword	ptr -7Ch
qdir		= dword	ptr -78h
dir_fd		= dword	ptr -74h
old		= dword	ptr -70h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0A4h
		mov	eax, [ebp+arg_0]
		mov	[ebp+oldname], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+qoldname],	eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+flags], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+oldname]	; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+newname], eax
		sub	esp, 0Ch
		push	[ebp+newname]
		call	last_component
		add	esp, 10h
		mov	[ebp+base], eax
		sub	esp, 0Ch
		push	[ebp+base]
		call	base_len
		add	esp, 10h
		mov	[ebp+len], eax
		sub	esp, 0Ch
		push	[ebp+newname]
		call	dir_name
		add	esp, 10h
		mov	[ebp+dir], eax
		sub	esp, 0Ch
		push	[ebp+dir]
		call	quotearg_colon
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+qdir], eax
		mov	[ebp+first], 1
		mov	[ebp+ok], 1
		sub	esp, 8
		push	10900h
		push	[ebp+dir]
		call	open_safer
		add	esp, 10h
		mov	[ebp+dir_fd], eax
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+11h]
		test	al, al
		jz	loc_80018DA
		sub	esp, 0Ch
		push	offset aSRemoving ; "%s: removing"
		call	gettext
		add	esp, 10h
		push	[ebp+qoldname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_80018DA
; ---------------------------------------------------------------------------

loc_80017A1:				; CODE XREF: wipename+23Ej
		mov	eax, 30h
		movsx	eax, al
		sub	esp, 4
		push	[ebp+len]	; n
		push	eax		; c
		push	[ebp+base]	; s
		call	memset
		add	esp, 10h
		mov	edx, [ebp+base]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	byte ptr [eax],	0

loc_80017CC:				; CODE XREF: wipename+227j
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	[ebp+newname]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jns	loc_80018B4
		sub	esp, 8
		push	[ebp+newname]	; new
		push	[ebp+oldname]	; old
		call	rename
		add	esp, 10h
		test	eax, eax
		jnz	loc_80018D2
		cmp	[ebp+dir_fd], 0
		js	short loc_800182A
		sub	esp, 8
		push	[ebp+qdir]	; qname
		push	[ebp+dir_fd]	; fd
		call	dosync
		add	esp, 10h
		test	eax, eax
		jz	short loc_800182A
		mov	[ebp+ok], 0

loc_800182A:				; CODE XREF: wipename+169j
					; wipename+17Ej
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+11h]
		test	al, al
		jz	short loc_8001882
		cmp	[ebp+first], 0
		jz	short loc_8001849
		mov	eax, [ebp+qoldname]
		jmp	short loc_800184F
; ---------------------------------------------------------------------------

loc_8001849:				; CODE XREF: wipename+19Cj
		mov	eax, [ebp+oldname]

loc_800184F:				; CODE XREF: wipename+1A4j
		mov	[ebp+old], eax
		sub	esp, 0Ch
		push	offset aSRenamedToS ; "%s: renamed to %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+newname]
		push	[ebp+old]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	[ebp+first], 0

loc_8001882:				; CODE XREF: wipename+193j
		mov	eax, [ebp+len]
		lea	edx, [eax+1]
		mov	ecx, [ebp+base]
		mov	eax, [ebp+newname]
		sub	ecx, eax
		mov	eax, ecx
		mov	ecx, eax
		mov	eax, [ebp+oldname]
		add	eax, ecx
		sub	esp, 4
		push	edx		; n
		push	[ebp+base]	; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		jmp	short loc_80018D3
; ---------------------------------------------------------------------------

loc_80018B4:				; CODE XREF: wipename+140j
		sub	esp, 8
		push	[ebp+len]	; len
		push	[ebp+base]	; name
		call	incname
		add	esp, 10h
		test	al, al
		jnz	loc_80017CC
		jmp	short loc_80018D3
; ---------------------------------------------------------------------------

loc_80018D2:				; CODE XREF: wipename+15Fj
		nop

loc_80018D3:				; CODE XREF: wipename+20Fj
					; wipename+22Dj
		sub	[ebp+len], 1

loc_80018DA:				; CODE XREF: wipename+D0j wipename+F9j
		cmp	[ebp+len], 0
		jnz	loc_80017A1
		sub	esp, 0Ch
		push	[ebp+oldname]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001930
		sub	esp, 0Ch
		push	offset aSFailedToRemov ; "%s: failed to	remove"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qoldname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	short loc_8001961
; ---------------------------------------------------------------------------

loc_8001930:				; CODE XREF: wipename+257j
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+11h]
		test	al, al
		jz	short loc_8001961
		sub	esp, 0Ch
		push	offset aSRemoved ; "%s:	removed"
		call	gettext
		add	esp, 10h
		push	[ebp+qoldname]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001961:				; CODE XREF: wipename+28Bj
					; wipename+299j
		cmp	[ebp+dir_fd], 0
		js	short loc_80019C4
		sub	esp, 8
		push	[ebp+qdir]	; qname
		push	[ebp+dir_fd]	; fd
		call	dosync
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001983
		mov	[ebp+ok], 0

loc_8001983:				; CODE XREF: wipename+2D7j
		sub	esp, 0Ch
		push	[ebp+dir_fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_80019C4
		sub	esp, 0Ch
		push	offset aSFailedToClose ; "%s: failed to	close"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qdir]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_80019C4:				; CODE XREF: wipename+2C2j
					; wipename+2F0j
		sub	esp, 0Ch
		push	[ebp+newname]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+dir]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+qdir]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8001A09
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001A09:				; CODE XREF: wipename+35Fj
		mov	ebx, [ebp+var_4]
		leave
		retn
wipename	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wipefile(char *name, const char	*qname,	randint_source *s, const Options *flags)
wipefile	proc near		; CODE XREF: main+44Bp

ok		= byte ptr -0Dh
fd		= dword	ptr -0Ch
var_4		= dword	ptr -4
name		= dword	ptr  8
qname		= dword	ptr  0Ch
s		= dword	ptr  10h
flags		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 8
		push	101h
		push	[ebp+name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		jns	short loc_8001A74
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 0Dh
		jnz	short loc_8001A74
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001A74
		sub	esp, 8
		push	80h		; mode
		push	[ebp+name]	; file
		call	chmod
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A74
		sub	esp, 8
		push	101h
		push	[ebp+name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+fd], eax

loc_8001A74:				; CODE XREF: wipefile+21j wipefile+2Dj ...
		cmp	[ebp+fd], 0
		jns	short loc_8001AAC
		sub	esp, 0Ch
		push	offset aSFailedToOpenF ; "%s: failed to	open for writing"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8001B2D
; ---------------------------------------------------------------------------

loc_8001AAC:				; CODE XREF: wipefile+6Aj
		push	[ebp+flags]	; flags
		push	[ebp+s]		; s
		push	[ebp+qname]	; qname
		push	[ebp+fd]	; fd
		call	do_wipefd
		add	esp, 10h
		mov	[ebp+ok], al
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001B01
		sub	esp, 0Ch
		push	offset aSFailedToClose ; "%s: failed to	close"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+qname]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8001B01:				; CODE XREF: wipefile+C5j
		cmp	[ebp+ok], 0
		jz	short loc_8001B29
		mov	eax, [ebp+flags]
		movzx	eax, byte ptr [eax+10h]
		test	al, al
		jz	short loc_8001B29
		sub	esp, 4
		push	[ebp+flags]	; flags
		push	[ebp+qname]	; qoldname
		push	[ebp+name]	; oldname
		call	wipename
		add	esp, 10h
		mov	[ebp+ok], al

loc_8001B29:				; CODE XREF: wipefile+F7j
					; wipefile+102j
		movzx	eax, [ebp+ok]

loc_8001B2D:				; CODE XREF: wipefile+99j
		mov	ebx, [ebp+var_4]
		leave
		retn
wipefile	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void clear_random_data()
clear_random_data proc near		; DATA XREF: main+396o
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:randint_source_0
		sub	esp, 0Ch
		push	eax
		call	randint_all_free
		add	esp, 10h
		nop
		leave
		retn
clear_random_data endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -5Ch
ok		= byte ptr -51h
i		= dword	ptr -50h
random_source	= dword	ptr -4Ch
c		= dword	ptr -48h
file		= dword	ptr -44h
n_files		= dword	ptr -40h
qname		= dword	ptr -3Ch
tmp		= qword	ptr -38h
flags		= Options ptr -30h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 5Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	dword ptr [ebp+flags.force], 0
		mov	[ebp+flags.n_iterations], 0
		mov	dword ptr [ebp+flags.size], 0
		mov	dword ptr [ebp+flags.size+4], 0
		mov	dword ptr [ebp+flags.remove_file], 0
		mov	[ebp+random_source], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+flags.n_iterations], 3
		mov	dword ptr [ebp+flags.size], 0FFFFFFFFh
		mov	dword ptr [ebp+flags.size+4], 0FFFFFFFFh
		jmp	loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001C12:				; CODE XREF: main+2F5j
		mov	eax, [ebp+c]
		cmp	eax, 73h
		jz	loc_8001D64
		cmp	eax, 73h
		jg	short loc_8001C54
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8001DD7
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_8001C45
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8001DE1
		jmp	loc_8001E14
; ---------------------------------------------------------------------------

loc_8001C45:				; CODE XREF: main+E7j
		cmp	eax, 66h
		jz	short loc_8001C92
		cmp	eax, 6Eh
		jz	short loc_8001C9B
		jmp	loc_8001E14
; ---------------------------------------------------------------------------

loc_8001C54:				; CODE XREF: main+D5j
		cmp	eax, 78h
		jz	loc_8001DCB
		cmp	eax, 78h
		jg	short loc_8001C79
		cmp	eax, 75h
		jz	loc_8001D5B
		cmp	eax, 76h
		jz	loc_8001DC5
		jmp	loc_8001E14
; ---------------------------------------------------------------------------

loc_8001C79:				; CODE XREF: main+114j
		cmp	eax, 7Ah
		jz	loc_8001DD1
		cmp	eax, 80h
		jz	loc_8001D10
		jmp	loc_8001E14
; ---------------------------------------------------------------------------

loc_8001C92:				; CODE XREF: main+FCj
		mov	[ebp+flags.force], 1
		jmp	loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001C9B:				; CODE XREF: main+101j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+tmp]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8001CD1
		mov	eax, dword ptr [ebp+tmp]
		mov	edx, dword ptr [ebp+tmp+4]
		cmp	edx, 0
		jb	short loc_8001D02
		cmp	edx, 0
		ja	short loc_8001CD1
		cmp	eax, 3FFFFFFFh
		jbe	short loc_8001D02

loc_8001CD1:				; CODE XREF: main+16Cj	main+17Cj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSInvalidNumber ; "%s: invalid number of	passes"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D02:				; CODE XREF: main+177j	main+183j
		mov	eax, dword ptr [ebp+tmp]
		mov	edx, dword ptr [ebp+tmp+4]
		mov	[ebp+flags.n_iterations], eax
		jmp	loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001D10:				; CODE XREF: main+13Bj
		cmp	[ebp+random_source], 0
		jz	short loc_8001D4E
		mov	eax, ds:optarg
		sub	esp, 8
		push	eax		; s2
		push	[ebp+random_source] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001D4E
		sub	esp, 0Ch
		push	offset aMultipleRandom ; "multiple random sources specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D4E:				; CODE XREF: main+1C8j	main+1E0j
		mov	eax, ds:optarg
		mov	[ebp+random_source], eax
		jmp	loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001D5B:				; CODE XREF: main+119j
		mov	[ebp+flags.remove_file], 1
		jmp	loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001D64:				; CODE XREF: main+CCj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset aCbbkkmgtpezy0 ;	"cbBkKMGTPEZY0"
		lea	edx, [ebp+tmp]
		push	edx
		push	0
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jz	short loc_8001DB7
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSInvalidFileSi ; "%s: invalid file size"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001DB7:				; CODE XREF: main+238j
		mov	eax, dword ptr [ebp+tmp]
		mov	edx, dword ptr [ebp+tmp+4]
		mov	dword ptr [ebp+flags.size], eax
		mov	dword ptr [ebp+flags.size+4], edx
		jmp	short loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001DC5:				; CODE XREF: main+122j
		mov	[ebp+flags.verbose], 1
		jmp	short loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001DCB:				; CODE XREF: main+10Bj
		mov	[ebp+flags.exact], 1
		jmp	short loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001DD1:				; CODE XREF: main+130j
		mov	[ebp+flags.zero_fill], 1
		jmp	short loc_8001E1E
; ---------------------------------------------------------------------------

loc_8001DD7:				; CODE XREF: main+DCj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001DE1:				; CODE XREF: main+EEj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aColinPlumb ; "Colin Plumb"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aShred	; "shred"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001E14:				; CODE XREF: main+F4j main+103j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001E1E:				; CODE XREF: main+C1j main+14Aj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_opts ; longopts
		push	offset shortopts ; "fn:s:uvxz"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8001C12
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	[ebp+file], eax
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_files], eax
		cmp	[ebp+n_files], 0
		jnz	short loc_8001E99
		sub	esp, 0Ch
		push	offset aMissingFileOpe ; "missing file operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001E99:				; CODE XREF: main+321j
		sub	esp, 8
		push	0FFFFFFFFh
		push	[ebp+random_source]
		call	randint_all_new
		add	esp, 10h
		mov	ds:randint_source_0, eax
		mov	eax, ds:randint_source_0
		test	eax, eax
		jnz	short loc_8001EDF
		sub	esp, 0Ch
		push	[ebp+random_source]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001EDF:				; CODE XREF: main+369j
		sub	esp, 0Ch
		push	offset clear_random_data ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	loc_8001FC2
; ---------------------------------------------------------------------------

loc_8001EFB:				; CODE XREF: main+47Cj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quotearg_colon
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+qname], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80030A6 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001F77
		mov	eax, ds:randint_source_0
		lea	edx, [ebp+flags]
		push	edx		; flags
		push	eax		; s
		push	[ebp+qname]	; qname
		push	1		; fd
		call	wipefd
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	short loc_8001FB0
; ---------------------------------------------------------------------------

loc_8001F77:				; CODE XREF: main+3FFj
		mov	edx, ds:randint_source_0
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, ecx
		mov	eax, [eax]
		lea	ecx, [ebp+flags]
		push	ecx		; flags
		push	edx		; s
		push	[ebp+qname]	; qname
		push	eax		; name
		call	wipefile
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001FB0:				; CODE XREF: main+429j
		sub	esp, 0Ch
		push	[ebp+qname]	; ptr
		call	free
		add	esp, 10h
		add	[ebp+i], 1

loc_8001FC2:				; CODE XREF: main+3AAj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jl	loc_8001EFB
		cmp	[ebp+ok], 0
		jz	short loc_8001FDB
		mov	eax, 0
		jmp	short loc_8001FE0
; ---------------------------------------------------------------------------

loc_8001FDB:				; CODE XREF: main+486j
		mov	eax, 1

loc_8001FE0:				; CODE XREF: main+48Dj
		sub	esp, 0Ch
		push	eax		; status

loc_8001FE4:				; DATA XREF: .eh_frame:080030C8o
					; .eh_frame:080030ECo ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8001FECh
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; randint_source *randint_source_0
randint_source_0 dd ?			; DATA XREF: clear_random_data+6r
					; main+35Dw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8002000h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+7Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+2ABo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aExact		db 'exact',0            ; DATA XREF: .rodata:long_optso
aForce		db 'force',0            ; DATA XREF: .rodata:long_optso
aIterations	db 'iterations',0       ; DATA XREF: .rodata:long_optso
aSize		db 'size',0             ; DATA XREF: .rodata:long_optso
aRandomSource	db 'random-source',0    ; DATA XREF: .rodata:long_optso
aRemove		db 'remove',0           ; DATA XREF: .rodata:long_optso
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:long_optso
aZero		db 'zero',0             ; DATA XREF: .rodata:long_optso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optso
		align 10h
; const	option long_opts[11]
long_opts	option <offset aExact, 0, 0, 78h> ; DATA XREF: main+2D7o
		option <offset aForce, 0, 0, 66h> ; "exact"
		option <offset aIterations, 1, 0, 6Eh>
		option <offset aSize, 1, 0, 73h>
		option <offset aRandomSource, 1, 0, 80h>
		option <offset aRemove,	0, 0, 75h>
		option <offset aVerbose, 0, 0, 76h>
		option <offset aZero, 0, 0, 7Ah>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... FILE...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aOverwriteTheSp[]
aOverwriteTheSp	db 'Overwrite the specified FILE(s) repeatedly, in order to make it h'
					; DATA XREF: usage+69o
		db 'arder',0Ah
		db 'for even very expensive hardware probing to recover the data.',0Ah
		db 0Ah,0
		align 10h
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aFForceChangePe[]
aFForceChangePe	db '  -f, --force    change permissions to allow writing if necessary'
					; DATA XREF: usage+A9o
		db 0Ah
		db '  -n, --iterations=N  overwrite N times instead of the default (%'
		db 'd)',0Ah
		db '      --random-source=FILE  get random bytes from FILE',0Ah
		db '  -s, --size=N   shred this many bytes (suffixes like K, M, G acc'
		db 'epted)',0Ah,0
		align 4
; char aURemoveTruncat[]
aURemoveTruncat	db '  -u, --remove   truncate and remove file after overwriting',0Ah
					; DATA XREF: usage+CDo
		db '  -v, --verbose  show progress',0Ah
		db '  -x, --exact    do not round file sizes up to the next full bloc'
		db 'k;',0Ah
		db '                   this is the default for non-regular files',0Ah
		db '  -z, --zero     add a final overwrite with zeros to hide shreddi'
		db 'ng',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+F0o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+113o
		align 10h
; char aIfFileIsShredS[]
aIfFileIsShredS	db 0Ah			; DATA XREF: usage+136o
		db 'If FILE is -, shred standard output.',0Ah
		db 0Ah
		db 'Delete FILE(s) if --remove (-u) is specified.  The default is not'
		db ' to remove',0Ah
		db 'the files because it is common to operate on device files like /d'
		db 'ev/hda,',0Ah
		db 'and those files usually should not be removed.  When operating on'
		db ' regular',0Ah
		db 'files, most people use the --remove option.',0Ah
		db 0Ah,0
; char aCautionNoteTha[]
aCautionNoteTha	db 'CAUTION: Note that shred relies on a very important assumption:',0Ah
					; DATA XREF: usage+159o
		db 'that the file system overwrites data in place.  This is the tradi'
		db 'tional',0Ah
		db 'way to do things, but many modern file system designs do not sati'
		db 'sfy this',0Ah
		db 'assumption.  The following are examples of file systems on which '
		db 'shred is',0Ah
		db 'not effective, or is not guaranteed to be effective in all file s'
		db 'ystem modes:',0Ah
		db 0Ah,0
; char aLogStructuredO[]
aLogStructuredO	db '* log-structured or journaled file systems, such as those supplie'
					; DATA XREF: usage+17Co
		db 'd with',0Ah
		db 'AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)',0Ah
		db 0Ah
		db '* file systems that write redundant data and carry on even if som'
		db 'e writes',0Ah
		db 'fail, such as RAID-based file systems',0Ah
		db 0Ah
		db '* file systems that make snapshots, such as Network Appliance',27h,'s'
		db ' NFS server',0Ah
		db 0Ah,0
; char aFileSystemsTha[]
aFileSystemsTha	db '* file systems that cache in temporary locations, such as NFS',0Ah
					; DATA XREF: usage+19Fo
		db 'version 3 clients',0Ah
		db 0Ah
		db '* compressed file systems',0Ah
		db 0Ah,0
		align 4
; char aInTheCaseOfExt[]
aInTheCaseOfExt	db 'In the case of ext3 file systems, the above disclaimer applies',0Ah
					; DATA XREF: usage+1C2o
		db '(and shred is thus of limited effectiveness) only in data=journal'
		db ' mode,',0Ah
		db 'which journals file data in addition to just metadata.  In both t'
		db 'he',0Ah
		db 'data=ordered (default) and data=writeback modes, shred works as u'
		db 'sual.',0Ah
		db 'Ext3 journaling modes can be changed by adding the data=something'
		db ' option',0Ah
		db 'to the mount options for a particular file system in the /etc/fst'
		db 'ab file,',0Ah
		db 'as documented in the mount man page (man mount).',0Ah
		db 0Ah,0
; char aInAdditionFile[]
aInAdditionFile	db 'In addition, file system backups and remote mirrors may contain c'
					; DATA XREF: usage+1E5o
		db 'opies',0Ah
		db 'of the file that cannot be removed, and that will allow a shredde'
		db 'd file',0Ah
		db 'to be recovered later.',0Ah,0
; char format[]
format		db '%02x%02x%02x',0     ; DATA XREF: passname+33o
aRandom		db 'random',0           ; DATA XREF: passname+4Ao
; char aSFdatasyncFail[]
aSFdatasyncFail	db '%s: fdatasync failed',0 ; DATA XREF: dosync+44o
; char aSFsyncFailed[]
aSFsyncFailed	db '%s: fsync failed',0 ; DATA XREF: dosync+B0o
; char aSCannotRewind[]
aSCannotRewind	db '%s: cannot rewind',0 ; DATA XREF: dopass+95o
; char aSPassLuLuS___[]
aSPassLuLuS___	db '%s: pass %lu/%lu (%s)...',0 ; DATA XREF: dopass+161o
; char locale[4]
locale		db 4 dup(0)		; DATA XREF: dopass+1A9o main+68o
; char aSErrorWritingA[]
aSErrorWritingA	db '%s: error writing at offset %s',0 ; DATA XREF: dopass+3A5o
; char aSLseekFailed[]
aSLseekFailed	db '%s: lseek failed',0 ; DATA XREF: dopass+468o
; char aSFileTooLarge[]
aSFileTooLarge	db '%s: file too large',0 ; DATA XREF: dopass+4F7o
; char aSPassLuLuS_[]
aSPassLuLuS___S	db '%s: pass %lu/%lu (%s)...%s',0 ; DATA XREF: dopass+620o
		align 4
; char aSPassLuLuS___0[]
aSPassLuLuS___0	db '%s: pass %lu/%lu (%s)...%s/%s %d%%',0 ; DATA XREF: dopass+785o
		align 10h
; const	int patterns[55]
patterns	dd 0FFFFFFFEh, 2, 0, 0FFFh, 2, 555h, 0AAAh, 0FFFFFFFFh
					; DATA XREF: genpattern+11o
					; genpattern+3Fo
		dd 6, 249h, 492h, 6DBh,	924h, 0B6Dh, 0DB6h, 0Ch, 111h
		dd 222h, 333h, 444h, 666h, 777h, 888h, 999h, 0BBBh, 0CCCh
		dd 0DDDh, 0EEEh, 0FFFFFFFFh, 8,	1000h, 1249h, 1492h, 16DBh
		dd 1924h, 1B6Dh, 1DB6h,	1FFFh, 0Eh, 1111h, 1222h, 1333h
		dd 1444h, 1555h, 1666h,	1777h, 1888h, 1999h, 1AAAh, 1BBBh
		dd 1CCCh, 1DDDh, 1EEEh,	0FFFFFFFFh, 0
; char aSFstatFailed[]
aSFstatFailed	db '%s: fstat failed',0 ; DATA XREF: do_wipefd+87o
; char aSInvalidFileTy[]
aSInvalidFileTy	db '%s: invalid file type',0 ; DATA XREF: do_wipefd+FBo
; char aSFileHasNegati[]
aSFileHasNegati	db '%s: file has negative size',0 ; DATA XREF: do_wipefd+1A4o
; char aSErrorTruncati[]
aSErrorTruncati	db '%s: error truncating',0 ; DATA XREF: do_wipefd+4A4o
; char aSFcntlFailed[]
aSFcntlFailed	db '%s: fcntl failed',0 ; DATA XREF: wipefd+23o
; char aSCannotShredAp[]
aSCannotShredAp	db '%s: cannot shred append-only file descriptor',0 ; DATA XREF: wipefd+5Eo
		align 10h
; char nameset[65]
nameset		db '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.',0
					; DATA XREF: incname+1Ao
; char aSRemoving[]
aSRemoving	db '%s: removing',0     ; DATA XREF: wipename+D9o
; char aSRenamedToS[]
aSRenamedToS	db '%s: renamed to %s',0 ; DATA XREF: wipename+1B2o
; char aSFailedToRemov[]
aSFailedToRemov	db '%s: failed to remove',0 ; DATA XREF: wipename+25Co
; char aSRemoved[]
aSRemoved	db '%s: removed',0      ; DATA XREF: wipename+29Eo
; char aSFailedToClose[]
aSFailedToClose	db '%s: failed to close',0 ; DATA XREF: wipename+2F5o
					; wipefile+CAo
		align 4
; char aSFailedToOpenF[]
aSFailedToOpenF	db '%s: failed to open for writing',0 ; DATA XREF: wipefile+6Fo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+7Ao
; char aSInvalidNumber[]
aSInvalidNumber	db '%s: invalid number of passes',0 ; DATA XREF: main+19Bo
; char aMultipleRandom[]
aMultipleRandom	db 'multiple random sources specified',0 ; DATA XREF: main+1E5o
aCbbkkmgtpezy0	db 'cbBkKMGTPEZY0',0    ; DATA XREF: main+220o
; char aSInvalidFileSi[]
aSInvalidFileSi	db '%s: invalid file size',0 ; DATA XREF: main+250o
aColinPlumb	db 'Colin Plumb',0      ; DATA XREF: main+2A5o
aShred		db 'shred',0            ; DATA XREF: main+2B0o
; char shortopts[]
shortopts	db 'fn:s:uvxz',0        ; DATA XREF: main+2DCo
; char aMissingFileOpe[]
aMissingFileOpe	db 'missing file operand',0 ; DATA XREF: main+326o
; char aS[]
aS		db '%s',0               ; DATA XREF: main+383o
; char asc_80030A6[]
asc_80030A6	db '-',0                ; DATA XREF: main+3EFo
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80030A8h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8001FE4-80050ACh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset loc_8001FE4-8004FB4h
		dd 30h,	80E4100h, 0D420285h, 0CC56C05h,	404h, 18h, 60h
		dd offset loc_8001FE4-8004FA4h
		dd 20Fh, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_8001FE4-8004DB1h
		dd 0D5h, 80E4100h, 0D420285h, 0C5D10205h, 4040Ch, 1Ch
		dd 9Ch
		dd offset loc_8001FE4-8004CFCh
		dd 5Dh,	80E4100h, 0D420285h, 0C5590205h, 4040Ch, 1Ch, 0BCh
		dd offset loc_8001FE4-8004CBFh
		dd 26h,	80E4100h, 0D420285h, 0CC56205h,	404h, 1Ch, 0DCh
		dd offset loc_8001FE4-8004CB9h
		dd 0EDh, 80E4100h, 0D420285h, 0C5E90205h, 4040Ch, 1Ch
		dd 0FCh
		dd offset loc_8001FE4-8004BECh
		dd 5Ah,	80E4100h, 0D420285h, 0C5560205h, 4040Ch, 20h, 11Ch
		dd offset loc_8001FE4-8004BB2h
		dd 88Ah, 80E4100h, 0D420285h, 3834705h,	0C5087F03h, 4040CC3h
		dd 20h,	140h
		dd offset loc_8001FE4-800434Ch
		dd 220h, 80E4100h, 0D420285h, 3834405h,	0C5021803h, 4040CC3h
		dd 28h,	164h
		dd offset loc_8001FE4-8004150h
		dd 4F2h, 80E4100h, 0D420285h, 3864805h,	0E4030483h, 0C641C304h
		dd 40CC541h, 4,	20h, 190h
		dd offset loc_8001FE4-8003C8Ah
		dd 9Bh,	80E4100h, 0D420285h, 3834405h, 0C3C59302h, 4040Ch
		dd 1Ch,	1B4h
		dd offset loc_8001FE4-8003C13h
		dd 72h,	80E4100h, 0D420285h, 0C56E0205h, 4040Ch, 20h, 1D4h
		dd offset loc_8001FE4-8003BC1h
		dd 36Bh, 80E4100h, 0D420285h, 3834705h,	0C5036003h, 4040CC3h
		dd 20h,	1F8h
		dd offset loc_8001FE4-800387Ah
		dd 124h, 80E4100h, 0D420285h, 3834405h,	0C5011C03h, 4040CC3h
		dd 1Ch,	21Ch
		dd offset loc_8001FE4-800377Ah
		dd 1Ah,	80E4100h, 0D420285h, 0CC55605h,	404h, 28h, 23Ch
		dd offset loc_8001FE4-8003780h
		dd 49Dh, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+6Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn randint_genmax:near ; CODE XREF: randint_choose+26p
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+20Ap main+2C3p ...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: fillpattern+5Bp
					; fillpattern+8Ep ...
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: passname+3Bp
; int fdatasync(int fildes)
		extrn fdatasync:near	; CODE XREF: dosync+Cp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: dosync:loc_80004D5p
					; dosync+62p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: dosync+5Ap dosync+C6p ...
; int fsync(int	fd)
		extrn fsync:near	; CODE XREF: dosync+7Bp
; void sync(void)
		extrn sync:near		; CODE XREF: dosync:loc_8000594p
		extrn rpl_fcntl:near	; CODE XREF: direct_mode+14p
					; direct_mode+4Fp ...
		extrn __udivdi3:near	; CODE XREF: dopass+6DEp dopass+710p
		extrn __divdi3:near	; CODE XREF: dopass+6FAp
		extrn lseek64:near	; CODE XREF: dopass+7Cp dopass+434p ...
; time_t time(time_t *timer)
		extrn time:near		; CODE XREF: dopass+198p dopass+574p
		extrn randread:near	; CODE XREF: dopass+275p
; ssize_t write(int fd,	const void *buf, size_t	n)
		extrn write:near	; CODE XREF: dopass+2AEp
		extrn umaxtostr:near	; CODE XREF: dopass+398p
		extrn human_readable:near ; CODE XREF: dopass+5C7p dopass+748p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: dopass+604p main+1D6p ...
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: dopass+7D9p
		extrn __stack_chk_fail:near ; CODE XREF: dopass+880p
					; do_wipefd+4E6p ...
		extrn __moddi3:near	; CODE XREF: do_wipefd+2ADp
		extrn fstat64:near	; CODE XREF: do_wipefd+78p
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: do_wipefd+CEp
		extrn xnmalloc:near	; CODE XREF: do_wipefd+144p
		extrn randint_get_source:near ;	CODE XREF: do_wipefd+30Fp
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: do_wipefd+399p
					; do_wipefd+3F7p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: do_wipefd+3AAp
					; do_wipefd+408p ...
		extrn ftruncate64:near	; CODE XREF: do_wipefd+486p
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: incname+1Fp
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: wipename+39p wipename+95p ...
		extrn base_len:near	; CODE XREF: wipename+61p
		extrn dir_name:near	; CODE XREF: wipename+78p
		extrn quotearg_colon:near ; CODE XREF: wipename+89p main+18Ep	...
		extrn open_safer:near	; CODE XREF: wipename+B9p wipefile+12p ...
		extrn lstat64:near	; CODE XREF: wipename+136p
; int rename(const char	*old, const char *new)
		extrn rename:near	; CODE XREF: wipename+155p
; int unlink(const char	*name)
		extrn unlink:near	; CODE XREF: wipename+24Dp
; int close(int	fd)
		extrn close:near	; CODE XREF: wipename+2E6p
					; wipefile+BBp
; int chmod(const char *file, __mode_t mode)
		extrn chmod:near	; CODE XREF: wipefile+44p
		extrn randint_all_free:near ; CODE XREF: clear_random_data+Fp
		extrn set_program_name:near ; CODE XREF: main+5Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+84p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+94p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+9Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+A4p main+39Bp
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8001C9Br
					; main:loc_8001CD1r ...
		extrn xstrtoumax:near	; CODE XREF: main+162p	main+22Ep
		extrn Version:dword	; DATA XREF: main:loc_8001DE1r
		extrn version_etc:near	; CODE XREF: main+2B6p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+2E6p
; int optind
		extrn optind:dword	; DATA XREF: main+2FBr	main+30Fr
		extrn randint_all_new:near ; CODE XREF:	main+355p


		end
