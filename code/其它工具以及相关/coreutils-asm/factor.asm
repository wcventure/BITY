;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	28A5DAA004F4E901731071E315CFA01A
; Input	CRC32 :	7BA718B5

; File Name   :	D:\coreutils-o\factor.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'factor.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+CEp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void debug(const char	*fmt, ...)
debug		proc near		; CODE XREF: print_factors+5Dp

fmt		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
debug		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl factor_wheel(uintmax_t	n0, size_t max_n_factors, uintmax_t *factors)
factor_wheel	proc near		; CODE XREF: print_factors_single+3Bp

n0		= qword	ptr -30h
n_factors	= dword	ptr -28h
w		= dword	ptr -24h
n		= qword	ptr -20h
d		= qword	ptr -18h
q		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
max_n_factors	= dword	ptr  10h
factors		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n0], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n0+4], eax
		mov	eax, dword ptr [ebp+n0]
		mov	edx, dword ptr [ebp+n0+4]
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		mov	[ebp+n_factors], 0
		mov	[ebp+w], offset	wheel_tab
		cmp	dword ptr [ebp+n+4], 0
		ja	short loc_8000168
		cmp	dword ptr [ebp+n+4], 0
		jb	short loc_8000160
		cmp	dword ptr [ebp+n], 1
		ja	short loc_8000168

loc_8000160:				; CODE XREF: factor_wheel+36j
		mov	eax, [ebp+n_factors]
		jmp	locret_80002D0
; ---------------------------------------------------------------------------

loc_8000168:				; CODE XREF: factor_wheel+30j
					; factor_wheel+3Cj
		mov	dword ptr [ebp+d], 2
		mov	dword ptr [ebp+d+4], 0

loc_8000176:				; CODE XREF: factor_wheel+13Bj
					; factor_wheel+149j
		push	dword ptr [ebp+d+4]
		push	dword ptr [ebp+d]
		push	dword ptr [ebp+n+4]
		push	dword ptr [ebp+n]
		call	__udivdi3
		add	esp, 10h
		mov	dword ptr [ebp+q], eax
		mov	dword ptr [ebp+q+4], edx
		jmp	short loc_80001FA
; ---------------------------------------------------------------------------

loc_8000192:				; CODE XREF: factor_wheel+101j
		mov	eax, [ebp+n_factors]
		cmp	eax, [ebp+max_n_factors]
		jb	short loc_80001B3
		push	offset __PRETTY_FUNCTION___5163	; "factor_wheel"
		push	13Ah		; line
		push	offset file	; "factor.c"
		push	offset assertion ; "n_factors <	max_n_factors"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80001B3:				; CODE XREF: factor_wheel+76j
		mov	eax, [ebp+n_factors]
		lea	edx, [eax+1]
		mov	[ebp+n_factors], edx
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+factors]
		lea	ecx, [edx+eax]
		mov	eax, dword ptr [ebp+d]
		mov	edx, dword ptr [ebp+d+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, dword ptr [ebp+q]
		mov	edx, dword ptr [ebp+q+4]
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		push	dword ptr [ebp+d+4]
		push	dword ptr [ebp+d]
		push	dword ptr [ebp+n+4]
		push	dword ptr [ebp+n]
		call	__udivdi3
		add	esp, 10h
		mov	dword ptr [ebp+q], eax
		mov	dword ptr [ebp+q+4], edx

loc_80001FA:				; CODE XREF: factor_wheel+6Ej
		mov	eax, dword ptr [ebp+q+4]
		imul	eax, dword ptr [ebp+d]
		mov	edx, eax
		mov	eax, dword ptr [ebp+d+4]
		imul	eax, dword ptr [ebp+q]
		lea	ecx, [edx+eax]
		mov	eax, dword ptr [ebp+d]
		mul	dword ptr [ebp+q]
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+n+4]
		xor	eax, dword ptr [ebp+n]
		or	eax, ecx
		test	eax, eax
		jz	loc_8000192
		mov	eax, [ebp+w]
		lea	edx, [eax+1]
		mov	[ebp+w], edx
		movzx	ecx, byte ptr [eax]
		movzx	eax, cl
		mov	edx, 0
		add	dword ptr [ebp+d], eax
		adc	dword ptr [ebp+d+4], edx
		mov	eax, offset file ; "factor.c"
		cmp	[ebp+w], eax
		jnz	short loc_8000254
		mov	[ebp+w], (offset wheel_tab+5)

loc_8000254:				; CODE XREF: factor_wheel+129j
		mov	eax, dword ptr [ebp+d]
		mov	edx, dword ptr [ebp+d+4]
		cmp	edx, dword ptr [ebp+q+4]
		jb	loc_8000176
		cmp	edx, dword ptr [ebp+q+4]
		ja	short loc_8000271
		cmp	eax, dword ptr [ebp+q]
		jbe	loc_8000176

loc_8000271:				; CODE XREF: factor_wheel+144j
		mov	eax, dword ptr [ebp+n]
		xor	eax, 1
		or	eax, dword ptr [ebp+n+4]
		test	eax, eax
		jnz	short loc_800028B
		mov	eax, dword ptr [ebp+n0]
		xor	eax, 1
		or	eax, dword ptr [ebp+n0+4]
		test	eax, eax
		jnz	short loc_80002CD

loc_800028B:				; CODE XREF: factor_wheel+15Aj
		mov	eax, [ebp+n_factors]
		cmp	eax, [ebp+max_n_factors]
		jb	short loc_80002AC
		push	offset __PRETTY_FUNCTION___5163	; "factor_wheel"
		push	147h		; line
		push	offset file	; "factor.c"
		push	offset assertion ; "n_factors <	max_n_factors"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80002AC:				; CODE XREF: factor_wheel+16Fj
		mov	eax, [ebp+n_factors]
		lea	edx, [eax+1]
		mov	[ebp+n_factors], edx
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+factors]
		lea	ecx, [edx+eax]
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	[ecx], eax
		mov	[ecx+4], edx

loc_80002CD:				; CODE XREF: factor_wheel+167j
		mov	eax, [ebp+n_factors]

locret_80002D0:				; CODE XREF: factor_wheel+41j
		leave
		retn
factor_wheel	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_factors_single(uintmax_t n)
print_factors_single proc near		; CODE XREF: print_factors+70p

n		= qword	ptr -240h
i		= dword	ptr -230h
n_factors	= dword	ptr -22Ch
factors		= qword	ptr -228h
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 248h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		lea	eax, [ebp+factors]
		push	eax		; factors
		push	40h		; max_n_factors
		push	dword ptr [ebp+n+4]
		push	dword ptr [ebp+n] ; n0
		call	factor_wheel
		add	esp, 10h
		mov	[ebp+n_factors], eax
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+n+4]
		push	dword ptr [ebp+n]
		call	umaxtostr
		add	esp, 10h
		sub	esp, 8
		push	eax
		push	offset format	; "%s:"
		call	printf
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8000390
; ---------------------------------------------------------------------------

loc_8000353:				; CODE XREF: print_factors_single+CAj
		mov	eax, [ebp+i]
		mov	edx, dword ptr [ebp+eax*8+factors+4]
		mov	eax, dword ptr [ebp+eax*8+factors]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		sub	esp, 8
		push	eax
		push	offset aS_0	; " %s"
		call	printf
		add	esp, 10h
		add	[ebp+i], 1

loc_8000390:				; CODE XREF: print_factors_single+7Fj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_factors]
		jb	short loc_8000353
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80003BD
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80003BD:				; CODE XREF: print_factors_single+E4j
		leave
		retn
print_factors_single endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	print_factors(const char *s)
print_factors	proc near		; CODE XREF: do_stdin+4Dp main+137p

s		= dword	ptr -2Ch
err		= dword	ptr -1Ch
n		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset shortopts
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		push	0
		push	[ebp+s]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+err], eax
		mov	eax, [ebp+err]
		test	eax, eax
		jz	short loc_8000403
		cmp	eax, 1
		jz	short loc_800043E
		jmp	short loc_8000473
; ---------------------------------------------------------------------------

loc_8000403:				; CODE XREF: print_factors+3Bj
		sub	esp, 0Ch
		push	offset aUsingSinglePre ; "using	single-precision arithmetic"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	eax
		push	offset fmt	; "[%s]"
		call	debug
		add	esp, 10h
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		sub	esp, 8
		push	edx
		push	eax		; n
		call	print_factors_single
		add	esp, 10h
		mov	eax, 1
		jmp	short loc_80004A6
; ---------------------------------------------------------------------------

loc_800043E:				; CODE XREF: print_factors+40j
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSIsTooLarge ; "%s is too large"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_80004A6
; ---------------------------------------------------------------------------

loc_8000473:				; CODE XREF: print_factors+42j
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSIsNotAValidPo ; "%s is	not a valid positive integer"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0

loc_80004A6:				; CODE XREF: print_factors+7Dj
					; print_factors+B2j
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_80004B7
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80004B7:				; CODE XREF: print_factors+F1j
		mov	ebx, [ebp+var_4]
		leave
		retn
print_factors	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+96p main+D3p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_80004F7
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800058F
; ---------------------------------------------------------------------------

loc_80004F7:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSNumber__ ; "Usage: %s [NUMBER]...\n  or:	%s OPTION"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintThePrimeF ; "Print	the prime factors of each specifi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800058F:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	do_stdin()
do_stdin	proc near		; CODE XREF: main+10Ap

ok		= byte ptr -19h
token_length	= dword	ptr -18h
tokenbuffer	= token_buffer ptr -14h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		sub	esp, 0Ch
		lea	eax, [ebp+tokenbuffer]
		push	eax
		call	init_tokenbuffer
		add	esp, 10h

loc_80005BE:				; CODE XREF: do_stdin+66j
		mov	eax, ds:stdin
		lea	edx, [ebp+tokenbuffer]
		push	edx
		push	3
		push	offset asc_8000D1E ; "\n\t "
		push	eax
		call	readtoken
		add	esp, 10h
		mov	[ebp+token_length], eax
		cmp	[ebp+token_length], 0FFFFFFFFh
		jz	short loc_8000602
		mov	eax, [ebp+tokenbuffer.buffer]
		sub	esp, 0Ch
		push	eax		; s
		call	print_factors
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	short loc_80005BE
; ---------------------------------------------------------------------------

loc_8000602:				; CODE XREF: do_stdin+44j
		nop
		mov	eax, [ebp+tokenbuffer.buffer]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8000627
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000627:				; CODE XREF: do_stdin+86j
		leave
		retn
do_stdin	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ok		= byte ptr -11h
i		= dword	ptr -10h
c		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset shortopts ; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	short loc_8000701
; ---------------------------------------------------------------------------

loc_8000697:				; CODE XREF: main+FBj
		mov	eax, [ebp+c]
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_80006BA
		cmp	eax, 80h
		jz	short loc_80006B1
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_80006C4
		jmp	short loc_80006F7
; ---------------------------------------------------------------------------

loc_80006B1:				; CODE XREF: main+7Dj
		mov	ds:verbose, 1
		jmp	short loc_8000701
; ---------------------------------------------------------------------------

loc_80006BA:				; CODE XREF: main+76j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80006C4:				; CODE XREF: main+84j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aPaulRubin ; "Paul Rubin"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aFactor	; "factor"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80006F7:				; CODE XREF: main+86j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000701:				; CODE XREF: main+6Cj main+8Fj
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; shortopts
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8000697
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_800073D
		call	do_stdin
		mov	[ebp+ok], al
		jmp	short loc_800077E
; ---------------------------------------------------------------------------

loc_800073D:				; CODE XREF: main+108j
		mov	[ebp+ok], 1
		mov	eax, ds:optind
		mov	[ebp+i], eax
		jmp	short loc_8000777
; ---------------------------------------------------------------------------

loc_800074B:				; CODE XREF: main+153j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	print_factors
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000773
		mov	[ebp+ok], 0

loc_8000773:				; CODE XREF: main+144j
		add	[ebp+i], 1

loc_8000777:				; CODE XREF: main+120j
		mov	eax, [ebp+i]
		cmp	eax, [ebx]
		jl	short loc_800074B

loc_800077E:				; CODE XREF: main+112j
		cmp	[ebp+ok], 0
		jz	short loc_800078B
		mov	eax, 0
		jmp	short loc_8000790
; ---------------------------------------------------------------------------

loc_800078B:				; CODE XREF: main+159j
		mov	eax, 1

loc_8000790:				; CODE XREF: main+160j
		sub	esp, 0Ch
		push	eax		; status

loc_8000794:				; DATA XREF: .eh_frame:08000D7Co
					; .eh_frame:08000DA0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 800079Ah
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	verbose
verbose		db ?			; DATA XREF: main:loc_80006B1w
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80007A0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+B1o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 20h
; const	unsigned __int8	wheel_tab[485]
wheel_tab	db 1, 2	dup(2),	4, 2, 4, 2, 4, 6, 2, 6,	4, 2, 4, 2 dup(6)
					; DATA XREF: factor_wheel+25o
					; factor_wheel+12Bo
		db 2, 6, 4, 2, 6, 4, 6,	8, 4, 2, 4, 2, 4, 0Eh, 4, 6, 2
		db 0Ah,	2, 2 dup(6), 4,	2, 4, 6, 2, 0Ah, 2, 4, 2, 0Ch
		db 0Ah,	2, 4, 2, 4, 6, 2, 6, 4,	3 dup(6), 2, 6,	4, 2, 6
		db 4, 6, 8, 4, 2, 4, 6,	8, 6, 0Ah, 2, 4, 6, 2, 2 dup(6)
		db 4, 2, 4, 6, 2, 6, 4,	2, 6, 0Ah, 2, 0Ah, 2, 4, 2, 4
		db 6, 8, 4, 2, 4, 0Ch, 2, 6, 4,	2, 6, 4, 6, 0Ch, 2, 4
		db 2, 4, 8, 6, 4, 6, 2,	4, 6, 2, 6, 0Ah, 2, 4, 6, 2, 6
		db 4, 2, 4, 2, 0Ah, 2, 0Ah, 2, 4, 2 dup(6), 2, 2 dup(6)
		db 4, 2	dup(6),	2, 6, 4, 2, 6, 4, 6, 8,	4, 2, 6, 4, 8
		db 6, 4, 6, 2, 4, 6, 8,	6, 4, 2, 0Ah, 2, 6, 4, 2, 4, 2
		db 0Ah,	2, 0Ah,	2, 4, 2, 4, 8, 6, 4, 2,	4, 2 dup(6), 2
		db 6, 4, 8, 4, 6, 8, 4,	2, 4, 2, 4, 8, 6, 4, 3 dup(6)
		db 2, 2	dup(6),	4, 2, 4, 6, 2, 6, 4, 2,	4, 2, 0Ah, 2, 0Ah
		db 2, 6, 4, 6, 2, 6, 4,	2, 4, 2	dup(6),	8, 4, 2, 6, 0Ah
		db 8, 4, 2, 4, 2, 4, 8,	0Ah, 6,	2, 4, 8, 2 dup(6), 4, 2
		db 4, 6, 2, 6, 4, 6, 2,	0Ah, 2,	0Ah, 2,	4, 2, 4, 6, 2
		db 6, 4, 2, 4, 2 dup(6), 2, 3 dup(6), 4, 6, 8, 4, 2, 4
		db 2, 4, 8, 6, 4, 8, 4,	6, 2, 2	dup(6),	4, 2, 4, 6, 8
		db 4, 2, 4, 2, 0Ah, 2, 0Ah, 2, 4, 2, 4,	6, 2, 0Ah, 2, 4
		db 6, 8, 6, 4, 2, 6, 4,	6, 8, 4, 6, 2, 4, 8, 6,	4, 6, 2
		db 4, 6, 2, 2 dup(6), 4, 2 dup(6), 2, 2	dup(6),	4, 2, 0Ah
		db 2, 0Ah, 2, 4, 2, 4, 6, 2, 6,	4, 2, 0Ah, 6, 2, 6, 4
		db 2, 6, 4, 6, 8, 4, 2,	4, 2, 0Ch, 6, 4, 6, 2, 4, 6, 2
		db 0Ch,	4, 2, 4, 8, 6, 4, 2, 4,	2, 0Ah,	2, 0Ah,	6, 2, 4
		db 6, 2, 6, 4, 2, 4, 2 dup(6), 2, 6, 4,	2, 0Ah,	6, 8, 6
		db 4, 2, 4, 8, 6, 4, 6,	2, 4, 6, 2, 3 dup(6), 4, 6, 2
		db 6, 4, 2, 4, 2, 0Ah, 0Ch, 2, 4, 2, 0Ah, 2, 6,	4, 2, 4
		db 2 dup(6), 2,	0Ah, 2,	6, 4, 0Eh, 4, 2, 4, 2, 4, 8, 6
		db 4, 6, 2, 4, 6, 2, 2 dup(6), 4, 2, 4,	6, 2, 6, 4, 2
		db 4, 0Ch, 2, 0Ch
; char file[]
file		db 'factor.c',0         ; DATA XREF: factor_wheel+82o
					; factor_wheel+121o ...
; char assertion[]
assertion	db 'n_factors < max_n_factors',0 ; DATA XREF: factor_wheel+87o
					; factor_wheel+180o
; char format[]
format		db '%s:',0              ; DATA XREF: print_factors_single+68o
; char aS_0[]
aS_0		db ' %s',0              ; DATA XREF: print_factors_single+AAo
; char shortopts[4]
shortopts	db 4 dup(0)		; DATA XREF: print_factors+1Bo
					; main+28o ...
; char aUsingSinglePre[]
aUsingSinglePre	db 'using single-precision arithmetic',0 ; DATA XREF: print_factors+47o
; char fmt[]
fmt		db '[%s]',0             ; DATA XREF: print_factors+58o
; char aSIsTooLarge[]
aSIsTooLarge	db '%s is too large',0  ; DATA XREF: print_factors+92o
		align 4
; char aSIsNotAValidPo[]
aSIsNotAValidPo	db '%s is not a valid positive integer',0 ; DATA XREF: print_factors+C7o
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[4]
long_options	option <offset aVerbose, 0, 0, 80h> ; DATA XREF: main+DDo
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>	; "verbose"
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSNumber__[]
aUsageSNumber__	db 'Usage: %s [NUMBER]...',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s OPTION',0Ah,0
; char aPrintThePrimeF[]
aPrintThePrimeF	db 'Print the prime factors of each specified integer NUMBER.  If non'
					; DATA XREF: usage+6Eo
		db 'e',0Ah
		db 'are specified on the command line, read them from standard input.'
		db 0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+91o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+B4o
asc_8000D1E	db 0Ah			; DATA XREF: do_stdin+2Fo
		db 9,' ',0
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
aPaulRubin	db 'Paul Rubin',0       ; DATA XREF: main+ABo
aFactor		db 'factor',0           ; DATA XREF: main+B6o
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5163[13]
__PRETTY_FUNCTION___5163 db 'factor_wheel',0 ; DATA XREF: factor_wheel+78o
					; factor_wheel+171o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8000D5Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8000794-8001510h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset loc_8000794-8001418h
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 60h
		dd offset loc_8000794-8001432h
		dd 1B0h, 80E4100h, 0D420285h, 1AC0305h,	4040CC5h, 1Ch
		dd 80h
		dd offset loc_8000794-80012A2h
		dd 0EDh, 80E4100h, 0D420285h, 0C5E90205h, 4040Ch, 20h
		dd 0A0h
		dd offset loc_8000794-80011D5h
		dd 0FDh, 80E4100h, 0D420285h, 3834405h,	0C3C5F502h, 4040Ch
		dd 1Ch,	0C4h
		dd offset loc_8000794-80010FCh
		dd 0DEh, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 0E4h
		dd offset loc_8000794-800103Eh
		dd 8Fh,	80E4100h, 0D420285h, 0C58B0205h, 4040Ch, 24h, 104h
		dd offset loc_8000794-8000FCFh
		dd 170h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn __udivdi3:near	; CODE XREF: factor_wheel+60p
					; factor_wheel+CAp
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: factor_wheel+8Cp
					; factor_wheel+185p
		extrn umaxtostr:near	; CODE XREF: print_factors_single+5Cp
					; print_factors_single+9Ep
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: print_factors_single+D1p
		extrn __stack_chk_fail:near ; CODE XREF: print_factors_single+E6p
					; print_factors+F3p ...
		extrn xstrtoumax:near	; CODE XREF: print_factors+2Bp
		extrn quote:near	; CODE XREF: print_factors+85p
					; print_factors+BAp
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: print_factors+A5p
					; print_factors+DAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+D9p	main+C9p ...
		extrn init_tokenbuffer:near ; CODE XREF: do_stdin+1Cp
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: do_stdin:loc_80005BEr
		extrn readtoken:near	; CODE XREF: do_stdin+35p
; void free(void *ptr)
		extrn free:near		; CODE XREF: do_stdin+70p
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+5Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+64p
		extrn Version:dword	; DATA XREF: main:loc_80006C4r
		extrn version_etc:near	; CODE XREF: main+BCp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+ECp
; int optind
		extrn optind:dword	; DATA XREF: main+101r	main+118r


		end
