;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	FCDBE25458A0319CE98FEB570DBC102F
; Input	CRC32 :	8163F1E5

; File Name   :	D:\coreutils-o\remove.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'remove.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl lstatat(int fd, const char *name,	stat *st)
lstatat		proc near		; CODE XREF: excise+EEp

fd		= dword	ptr  8
name		= dword	ptr  0Ch
st		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	100h
		push	[ebp+st]
		push	[ebp+name]
		push	[ebp+fd]
		call	fstatat64
		add	esp, 10h
		leave
		retn
lstatat		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	dot_or_dotdot(const char *file_name)
dot_or_dotdot	proc near		; CODE XREF: readdir_ignoring_dot_and_dotdot+27p
					; rm_fts+FEp

sep		= byte ptr -1
file_name	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+file_name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_800006F
		mov	eax, [ebp+file_name]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8000042
		mov	edx, 2
		jmp	short loc_8000047
; ---------------------------------------------------------------------------

loc_8000042:				; CODE XREF: dot_or_dotdot+1Bj
		mov	edx, 1

loc_8000047:				; CODE XREF: dot_or_dotdot+22j
		mov	eax, [ebp+file_name]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sep], al
		cmp	[ebp+sep], 0
		jz	short loc_800005E
		cmp	[ebp+sep], 2Fh
		jnz	short loc_8000065

loc_800005E:				; CODE XREF: dot_or_dotdot+38j
		mov	eax, 1
		jmp	short loc_800006A
; ---------------------------------------------------------------------------

loc_8000065:				; CODE XREF: dot_or_dotdot+3Ej
		mov	eax, 0

loc_800006A:				; CODE XREF: dot_or_dotdot+45j
		and	eax, 1
		jmp	short locret_8000074
; ---------------------------------------------------------------------------

loc_800006F:				; CODE XREF: dot_or_dotdot+Ej
		mov	eax, 0

locret_8000074:				; CODE XREF: dot_or_dotdot+4Fj
		leave
		retn
dot_or_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	dirent *__cdecl	readdir_ignoring_dot_and_dotdot(DIR *dirp)
readdir_ignoring_dot_and_dotdot	proc near ; CODE XREF: is_empty_dir+69p

dp		= dword	ptr -0Ch
dirp		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h

loc_800007C:				; CODE XREF: readdir_ignoring_dot_and_dotdot+34j
		sub	esp, 0Ch
		push	[ebp+dirp]
		call	readdir64
		add	esp, 10h
		mov	[ebp+dp], eax
		cmp	[ebp+dp], 0
		jz	short loc_80000AC
		mov	eax, [ebp+dp]
		add	eax, 13h
		sub	esp, 0Ch
		push	eax		; file_name
		call	dot_or_dotdot
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_800007C

loc_80000AC:				; CODE XREF: readdir_ignoring_dot_and_dotdot+1Bj
		mov	eax, [ebp+dp]
		leave
		retn
readdir_ignoring_dot_and_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_empty_dir(int fd_cwd, const char *dir)
is_empty_dir	proc near		; CODE XREF: prompt+297p

fd		= dword	ptr -18h
dirp		= dword	ptr -14h
dp		= dword	ptr -10h
saved_errno	= dword	ptr -0Ch
fd_cwd		= dword	ptr  8
dir		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 4
		push	30900h
		push	[ebp+dir]
		push	[ebp+fd_cwd]
		call	openat64
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		jns	short loc_80000DD
		mov	eax, 0
		jmp	short locret_8000151
; ---------------------------------------------------------------------------

loc_80000DD:				; CODE XREF: is_empty_dir+23j
		sub	esp, 0Ch
		push	[ebp+fd]
		call	fdopendir
		add	esp, 10h
		mov	[ebp+dirp], eax
		cmp	[ebp+dirp], 0
		jnz	short loc_8000109
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_8000151
; ---------------------------------------------------------------------------

loc_8000109:				; CODE XREF: is_empty_dir+41j
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	readdir_ignoring_dot_and_dotdot
		add	esp, 10h
		mov	[ebp+dp], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		cmp	[ebp+dp], 0
		jz	short loc_800014A
		mov	eax, 0
		jmp	short locret_8000151
; ---------------------------------------------------------------------------

loc_800014A:				; CODE XREF: is_empty_dir+90j
		cmp	[ebp+saved_errno], 0
		setz	al

locret_8000151:				; CODE XREF: is_empty_dir+2Aj
					; is_empty_dir+56j ...
		leave
		retn
is_empty_dir	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cache_fstatat(int	fd, const char *file, stat *st,	int flag)
cache_fstatat	proc near		; CODE XREF: write_protected_non_symlink+27p
					; prompt+182p ...

fd		= dword	ptr  8
file		= dword	ptr  0Ch
st		= dword	ptr  10h
flag		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+st]
		mov	edx, [eax+30h]
		mov	eax, [eax+2Ch]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_80001AA
		push	[ebp+flag]
		push	[ebp+st]
		push	[ebp+file]
		push	[ebp+fd]
		call	fstatat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_80001AA
		mov	eax, [ebp+st]
		mov	dword ptr [eax+2Ch], 0FFFFFFFEh
		mov	dword ptr [eax+30h], 0FFFFFFFFh
		call	__errno_location
		mov	eax, [eax]
		cdq
		mov	ecx, [ebp+st]
		mov	[ecx+58h], eax
		mov	[ecx+5Ch], edx

loc_80001AA:				; CODE XREF: cache_fstatat+1Bj
					; cache_fstatat+33j
		mov	eax, [ebp+st]
		mov	edx, [eax+30h]
		mov	eax, [eax+2Ch]
		test	edx, edx
		js	short loc_80001BE
		mov	eax, 0
		jmp	short locret_80001D5
; ---------------------------------------------------------------------------

loc_80001BE:				; CODE XREF: cache_fstatat+62j
		call	__errno_location
		mov	ecx, eax
		mov	eax, [ebp+st]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	[ecx], eax
		mov	eax, 0FFFFFFFFh

locret_80001D5:				; CODE XREF: cache_fstatat+69j
		leave
		retn
cache_fstatat	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; stat *__cdecl	cache_stat_init(stat *st)
cache_stat_init	proc near		; CODE XREF: prompt+85p

st		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+st]
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		mov	dword ptr [eax+30h], 0FFFFFFFFh
		mov	eax, [ebp+st]
		pop	ebp
		retn
cache_stat_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl write_protected_non_symlink(int fd_cwd, const char *file,	const char *full_name, stat *buf)
write_protected_non_symlink proc near	; CODE XREF: prompt+12Cp

file_name_len	= dword	ptr -0Ch
fd_cwd		= dword	ptr  8
file		= dword	ptr  0Ch
full_name	= dword	ptr  10h
buf		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		call	can_write_any_file
		test	al, al
		jz	short loc_8000209
		mov	eax, 0
		jmp	locret_80002D9
; ---------------------------------------------------------------------------

loc_8000209:				; CODE XREF: write_protected_non_symlink+Dj
		push	100h		; flag
		push	[ebp+buf]	; st
		push	[ebp+file]	; file
		push	[ebp+fd_cwd]	; fd
		call	cache_fstatat
		add	esp, 10h
		test	eax, eax
		jz	short loc_800022D
		mov	eax, 0FFFFFFFFh
		jmp	locret_80002D9
; ---------------------------------------------------------------------------

loc_800022D:				; CODE XREF: write_protected_non_symlink+31j
		mov	eax, [ebp+buf]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8000249
		mov	eax, 0
		jmp	locret_80002D9
; ---------------------------------------------------------------------------

loc_8000249:				; CODE XREF: write_protected_non_symlink+4Dj
		push	200h
		push	2
		push	[ebp+file]
		push	[ebp+fd_cwd]
		call	faccessat
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000269
		mov	eax, 0
		jmp	short locret_80002D9
; ---------------------------------------------------------------------------

loc_8000269:				; CODE XREF: write_protected_non_symlink+70j
		sub	esp, 0Ch
		push	[ebp+full_name]	; s
		call	strlen
		add	esp, 10h
		mov	[ebp+file_name_len], eax
		cmp	[ebp+file_name_len], 0FFFh
		jbe	short loc_800029B
		sub	esp, 8
		push	2
		push	[ebp+buf]
		call	euidaccess_stat
		add	esp, 10h
		xor	eax, 1
		movzx	eax, al
		jmp	short locret_80002D9
; ---------------------------------------------------------------------------

loc_800029B:				; CODE XREF: write_protected_non_symlink+91j
		sub	esp, 8
		push	2
		push	[ebp+full_name]
		call	euidaccess
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80002B6
		mov	eax, 0
		jmp	short locret_80002D9
; ---------------------------------------------------------------------------

loc_80002B6:				; CODE XREF: write_protected_non_symlink+BDj
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 0Dh
		jnz	short loc_80002D4
		call	__errno_location
		mov	dword ptr [eax], 0
		mov	eax, 1
		jmp	short locret_80002D9
; ---------------------------------------------------------------------------

loc_80002D4:				; CODE XREF: write_protected_non_symlink+D0j
		mov	eax, 0FFFFFFFFh

locret_80002D9:				; CODE XREF: write_protected_non_symlink+14j
					; write_protected_non_symlink+38j ...
		leave
		retn
write_protected_non_symlink endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; RM_status __cdecl prompt(const FTS *fts, const FTSENT	*ent, _Bool is_dir, const rm_options *x, Prompt_action mode, Ternary_0 *is_empty_p)
prompt		proc near		; CODE XREF: rm_fts+29Ep rm_fts+3D7p

is_empty_p	= dword	ptr -0ACh
x		= dword	ptr -0A8h
is_dir		= byte ptr -0A4h
ent		= dword	ptr -0A0h
fts		= dword	ptr -9Ch
is_empty	= byte ptr -8Dh
dirent_type	= dword	ptr -8Ch
write_protected	= dword	ptr -88h
wp_errno	= dword	ptr -84h
fd_cwd		= dword	ptr -80h
full_name	= dword	ptr -7Ch
filename	= dword	ptr -78h
sbuf		= dword	ptr -74h
quoted_name	= dword	ptr -70h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
mode		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0B0h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+fts], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+ent], edx
		mov	[ebp+is_dir], al
		mov	eax, [ebp+arg_C]
		mov	[ebp+x], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+is_empty_p], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+fts]
		mov	eax, [eax+1Ch]
		mov	[ebp+fd_cwd], eax
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		mov	[ebp+full_name], eax
		mov	eax, [ebp+ent]
		mov	eax, [eax+14h]
		mov	[ebp+filename],	eax
		cmp	[ebp+is_empty_p], 0
		jz	short loc_8000357
		mov	eax, [ebp+is_empty_p]
		mov	dword ptr [eax], 2

loc_8000357:				; CODE XREF: prompt+6Ej
		lea	eax, [ebp+st]
		mov	[ebp+sbuf], eax
		push	[ebp+sbuf]	; st
		call	cache_stat_init
		add	esp, 4
		cmp	[ebp+is_dir], 0
		jz	short loc_8000378
		mov	eax, 4
		jmp	short loc_800037D
; ---------------------------------------------------------------------------

loc_8000378:				; CODE XREF: prompt+94j
		mov	eax, 0

loc_800037D:				; CODE XREF: prompt+9Bj
		mov	[ebp+dirent_type], eax
		mov	[ebp+write_protected], 0
		mov	eax, [ebp+ent]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_80003A4
		mov	eax, 3
		jmp	loc_80006CD
; ---------------------------------------------------------------------------

loc_80003A4:				; CODE XREF: prompt+BDj
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 5
		jnz	short loc_80003BC
		mov	eax, 2
		jmp	loc_80006CD
; ---------------------------------------------------------------------------

loc_80003BC:				; CODE XREF: prompt+D5j
		mov	[ebp+wp_errno],	0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8000422
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 3
		jz	short loc_80003F2
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+10h]
		test	al, al
		jz	short loc_8000422

loc_80003F2:				; CODE XREF: prompt+107j
		cmp	[ebp+dirent_type], 0Ah
		jz	short loc_8000422
		push	[ebp+sbuf]	; buf
		push	[ebp+full_name]	; full_name
		push	[ebp+filename]	; file
		push	[ebp+fd_cwd]	; fd_cwd
		call	write_protected_non_symlink
		add	esp, 10h
		mov	[ebp+write_protected], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+wp_errno],	eax

loc_8000422:				; CODE XREF: prompt+F9j prompt+115j ...
		cmp	[ebp+write_protected], 0
		jnz	short loc_800043D
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 3
		jnz	loc_80006C8

loc_800043D:				; CODE XREF: prompt+14Ej
		cmp	[ebp+write_protected], 0
		js	short loc_80004BC
		cmp	[ebp+dirent_type], 0
		jnz	short loc_80004BC
		push	100h		; flag
		push	[ebp+sbuf]	; st
		push	[ebp+filename]	; file
		push	[ebp+fd_cwd]	; fd
		call	cache_fstatat
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80004A5
		mov	eax, [ebp+sbuf]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8000487
		mov	[ebp+dirent_type], 0Ah
		jmp	short loc_80004BC
; ---------------------------------------------------------------------------

loc_8000487:				; CODE XREF: prompt+19Ej
		mov	eax, [ebp+sbuf]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80004BC
		mov	[ebp+dirent_type], 4
		jmp	short loc_80004BC
; ---------------------------------------------------------------------------

loc_80004A5:				; CODE XREF: prompt+18Cj
		mov	[ebp+write_protected], 0FFFFFFFFh
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+wp_errno],	eax

loc_80004BC:				; CODE XREF: prompt+169j prompt+172j ...
		cmp	[ebp+write_protected], 0
		js	short loc_8000518
		mov	eax, [ebp+dirent_type]
		cmp	eax, 4
		jz	short loc_80004ED
		cmp	eax, 0Ah
		jnz	short loc_8000518
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 3
		jz	short loc_8000514
		mov	eax, 2
		jmp	loc_80006CD
; ---------------------------------------------------------------------------

loc_80004ED:				; CODE XREF: prompt+1F3j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+9]
		xor	eax, 1
		test	al, al
		jz	short loc_8000517
		mov	[ebp+write_protected], 0FFFFFFFFh
		mov	[ebp+wp_errno],	15h
		jmp	short loc_8000517
; ---------------------------------------------------------------------------

loc_8000514:				; CODE XREF: prompt+206j
		nop
		jmp	short loc_8000518
; ---------------------------------------------------------------------------

loc_8000517:				; CODE XREF: prompt+221j prompt+237j
		nop

loc_8000518:				; CODE XREF: prompt+1E8j prompt+1F8j ...
		sub	esp, 0Ch
		push	[ebp+full_name]
		call	quote
		add	esp, 10h
		mov	[ebp+quoted_name], eax
		cmp	[ebp+write_protected], 0
		jns	short loc_8000560
		sub	esp, 0Ch
		push	offset msgid	; "cannot remove %s"
		call	gettext
		add	esp, 10h
		push	[ebp+quoted_name]
		push	eax		; format
		push	[ebp+wp_errno]	; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 4
		jmp	loc_80006CD
; ---------------------------------------------------------------------------

loc_8000560:				; CODE XREF: prompt+255j
		cmp	[ebp+is_empty_p], 0
		jz	short loc_800059F
		sub	esp, 8
		push	[ebp+filename]	; dir
		push	[ebp+fd_cwd]	; fd_cwd
		call	is_empty_dir
		add	esp, 10h
		mov	[ebp+is_empty],	al
		cmp	[ebp+is_empty],	0
		jz	short loc_8000590
		mov	edx, 4
		jmp	short loc_8000595
; ---------------------------------------------------------------------------

loc_8000590:				; CODE XREF: prompt+2ACj
		mov	edx, 3

loc_8000595:				; CODE XREF: prompt+2B3j
		mov	eax, [ebp+is_empty_p]
		mov	[eax], edx
		jmp	short loc_80005A6
; ---------------------------------------------------------------------------

loc_800059F:				; CODE XREF: prompt+28Cj
		mov	[ebp+is_empty],	0

loc_80005A6:				; CODE XREF: prompt+2C2j
		cmp	[ebp+dirent_type], 4
		jnz	short loc_8000610
		cmp	[ebp+mode], 2
		jnz	short loc_8000610
		movzx	eax, [ebp+is_empty]
		xor	eax, 1
		test	al, al
		jz	short loc_8000610
		mov	ebx, ds:program_name
		cmp	[ebp+write_protected], 0
		jz	short loc_80005E6
		sub	esp, 0Ch
		push	offset aSDescendIntoWr ; "%s: descend into write-protected direct"...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_80005F8
; ---------------------------------------------------------------------------

loc_80005E6:				; CODE XREF: prompt+2F5j
		sub	esp, 0Ch
		push	offset aSDescendIntoDi ; "%s: descend into directory %s? "
		call	gettext
		add	esp, 10h
		mov	edx, eax

loc_80005F8:				; CODE XREF: prompt+309j
		mov	eax, ds:stderr
		push	[ebp+quoted_name]
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80006B5
; ---------------------------------------------------------------------------

loc_8000610:				; CODE XREF: prompt+2D2j prompt+2D8j ...
		push	100h		; flag
		push	[ebp+sbuf]	; st
		push	[ebp+filename]	; file
		push	[ebp+fd_cwd]	; fd
		call	cache_fstatat
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000659
		sub	esp, 0Ch
		push	offset msgid	; "cannot remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+quoted_name]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 4
		jmp	short loc_80006CD
; ---------------------------------------------------------------------------

loc_8000659:				; CODE XREF: prompt+34Dj
		sub	esp, 0Ch
		push	[ebp+sbuf]
		call	file_type
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:program_name
		cmp	[ebp+write_protected], 0
		jz	short loc_800068C
		sub	esp, 0Ch
		push	offset aSRemoveWritePr ; "%s: remove write-protected %s	%s? "
		call	gettext
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_800069E
; ---------------------------------------------------------------------------

loc_800068C:				; CODE XREF: prompt+39Bj
		sub	esp, 0Ch
		push	offset aSRemoveSS? ; "%s: remove %s %s?	"
		call	gettext
		add	esp, 10h
		mov	edx, eax

loc_800069E:				; CODE XREF: prompt+3AFj
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	[ebp+quoted_name]
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 20h

loc_80006B5:				; CODE XREF: prompt+330j
		call	yesno
		xor	eax, 1
		test	al, al
		jz	short loc_80006C8
		mov	eax, 3
		jmp	short loc_80006CD
; ---------------------------------------------------------------------------

loc_80006C8:				; CODE XREF: prompt+15Cj prompt+3E4j
		mov	eax, 2

loc_80006CD:				; CODE XREF: prompt+C4j prompt+DCj ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80006DE
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80006DE:				; CODE XREF: prompt+3FCj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
prompt		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	nonexistent_file_errno(int errnum)
nonexistent_file_errno proc near	; CODE XREF: ignorable_missing+10p

errnum		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+errnum]
		cmp	eax, 2
		jz	short loc_80006F5
		cmp	eax, 14h
		jnz	short loc_80006FC

loc_80006F5:				; CODE XREF: nonexistent_file_errno+9j
		mov	eax, 1
		jmp	short loc_8000701
; ---------------------------------------------------------------------------

loc_80006FC:				; CODE XREF: nonexistent_file_errno+Ej
		mov	eax, 0

loc_8000701:				; CODE XREF: nonexistent_file_errno+15j
		pop	ebp
		retn
nonexistent_file_errno endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	ignorable_missing(const	rm_options *x, int errnum)
ignorable_missing proc near		; CODE XREF: excise+122p

x		= dword	ptr  8
errnum		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000726
		push	[ebp+errnum]	; errnum
		call	nonexistent_file_errno
		add	esp, 4
		test	al, al
		jz	short loc_8000726
		mov	eax, 1
		jmp	short loc_800072B
; ---------------------------------------------------------------------------

loc_8000726:				; CODE XREF: ignorable_missing+Bj
					; ignorable_missing+1Aj
		mov	eax, 0

loc_800072B:				; CODE XREF: ignorable_missing+21j
		and	eax, 1
		leave
		retn
ignorable_missing endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl fts_skip_tree(FTS *fts, FTSENT *ent)
fts_skip_tree	proc near		; CODE XREF: rm_fts+98p rm_fts+145p ...

fts		= dword	ptr  8
ent		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	4		; int
		push	[ebp+ent]	; FTSENT *
		push	[ebp+fts]	; FTS *
		call	fts_set
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+fts]	; FTS *
		call	fts_read
		add	esp, 10h
		mov	[ebp+ent], eax
		nop
		leave
		retn
fts_skip_tree	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mark_ancestor_dirs(FTSENT *ent)
mark_ancestor_dirs proc	near		; CODE XREF: excise+191p rm_fts+87p ...

p		= dword	ptr -4
ent		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+ent]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		jmp	short loc_800078B
; ---------------------------------------------------------------------------

loc_800076E:				; CODE XREF: mark_ancestor_dirs+36j
		mov	eax, [ebp+p]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jnz	short loc_8000797
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], 1
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+p], eax

loc_800078B:				; CODE XREF: mark_ancestor_dirs+Fj
		mov	eax, [ebp+p]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jns	short loc_800076E
		jmp	short loc_8000798
; ---------------------------------------------------------------------------

loc_8000797:				; CODE XREF: mark_ancestor_dirs+19j
		nop

loc_8000798:				; CODE XREF: mark_ancestor_dirs+38j
		nop
		leave
		retn
mark_ancestor_dirs endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; RM_status __cdecl excise(FTS *fts, FTSENT *ent, const	rm_options *x, _Bool is_dir)
excise		proc near		; CODE XREF: rm_fts+2C2p rm_fts+3FEp

is_dir		= byte ptr -88h
x		= dword	ptr -84h
ent		= dword	ptr -80h
fts		= dword	ptr -7Ch
flag		= dword	ptr -70h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_C]
		mov	edx, [ebp+arg_0]
		mov	[ebp+fts], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+ent], edx
		mov	edx, [ebp+arg_8]
		mov	[ebp+x], edx
		mov	[ebp+is_dir], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		cmp	[ebp+is_dir], 0
		jz	short loc_80007DC
		mov	eax, 200h
		jmp	short loc_80007E1
; ---------------------------------------------------------------------------

loc_80007DC:				; CODE XREF: excise+38j
		mov	eax, 0

loc_80007E1:				; CODE XREF: excise+3Fj
		mov	[ebp+flag], eax
		mov	eax, [ebp+ent]
		mov	edx, [eax+14h]
		mov	eax, [ebp+fts]
		mov	eax, [eax+1Ch]
		sub	esp, 4
		push	[ebp+flag]
		push	edx
		push	eax
		call	unlinkat
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000868
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+11h]
		test	al, al
		jz	short loc_800085E
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		cmp	[ebp+is_dir], 0
		jz	short loc_8000841
		sub	esp, 0Ch
		push	offset aRemovedDirecto ; "removed directory: %s\n"
		call	gettext
		add	esp, 10h
		jmp	short loc_8000851
; ---------------------------------------------------------------------------

loc_8000841:				; CODE XREF: excise+92j
		sub	esp, 0Ch
		push	offset aRemovedS ; "removed %s\n"
		call	gettext
		add	esp, 10h

loc_8000851:				; CODE XREF: excise+A4j
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_800085E:				; CODE XREF: excise+75j
		mov	eax, 2
		jmp	loc_8000939
; ---------------------------------------------------------------------------

loc_8000868:				; CODE XREF: excise+67j
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1Eh
		jnz	short loc_80008AC
		mov	eax, [ebp+ent]
		mov	edx, [eax+14h]
		mov	eax, [ebp+fts]
		mov	eax, [eax+1Ch]
		sub	esp, 4
		lea	ecx, [ebp+st]
		push	ecx		; st
		push	edx		; name
		push	eax		; fd
		call	lstatat
		add	esp, 10h
		test	eax, eax
		jz	short loc_80008A1
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jz	short loc_80008AC

loc_80008A1:				; CODE XREF: excise+F8j
		call	__errno_location
		mov	dword ptr [eax], 1Eh

loc_80008AC:				; CODE XREF: excise+D7j excise+104j
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; errnum
		push	[ebp+x]		; x
		call	ignorable_missing
		add	esp, 10h
		test	al, al
		jz	short loc_80008D0
		mov	eax, 2
		jmp	short loc_8000939
; ---------------------------------------------------------------------------

loc_80008D0:				; CODE XREF: excise+12Cj
		mov	eax, [ebp+ent]
		movzx	eax, word ptr [eax+38h]
		cmp	ax, 4
		jnz	short loc_80008EC
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+ent]
		mov	eax, [eax+1Ch]
		mov	[edx], eax

loc_80008EC:				; CODE XREF: excise+140j
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset msgid	; "cannot remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+ent]	; ent
		call	mark_ancestor_dirs
		add	esp, 10h
		mov	eax, 4

loc_8000939:				; CODE XREF: excise+C8j excise+133j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800094A
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800094A:				; CODE XREF: excise+1A8j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
excise		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; RM_status __cdecl rm_fts(FTS *fts, FTSENT *ent, const	rm_options *x)
rm_fts		proc near		; CODE XREF: rm+AAp

x		= dword	ptr -34h
ent		= dword	ptr -30h
fts		= dword	ptr -2Ch
is_dir		= byte ptr -19h
is_empty_directory= dword ptr -18h
s		= dword	ptr -14h
s_0		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fts], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+ent], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+x], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+ent]
		movzx	eax, word ptr [eax+38h]
		movzx	eax, ax
		cmp	eax, 0Dh	; switch 14 cases
		ja	loc_8000DFA	; jumptable 08000990 default case
		mov	eax, ds:off_800127C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000992:				; CODE XREF: rm_fts+3Fj
					; DATA XREF: .rodata:off_800127Co
		mov	eax, [ebp+x]	; jumptable 08000990 case 1
		movzx	eax, byte ptr [eax+9]
		xor	eax, 1
		test	al, al
		jz	short loc_80009FB
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "cannot remove %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	15h		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+ent]	; ent
		call	mark_ancestor_dirs
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h
		mov	eax, 4
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_80009FB:				; CODE XREF: rm_fts+4Dj
		mov	eax, [ebp+ent]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jnz	loc_8000BDB
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	strip_trailing_slashes
		add	esp, 10h
		test	al, al
		jz	short loc_8000A39
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+ent]
		mov	[eax+24h], edx

loc_8000A39:				; CODE XREF: rm_fts+CCj
		mov	eax, [ebp+ent]
		mov	eax, [eax+14h]
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; file_name
		call	dot_or_dotdot
		add	esp, 10h
		test	al, al
		jz	short loc_8000AA8
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotRemoveDi ; "cannot remove	directory: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h
		mov	eax, 4
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000AA8:				; CODE XREF: rm_fts+108j
		mov	eax, [ebp+x]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	loc_8000BDB
		mov	eax, [ebp+ent]
		mov	ecx, [eax+98h]
		mov	ebx, [eax+9Ch]
		mov	eax, [ebp+x]
		mov	eax, [eax+0Ch]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	loc_8000BDB
		mov	eax, [ebp+ent]
		mov	ecx, [eax+40h]
		mov	ebx, [eax+44h]
		mov	eax, [ebp+x]
		mov	eax, [eax+0Ch]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	loc_8000BDB
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 8
		push	offset s2	; "/"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000B54
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aItIsDangerousT ; "it is	dangerous to operate recursively "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000BA0
; ---------------------------------------------------------------------------

loc_8000B54:				; CODE XREF: rm_fts+1CDj
		sub	esp, 8
		push	offset s2	; "/"
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 8
		push	eax
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aItIsDangerou_0 ; "it is	dangerous to operate recursively "...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8000BA0:				; CODE XREF: rm_fts+201j
		sub	esp, 0Ch
		push	offset aUseNoPreserveR ; "use --no-preserve-root to override this"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h
		mov	eax, 4
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000BDB:				; CODE XREF: rm_fts+B2j rm_fts+15Fj ...
		sub	esp, 8
		lea	eax, [ebp+is_empty_directory]
		push	eax		; is_empty_p
		push	2		; mode
		push	[ebp+x]		; x
		push	1		; is_dir
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	prompt
		add	esp, 20h
		mov	[ebp+s], eax
		cmp	[ebp+s], 2
		jnz	short loc_8000C2F
		mov	eax, [ebp+is_empty_directory]
		cmp	eax, 4
		jnz	short loc_8000C2F
		push	1		; is_dir
		push	[ebp+x]		; x
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	excise
		add	esp, 10h
		mov	[ebp+s], eax
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h

loc_8000C2F:				; CODE XREF: rm_fts+2ADj rm_fts+2B5j
		cmp	[ebp+s], 2
		jz	short loc_8000C54
		sub	esp, 0Ch
		push	[ebp+ent]	; ent
		call	mark_ancestor_dirs
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h

loc_8000C54:				; CODE XREF: rm_fts+2E2j
		mov	eax, [ebp+s]
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000C5C:				; CODE XREF: rm_fts+3Fj
					; DATA XREF: .rodata:off_800127Co
		mov	eax, [ebp+ent]	; jumptable 08000990 cases 3,4,6,8,10-13
		movzx	eax, word ptr [eax+38h]
		cmp	ax, 6
		jnz	short loc_8000CE6
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+8]
		test	al, al
		jz	short loc_8000CE6
		mov	eax, [ebp+ent]
		mov	eax, [eax+2Ch]
		test	eax, eax
		jle	short loc_8000CE6
		mov	eax, [ebp+ent]
		mov	ecx, [eax+40h]
		mov	ebx, [eax+44h]
		mov	eax, [ebp+fts]
		mov	edx, [eax+10h]
		mov	eax, [eax+0Ch]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8000CE6
		sub	esp, 0Ch
		push	[ebp+ent]	; ent
		call	mark_ancestor_dirs
		add	esp, 10h
		mov	eax, [ebp+ent]
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSkippingSSince ; "skipping %s, since it's on a different "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 4
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000CE6:				; CODE XREF: rm_fts+316j rm_fts+321j ...
		mov	eax, [ebp+ent]
		movzx	eax, word ptr [eax+38h]
		cmp	ax, 6
		jz	short loc_8000D00
		mov	eax, [ebp+ent]
		movzx	eax, word ptr [eax+38h]
		cmp	ax, 4
		jnz	short loc_8000D07

loc_8000D00:				; CODE XREF: rm_fts+3A0j
		mov	eax, 1
		jmp	short loc_8000D0C
; ---------------------------------------------------------------------------

loc_8000D07:				; CODE XREF: rm_fts+3ADj
		mov	eax, 0

loc_8000D0C:				; CODE XREF: rm_fts+3B4j
		mov	[ebp+is_dir], al
		and	[ebp+is_dir], 1
		movzx	eax, [ebp+is_dir]
		sub	esp, 8
		push	0		; is_empty_p
		push	3		; mode
		push	[ebp+x]		; x
		push	eax		; is_dir
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	prompt
		add	esp, 20h
		mov	[ebp+s_0], eax
		cmp	[ebp+s_0], 2
		jz	short loc_8000D41
		mov	eax, [ebp+s_0]
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000D41:				; CODE XREF: rm_fts+3E6j
		movzx	eax, [ebp+is_dir]
		push	eax		; is_dir
		push	[ebp+x]		; x
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	excise
		add	esp, 10h
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000D5C:				; CODE XREF: rm_fts+3Fj
					; DATA XREF: .rodata:off_800127Co
		mov	eax, [ebp+ent]	; jumptable 08000990 case 2
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWarningCircula ; "WARNING: Circular directory structure.\"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h
		mov	eax, 4
		jmp	loc_8000E44
; ---------------------------------------------------------------------------

loc_8000DA9:				; CODE XREF: rm_fts+3Fj
					; DATA XREF: .rodata:off_800127Co
		mov	eax, [ebp+ent]	; jumptable 08000990 case 7
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aTraversalFaile ; "traversal failed: %s"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+ent]
		mov	eax, [eax+1Ch]
		push	ebx
		push	edx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 8
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	fts_skip_tree
		add	esp, 10h
		mov	eax, 4
		jmp	short loc_8000E44
; ---------------------------------------------------------------------------

loc_8000DFA:				; CODE XREF: rm_fts+32j rm_fts+3Fj
					; DATA XREF: ...
		mov	eax, [ebp+ent]	; jumptable 08000990 default case
		mov	eax, [eax+18h]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+ent]
		movzx	eax, word ptr [eax+38h]
		movzx	ebx, ax
		sub	esp, 0Ch
		push	offset aUnexpectedFail ; "unexpected failure: fts_info=%d: %s\npl"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		call	abort
; ---------------------------------------------------------------------------

loc_8000E44:				; CODE XREF: rm_fts+A5j rm_fts+152j ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000E55
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000E55:				; CODE XREF: rm_fts+4FDj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
rm_fts		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; RM_status __cdecl rm(char *const *file, const	rm_options *x)
		public rm
rm		proc near

rm_status	= dword	ptr -1Ch
bit_flags	= dword	ptr -18h
fts		= dword	ptr -14h
ent		= dword	ptr -10h
s		= dword	ptr -0Ch
var_4		= dword	ptr -4
file		= dword	ptr  8
x		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+rm_status], 2
		mov	eax, [ebp+file]
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8000FA3
		mov	[ebp+bit_flags], 218h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+8]
		test	al, al
		jz	short loc_8000E8D
		or	[ebp+bit_flags], 40h

loc_8000E8D:				; CODE XREF: rm+2Bj
		sub	esp, 4
		push	0
		push	[ebp+bit_flags]
		push	[ebp+file]
		call	xfts_open
		add	esp, 10h
		mov	[ebp+fts], eax

loc_8000EA3:				; CODE XREF: rm+EAj rm+F4j ...
		sub	esp, 0Ch
		push	[ebp+fts]	; FTS *
		call	fts_read
		add	esp, 10h
		mov	[ebp+ent], eax
		cmp	[ebp+ent], 0
		jnz	short loc_8000EFA
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8000F61
		sub	esp, 0Ch
		push	offset aFts_readFailed ; "fts_read failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+rm_status], 4
		jmp	short loc_8000F61
; ---------------------------------------------------------------------------

loc_8000EFA:				; CODE XREF: rm+5Cj
		sub	esp, 4
		push	[ebp+x]		; x
		push	[ebp+ent]	; ent
		push	[ebp+fts]	; fts
		call	rm_fts
		add	esp, 10h
		mov	[ebp+s], eax
		cmp	[ebp+s], 2
		jz	short loc_8000F3C
		cmp	[ebp+s], 3
		jz	short loc_8000F3C
		cmp	[ebp+s], 4
		jz	short loc_8000F3C
		push	offset __PRETTY_FUNCTION___5460	; "rm"
		push	270h		; line
		push	offset file	; "remove.c"
		push	offset assertion ; "VALID_STATUS (s)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000F3C:				; CODE XREF: rm+B9j rm+BFj ...
		cmp	[ebp+s], 4
		jz	short loc_8000F56
		cmp	[ebp+s], 3
		jnz	loc_8000EA3
		cmp	[ebp+rm_status], 2
		jnz	loc_8000EA3

loc_8000F56:				; CODE XREF: rm+E4j
		mov	eax, [ebp+s]
		mov	[ebp+rm_status], eax
		jmp	loc_8000EA3
; ---------------------------------------------------------------------------

loc_8000F61:				; CODE XREF: rm+67j rm+9Cj
		nop
		sub	esp, 0Ch
		push	[ebp+fts]	; FTS *
		call	fts_close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000FA3
		sub	esp, 0Ch
		push	offset aFts_closeFaile ; "fts_close failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+rm_status], 4

loc_8000FA3:				; CODE XREF: rm+15j rm+116j
		mov	eax, [ebp+rm_status]
		mov	ebx, [ebp+var_4]
		leave

locret_8000FAA:				; DATA XREF: .eh_frame:08001314o
					; .eh_frame:08001334o ...
		retn
rm		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 8000FB0h
; char msgid[]
msgid		db 'cannot remove %s',0 ; DATA XREF: prompt+25Ao prompt+352o ...
		align 4
; char aSDescendIntoWr[]
aSDescendIntoWr	db '%s: descend into write-protected directory %s? ',0
					; DATA XREF: prompt+2FAo
; char aSDescendIntoDi[]
aSDescendIntoDi	db '%s: descend into directory %s? ',0 ; DATA XREF: prompt+30Eo
; char aSRemoveWritePr[]
aSRemoveWritePr	db '%s: remove write-protected %s %s? ',0 ; DATA XREF: prompt+3A0o
; char aSRemoveSS_[]
aSRemoveSS?	db '%s: remove %s %s? ',0 ; DATA XREF: prompt+3B4o
; char aRemovedDirecto[]
aRemovedDirecto	db 'removed directory: %s',0Ah,0 ; DATA XREF: excise+97o
; char aRemovedS[]
aRemovedS	db 'removed %s',0Ah,0   ; DATA XREF: excise+A9o
; char aCannotRemoveDi[]
aCannotRemoveDi	db 'cannot remove directory: %s',0 ; DATA XREF: rm_fts+121o
; char s2[]
s2		db '/',0                ; DATA XREF: rm_fts+1BDo rm_fts+206o
		align 4
; char aItIsDangerousT[]
aItIsDangerousT	db 'it is dangerous to operate recursively on %s',0 ; DATA XREF: rm_fts+1E6o
		align 4
; char aItIsDangerou_0[]
aItIsDangerou_0	db 'it is dangerous to operate recursively on %s (same as %s)',0
					; DATA XREF: rm_fts+230o
		align 4
; char aUseNoPreserveR[]
aUseNoPreserveR	db 'use --no-preserve-root to override this failsafe',0
					; DATA XREF: rm_fts+252o
		align 4
; char aSkippingSSince[]
aSkippingSSince	db 'skipping %s, since it',27h,'s on a different device',0
					; DATA XREF: rm_fts+370o
		align 4
; char aWarningCircula[]
aWarningCircula	db 'WARNING: Circular directory structure.',0Ah ; DATA XREF: rm_fts+422o
		db 'This almost certainly means that you have a corrupted file system'
		db '.',0Ah
		db 'NOTIFY YOUR SYSTEM MANAGER.',0Ah
		db 'The following directory is part of the cycle:',0Ah
		db '  %s',0Ah,0
; char aTraversalFaile[]
aTraversalFaile	db 'traversal failed: %s',0 ; DATA XREF: rm_fts+46Fo
		align 4
; char aUnexpectedFail[]
aUnexpectedFail	db 'unexpected failure: fts_info=%d: %s',0Ah ; DATA XREF: rm_fts+4CAo
		db 'please report to %s',0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: rm_fts+4DAo
		align 4
off_800127C	dd offset loc_8000DFA	; DATA XREF: rm_fts+38r
		dd offset loc_8000992	; jump table for switch	statement
		dd offset loc_8000D5C
		dd offset loc_8000C5C
		dd offset loc_8000C5C
		dd offset loc_8000DFA
		dd offset loc_8000C5C
		dd offset loc_8000DA9
		dd offset loc_8000C5C
		dd offset loc_8000DFA
		dd offset loc_8000C5C
		dd offset loc_8000C5C
		dd offset loc_8000C5C
		dd offset loc_8000C5C
; char aFts_readFailed[]
aFts_readFailed	db 'fts_read failed',0  ; DATA XREF: rm+70o
; char file[]
file		db 'remove.c',0         ; DATA XREF: rm+D1o
; char assertion[]
assertion	db 'VALID_STATUS (s)',0 ; DATA XREF: rm+D6o
; char aFts_closeFaile[]
aFts_closeFaile	db 'fts_close failed',0 ; DATA XREF: rm+11Bo
; Function-local static	variable
; char _PRETTY_FUNCTION___5460[3]
__PRETTY_FUNCTION___5460 db 'rm',0      ; DATA XREF: rm+C7o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80012F4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_8000FAA-80022BEh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 3Ch
		dd offset locret_8000FAA-80022C0h
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 1Ch, 5Ch
		dd offset locret_8000FAA-8002288h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 1Ch, 7Ch
		dd offset locret_8000FAA-800226Dh
		dd 0A2h, 80E4100h, 0D420285h, 0C59E0205h, 4040Ch, 1Ch
		dd 9Ch
		dd offset locret_8000FAA-80021EBh
		dd 84h,	80E4100h, 0D420285h, 0C5800205h, 4040Ch, 1Ch, 0BCh
		dd offset locret_8000FAA-8002187h
		dd 19h,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 0DCh
		dd offset locret_8000FAA-800218Eh
		dd 0EBh, 80E4100h, 0D420285h, 0C5E70205h, 4040Ch, 28h
		dd 0FCh
		dd offset locret_8000FAA-80020C3h
		dd 40Ah, 80E4100h, 0D420285h, 3864805h,	0FC030483h, 0C641C303h
		dd 40CC541h, 4,	1Ch, 128h
		dd offset locret_8000FAA-8001CE5h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 148h
		dd offset locret_8000FAA-8001CE7h
		dd 2Dh,	80E4100h, 0D420285h, 0CC56905h,	404h, 1Ch, 168h
		dd offset locret_8000FAA-8001CDAh
		dd 2Dh,	80E4100h, 0D420285h, 0CC56905h,	404h, 1Ch, 188h
		dd offset locret_8000FAA-8001CCDh
		dd 3Eh,	80E4100h, 0D420285h, 0CC57A05h,	404h, 28h, 1A8h
		dd offset locret_8000FAA-8001CAFh
		dd 1B6h, 80E4100h, 0D420285h, 3864505h,	0AB030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 1D4h
		dd offset locret_8000FAA-8001B25h
		dd 50Bh, 80E4100h, 0D420285h, 3864505h,	30483h,	0C641C305h
		dd 40CC541h, 4,	20h, 200h
		dd offset locret_8000FAA-8001646h
		dd 14Fh, 80E4100h, 0D420285h, 3834405h,	0C5014703h, 4040CC3h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn fstatat64:near	; CODE XREF: lstatat+14p
					; cache_fstatat+29p
		extrn readdir64:near	; CODE XREF: readdir_ignoring_dot_and_dotdot+Cp
		extrn openat64:near	; CODE XREF: is_empty_dir+14p
		extrn fdopendir:near	; CODE XREF: is_empty_dir+32p
; int close(int	fd)
		extrn close:near	; CODE XREF: is_empty_dir+49p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: is_empty_dir:loc_8000109p
					; is_empty_dir+74p ...
; int closedir(DIR *dirp)
		extrn closedir:near	; CODE XREF: is_empty_dir+84p
		extrn can_write_any_file:near ;	CODE XREF: write_protected_non_symlink+6p
		extrn faccessat:near	; CODE XREF: write_protected_non_symlink+66p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: write_protected_non_symlink+7Fp
					; rm_fts+D8p
		extrn euidaccess_stat:near ; CODE XREF:	write_protected_non_symlink+9Bp
		extrn euidaccess:near	; CODE XREF: write_protected_non_symlink+B3p
		extrn quote:near	; CODE XREF: prompt+243p excise+81p ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: prompt+25Fp prompt+2FFp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: prompt+273p prompt+36Fp ...
		extrn program_name:dword ; DATA	XREF: prompt+2E8r prompt+38Er
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: prompt:loc_80005F8r
					; prompt:loc_800069Er
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: prompt+328p prompt+3D2p
		extrn file_type:near	; CODE XREF: prompt+384p
		extrn yesno:near	; CODE XREF: prompt:loc_80006B5p
		extrn __stack_chk_fail:near ; CODE XREF: prompt+3FEp
					; excise+1AAp ...
; int fts_set(FTS *, FTSENT *, int)
		extrn fts_set:near	; CODE XREF: fts_skip_tree+11p
; FTSENT *fts_read(FTS *)
		extrn fts_read:near	; CODE XREF: fts_skip_tree+1Fp	rm+4Dp
		extrn unlinkat:near	; CODE XREF: excise+5Dp
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: excise+BBp
		extrn strip_trailing_slashes:near ; CODE XREF: rm_fts+C2p
		extrn last_component:near ; CODE XREF: rm_fts+F2p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: rm_fts+1C3p
		extrn quote_n:near	; CODE XREF: rm_fts+20Dp rm_fts+223p
; void abort(void)
		extrn abort:near	; CODE XREF: rm_fts+4EEp
		extrn xfts_open:near	; CODE XREF: rm+3Cp
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: rm+DBp
; int fts_close(FTS *)
		extrn fts_close:near	; CODE XREF: rm+10Cp


		end
