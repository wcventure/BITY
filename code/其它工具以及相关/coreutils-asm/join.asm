;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BECE3B808707EA6BF5E08EF6C2AC37AA
; Input	CRC32 :	72C30DF5

; File Name   :	D:\coreutils-o\join.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'join.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: xfields+B0p xfields+F7p ...

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+132p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: add_file_name+A6p
					; main+4BFp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000265
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	FILE1 FILE2\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aForEachPairOfI ; "For each pair	of input lines with ident"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIIgnoreCaseIgn ; "  -i,	--ignore-case  ignore differences"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVFilenumLikeAF ; "  -v FILENUM	      like -a FILENUM, bu"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUnlessTCharIsG ; "\nUnless -t CHAR is given, leading blan"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000265:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl extract_field(line *line, char *field, size_t len)
extract_field	proc near		; CODE XREF: xfields+4Cp xfields+127p	...

line		= dword	ptr  8
field		= dword	ptr  0Ch
len		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+line]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+line]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jb	short loc_80002A9
		mov	eax, [ebp+line]
		lea	edx, [eax+10h]
		mov	eax, [ebp+line]
		mov	eax, [eax+14h]
		sub	esp, 4
		push	8
		push	edx
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+line]
		mov	[eax+14h], edx

loc_80002A9:				; CODE XREF: extract_field+14j
		mov	eax, [ebp+line]
		mov	edx, [eax+14h]
		mov	eax, [ebp+line]
		mov	eax, [eax+0Ch]
		shl	eax, 3
		add	edx, eax
		mov	eax, [ebp+field]
		mov	[edx], eax
		mov	eax, [ebp+line]
		mov	edx, [eax+14h]
		mov	eax, [ebp+line]
		mov	eax, [eax+0Ch]
		shl	eax, 3
		add	edx, eax
		mov	eax, [ebp+len]
		mov	[edx+4], eax
		mov	eax, [ebp+line]
		mov	eax, [eax+0Ch]
		lea	edx, [eax+1]
		mov	eax, [ebp+line]
		mov	[eax+0Ch], edx
		nop
		leave
		retn
extract_field	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl xfields(line *line)
xfields		proc near		; CODE XREF: get_line+DEp

ptr		= dword	ptr -18h
sep_0		= dword	ptr -14h
lim		= dword	ptr -10h
sep		= dword	ptr -0Ch
var_4		= dword	ptr -4
line		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		mov	[ebp+ptr], eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		lea	edx, [eax-1]
		mov	eax, [ebp+ptr]
		add	eax, edx
		mov	[ebp+lim], eax
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jz	loc_8000490
		mov	eax, tab
		test	eax, eax
		js	short loc_8000384
		jmp	short loc_8000345
; ---------------------------------------------------------------------------

loc_8000320:				; CODE XREF: xfields+85j
		mov	edx, [ebp+sep]
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; len
		push	[ebp+ptr]	; field
		push	[ebp+line]	; line
		call	extract_field
		add	esp, 10h
		mov	eax, [ebp+sep]
		add	eax, 1
		mov	[ebp+ptr], eax

loc_8000345:				; CODE XREF: xfields+36j
		mov	edx, [ebp+lim]
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, tab
		sub	esp, 4
		push	edx		; n
		push	eax		; c
		push	[ebp+ptr]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+sep], eax
		cmp	[ebp+sep], 0
		jnz	short loc_8000320
		jmp	loc_8000472
; ---------------------------------------------------------------------------

loc_8000374:				; CODE XREF: xfields+CAj
		add	[ebp+ptr], 1
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jz	loc_8000493

loc_8000384:				; CODE XREF: xfields+34j
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_8000374

loc_80003B4:				; CODE XREF: xfields+184j
		mov	eax, [ebp+ptr]
		add	eax, 1
		mov	[ebp+sep_0], eax
		jmp	short loc_80003C3
; ---------------------------------------------------------------------------

loc_80003BF:				; CODE XREF: xfields+111j
		add	[ebp+sep_0], 1

loc_80003C3:				; CODE XREF: xfields+D5j
		mov	eax, [ebp+sep_0]
		cmp	eax, [ebp+lim]
		jz	short loc_80003FB
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+sep_0]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jz	short loc_80003BF

loc_80003FB:				; CODE XREF: xfields+E1j
		mov	edx, [ebp+sep_0]
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; len
		push	[ebp+ptr]	; field
		push	[ebp+line]	; line
		call	extract_field
		add	esp, 10h
		mov	eax, [ebp+sep_0]
		cmp	eax, [ebp+lim]
		jz	short loc_8000496
		mov	eax, [ebp+sep_0]
		add	eax, 1
		mov	[ebp+ptr], eax
		jmp	short loc_800042E
; ---------------------------------------------------------------------------

loc_800042A:				; CODE XREF: xfields+17Cj
		add	[ebp+ptr], 1

loc_800042E:				; CODE XREF: xfields+140j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jz	short loc_8000466
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_800042A

loc_8000466:				; CODE XREF: xfields+14Cj
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnz	loc_80003B4

loc_8000472:				; CODE XREF: xfields+87j
		mov	edx, [ebp+lim]
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; len
		push	[ebp+ptr]	; field
		push	[ebp+line]	; line
		call	extract_field
		add	esp, 10h
		jmp	short loc_8000497
; ---------------------------------------------------------------------------

loc_8000490:				; CODE XREF: xfields+27j
		nop
		jmp	short loc_8000497
; ---------------------------------------------------------------------------

loc_8000493:				; CODE XREF: xfields+96j
		nop
		jmp	short loc_8000497
; ---------------------------------------------------------------------------

loc_8000496:				; CODE XREF: xfields+135j
		nop

loc_8000497:				; CODE XREF: xfields+1A6j xfields+1A9j ...
		mov	ebx, [ebp+var_4]
		leave
		retn
xfields		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl freeline(line *line)
freeline	proc near		; CODE XREF: get_line+C9p
					; free_spareline+2Bp ...

line		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+line]
		mov	eax, [eax+14h]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+line]
		mov	dword ptr [eax+8], 0
		nop
		leave
		retn
freeline	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl keycmp(const line	*line1,	const line *line2, size_t jf_1,	size_t jf_2)
keycmp		proc near		; CODE XREF: check_order+5Ep
					; system_join+9Dp ...

beg1		= dword	ptr -1Ch
beg2		= dword	ptr -18h
len1		= dword	ptr -14h
len2		= dword	ptr -10h
diff		= dword	ptr -0Ch
line1		= dword	ptr  8
line2		= dword	ptr  0Ch
jf_1		= dword	ptr  10h
jf_2		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+line1]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+jf_1]
		jbe	short loc_800050D
		mov	eax, [ebp+line1]
		mov	eax, [eax+14h]
		mov	edx, [ebp+jf_1]
		shl	edx, 3
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+beg1], eax
		mov	eax, [ebp+line1]
		mov	eax, [eax+14h]
		mov	edx, [ebp+jf_1]
		shl	edx, 3
		add	eax, edx
		mov	eax, [eax+4]
		mov	[ebp+len1], eax
		jmp	short loc_800051B
; ---------------------------------------------------------------------------

loc_800050D:				; CODE XREF: keycmp+Fj
		mov	[ebp+beg1], 0
		mov	[ebp+len1], 0

loc_800051B:				; CODE XREF: keycmp+38j
		mov	eax, [ebp+line2]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+jf_2]
		jbe	short loc_800054F
		mov	eax, [ebp+line2]
		mov	eax, [eax+14h]
		mov	edx, [ebp+jf_2]
		shl	edx, 3
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+beg2], eax
		mov	eax, [ebp+line2]
		mov	eax, [eax+14h]
		mov	edx, [ebp+jf_2]
		shl	edx, 3
		add	eax, edx
		mov	eax, [eax+4]
		mov	[ebp+len2], eax
		jmp	short loc_800055D
; ---------------------------------------------------------------------------

loc_800054F:				; CODE XREF: keycmp+51j
		mov	[ebp+beg2], 0
		mov	[ebp+len2], 0

loc_800055D:				; CODE XREF: keycmp+7Aj
		cmp	[ebp+len1], 0
		jnz	short loc_800057D
		cmp	[ebp+len2], 0
		jnz	short loc_8000573
		mov	eax, 0
		jmp	locret_8000620
; ---------------------------------------------------------------------------

loc_8000573:				; CODE XREF: keycmp+94j
		mov	eax, 0FFFFFFFFh
		jmp	locret_8000620
; ---------------------------------------------------------------------------

loc_800057D:				; CODE XREF: keycmp+8Ej
		cmp	[ebp+len2], 0
		jnz	short loc_800058D
		mov	eax, 1
		jmp	locret_8000620
; ---------------------------------------------------------------------------

loc_800058D:				; CODE XREF: keycmp+AEj
		movzx	eax, ds:ignore_case
		test	al, al
		jz	short loc_80005B9
		mov	eax, [ebp+len1]
		cmp	[ebp+len2], eax
		cmovbe	eax, [ebp+len2]
		sub	esp, 4
		push	eax
		push	[ebp+beg2]
		push	[ebp+beg1]
		call	memcasecmp
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	short loc_80005F9
; ---------------------------------------------------------------------------

loc_80005B9:				; CODE XREF: keycmp+C3j
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	short loc_80005DA
		push	[ebp+len2]
		push	[ebp+beg2]
		push	[ebp+len1]
		push	[ebp+beg1]
		call	xmemcoll
		add	esp, 10h
		jmp	short locret_8000620
; ---------------------------------------------------------------------------

loc_80005DA:				; CODE XREF: keycmp+EFj
		mov	eax, [ebp+len1]
		cmp	[ebp+len2], eax
		cmovbe	eax, [ebp+len2]
		sub	esp, 4
		push	eax		; n
		push	[ebp+beg2]	; s2
		push	[ebp+beg1]	; s1
		call	memcmp
		add	esp, 10h
		mov	[ebp+diff], eax

loc_80005F9:				; CODE XREF: keycmp+E4j
		cmp	[ebp+diff], 0
		jz	short loc_8000604
		mov	eax, [ebp+diff]
		jmp	short locret_8000620
; ---------------------------------------------------------------------------

loc_8000604:				; CODE XREF: keycmp+12Aj
		mov	eax, [ebp+len1]
		cmp	eax, [ebp+len2]
		jb	short loc_800061A
		mov	eax, [ebp+len1]
		cmp	eax, [ebp+len2]
		setnz	al
		movzx	eax, al
		jmp	short loc_800061F
; ---------------------------------------------------------------------------

loc_800061A:				; CODE XREF: keycmp+137j
		mov	eax, 0FFFFFFFFh

loc_800061F:				; CODE XREF: keycmp+145j
		nop

locret_8000620:				; CODE XREF: keycmp+9Bj keycmp+A5j ...
		leave
		retn
keycmp		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_order(const line *prev, const line	*current, int whatfile)
check_order	proc near		; CODE XREF: get_line+10Ep

join_field	= dword	ptr -0Ch
prev		= dword	ptr  8
current		= dword	ptr  0Ch
whatfile	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:check_input_order
		cmp	eax, 2
		jz	loc_80006C8
		mov	eax, ds:check_input_order
		cmp	eax, 1
		jz	short loc_800064B
		movzx	eax, ds:seen_unpairable
		test	al, al
		jz	short loc_80006C8

loc_800064B:				; CODE XREF: check_order+1Cj
		mov	eax, [ebp+whatfile]
		sub	eax, 1
		movzx	eax, ds:issued_disorder_warning[eax]
		xor	eax, 1
		test	al, al
		jz	short loc_80006C8
		cmp	[ebp+whatfile],	1
		jnz	short loc_800066C
		mov	eax, join_field_1
		jmp	short loc_8000671
; ---------------------------------------------------------------------------

loc_800066C:				; CODE XREF: check_order+41j
		mov	eax, join_field_2

loc_8000671:				; CODE XREF: check_order+48j
		mov	[ebp+join_field], eax
		push	[ebp+join_field] ; jf_2
		push	[ebp+join_field] ; jf_1
		push	[ebp+current]	; line2
		push	[ebp+prev]	; line1
		call	keycmp
		add	esp, 10h
		test	eax, eax
		jle	short loc_80006C8
		sub	esp, 0Ch
		push	offset aFileDIsNotInSo ; "file %d is not in sorted order"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:check_input_order
		cmp	eax, 1
		setz	al
		movzx	eax, al
		push	[ebp+whatfile]
		push	edx		; format
		push	0		; errnum
		push	eax		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+whatfile]
		sub	eax, 1
		mov	ds:issued_disorder_warning[eax], 1

loc_80006C8:				; CODE XREF: check_order+Ej
					; check_order+27j ...
		nop
		leave
		retn
check_order	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl reset_line(line *line)
reset_line	proc near		; CODE XREF: get_line+58p

line		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+line]
		mov	dword ptr [eax+0Ch], 0
		nop
		pop	ebp
		retn
reset_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; line *__cdecl	init_linep(line	**linep)
init_linep	proc near		; CODE XREF: get_line+68p

line		= dword	ptr -0Ch
linep		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	18h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+line], eax
		sub	esp, 4
		push	18h		; n
		push	0		; c
		push	[ebp+line]	; s
		call	memset
		add	esp, 10h
		mov	eax, [ebp+linep]
		mov	edx, [ebp+line]
		mov	[eax], edx
		mov	eax, [ebp+line]
		leave
		retn
init_linep	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	get_line(FILE *fp, line	**linep, int which)
get_line	proc near		; CODE XREF: getseq+7Fp
					; system_join+3C7p ...

line		= dword	ptr -10h
tmp		= dword	ptr -0Ch
var_4		= dword	ptr -4
fp		= dword	ptr  8
linep		= dword	ptr  0Ch
which		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+linep]
		mov	eax, [eax]
		mov	[ebp+line], eax
		mov	eax, [ebp+which]
		sub	eax, 1
		mov	eax, ds:prevline[eax*4]
		cmp	eax, [ebp+line]
		jnz	short loc_800075F
		mov	eax, [ebp+line]
		mov	[ebp+tmp], eax
		mov	eax, [ebp+which]
		sub	eax, 1
		mov	eax, ds:spareline[eax*4]
		mov	[ebp+line], eax
		mov	eax, [ebp+which]
		lea	edx, [eax-1]
		mov	eax, [ebp+tmp]
		mov	ds:spareline[edx*4], eax
		mov	eax, [ebp+linep]
		mov	edx, [ebp+line]
		mov	[eax], edx

loc_800075F:				; CODE XREF: get_line+1Fj
		cmp	[ebp+line], 0
		jz	short loc_8000772
		push	[ebp+line]	; line
		call	reset_line
		add	esp, 4
		jmp	short loc_8000783
; ---------------------------------------------------------------------------

loc_8000772:				; CODE XREF: get_line+53j
		sub	esp, 0Ch
		push	[ebp+linep]	; linep
		call	init_linep
		add	esp, 10h
		mov	[ebp+line], eax

loc_8000783:				; CODE XREF: get_line+60j
		mov	eax, [ebp+line]
		sub	esp, 8
		push	[ebp+fp]
		push	eax
		call	readlinebuffer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80007E8
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80007D3
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007D3:				; CODE XREF: get_line+99j
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	freeline
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_800083B
; ---------------------------------------------------------------------------

loc_80007E8:				; CODE XREF: get_line+87j
		sub	esp, 0Ch
		push	[ebp+line]	; line
		call	xfields
		add	esp, 10h
		mov	eax, [ebp+which]
		sub	eax, 1
		mov	eax, ds:prevline[eax*4]
		test	eax, eax
		jz	short loc_8000826
		mov	eax, [ebp+which]
		sub	eax, 1
		mov	eax, ds:prevline[eax*4]
		sub	esp, 4
		push	[ebp+which]	; whatfile
		push	[ebp+line]	; current
		push	eax		; prev
		call	check_order
		add	esp, 10h

loc_8000826:				; CODE XREF: get_line+F5j
		mov	eax, [ebp+which]
		lea	edx, [eax-1]
		mov	eax, [ebp+line]
		mov	ds:prevline[edx*4], eax
		mov	eax, 1

loc_800083B:				; CODE XREF: get_line+D6j
		mov	ebx, [ebp+var_4]
		leave
		retn
get_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void free_spareline()
free_spareline	proc near		; DATA XREF: main+AFo

i		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_800088D
; ---------------------------------------------------------------------------

loc_800084F:				; CODE XREF: free_spareline+51j
		mov	eax, [ebp+i]
		mov	eax, ds:spareline[eax*4]
		test	eax, eax
		jz	short loc_8000889
		mov	eax, [ebp+i]
		mov	eax, ds:spareline[eax*4]
		sub	esp, 0Ch
		push	eax		; line
		call	freeline
		add	esp, 10h
		mov	eax, [ebp+i]
		mov	eax, ds:spareline[eax*4]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h

loc_8000889:				; CODE XREF: free_spareline+1Bj
		add	[ebp+i], 1

loc_800088D:				; CODE XREF: free_spareline+Dj
		cmp	[ebp+i], 1
		jbe	short loc_800084F
		nop
		leave
		retn
free_spareline	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initseq(seq *seq)
initseq		proc near		; CODE XREF: system_join+3Fp
					; system_join+62p

seq		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+seq]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+seq]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+seq]
		mov	dword ptr [eax+8], 0
		nop
		pop	ebp
		retn
initseq		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	getseq(FILE *fp, seq *seq, int whichfile)
getseq		proc near		; CODE XREF: advance_seq+27p
					; system_join+53p ...

i		= dword	ptr -0Ch
fp		= dword	ptr  8
seq		= dword	ptr  0Ch
whichfile	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+seq]
		mov	edx, [eax]
		mov	eax, [ebp+seq]
		mov	eax, [eax+4]
		cmp	edx, eax
		jnz	short loc_800091E
		mov	eax, [ebp+seq]
		lea	edx, [eax+4]
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		sub	esp, 4
		push	4
		push	edx
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+seq]
		mov	[eax+8], edx
		mov	eax, [ebp+seq]
		mov	eax, [eax]
		mov	[ebp+i], eax
		jmp	short loc_8000913
; ---------------------------------------------------------------------------

loc_80008FB:				; CODE XREF: getseq+63j
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	dword ptr [eax], 0
		add	[ebp+i], 1

loc_8000913:				; CODE XREF: getseq+40j
		mov	eax, [ebp+seq]
		mov	eax, [eax+4]
		cmp	eax, [ebp+i]
		ja	short loc_80008FB

loc_800091E:				; CODE XREF: getseq+13j
		mov	eax, [ebp+seq]
		mov	edx, [eax+8]
		mov	eax, [ebp+seq]
		mov	eax, [eax]
		shl	eax, 2
		add	eax, edx
		sub	esp, 4
		push	[ebp+whichfile]	; which
		push	eax		; linep
		push	[ebp+fp]	; fp
		call	get_line
		add	esp, 10h
		test	al, al
		jz	short loc_8000958
		mov	eax, [ebp+seq]
		mov	eax, [eax]
		lea	edx, [eax+1]
		mov	eax, [ebp+seq]
		mov	[eax], edx
		mov	eax, 1
		jmp	short locret_800095D
; ---------------------------------------------------------------------------

loc_8000958:				; CODE XREF: getseq+89j
		mov	eax, 0

locret_800095D:				; CODE XREF: getseq+9Dj
		leave
		retn
getseq		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	advance_seq(FILE *fp, seq *seq,	_Bool first, int whichfile)
advance_seq	proc near		; CODE XREF: system_join+DAp
					; system_join+120p ...

first		= byte ptr -0Ch
fp		= dword	ptr  8
seq		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
whichfile	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[ebp+first], al
		cmp	[ebp+first], 0
		jz	short loc_800097A
		mov	eax, [ebp+seq]
		mov	dword ptr [eax], 0

loc_800097A:				; CODE XREF: advance_seq+10j
		sub	esp, 4
		push	[ebp+whichfile]	; whichfile
		push	[ebp+seq]	; seq
		push	[ebp+fp]	; fp
		call	getseq
		add	esp, 10h
		leave
		retn
advance_seq	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl delseq(seq *seq)
delseq		proc near		; CODE XREF: system_join+496p
					; system_join+4A5p

i		= dword	ptr -0Ch
seq		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_8000A06
; ---------------------------------------------------------------------------

loc_800099F:				; CODE XREF: delseq+7Fj
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000A02
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_80009E6
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; line
		call	freeline
		add	esp, 10h

loc_80009E6:				; CODE XREF: delseq+38j
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		mov	edx, [ebp+i]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h

loc_8000A02:				; CODE XREF: delseq+21j
		add	[ebp+i], 1

loc_8000A06:				; CODE XREF: delseq+Dj
		mov	eax, [ebp+seq]
		mov	eax, [eax+4]
		cmp	eax, [ebp+i]
		ja	short loc_800099F
		mov	eax, [ebp+seq]
		mov	eax, [eax+8]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
delseq		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl prfield(size_t n, const line *line)
prfield		proc near		; CODE XREF: prjoin+8Fp prjoin+F5p ...

len		= dword	ptr -0Ch
n		= dword	ptr  8
line		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+line]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+n]
		jbe	short loc_8000A9B
		mov	eax, [ebp+line]
		mov	eax, [eax+14h]
		mov	edx, [ebp+n]
		shl	edx, 3
		add	eax, edx
		mov	eax, [eax+4]
		mov	[ebp+len], eax
		cmp	[ebp+len], 0
		jz	short loc_8000A78
		mov	edx, ds:stdout
		mov	eax, [ebp+line]
		mov	eax, [eax+14h]
		mov	ecx, [ebp+n]
		shl	ecx, 3
		add	eax, ecx
		mov	eax, [eax]
		push	edx		; stream
		push	[ebp+len]	; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8000ABC
; ---------------------------------------------------------------------------

loc_8000A78:				; CODE XREF: prfield+29j
		mov	eax, ds:empty_filler
		test	eax, eax
		jz	short loc_8000ABC
		mov	edx, ds:stdout
		mov	eax, ds:empty_filler
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		jmp	short loc_8000ABC
; ---------------------------------------------------------------------------

loc_8000A9B:				; CODE XREF: prfield+Fj
		mov	eax, ds:empty_filler
		test	eax, eax
		jz	short loc_8000ABC
		mov	edx, ds:stdout
		mov	eax, ds:empty_filler
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h

loc_8000ABC:				; CODE XREF: prfield+50j prfield+59j ...
		nop
		leave
		retn
prfield		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl prjoin(const line *line1, const line *line2)
prjoin		proc near		; CODE XREF: system_join+C7p
					; system_join+10Dp ...

output_separator= byte ptr -21h
o		= dword	ptr -20h
field		= dword	ptr -1Ch
line		= dword	ptr -18h
i		= dword	ptr -14h
outlist		= dword	ptr -10h
t		= dword	ptr -0Ch
line1		= dword	ptr  8
line2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, tab
		test	eax, eax
		js	short loc_8000AD5
		mov	eax, tab
		jmp	short loc_8000ADA
; ---------------------------------------------------------------------------

loc_8000AD5:				; CODE XREF: prjoin+Dj
		mov	eax, 20h

loc_8000ADA:				; CODE XREF: prjoin+14j
		mov	[ebp+output_separator],	al
		mov	eax, ds:outlist_head.next
		mov	[ebp+outlist], eax
		cmp	[ebp+outlist], 0
		jz	loc_8000B8D
		mov	eax, [ebp+outlist]
		mov	[ebp+o], eax

loc_8000AF5:				; CODE XREF: prjoin+B6j
		mov	eax, [ebp+o]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8000B27
		cmp	[ebp+line1], offset uni_blank
		jnz	short loc_8000B17
		mov	eax, [ebp+line2]
		mov	[ebp+line], eax
		mov	eax, join_field_2
		mov	[ebp+field], eax
		jmp	short loc_8000B45
; ---------------------------------------------------------------------------

loc_8000B17:				; CODE XREF: prjoin+46j
		mov	eax, [ebp+line1]
		mov	[ebp+line], eax
		mov	eax, join_field_1
		mov	[ebp+field], eax
		jmp	short loc_8000B45
; ---------------------------------------------------------------------------

loc_8000B27:				; CODE XREF: prjoin+3Dj
		mov	eax, [ebp+o]
		mov	eax, [eax]
		cmp	eax, 1
		jnz	short loc_8000B36
		mov	eax, [ebp+line1]
		jmp	short loc_8000B39
; ---------------------------------------------------------------------------

loc_8000B36:				; CODE XREF: prjoin+70j
		mov	eax, [ebp+line2]

loc_8000B39:				; CODE XREF: prjoin+75j
		mov	[ebp+line], eax
		mov	eax, [ebp+o]
		mov	eax, [eax+4]
		mov	[ebp+field], eax

loc_8000B45:				; CODE XREF: prjoin+56j prjoin+66j
		sub	esp, 8
		push	[ebp+line]	; line
		push	[ebp+field]	; n
		call	prfield
		add	esp, 10h
		mov	eax, [ebp+o]
		mov	eax, [eax+8]
		mov	[ebp+o], eax
		cmp	[ebp+o], 0
		jz	short loc_8000B7A
		movsx	eax, [ebp+output_separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000AF5
; ---------------------------------------------------------------------------

loc_8000B7A:				; CODE XREF: prjoin+A4j
		nop
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000CC9
; ---------------------------------------------------------------------------

loc_8000B8D:				; CODE XREF: prjoin+2Aj
		cmp	[ebp+line1], offset uni_blank
		jnz	short loc_8000BA8
		mov	eax, [ebp+line1]
		mov	[ebp+t], eax
		mov	eax, [ebp+line2]
		mov	[ebp+line1], eax
		mov	eax, [ebp+t]
		mov	[ebp+line2], eax

loc_8000BA8:				; CODE XREF: prjoin+D5j
		mov	eax, join_field_1
		sub	esp, 8
		push	[ebp+line1]	; line
		push	eax		; n
		call	prfield
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8000BEA
; ---------------------------------------------------------------------------

loc_8000BC5:				; CODE XREF: prjoin+13Ej
		movsx	eax, [ebp+output_separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 8
		push	[ebp+line1]	; line
		push	[ebp+i]		; n
		call	prfield
		add	esp, 10h
		add	[ebp+i], 1

loc_8000BEA:				; CODE XREF: prjoin+104j
		mov	eax, join_field_1
		cmp	[ebp+i], eax
		jnb	short loc_8000BFF
		mov	eax, [ebp+line1]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+i]
		ja	short loc_8000BC5

loc_8000BFF:				; CODE XREF: prjoin+133j
		mov	eax, join_field_1
		add	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_8000C31
; ---------------------------------------------------------------------------

loc_8000C0C:				; CODE XREF: prjoin+17Bj
		movsx	eax, [ebp+output_separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 8
		push	[ebp+line1]	; line
		push	[ebp+i]		; n
		call	prfield
		add	esp, 10h
		add	[ebp+i], 1

loc_8000C31:				; CODE XREF: prjoin+14Bj
		mov	eax, [ebp+line1]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+i]
		ja	short loc_8000C0C
		mov	[ebp+i], 0
		jmp	short loc_8000C6A
; ---------------------------------------------------------------------------

loc_8000C45:				; CODE XREF: prjoin+1BEj
		movsx	eax, [ebp+output_separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 8
		push	[ebp+line2]	; line
		push	[ebp+i]		; n
		call	prfield
		add	esp, 10h
		add	[ebp+i], 1

loc_8000C6A:				; CODE XREF: prjoin+184j
		mov	eax, join_field_2
		cmp	[ebp+i], eax
		jnb	short loc_8000C7F
		mov	eax, [ebp+line2]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+i]
		ja	short loc_8000C45

loc_8000C7F:				; CODE XREF: prjoin+1B3j
		mov	eax, join_field_2
		add	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_8000CB1
; ---------------------------------------------------------------------------

loc_8000C8C:				; CODE XREF: prjoin+1FBj
		movsx	eax, [ebp+output_separator]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 8
		push	[ebp+line2]	; line
		push	[ebp+i]		; n
		call	prfield
		add	esp, 10h
		add	[ebp+i], 1

loc_8000CB1:				; CODE XREF: prjoin+1CBj
		mov	eax, [ebp+line2]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+i]
		ja	short loc_8000C8C
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000CC9:				; CODE XREF: prjoin+C9j
		nop
		leave
		retn
prjoin		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl system_join(FILE	*fp1, FILE *fp2)
system_join	proc near		; CODE XREF: main+753p

fp2		= dword	ptr -50h
fp1		= dword	ptr -4Ch
eof1		= byte ptr -3Fh
eof2		= byte ptr -3Eh
checktail	= byte ptr -3Dh
i		= dword	ptr -3Ch
j		= dword	ptr -38h
linep		= dword	ptr -34h
diff		= dword	ptr -30h
tmp		= dword	ptr -2Ch
tmp_0		= dword	ptr -28h
seq1		= seq ptr -24h
seq2		= seq ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 50h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fp1], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+fp2], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	4		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+linep], eax
		mov	eax, [ebp+linep]
		mov	dword ptr [eax], 0
		sub	esp, 0Ch
		lea	eax, [ebp+seq1]
		push	eax		; seq
		call	initseq
		add	esp, 10h
		sub	esp, 4
		push	1		; whichfile
		lea	eax, [ebp+seq1]
		push	eax		; seq
		push	[ebp+fp1]	; fp
		call	getseq
		add	esp, 10h
		sub	esp, 0Ch
		lea	eax, [ebp+seq2]
		push	eax		; seq
		call	initseq
		add	esp, 10h
		sub	esp, 4
		push	2		; whichfile
		lea	eax, [ebp+seq2]
		push	eax		; seq
		push	[ebp+fp2]	; fp
		call	getseq
		add	esp, 10h
		jmp	loc_8000FC6
; ---------------------------------------------------------------------------

loc_8000D4F:				; CODE XREF: system_join+306j
		mov	ebx, join_field_2
		mov	ecx, join_field_1
		mov	eax, [ebp+seq2.lines]
		mov	edx, [eax]
		mov	eax, [ebp+seq1.lines]
		mov	eax, [eax]
		push	ebx		; jf_2
		push	ecx		; jf_1
		push	edx		; line2
		push	eax		; line1
		call	keycmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jns	short loc_8000DBA
		movzx	eax, ds:print_unpairables_1
		test	al, al
		jz	short loc_8000D9B
		mov	eax, [ebp+seq1.lines]
		mov	eax, [eax]
		sub	esp, 8
		push	offset uni_blank ; line2
		push	eax		; line1
		call	prjoin
		add	esp, 10h

loc_8000D9B:				; CODE XREF: system_join+B7j
		push	1		; whichfile
		push	1		; first
		lea	eax, [ebp+seq1]
		push	eax		; seq
		push	[ebp+fp1]	; fp
		call	advance_seq
		add	esp, 10h
		mov	ds:seen_unpairable, 1
		jmp	loc_8000FC6
; ---------------------------------------------------------------------------

loc_8000DBA:				; CODE XREF: system_join+ACj
		cmp	[ebp+diff], 0
		jle	short loc_8000E00
		movzx	eax, ds:print_unpairables_2
		test	al, al
		jz	short loc_8000DE1
		mov	eax, [ebp+seq2.lines]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; line2
		push	offset uni_blank ; line1
		call	prjoin
		add	esp, 10h

loc_8000DE1:				; CODE XREF: system_join+FDj
		push	2		; whichfile
		push	1		; first
		lea	eax, [ebp+seq2]
		push	eax		; seq
		push	[ebp+fp2]	; fp
		call	advance_seq
		add	esp, 10h
		mov	ds:seen_unpairable, 1
		jmp	loc_8000FC6
; ---------------------------------------------------------------------------

loc_8000E00:				; CODE XREF: system_join+F2j
		mov	[ebp+eof1], 0

loc_8000E04:				; CODE XREF: system_join+193j
		push	1		; whichfile
		push	0		; first
		lea	eax, [ebp+seq1]
		push	eax		; seq
		push	[ebp+fp1]	; fp
		call	advance_seq
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000E2D
		mov	[ebp+eof1], 1
		mov	eax, [ebp+seq1.count]
		add	eax, 1
		mov	[ebp+seq1.count], eax
		jmp	short loc_8000E61
; ---------------------------------------------------------------------------

loc_8000E2D:				; CODE XREF: system_join+150j
		mov	ebx, join_field_2
		mov	ecx, join_field_1
		mov	eax, [ebp+seq2.lines]
		mov	edx, [eax]
		mov	eax, [ebp+seq1.lines]
		mov	esi, [ebp+seq1.count]
		add	esi, 3FFFFFFFh
		shl	esi, 2
		add	eax, esi
		mov	eax, [eax]
		push	ebx		; jf_2
		push	ecx		; jf_1
		push	edx		; line2
		push	eax		; line1
		call	keycmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000E04

loc_8000E61:				; CODE XREF: system_join+15Fj
		mov	[ebp+eof2], 0

loc_8000E65:				; CODE XREF: system_join+1F4j
		push	2		; whichfile
		push	0		; first
		lea	eax, [ebp+seq2]
		push	eax		; seq
		push	[ebp+fp2]	; fp
		call	advance_seq
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000E8E
		mov	[ebp+eof2], 1
		mov	eax, [ebp+seq2.count]
		add	eax, 1
		mov	[ebp+seq2.count], eax
		jmp	short loc_8000EC2
; ---------------------------------------------------------------------------

loc_8000E8E:				; CODE XREF: system_join+1B1j
		mov	ebx, join_field_2
		mov	ecx, join_field_1
		mov	eax, [ebp+seq2.lines]
		mov	edx, [ebp+seq2.count]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+seq1.lines]
		mov	eax, [eax]
		push	ebx		; jf_2
		push	ecx		; jf_1
		push	edx		; line2
		push	eax		; line1
		call	keycmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000E65

loc_8000EC2:				; CODE XREF: system_join+1C0j
		movzx	eax, ds:print_pairables
		test	al, al
		jz	short loc_8000F24
		mov	[ebp+i], 0
		jmp	short loc_8000F19
; ---------------------------------------------------------------------------

loc_8000ED6:				; CODE XREF: system_join+256j
		mov	[ebp+j], 0
		jmp	short loc_8000F0A
; ---------------------------------------------------------------------------

loc_8000EDF:				; CODE XREF: system_join+247j
		mov	eax, [ebp+seq2.lines]
		mov	edx, [ebp+j]
		shl	edx, 2
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+seq1.lines]
		mov	ecx, [ebp+i]
		shl	ecx, 2
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; line2
		push	eax		; line1
		call	prjoin
		add	esp, 10h
		add	[ebp+j], 1

loc_8000F0A:				; CODE XREF: system_join+211j
		mov	eax, [ebp+seq2.count]
		sub	eax, 1
		cmp	eax, [ebp+j]
		ja	short loc_8000EDF
		add	[ebp+i], 1

loc_8000F19:				; CODE XREF: system_join+208j
		mov	eax, [ebp+seq1.count]
		sub	eax, 1
		cmp	eax, [ebp+i]
		ja	short loc_8000ED6

loc_8000F24:				; CODE XREF: system_join+1FFj
		movzx	eax, [ebp+eof1]
		xor	eax, 1
		test	al, al
		jz	short loc_8000F6E
		mov	eax, [ebp+seq1.lines]
		mov	eax, [eax]
		mov	[ebp+tmp], eax
		mov	eax, [ebp+seq1.lines]
		mov	edx, [ebp+seq1.lines]
		mov	ecx, [ebp+seq1.count]
		add	ecx, 3FFFFFFFh
		shl	ecx, 2
		add	edx, ecx
		mov	edx, [edx]
		mov	[eax], edx
		mov	eax, [ebp+seq1.lines]
		mov	edx, [ebp+seq1.count]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+tmp]
		mov	[edx], eax
		mov	[ebp+seq1.count], 1
		jmp	short loc_8000F75
; ---------------------------------------------------------------------------

loc_8000F6E:				; CODE XREF: system_join+261j
		mov	[ebp+seq1.count], 0

loc_8000F75:				; CODE XREF: system_join+2A0j
		movzx	eax, [ebp+eof2]
		xor	eax, 1
		test	al, al
		jz	short loc_8000FBF
		mov	eax, [ebp+seq2.lines]
		mov	eax, [eax]
		mov	[ebp+tmp_0], eax
		mov	eax, [ebp+seq2.lines]
		mov	edx, [ebp+seq2.lines]
		mov	ecx, [ebp+seq2.count]
		add	ecx, 3FFFFFFFh
		shl	ecx, 2
		add	edx, ecx
		mov	edx, [edx]
		mov	[eax], edx
		mov	eax, [ebp+seq2.lines]
		mov	edx, [ebp+seq2.count]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+tmp_0]
		mov	[edx], eax
		mov	[ebp+seq2.count], 1
		jmp	short loc_8000FC6
; ---------------------------------------------------------------------------

loc_8000FBF:				; CODE XREF: system_join+2B2j
		mov	[ebp+seq2.count], 0

loc_8000FC6:				; CODE XREF: system_join+7Ej
					; system_join+E9j ...
		mov	eax, [ebp+seq1.count]
		test	eax, eax
		jz	short loc_8000FD8
		mov	eax, [ebp+seq2.count]
		test	eax, eax
		jnz	loc_8000D4F

loc_8000FD8:				; CODE XREF: system_join+2FFj
		mov	eax, ds:check_input_order
		cmp	eax, 2
		jz	short loc_8001004
		movzx	eax, ds:issued_disorder_warning
		xor	eax, 1
		test	al, al
		jnz	short loc_8000FFE
		movzx	eax, ds:issued_disorder_warning+1
		xor	eax, 1
		test	al, al
		jz	short loc_8001004

loc_8000FFE:				; CODE XREF: system_join+322j
		mov	[ebp+checktail], 1
		jmp	short loc_8001008
; ---------------------------------------------------------------------------

loc_8001004:				; CODE XREF: system_join+314j
					; system_join+330j
		mov	[ebp+checktail], 0

loc_8001008:				; CODE XREF: system_join+336j
		movzx	eax, ds:print_unpairables_1
		test	al, al
		jnz	short loc_800101D
		cmp	[ebp+checktail], 0
		jz	loc_80010A2

loc_800101D:				; CODE XREF: system_join+345j
		mov	eax, [ebp+seq1.count]
		test	eax, eax
		jz	short loc_80010A2
		movzx	eax, ds:print_unpairables_1
		test	al, al
		jz	short loc_8001045
		mov	eax, [ebp+seq1.lines]
		mov	eax, [eax]
		sub	esp, 8
		push	offset uni_blank ; line2
		push	eax		; line1
		call	prjoin
		add	esp, 10h

loc_8001045:				; CODE XREF: system_join+361j
		mov	ds:seen_unpairable, 1
		jmp	short loc_8001088
; ---------------------------------------------------------------------------

loc_800104E:				; CODE XREF: system_join+3D1j
		movzx	eax, ds:print_unpairables_1
		test	al, al
		jz	short loc_800106F
		mov	eax, [ebp+linep]
		mov	eax, [eax]
		sub	esp, 8
		push	offset uni_blank ; line2
		push	eax		; line1
		call	prjoin
		add	esp, 10h

loc_800106F:				; CODE XREF: system_join+38Bj
		movzx	eax, ds:issued_disorder_warning
		test	al, al
		jz	short loc_8001088
		movzx	eax, ds:print_unpairables_1
		xor	eax, 1
		test	al, al
		jnz	short loc_80010A1

loc_8001088:				; CODE XREF: system_join+380j
					; system_join+3ACj
		sub	esp, 4
		push	1		; which
		push	[ebp+linep]	; linep
		push	[ebp+fp1]	; fp
		call	get_line
		add	esp, 10h
		test	al, al
		jnz	short loc_800104E
		jmp	short loc_80010A2
; ---------------------------------------------------------------------------

loc_80010A1:				; CODE XREF: system_join+3BAj
		nop

loc_80010A2:				; CODE XREF: system_join+34Bj
					; system_join+356j ...
		movzx	eax, ds:print_unpairables_2
		test	al, al
		jnz	short loc_80010B7
		cmp	[ebp+checktail], 0
		jz	loc_800113C

loc_80010B7:				; CODE XREF: system_join+3DFj
		mov	eax, [ebp+seq2.count]
		test	eax, eax
		jz	short loc_800113C
		movzx	eax, ds:print_unpairables_2
		test	al, al
		jz	short loc_80010DF
		mov	eax, [ebp+seq2.lines]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; line2
		push	offset uni_blank ; line1
		call	prjoin
		add	esp, 10h

loc_80010DF:				; CODE XREF: system_join+3FBj
		mov	ds:seen_unpairable, 1
		jmp	short loc_8001122
; ---------------------------------------------------------------------------

loc_80010E8:				; CODE XREF: system_join+46Bj
		movzx	eax, ds:print_unpairables_2
		test	al, al
		jz	short loc_8001109
		mov	eax, [ebp+linep]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; line2
		push	offset uni_blank ; line1
		call	prjoin
		add	esp, 10h

loc_8001109:				; CODE XREF: system_join+425j
		movzx	eax, ds:issued_disorder_warning+1
		test	al, al
		jz	short loc_8001122
		movzx	eax, ds:print_unpairables_2
		xor	eax, 1
		test	al, al
		jnz	short loc_800113B

loc_8001122:				; CODE XREF: system_join+41Aj
					; system_join+446j
		sub	esp, 4
		push	2		; which
		push	[ebp+linep]	; linep
		push	[ebp+fp2]	; fp
		call	get_line
		add	esp, 10h
		test	al, al
		jnz	short loc_80010E8
		jmp	short loc_800113C
; ---------------------------------------------------------------------------

loc_800113B:				; CODE XREF: system_join+454j
		nop

loc_800113C:				; CODE XREF: system_join+3E5j
					; system_join+3F0j ...
		mov	eax, [ebp+linep]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+linep]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		lea	eax, [ebp+seq1]
		push	eax		; seq
		call	delseq
		add	esp, 10h
		sub	esp, 0Ch
		lea	eax, [ebp+seq2]
		push	eax		; seq
		call	delseq
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_800118B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800118B:				; CODE XREF: system_join+4B8j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
system_join	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_field(int file, size_t field)
add_field	proc near		; CODE XREF: add_field_list+6Cp

o		= dword	ptr -0Ch
file		= dword	ptr  8
field		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		cmp	[ebp+file], 0
		jz	short loc_80011C3
		cmp	[ebp+file], 1
		jz	short loc_80011C3
		cmp	[ebp+file], 2
		jz	short loc_80011C3
		push	offset __PRETTY_FUNCTION___5404	; "add_field"
		push	2EAh		; line
		push	offset file	; "join.c"
		push	offset assertion ; "file == 0 || file == 1 || file == 2"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80011C3:				; CODE XREF: add_field+Aj
					; add_field+10j ...
		cmp	[ebp+file], 0
		jnz	short loc_80011E8
		cmp	[ebp+field], 0
		jz	short loc_80011E8
		push	offset __PRETTY_FUNCTION___5404	; "add_field"
		push	2EBh		; line
		push	offset file	; "join.c"
		push	offset aFile0Field0 ; "file != 0 || field == 0"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80011E8:				; CODE XREF: add_field+35j
					; add_field+3Bj
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+o], eax
		mov	eax, [ebp+o]
		mov	edx, [ebp+file]
		mov	[eax], edx
		mov	eax, [ebp+o]
		mov	edx, [ebp+field]
		mov	[eax+4], edx
		mov	eax, [ebp+o]
		mov	dword ptr [eax+8], 0
		mov	eax, outlist_end
		mov	edx, [ebp+o]
		mov	[eax+8], edx
		mov	eax, [ebp+o]
		mov	outlist_end, eax
		nop
		leave
		retn
add_field	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl string_to_join_field(const char *str)
string_to_join_field proc near		; CODE XREF: decode_field_spec+D1p
					; add_file_name+BEp ...

str		= dword	ptr -1Ch
val		= dword	ptr -18h
s_err		= dword	ptr -14h
result		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+str], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+val]
		push	eax
		push	0Ah
		push	0
		push	[ebp+str]
		call	xstrtoul
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 1
		jnz	short loc_800126E
		mov	[ebp+val], 0FFFFFFFFh
		jmp	short loc_80012A9
; ---------------------------------------------------------------------------

loc_800126E:				; CODE XREF: string_to_join_field+3Aj
		cmp	[ebp+s_err], 0
		jnz	short loc_800127B
		mov	eax, [ebp+val]
		test	eax, eax
		jnz	short loc_80012A9

loc_800127B:				; CODE XREF: string_to_join_field+49j
		sub	esp, 0Ch
		push	[ebp+str]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidFieldNu ; "invalid field	number:	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80012A9:				; CODE XREF: string_to_join_field+43j
					; string_to_join_field+50j
		mov	eax, [ebp+val]
		sub	eax, 1
		mov	[ebp+result], eax
		mov	eax, [ebp+result]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_80012C6
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80012C6:				; CODE XREF: string_to_join_field+96j
		mov	ebx, [ebp+var_4]
		leave
		retn
string_to_join_field endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl decode_field_spec(const char *s,	int *file_index, size_t	*field_index)
decode_field_spec proc near		; CODE XREF: add_field_list+59p

var_4		= dword	ptr -4
s		= dword	ptr  8
file_index	= dword	ptr  0Ch
field_index	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 30h
		jz	short loc_80012F4
		cmp	eax, 30h
		jl	loc_80013AD
		cmp	eax, 32h
		jg	loc_80013AD
		jmp	short loc_8001346
; ---------------------------------------------------------------------------

loc_80012F4:				; CODE XREF: decode_field_spec+13j
		mov	eax, [ebp+s]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_800132F
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidFieldSp ; "invalid field	specifier: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800132F:				; CODE XREF: decode_field_spec+34j
		mov	eax, [ebp+file_index]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+field_index]
		mov	dword ptr [eax], 0
		jmp	loc_80013E0
; ---------------------------------------------------------------------------

loc_8001346:				; CODE XREF: decode_field_spec+27j
		mov	eax, [ebp+s]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jz	short loc_8001381
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidFieldSp ; "invalid field	specifier: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001381:				; CODE XREF: decode_field_spec+86j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		lea	edx, [eax-30h]
		mov	eax, [ebp+file_index]
		mov	[eax], edx
		mov	eax, [ebp+s]
		add	eax, 2
		sub	esp, 0Ch
		push	eax		; str
		call	string_to_join_field
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+field_index]
		mov	[eax], edx
		jmp	short loc_80013E0
; ---------------------------------------------------------------------------

loc_80013AD:				; CODE XREF: decode_field_spec+18j
					; decode_field_spec+21j
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidFileNum ; "invalid file number in field spec: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		call	abort
; ---------------------------------------------------------------------------

loc_80013E0:				; CODE XREF: decode_field_spec+76j
					; decode_field_spec+E0j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
decode_field_spec endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_field_list(char *str)
add_field_list	proc near		; CODE XREF: add_file_name+10Dp
					; main+38Ep

str		= dword	ptr -2Ch
file_index	= dword	ptr -1Ch
field_index	= dword	ptr -18h
p		= dword	ptr -14h
spec_item	= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+str], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+str]
		mov	[ebp+p], eax

loc_8001403:				; CODE XREF: add_field_list+78j
		mov	eax, [ebp+p]
		mov	[ebp+spec_item], eax
		sub	esp, 8
		push	offset accept	; ", \t"
		push	[ebp+p]		; s
		call	strpbrk
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jz	short loc_8001431
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	0

loc_8001431:				; CODE XREF: add_field_list+3Dj
		sub	esp, 4
		lea	eax, [ebp+field_index]
		push	eax		; field_index
		lea	eax, [ebp+file_index]
		push	eax		; file_index
		push	[ebp+spec_item]	; s
		call	decode_field_spec
		add	esp, 10h
		mov	edx, [ebp+field_index]
		mov	eax, [ebp+file_index]
		sub	esp, 8
		push	edx		; field
		push	eax		; file
		call	add_field
		add	esp, 10h
		cmp	[ebp+p], 0
		jnz	short loc_8001403
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8001472
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001472:				; CODE XREF: add_field_list+85j
		leave
		retn
add_field_list	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_join_field(size_t *var, size_t val)
set_join_field	proc near		; CODE XREF: add_file_name+CFp
					; add_file_name+FDp ...

var1		= dword	ptr -10h
val1		= dword	ptr -0Ch
var		= dword	ptr  8
val		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+var]
		mov	eax, [eax]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_80014C8
		mov	eax, [ebp+var]
		mov	eax, [eax]
		cmp	eax, [ebp+val]
		jz	short loc_80014C8
		mov	eax, [ebp+var]
		mov	eax, [eax]
		add	eax, 1
		mov	[ebp+var1], eax
		mov	eax, [ebp+val]
		add	eax, 1
		mov	[ebp+val1], eax
		sub	esp, 0Ch
		push	offset aIncompatibleJo ; "incompatible join fields %lu,	%lu"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+val1]
		push	[ebp+var1]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80014C8:				; CODE XREF: set_join_field+Ej
					; set_join_field+18j
		mov	eax, [ebp+var]
		mov	edx, [ebp+val]
		mov	[eax], edx
		nop
		leave
		retn
set_join_field	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_file_name(char *name, char **names, int *operand_status, int	*joption_count,	int *nfiles, int *prev_optc_status, int	*optc_status)
add_file_name	proc near		; CODE XREF: main+4B0p	main+571p

op0		= byte ptr -11h
n		= dword	ptr -10h
arg		= dword	ptr -0Ch
var_4		= dword	ptr -4
name		= dword	ptr  8
names		= dword	ptr  0Ch
operand_status	= dword	ptr  10h
joption_count	= dword	ptr  14h
nfiles		= dword	ptr  18h
prev_optc_status= dword	ptr  1Ch
optc_status	= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+nfiles]
		mov	eax, [eax]
		mov	[ebp+n], eax
		cmp	[ebp+n], 2
		jnz	loc_8001611
		mov	eax, [ebp+operand_status]
		mov	eax, [eax]
		test	eax, eax
		setz	al
		mov	[ebp+op0], al
		movzx	eax, [ebp+op0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+names]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+arg], eax
		movzx	eax, [ebp+op0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand_status]
		add	eax, edx
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_800157E
		cmp	eax, 1
		jg	short loc_8001533
		test	eax, eax
		jz	short loc_8001546
		jmp	loc_80015E9
; ---------------------------------------------------------------------------

loc_8001533:				; CODE XREF: add_file_name+55j
		cmp	eax, 2
		jz	short loc_80015AC
		cmp	eax, 3
		jz	loc_80015DA
		jmp	loc_80015E9
; ---------------------------------------------------------------------------

loc_8001546:				; CODE XREF: add_file_name+59j
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800157E:				; CODE XREF: add_file_name+50j
		mov	eax, [ebp+joption_count]
		mov	eax, [eax]
		lea	edx, [eax-1]
		mov	eax, [ebp+joption_count]
		mov	[eax], edx
		sub	esp, 0Ch
		push	[ebp+arg]	; str
		call	string_to_join_field
		add	esp, 10h
		sub	esp, 8
		push	eax		; val
		push	offset join_field_1 ; var
		call	set_join_field
		add	esp, 10h
		jmp	short loc_80015E9
; ---------------------------------------------------------------------------

loc_80015AC:				; CODE XREF: add_file_name+63j
		mov	eax, [ebp+joption_count]
		add	eax, 4
		mov	edx, [eax]
		sub	edx, 1
		mov	[eax], edx
		sub	esp, 0Ch
		push	[ebp+arg]	; str
		call	string_to_join_field
		add	esp, 10h
		sub	esp, 8
		push	eax		; val
		push	offset join_field_2 ; var
		call	set_join_field
		add	esp, 10h
		jmp	short loc_80015E9
; ---------------------------------------------------------------------------

loc_80015DA:				; CODE XREF: add_file_name+68j
		sub	esp, 0Ch
		push	[ebp+arg]	; str
		call	add_field_list
		add	esp, 10h
		nop

loc_80015E9:				; CODE XREF: add_file_name+5Bj
					; add_file_name+6Ej ...
		movzx	eax, [ebp+op0]
		xor	eax, 1
		test	al, al
		jz	short loc_800160A
		mov	eax, [ebp+operand_status]
		mov	edx, [eax+4]
		mov	eax, [ebp+operand_status]
		mov	[eax], edx
		mov	eax, [ebp+names]
		mov	edx, [eax+4]
		mov	eax, [ebp+names]
		mov	[eax], edx

loc_800160A:				; CODE XREF: add_file_name+11Fj
		mov	[ebp+n], 1

loc_8001611:				; CODE XREF: add_file_name+13j
		mov	eax, [ebp+n]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand_status]
		add	edx, eax
		mov	eax, [ebp+prev_optc_status]
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+n]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+names]
		add	edx, eax
		mov	eax, [ebp+name]
		mov	[edx], eax
		mov	eax, [ebp+n]
		lea	edx, [eax+1]
		mov	eax, [ebp+nfiles]
		mov	[eax], edx
		mov	eax, [ebp+prev_optc_status]
		mov	eax, [eax]
		cmp	eax, 3
		jnz	short loc_8001659
		mov	eax, [ebp+optc_status]
		mov	dword ptr [eax], 3

loc_8001659:				; CODE XREF: add_file_name+17Bj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
add_file_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -5Ch
newtab		= byte ptr -56h
is_j2		= byte ptr -55h
optc_status	= dword	ptr -54h
prev_optc_status= dword	ptr -50h
nfiles		= dword	ptr -4Ch
val		= dword	ptr -48h
i		= dword	ptr -44h
optc		= dword	ptr -40h
fp1		= dword	ptr -3Ch
fp2		= dword	ptr -38h
operand_status	= dword	ptr -34h
joption_count	= dword	ptr -2Ch
names		= dword	ptr -24h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 5Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+prev_optc_status],	0
		mov	[ebp+joption_count], 0
		mov	[ebp+joption_count+4], 0
		mov	[ebp+nfiles], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	3
		call	hard_locale
		add	esp, 10h
		mov	ds:hard_LC_COLLATE, al
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		sub	esp, 0Ch
		push	offset free_spareline ;	func
		call	atexit
		add	esp, 10h
		mov	ds:print_pairables, 1
		mov	ds:seen_unpairable, 0
		mov	ds:issued_disorder_warning+1, 0
		movzx	eax, ds:issued_disorder_warning+1
		mov	ds:issued_disorder_warning, al
		mov	ds:check_input_order, 0
		jmp	loc_8001B66
; ---------------------------------------------------------------------------

loc_800174B:				; CODE XREF: main+52Aj
		mov	[ebp+optc_status], 0
		mov	eax, [ebp+optc]
		cmp	eax, 65h
		jz	loc_800187F
		cmp	eax, 65h
		jg	short loc_80017A8
		cmp	eax, 1
		jz	loc_8001AEE
		cmp	eax, 1
		jg	short loc_800178C
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8001B23
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8001B19
		jmp	loc_8001B56
; ---------------------------------------------------------------------------

loc_800178C:				; CODE XREF: main+110j
		cmp	eax, 32h
		jz	loc_8001906
		cmp	eax, 61h
		jz	short loc_80017FC
		cmp	eax, 31h
		jz	loc_80018DF
		jmp	loc_8001B56
; ---------------------------------------------------------------------------

loc_80017A8:				; CODE XREF: main+102j
		cmp	eax, 74h
		jz	loc_8001A01
		cmp	eax, 74h
		jg	short loc_80017D6
		cmp	eax, 6Ah
		jz	loc_800192D
		cmp	eax, 6Fh
		jz	loc_80019E4
		cmp	eax, 69h
		jz	loc_80018D3
		jmp	loc_8001B56
; ---------------------------------------------------------------------------

loc_80017D6:				; CODE XREF: main+155j
		cmp	eax, 80h
		jz	loc_8001AE2
		cmp	eax, 81h
		jz	loc_8001AD6
		cmp	eax, 76h
		jnz	loc_8001B56
		mov	ds:print_pairables, 0

loc_80017FC:				; CODE XREF: main+139j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+val]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_800182E
		mov	eax, [ebp+val]
		cmp	eax, 1
		jz	short loc_800185F
		mov	eax, [ebp+val]
		cmp	eax, 2
		jz	short loc_800185F

loc_800182E:				; CODE XREF: main+1BDj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidFieldNu ; "invalid field	number:	%s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800185F:				; CODE XREF: main+1C5j	main+1CDj
		mov	eax, [ebp+val]
		cmp	eax, 1
		jnz	short loc_8001873
		mov	ds:print_unpairables_1,	1
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_8001873:				; CODE XREF: main+206j
		mov	ds:print_unpairables_2,	1
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_800187F:				; CODE XREF: main+F9j
		mov	eax, ds:empty_filler
		test	eax, eax
		jz	short loc_80018C4
		mov	edx, ds:optarg
		mov	eax, ds:empty_filler
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80018C4
		sub	esp, 0Ch
		push	offset aConflictingEmp ; "conflicting empty-field replacement str"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80018C4:				; CODE XREF: main+227j	main+243j
		mov	eax, ds:optarg
		mov	ds:empty_filler, eax
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_80018D3:				; CODE XREF: main+16Cj
		mov	ds:ignore_case,	1
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_80018DF:				; CODE XREF: main+13Ej
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; str
		call	string_to_join_field
		add	esp, 10h
		sub	esp, 8
		push	eax		; val
		push	offset join_field_1 ; var
		call	set_join_field
		add	esp, 10h
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_8001906:				; CODE XREF: main+130j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; str
		call	string_to_join_field
		add	esp, 10h
		sub	esp, 8
		push	eax		; val
		push	offset join_field_2 ; var
		call	set_join_field
		add	esp, 10h
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_800192D:				; CODE XREF: main+15Aj
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 31h
		jz	short loc_8001945
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 32h
		jnz	short loc_80019A7

loc_8001945:				; CODE XREF: main+2D8j
		mov	eax, ds:optarg
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80019A7
		mov	eax, ds:optind
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		lea	edx, [eax+2]
		mov	eax, ds:optarg
		cmp	edx, eax
		jnz	short loc_80019A7
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 32h
		setz	al
		mov	[ebp+is_j2], al
		movzx	eax, [ebp+is_j2]
		mov	edx, [ebp+eax*4+joption_count]
		add	edx, 1
		mov	[ebp+eax*4+joption_count], edx
		movzx	eax, [ebp+is_j2]
		add	eax, 1
		mov	[ebp+optc_status], eax
		nop
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_80019A7:				; CODE XREF: main+2E4j	main+2F3j ...
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; str
		call	string_to_join_field
		add	esp, 10h
		sub	esp, 8
		push	eax		; val
		push	offset join_field_1 ; var
		call	set_join_field
		add	esp, 10h
		mov	eax, join_field_1
		sub	esp, 8
		push	eax		; val
		push	offset join_field_2 ; var
		call	set_join_field
		add	esp, 10h
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_80019E4:				; CODE XREF: main+163j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; str
		call	add_field_list
		add	esp, 10h
		mov	[ebp+optc_status], 3
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_8001A01:				; CODE XREF: main+14Cj
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		mov	[ebp+newtab], al
		cmp	[ebp+newtab], 0
		jnz	short loc_8001A32
		sub	esp, 0Ch
		push	offset aEmptyTab ; "empty tab"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001A32:				; CODE XREF: main+3B1j
		mov	eax, ds:optarg
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001A92
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset a0	; "\\0"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A61
		mov	[ebp+newtab], 0
		jmp	short loc_8001A92
; ---------------------------------------------------------------------------

loc_8001A61:				; CODE XREF: main+3FAj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aMultiCharacter ; "multi-character tab %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001A92:				; CODE XREF: main+3E0j	main+400j
		mov	eax, tab
		test	eax, eax
		js	short loc_8001AC8
		movzx	edx, [ebp+newtab]
		mov	eax, tab
		cmp	edx, eax
		jz	short loc_8001AC8
		sub	esp, 0Ch
		push	offset aIncompatibleTa ; "incompatible tabs"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001AC8:				; CODE XREF: main+43Aj	main+447j
		movzx	eax, [ebp+newtab]
		mov	tab, eax
		jmp	loc_8001B60
; ---------------------------------------------------------------------------

loc_8001AD6:				; CODE XREF: main+187j
		mov	ds:check_input_order, 2
		jmp	short loc_8001B60
; ---------------------------------------------------------------------------

loc_8001AE2:				; CODE XREF: main+17Cj
		mov	ds:check_input_order, 1
		jmp	short loc_8001B60
; ---------------------------------------------------------------------------

loc_8001AEE:				; CODE XREF: main+107j
		mov	eax, ds:optarg
		sub	esp, 4
		lea	edx, [ebp+optc_status]
		push	edx		; optc_status
		lea	edx, [ebp+prev_optc_status]
		push	edx		; prev_optc_status
		lea	edx, [ebp+nfiles]
		push	edx		; nfiles
		lea	edx, [ebp+joption_count]
		push	edx		; joption_count
		lea	edx, [ebp+operand_status]
		push	edx		; operand_status
		lea	edx, [ebp+names]
		push	edx		; names
		push	eax		; name
		call	add_file_name
		add	esp, 20h
		jmp	short loc_8001B60
; ---------------------------------------------------------------------------

loc_8001B19:				; CODE XREF: main+122j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001B23:				; CODE XREF: main+117j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aMikeHaertel ; "Mike Haertel"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aJoin	; "join"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001B56:				; CODE XREF: main+128j	main+144j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001B60:				; CODE XREF: main+20Fj	main+21Bj ...
		mov	eax, [ebp+optc_status]
		mov	[ebp+prev_optc_status],	eax

loc_8001B66:				; CODE XREF: main+E7j
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "-a:e:i1:2:j:o:t:v:"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_800174B
		mov	[ebp+prev_optc_status],	0
		jmp	short loc_8001BD8
; ---------------------------------------------------------------------------

loc_8001B98:				; CODE XREF: main+580j
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		lea	edx, [ebp+optc_status]
		push	edx		; optc_status
		lea	edx, [ebp+prev_optc_status]
		push	edx		; prev_optc_status
		lea	edx, [ebp+nfiles]
		push	edx		; nfiles
		lea	edx, [ebp+joption_count]
		push	edx		; joption_count
		lea	edx, [ebp+operand_status]
		push	edx		; operand_status
		lea	edx, [ebp+names]
		push	edx		; names
		push	eax		; name
		call	add_file_name
		add	esp, 20h

loc_8001BD8:				; CODE XREF: main+537j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_8001B98
		mov	eax, [ebp+nfiles]
		cmp	eax, 2
		jz	short loc_8001C5D
		mov	eax, [ebp+nfiles]
		test	eax, eax
		jnz	short loc_8001C12
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001C53
; ---------------------------------------------------------------------------

loc_8001C12:				; CODE XREF: main+58Fj
		mov	eax, [ebx]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingOpera_0 ; "missing operand after	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001C53:				; CODE XREF: main+5B1j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001C5D:				; CODE XREF: main+588j
		mov	[ebp+i], 0
		jmp	short loc_8001C9D
; ---------------------------------------------------------------------------

loc_8001C66:				; CODE XREF: main+642j
		mov	eax, [ebp+i]
		mov	eax, [ebp+eax*4+joption_count]
		test	eax, eax
		jz	short loc_8001C99
		mov	eax, [ebp+i]
		sub	esp, 8
		push	eax		; val
		push	offset join_field_1 ; var
		call	set_join_field
		add	esp, 10h
		mov	eax, [ebp+i]
		sub	esp, 8
		push	eax		; val
		push	offset join_field_2 ; var
		call	set_join_field
		add	esp, 10h

loc_8001C99:				; CODE XREF: main+610j
		add	[ebp+i], 1

loc_8001C9D:				; CODE XREF: main+605j
		cmp	[ebp+i], 1
		jle	short loc_8001C66
		mov	eax, join_field_1
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001CB7
		mov	join_field_1, 0

loc_8001CB7:				; CODE XREF: main+64Cj
		mov	eax, join_field_2
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001CCB
		mov	join_field_2, 0

loc_8001CCB:				; CODE XREF: main+660j
		mov	eax, [ebp+names]
		sub	esp, 8
		push	offset asc_80029A0 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001CF9
		mov	eax, [ebp+names]
		sub	esp, 8
		push	offset aR	; "r"
		push	eax
		call	fopen_safer
		add	esp, 10h
		jmp	short loc_8001CFE
; ---------------------------------------------------------------------------

loc_8001CF9:				; CODE XREF: main+682j
		mov	eax, ds:stdin

loc_8001CFE:				; CODE XREF: main+698j
		mov	[ebp+fp1], eax
		cmp	[ebp+fp1], 0
		jnz	short loc_8001D22
		mov	ebx, [ebp+names]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D22:				; CODE XREF: main+6A6j
		mov	eax, [ebp+names+4]
		sub	esp, 8
		push	offset asc_80029A0 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001D50
		mov	eax, [ebp+names+4]
		sub	esp, 8
		push	offset aR	; "r"
		push	eax
		call	fopen_safer
		add	esp, 10h
		jmp	short loc_8001D55
; ---------------------------------------------------------------------------

loc_8001D50:				; CODE XREF: main+6D9j
		mov	eax, ds:stdin

loc_8001D55:				; CODE XREF: main+6EFj
		mov	[ebp+fp2], eax
		cmp	[ebp+fp2], 0
		jnz	short loc_8001D79
		mov	ebx, [ebp+names+4]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D79:				; CODE XREF: main+6FDj
		mov	eax, [ebp+fp1]
		cmp	eax, [ebp+fp2]
		jnz	short loc_8001DA9
		sub	esp, 0Ch
		push	offset aBothFilesCanno ; "both files cannot be standard	input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001DA9:				; CODE XREF: main+720j
		sub	esp, 8
		push	[ebp+fp2]	; fp2
		push	[ebp+fp1]	; fp1
		call	system_join
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+fp1]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001DE7
		mov	ebx, [ebp+names]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001DE7:				; CODE XREF: main+76Bj
		sub	esp, 0Ch
		push	[ebp+fp2]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001E14
		mov	ebx, [ebp+names+4]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001E14:				; CODE XREF: main+798j
		movzx	eax, ds:issued_disorder_warning
		test	al, al
		jnz	short loc_8001E2A
		movzx	eax, ds:issued_disorder_warning+1
		test	al, al
		jz	short loc_8001E34

loc_8001E2A:				; CODE XREF: main+7BEj
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001E34:				; CODE XREF: main+7C9j
		sub	esp, 0Ch
		push	0		; status

loc_8001E39:				; DATA XREF: .eh_frame:080029F8o
					; .eh_frame:08002A18o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 8001E40h
; size_t join_field_1
join_field_1	dd 0FFFFFFFFh		; DATA XREF: check_order+43r
					; prjoin+5Er ...
; size_t join_field_2
join_field_2	dd 0FFFFFFFFh		; DATA XREF: check_order:loc_800066Cr
					; prjoin+4Er ...
; outlist *outlist_end
outlist_end	dd offset outlist_head	; DATA XREF: add_field+81r
					; add_field+8Fw
; int tab
tab		dd 0FFFFFFFFh		; DATA XREF: xfields+2Dr xfields+69r ...
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8001E50h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; line *prevline[2]
prevline	dd 2 dup(?)		; DATA XREF: get_line+15r get_line+ECr ...
; line *spareline[2]
spareline	dd 2 dup(?)		; DATA XREF: get_line+2Dr get_line+40w ...
; _Bool	hard_LC_COLLATE
hard_LC_COLLATE	db ?			; DATA XREF: keycmp:loc_80005B9r
					; main+97w
; _Bool	print_unpairables_1
print_unpairables_1 db ?		; DATA XREF: system_join+AEr
					; system_join:loc_8001008r ...
; _Bool	print_unpairables_2
print_unpairables_2 db ?		; DATA XREF: system_join+F4r
					; system_join:loc_80010A2r ...
; _Bool	print_pairables
print_pairables	db ?			; DATA XREF: system_join:loc_8000EC2r
					; main+BCw ...
; _Bool	seen_unpairable
seen_unpairable	db ?			; DATA XREF: check_order+1Er
					; system_join+E2w ...
; _Bool	issued_disorder_warning[2]
issued_disorder_warning	db 2 dup(?)	; DATA XREF: check_order+2Fr
					; check_order+9Fw ...
		align 4
; const	char *empty_filler
empty_filler	dd ?			; DATA XREF: prfield:loc_8000A78r
					; prfield+61r ...
; outlist outlist_head
outlist_head	outlist	<?>		; DATA XREF: .data:outlist_endo
					; prjoin+1Er
; $777E6CB8FEE56A4B24BB97DACA1BB4F3 check_input_order
check_input_order dd ?			; DATA XREF: check_order+6r
					; check_order+14r ...
; line uni_blank
uni_blank	line <?>		; DATA XREF: prjoin+3Fo
					; prjoin:loc_8000B8Do ...
; _Bool	ignore_case
ignore_case	db ?			; DATA XREF: keycmp:loc_800058Dr
					; main:loc_80018D3w
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8001EA0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+6Do ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+4DAo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aIgnoreCase	db 'ignore-case',0      ; DATA XREF: .rodata:longoptso
aCheckOrder	db 'check-order',0      ; DATA XREF: .rodata:longoptso
aNocheckOrder	db 'nocheck-order',0    ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 10h
; const	option longopts[6]
longopts	option <offset aIgnoreCase, 0, 0, 69h> ; DATA XREF: main+50Co
		option <offset aCheckOrder, 0, 0, 80h> ; "ignore-case"
		option <offset aNocheckOrder, 0, 0, 81h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... FILE1 FILE2',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aForEachPairOfI[]
aForEachPairOfI	db 'For each pair of input lines with identical join fields, write a '
					; DATA XREF: usage+69o
		db 'line to',0Ah
		db 'standard output.  The default join field is the first, delimited',0Ah
		db 'by whitespace.  When FILE1 or FILE2 (not both) is -, read standar'
		db 'd input.',0Ah
		db 0Ah
		db '  -a FILENUM        print unpairable lines coming from file FILEN'
		db 'UM, where',0Ah
		db '                      FILENUM is 1 or 2, corresponding to FILE1 o'
		db 'r FILE2',0Ah
		db '  -e EMPTY          replace missing input fields with EMPTY',0Ah,0
		align 4
; char aIIgnoreCaseIgn[]
aIIgnoreCaseIgn	db '  -i, --ignore-case  ignore differences in case when comparing fi'
					; DATA XREF: usage+8Co
		db 'elds',0Ah
		db '  -j FIELD          equivalent to `-1 FIELD -2 FIELD',27h,0Ah
		db '  -o FORMAT         obey FORMAT while constructing output line',0Ah
		db '  -t CHAR           use CHAR as input and output field separator',0Ah
		db 0
		align 4
; char aVFilenumLikeAF[]
aVFilenumLikeAF	db '  -v FILENUM        like -a FILENUM, but suppress joined output l'
					; DATA XREF: usage+AFo
		db 'ines',0Ah
		db '  -1 FIELD          join on this FIELD of file 1',0Ah
		db '  -2 FIELD          join on this FIELD of file 2',0Ah
		db '  --check-order     check that the input is correctly sorted, eve'
		db 'n',0Ah
		db '                      if all input lines are pairable',0Ah
		db '  --nocheck-order   do not check that the input is correctly sort'
		db 'ed',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+F5o
		align 4
; char aUnlessTCharIsG[]
aUnlessTCharIsG	db 0Ah			; DATA XREF: usage+118o
		db 'Unless -t CHAR is given, leading blanks separate fields and are i'
		db 'gnored,',0Ah
		db 'else fields are separated by CHAR.  Any FIELD is a field number c'
		db 'ounted',0Ah
		db 'from 1.  FORMAT is one or more comma or blank separated specifica'
		db 'tions,',0Ah
		db 'each being `FILENUM.FIELD',27h,' or `0',27h,'.  Default FORMAT outputs '
		db 'the join field,',0Ah
		db 'the remaining fields from FILE1, the remaining fields from FILE2,'
		db ' all',0Ah
		db 'separated by CHAR.',0Ah
		db 0Ah
		db 'Important: FILE1 and FILE2 must be sorted on the join fields.',0Ah
		db 'E.g., use `sort -k 1b,1',27h,' if `join',27h,' has no options.',0Ah
		db 'Note, comparisons honor the rules specified by `LC_COLLATE',27h,'.',0Ah
		db 'If the input is not sorted and some lines cannot be joined, a',0Ah
		db 'warning message will be given.',0Ah,0
		align 10h
; char aFileDIsNotInSo[]
aFileDIsNotInSo	db 'file %d is not in sorted order',0 ; DATA XREF: check_order+6Do
; char aReadError[]
aReadError	db 'read error',0       ; DATA XREF: get_line+9Eo
; char file[]
file		db 'join.c',0           ; DATA XREF: add_field+22o
					; add_field+47o
		align 4
; char assertion[]
assertion	db 'file == 0 || file == 1 || file == 2',0 ; DATA XREF: add_field+27o
; char aFile0Field0[]
aFile0Field0	db 'file != 0 || field == 0',0 ; DATA XREF: add_field+4Co
; char locale
locale		db 0			; DATA XREF: string_to_join_field+1Bo
					; main+56o ...
; char aInvalidFieldNu[]
aInvalidFieldNu	db 'invalid field number: %s',0 ; DATA XREF: string_to_join_field+65o
					; main+1E5o
; char aInvalidFieldSp[]
aInvalidFieldSp	db 'invalid field specifier: %s',0 ; DATA XREF: decode_field_spec+49o
					; decode_field_spec+9Bo
		align 4
; char aInvalidFileNum[]
aInvalidFileNum	db 'invalid file number in field spec: %s',0
					; DATA XREF: decode_field_spec+F5o
; char accept[]
accept		db ', ',9,0             ; DATA XREF: add_field_list+26o
		align 4
; char aIncompatibleJo[]
aIncompatibleJo	db 'incompatible join fields %lu, %lu',0 ; DATA XREF: set_join_field+31o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: add_file_name+86o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+68o
		align 10h
; char aConflictingEmp[]
aConflictingEmp	db 'conflicting empty-field replacement strings',0 ; DATA XREF: main+248o
; char aEmptyTab[]
aEmptyTab	db 'empty tab',0        ; DATA XREF: main+3B6o
; char a0[]
a0		db '\0',0               ; DATA XREF: main+3EAo
; char aMultiCharacter[]
aMultiCharacter	db 'multi-character tab %s',0 ; DATA XREF: main+418o
; char aIncompatibleTa[]
aIncompatibleTa	db 'incompatible tabs',0 ; DATA XREF: main+44Co
aMikeHaertel	db 'Mike Haertel',0     ; DATA XREF: main+4D4o
aJoin		db 'join',0             ; DATA XREF: main+4DFo
; char shortopts[]
shortopts	db '-a:e:i1:2:j:o:t:v:',0 ; DATA XREF: main+511o
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+594o
; char aMissingOpera_0[]
aMissingOpera_0	db 'missing operand after %s',0 ; DATA XREF: main+5D9o
; char asc_80029A0[]
asc_80029A0	db '-',0                ; DATA XREF: main+672o main+6C9o
aR		db 'r',0                ; DATA XREF: main+68Ao main+6E1o
; char format[]
format		db '%s',0               ; DATA XREF: main+6B3o main+70Ao ...
		align 4
; char aBothFilesCanno[]
aBothFilesCanno	db 'both files cannot be standard input',0 ; DATA XREF: main+725o
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5404[10]
__PRETTY_FUNCTION___5404 db 'add_field',0 ; DATA XREF: add_field+18o
					; add_field+3Do
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80029D8h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8001E39-8004831h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8001E39-800483Fh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	60h
		dd offset loc_8001E39-8004747h
		dd 142h, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_8001E39-8004621h
		dd 78h,	80E4100h, 0D420285h, 0C5740205h, 4040Ch, 20h, 9Ch
		dd offset loc_8001E39-80045C9h
		dd 1B4h, 80E4100h, 0D420285h, 3834405h,	0C501AC03h, 4040CC3h
		dd 1Ch,	0C0h
		dd offset loc_8001E39-8004439h
		dd 37h,	80E4100h, 0D420285h, 0CC57305h,	404h, 1Ch, 0E0h
		dd offset loc_8001E39-8004422h
		dd 14Fh, 80E4100h, 0D420285h, 14B0305h,	4040CC5h, 1Ch
		dd 100h
		dd offset loc_8001E39-80042F3h
		dd 0A9h, 80E4100h, 0D420285h, 0C5A50205h, 4040Ch, 1Ch
		dd 120h
		dd offset loc_8001E39-800426Ah
		dd 10h,	80E4100h, 0D420285h, 0CC54C05h,	404h, 1Ch, 140h
		dd offset loc_8001E39-800427Ah
		dd 35h,	80E4100h, 0D420285h, 0CC57105h,	404h, 20h, 160h
		dd offset loc_8001E39-8004265h
		dd 130h, 80E4100h, 0D420285h, 3834405h,	0C5012803h, 4040CC3h
		dd 1Ch,	184h
		dd offset loc_8001E39-8004159h
		dd 56h,	80E4100h, 0D420285h, 0C5520205h, 4040Ch, 1Ch, 1A4h
		dd offset loc_8001E39-8004123h
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 1Ch, 1C4h
		dd offset loc_8001E39-8004120h
		dd 0A6h, 80E4100h, 0D420285h, 0C5A20205h, 4040Ch, 1Ch
		dd 1E4h
		dd offset loc_8001E39-800409Ah
		dd 31h,	80E4100h, 0D420285h, 0CC56D05h,	404h, 1Ch, 204h
		dd offset loc_8001E39-8004089h
		dd 96h,	80E4100h, 0D420285h, 0C5920205h, 4040Ch, 1Ch, 224h
		dd offset loc_8001E39-8004013h
		dd 99h,	80E4100h, 0D420285h, 0C5950205h, 4040Ch, 1Ch, 244h
		dd offset loc_8001E39-8003F9Ah
		dd 20Dh, 80E4100h, 0D420285h, 2090305h,	4040CC5h, 28h
		dd 264h
		dd offset loc_8001E39-8003DADh
		dd 4C6h, 80E4100h, 0D420285h, 3864505h,	0BB030483h, 0C641C304h
		dd 40CC541h, 4,	1Ch, 290h
		dd offset loc_8001E39-8003913h
		dd 97h,	80E4100h, 0D420285h, 0C5930205h, 4040Ch, 20h, 2B0h
		dd offset loc_8001E39-800389Ch
		dd 0A2h, 80E4100h, 0D420285h, 3834405h,	0C3C59A02h, 4040Ch
		dd 20h,	2D4h
		dd offset loc_8001E39-800381Eh
		dd 11Bh, 80E4100h, 0D420285h, 3834405h,	0C5011303h, 4040CC3h
		dd 1Ch,	2F8h
		dd offset loc_8001E39-8003727h
		dd 8Eh,	80E4100h, 0D420285h, 0C58A0205h, 4040Ch, 1Ch, 318h
		dd offset loc_8001E39-80036B9h
		dd 5Fh,	80E4100h, 0D420285h, 0C55B0205h, 4040Ch, 20h, 338h
		dd offset loc_8001E39-800367Ah
		dd 18Ch, 80E4100h, 0D420285h, 3834405h,	0C5018403h, 4040CC3h
		dd 28h,	35Ch
		dd offset loc_8001E39-8003512h
		dd 7DFh, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+5Dp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+13Dp main+4F2p ...
		extrn x2nrealloc:near	; CODE XREF: extract_field+29p
					; getseq+28p
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: xfields+76p
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: xfields:loc_8000384p
					; xfields+E3p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: freeline+10p freeline+22p ...
		extrn memcasecmp:near	; CODE XREF: keycmp+D9p
		extrn xmemcoll:near	; CODE XREF: keycmp+FDp
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: keycmp+11Bp
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: check_order+91p
					; get_line+BBp	...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: init_linep+Bp
					; system_join+24p ...
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: init_linep+20p
		extrn readlinebuffer:near ; CODE XREF: get_line+7Dp
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	get_line+8Fp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: get_line+ADp
					; main+6ABp ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	prfield+48p
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: prjoin+AEp prjoin+C1p ...
		extrn __stack_chk_fail:near ; CODE XREF: system_join+4BAp
					; string_to_join_field+98p ...
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: add_field+2Cp
					; add_field+51p
		extrn xstrtoul:near	; CODE XREF: string_to_join_field+2Bp
					; main+1B3p
		extrn quote:near	; CODE XREF: string_to_join_field+58p
					; decode_field_spec+3Cp ...
; void abort(void)
		extrn abort:near	; CODE XREF: decode_field_spec+110p
; char *strpbrk(const char *s, const char *accept)
		extrn strpbrk:near	; CODE XREF: add_field_list+2Ep
		extrn set_program_name:near ; CODE XREF: main+4Bp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+72p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+82p
		extrn hard_locale:near	; CODE XREF: main+8Fp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+9Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+A4p main+B4p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_80017FCr
					; main:loc_800182Er ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+239p	main+3F0p ...
; int optind
		extrn optind:dword	; DATA XREF: main+2F5r
					; main:loc_8001B98r ...
		extrn Version:dword	; DATA XREF: main:loc_8001B23r
		extrn version_etc:near	; CODE XREF: main+4E5p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+51Bp
		extrn fopen_safer:near	; CODE XREF: main+690p	main+6E7p
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main:loc_8001CF9r
					; main:loc_8001D50r
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+761p	main+78Ep


		end
