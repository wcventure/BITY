;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	05548423CDCD8ACBE99922A99E2298C9
; Input	CRC32 :	825BEE41

; File Name   :	D:\coreutils-o\shuf.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'shuf.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+13Fp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+394p	main+3D1p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_800015B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000260
; ---------------------------------------------------------------------------

loc_800015B:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]\n  or:  %s"...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWriteARandomPe ; "Write	a random permutation of	the input"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEEchoTreatEach ; "  -e,	--echo		      treat each "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithNoFileOrWh ; "\nWith no FILE, or when FILE is -, read"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000260:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	input_numbers_option_used(size_t lo_input, size_t hi_input)
input_numbers_option_used proc near	; CODE XREF: main+158p	main+430p ...

lo_input	= dword	ptr  8
hi_input	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		cmp	[ebp+lo_input],	0FFFFFFFFh
		jnz	short loc_800027A
		cmp	[ebp+hi_input],	0
		jz	short loc_8000281

loc_800027A:				; CODE XREF: input_numbers_option_used+7j
		mov	eax, 1
		jmp	short loc_8000286
; ---------------------------------------------------------------------------

loc_8000281:				; CODE XREF: input_numbers_option_used+Dj
		mov	eax, 0

loc_8000286:				; CODE XREF: input_numbers_option_used+14j
		and	eax, 1
		pop	ebp
		retn
input_numbers_option_used endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl input_from_argv(char **operand, int n_operands, char eolbyte)
input_from_argv	proc near		; CODE XREF: main+46Ap

eolbyte		= byte ptr -1Ch
p		= dword	ptr -18h
size		= dword	ptr -14h
i		= dword	ptr -10h
p1		= dword	ptr -0Ch
operand		= dword	ptr  8
n_operands	= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_8]
		mov	[ebp+eolbyte], al
		mov	eax, [ebp+n_operands]
		mov	[ebp+size], eax
		mov	[ebp+i], 0
		jmp	short loc_80002CA
; ---------------------------------------------------------------------------

loc_80002A6:				; CODE XREF: input_from_argv+45j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	[ebp+size], eax
		add	[ebp+i], 1

loc_80002CA:				; CODE XREF: input_from_argv+19j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_operands]
		jl	short loc_80002A6
		sub	esp, 0Ch
		push	[ebp+size]	; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		mov	[ebp+i], 0
		jmp	short loc_800033C
; ---------------------------------------------------------------------------

loc_80002EC:				; CODE XREF: input_from_argv+B7j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	[ebp+p]
		call	stpcpy
		add	esp, 10h
		mov	[ebp+p1], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand]
		add	edx, eax
		mov	eax, [ebp+p]
		mov	[edx], eax
		mov	eax, [ebp+p1]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	edx, [ebp+eolbyte]
		mov	[eax], dl
		add	[ebp+i], 1

loc_800033C:				; CODE XREF: input_from_argv+5Fj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_operands]
		jl	short loc_80002EC
		mov	eax, [ebp+n_operands]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+operand]
		add	edx, eax
		mov	eax, [ebp+p]
		mov	[edx], eax
		nop
		leave
		retn
input_from_argv	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	next_line(char *line, char eolbyte, size_t n)
next_line	proc near		; CODE XREF: read_input+29Fp
					; read_input+346p

eolbyte		= byte ptr -1Ch
p		= dword	ptr -0Ch
line		= dword	ptr  8
arg_4		= dword	ptr  0Ch
n		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+eolbyte], al
		movsx	eax, [ebp+eolbyte]
		sub	esp, 4
		push	[ebp+n]		; n
		push	eax		; c
		push	[ebp+line]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		add	eax, 1
		leave
		retn
next_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl read_input(FILE *in, char eolbyte, char ***pline)
read_input	proc near		; CODE XREF: main+5B3p

pline		= dword	ptr -0C4h
eolbyte		= byte ptr -0C0h
in		= dword	ptr -0BCh
p		= dword	ptr -0B8h
buf		= dword	ptr -0B4h
alloc		= dword	ptr -0B0h
used		= dword	ptr -0ACh
next_alloc	= dword	ptr -0A8h
i		= dword	ptr -0A4h
n_lines		= dword	ptr -0A0h
bytes_to_read	= dword	ptr -9Ch
nread		= dword	ptr -98h
fread_errno	= dword	ptr -94h
lim		= dword	ptr -90h
line		= dword	ptr -8Ch
file_size	= qword	ptr -88h
current_offset	= qword	ptr -80h
remaining_size	= qword	ptr -78h
instat		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0C4h
		mov	eax, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+in], edx
		mov	[ebp+eolbyte], al
		mov	eax, [ebp+arg_8]
		mov	[ebp+pline], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+buf], 0
		mov	[ebp+alloc], 0
		mov	[ebp+used], 0
		mov	[ebp+next_alloc], 2001h
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	fileno
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		lea	eax, [ebp+instat]
		push	eax
		push	edx
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	loc_80004B2
		mov	eax, [ebp+instat.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_80004B2
		mov	eax, dword ptr [ebp+instat.st_size]
		mov	edx, dword ptr [ebp+instat.st_size+4]
		mov	dword ptr [ebp+file_size], eax
		mov	dword ptr [ebp+file_size+4], edx
		sub	esp, 0Ch
		push	[ebp+in]
		call	ftello64
		add	esp, 10h
		mov	dword ptr [ebp+current_offset],	eax
		mov	dword ptr [ebp+current_offset+4], edx
		cmp	dword ptr [ebp+current_offset+4], 0
		js	short loc_80004B2
		mov	eax, dword ptr [ebp+current_offset]
		mov	edx, dword ptr [ebp+current_offset+4]
		cmp	edx, dword ptr [ebp+file_size+4]
		jg	short loc_800047F
		cmp	edx, dword ptr [ebp+file_size+4]
		jl	short loc_800046B
		cmp	eax, dword ptr [ebp+file_size]
		jnb	short loc_800047F

loc_800046B:				; CODE XREF: read_input+D9j
		mov	eax, dword ptr [ebp+file_size]
		mov	edx, dword ptr [ebp+file_size+4]
		sub	eax, dword ptr [ebp+current_offset]
		sbb	edx, dword ptr [ebp+current_offset+4]
		jmp	short loc_8000489
; ---------------------------------------------------------------------------

loc_800047F:				; CODE XREF: read_input+D1j
					; read_input+E1j
		mov	eax, 0
		mov	edx, 0

loc_8000489:				; CODE XREF: read_input+F5j
		mov	dword ptr [ebp+remaining_size],	eax
		mov	dword ptr [ebp+remaining_size+4], edx
		cmp	dword ptr [ebp+remaining_size+4], 0
		js	short loc_80004A6
		cmp	dword ptr [ebp+remaining_size+4], 0
		jg	short loc_80004A1
		cmp	dword ptr [ebp+remaining_size],	0FFFFFFFDh
		jbe	short loc_80004A6

loc_80004A1:				; CODE XREF: read_input+111j
		call	xalloc_die

loc_80004A6:				; CODE XREF: read_input+10Bj
					; read_input+117j
		mov	eax, dword ptr [ebp+remaining_size]
		add	eax, 2
		mov	[ebp+next_alloc], eax

loc_80004B2:				; CODE XREF: read_input+7Dj
					; read_input+90j ...
		mov	eax, [ebp+used]
		add	eax, 1
		cmp	eax, [ebp+alloc]
		jb	short loc_8000520
		cmp	[ebp+alloc], 0FFFFFFFFh
		jnz	short loc_80004D1
		call	xalloc_die

loc_80004D1:				; CODE XREF: read_input+142j
		mov	eax, [ebp+next_alloc]
		mov	[ebp+alloc], eax
		mov	eax, [ebp+alloc]
		add	eax, eax
		mov	[ebp+next_alloc], eax
		mov	eax, [ebp+next_alloc]
		cmp	eax, [ebp+alloc]
		jnb	short loc_8000503
		mov	[ebp+next_alloc], 0FFFFFFFFh

loc_8000503:				; CODE XREF: read_input+16Fj
		sub	esp, 8
		push	[ebp+alloc]	; size_t
		push	[ebp+buf]	; void *
		call	xrealloc
		add	esp, 10h
		mov	[ebp+buf], eax

loc_8000520:				; CODE XREF: read_input+139j
		mov	eax, [ebp+alloc]
		sub	eax, [ebp+used]
		sub	eax, 1
		mov	[ebp+bytes_to_read], eax
		mov	edx, [ebp+buf]
		mov	eax, [ebp+used]
		add	eax, edx
		push	[ebp+in]	; stream
		push	[ebp+bytes_to_read] ; n
		push	1		; size
		push	eax		; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+nread], eax
		mov	eax, [ebp+nread]
		add	[ebp+used], eax
		mov	eax, [ebp+nread]
		cmp	eax, [ebp+bytes_to_read]
		jz	loc_80004B2
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+fread_errno], eax
		cmp	[ebp+used], 0
		jz	short loc_80005D0
		mov	eax, [ebp+used]
		lea	edx, [eax-1]
		mov	eax, [ebp+buf]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+eolbyte]
		jz	short loc_80005D0
		mov	eax, [ebp+used]
		lea	edx, [eax+1]
		mov	[ebp+used], edx
		mov	edx, [ebp+buf]
		add	edx, eax
		movzx	eax, [ebp+eolbyte]
		mov	[edx], al

loc_80005D0:				; CODE XREF: read_input+20Aj
					; read_input+226j
		mov	edx, [ebp+buf]
		mov	eax, [ebp+used]
		add	eax, edx
		mov	[ebp+lim], eax
		mov	[ebp+n_lines], 0
		mov	eax, [ebp+buf]
		mov	[ebp+p], eax
		jmp	short loc_8000635
; ---------------------------------------------------------------------------

loc_80005FC:				; CODE XREF: read_input+2B9j
		add	[ebp+n_lines], 1
		mov	edx, [ebp+lim]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		movsx	eax, [ebp+eolbyte]
		sub	esp, 4
		push	edx		; n
		push	eax		; eolbyte
		push	[ebp+p]		; line
		call	next_line
		add	esp, 10h
		mov	[ebp+p], eax

loc_8000635:				; CODE XREF: read_input+272j
		mov	eax, [ebp+p]
		cmp	eax, [ebp+lim]
		jb	short loc_80005FC
		mov	eax, [ebp+n_lines]
		add	eax, 1
		sub	esp, 8
		push	4
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+line], eax
		mov	eax, [ebp+pline]
		mov	edx, [ebp+line]
		mov	[eax], edx
		mov	eax, [ebp+buf]
		mov	[ebp+p], eax
		mov	eax, [ebp+line]
		mov	edx, [ebp+p]
		mov	[eax], edx
		mov	[ebp+i], 1
		jmp	short loc_80006EB
; ---------------------------------------------------------------------------

loc_8000694:				; CODE XREF: read_input+36Fj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+line]
		lea	ebx, [edx+eax]
		mov	edx, [ebp+lim]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		movsx	eax, [ebp+eolbyte]
		sub	esp, 4
		push	edx		; n
		push	eax		; eolbyte
		push	[ebp+p]		; line
		call	next_line
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	[ebx], eax
		add	[ebp+i], 1

loc_80006EB:				; CODE XREF: read_input+30Aj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_lines]
		jbe	short loc_8000694
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+fread_errno]
		mov	[edx], eax
		mov	eax, [ebp+n_lines]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800071F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800071F:				; CODE XREF: read_input+390j
		mov	ebx, [ebp+var_4]
		leave
		retn
read_input	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl write_permuted_output(size_t n_lines, char *const	*line, size_t lo_input,	const size_t *permutation, char	eolbyte)
write_permuted_output proc near		; CODE XREF: main+70Dp

eolbyte		= byte ptr -1Ch
i		= dword	ptr -18h
p		= dword	ptr -14h
len		= dword	ptr -10h
n		= dword	ptr -0Ch
n_lines		= dword	ptr  8
line		= dword	ptr  0Ch
lo_input	= dword	ptr  10h
permutation	= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_10]
		mov	[ebp+eolbyte], al
		cmp	[ebp+line], 0
		jz	short loc_80007A9
		mov	[ebp+i], 0
		jmp	short loc_800079F
; ---------------------------------------------------------------------------

loc_800073F:				; CODE XREF: write_permuted_output+81j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+permutation]
		add	eax, edx
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+line]
		add	eax, edx
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		add	eax, 4
		mov	eax, [eax]
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+len], eax
		mov	edx, ds:stdout
		mov	eax, [ebp+p]
		mov	eax, [eax]
		push	edx		; stream
		push	[ebp+len]	; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+len]
		jz	short loc_800079B
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80007FF
; ---------------------------------------------------------------------------

loc_800079B:				; CODE XREF: write_permuted_output+6Ej
		add	[ebp+i], 1

loc_800079F:				; CODE XREF: write_permuted_output+19j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_lines]
		jb	short loc_800073F
		jmp	short loc_80007FA
; ---------------------------------------------------------------------------

loc_80007A9:				; CODE XREF: write_permuted_output+10j
		mov	[ebp+i], 0
		jmp	short loc_80007F2
; ---------------------------------------------------------------------------

loc_80007B2:				; CODE XREF: write_permuted_output+D4j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+permutation]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+lo_input]
		add	eax, edx
		mov	[ebp+n], eax
		movsx	eax, [ebp+eolbyte]
		sub	esp, 4
		push	eax
		push	[ebp+n]
		push	offset format	; "%lu%c"
		call	printf
		add	esp, 10h
		test	eax, eax
		jns	short loc_80007EE
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80007FF
; ---------------------------------------------------------------------------

loc_80007EE:				; CODE XREF: write_permuted_output+C1j
		add	[ebp+i], 1

loc_80007F2:				; CODE XREF: write_permuted_output+8Cj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_lines]
		jb	short loc_80007B2

loc_80007FA:				; CODE XREF: write_permuted_output+83j
		mov	eax, 0

locret_80007FF:				; CODE XREF: write_permuted_output+75j
					; write_permuted_output+C8j
		leave
		retn
write_permuted_output endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -6Ch
echo		= byte ptr -63h
eolbyte		= byte ptr -62h
invalid		= byte ptr -61h
input_lines	= dword	ptr -60h
argval		= dword	ptr -5Ch
lo_input	= dword	ptr -58h
hi_input	= dword	ptr -54h
head_lines	= dword	ptr -50h
outfile		= dword	ptr -4Ch
random_source	= dword	ptr -48h
n_lines		= dword	ptr -44h
line		= dword	ptr -40h
hi_optarg	= dword	ptr -3Ch
optc		= dword	ptr -38h
p		= dword	ptr -34h
e		= dword	ptr -30h
n_operands	= dword	ptr -2Ch
operand		= dword	ptr -28h
randint_source	= dword	ptr -24h
permutation	= dword	ptr -20h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 6Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+echo], 0
		mov	[ebp+lo_input],	0FFFFFFFFh
		mov	[ebp+hi_input],	0
		mov	[ebp+head_lines], 0FFFFFFFFh
		mov	[ebp+outfile], 0
		mov	[ebp+random_source], 0
		mov	[ebp+eolbyte], 0Ah
		mov	[ebp+input_lines], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_80008B6:				; CODE XREF: main+3F9j
		mov	eax, [ebp+optc]
		cmp	eax, 69h
		jz	short loc_8000921
		cmp	eax, 69h
		jg	short loc_80008E3
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000B90
		cmp	eax, 65h
		jz	short loc_8000918
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000B9A
		jmp	loc_8000BCD
; ---------------------------------------------------------------------------

loc_80008E3:				; CODE XREF: main+C0j
		cmp	eax, 6Fh
		jz	loc_8000AF7
		cmp	eax, 6Fh
		jg	short loc_80008FF
		cmp	eax, 6Eh
		jz	loc_8000A80
		jmp	loc_8000BCD
; ---------------------------------------------------------------------------

loc_80008FF:				; CODE XREF: main+EEj
		cmp	eax, 7Ah
		jz	loc_8000B8A
		cmp	eax, 80h
		jz	loc_8000B42
		jmp	loc_8000BCD
; ---------------------------------------------------------------------------

loc_8000918:				; CODE XREF: main+D0j
		mov	[ebp+echo], 1
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000921:				; CODE XREF: main+BBj
		mov	[ebp+argval], 0
		mov	eax, ds:optarg
		sub	esp, 8
		push	2Dh		; c
		push	eax		; s
		call	strchr
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, ds:optarg
		mov	[ebp+hi_optarg], eax
		cmp	[ebp+p], 0
		setz	al
		mov	[ebp+invalid], al
		sub	esp, 8
		push	[ebp+hi_input]	; hi_input
		push	[ebp+lo_input]	; lo_input
		call	input_numbers_option_used
		add	esp, 10h
		test	al, al
		jz	short loc_8000985
		sub	esp, 0Ch
		push	offset aMultipleIOptio ; "multiple -i options specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000985:				; CODE XREF: main+162j
		cmp	[ebp+p], 0
		jz	short loc_80009D8
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	0
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+argval]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jz	short loc_80009B7
		mov	eax, 1
		jmp	short loc_80009BC
; ---------------------------------------------------------------------------

loc_80009B7:				; CODE XREF: main+1ADj
		mov	eax, 0

loc_80009BC:				; CODE XREF: main+1B4j
		mov	[ebp+invalid], al
		and	[ebp+invalid], 1
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	2Dh
		mov	eax, [ebp+argval]
		mov	[ebp+lo_input],	eax
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+hi_optarg], eax

loc_80009D8:				; CODE XREF: main+188j
		sub	esp, 0Ch
		push	0
		lea	eax, [ebp+argval]
		push	eax
		push	0Ah
		push	0
		push	[ebp+hi_optarg]
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jz	short loc_80009FB
		mov	edx, 1
		jmp	short loc_8000A00
; ---------------------------------------------------------------------------

loc_80009FB:				; CODE XREF: main+1F1j
		mov	edx, 0

loc_8000A00:				; CODE XREF: main+1F8j
		movzx	eax, [ebp+invalid]
		or	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		mov	eax, [ebp+argval]
		mov	[ebp+hi_input],	eax
		mov	eax, [ebp+hi_input]
		sub	eax, [ebp+lo_input]
		add	eax, 1
		mov	[ebp+n_lines], eax
		mov	eax, [ebp+lo_input]
		cmp	eax, [ebp+hi_input]
		setnbe	dl
		cmp	[ebp+n_lines], 0
		setz	al
		xor	eax, edx
		or	al, [ebp+invalid]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		cmp	[ebp+invalid], 0
		jz	loc_8000BD7
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidInputRa ; "invalid input	range %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000A80:				; CODE XREF: main+F3j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+argval]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		mov	[ebp+e], eax
		cmp	[ebp+e], 0
		jnz	short loc_8000AB7
		mov	edx, [ebp+argval]
		mov	eax, [ebp+head_lines]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+head_lines], eax
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000AB7:				; CODE XREF: main+2A1j
		cmp	[ebp+e], 1
		jz	loc_8000BD7
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidLineCou ; "invalid line count %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000AF7:				; CODE XREF: main+E5j
		cmp	[ebp+outfile], 0
		jz	short loc_8000B35
		mov	eax, ds:optarg
		sub	esp, 8
		push	eax		; s2
		push	[ebp+outfile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B35
		sub	esp, 0Ch
		push	offset aMultipleOutput ; "multiple output files	specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B35:				; CODE XREF: main+2FAj	main+312j
		mov	eax, ds:optarg
		mov	[ebp+outfile], eax
		jmp	loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000B42:				; CODE XREF: main+10Cj
		cmp	[ebp+random_source], 0
		jz	short loc_8000B80
		mov	eax, ds:optarg
		sub	esp, 8
		push	eax		; s2
		push	[ebp+random_source] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B80
		sub	esp, 0Ch
		push	offset aMultipleRandom ; "multiple random sources specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B80:				; CODE XREF: main+345j	main+35Dj
		mov	eax, ds:optarg
		mov	[ebp+random_source], eax
		jmp	short loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000B8A:				; CODE XREF: main+101j
		mov	[ebp+eolbyte], 0
		jmp	short loc_8000BD7
; ---------------------------------------------------------------------------

loc_8000B90:				; CODE XREF: main+C7j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000B9A:				; CODE XREF: main+D7j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aPaulEggert ; "Paul Eggert"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aShuf	; "shuf"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000BCD:				; CODE XREF: main+DDj main+F9j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000BD7:				; CODE XREF: main+B0j main+11Bj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_opts ; longopts
		push	offset shortopts ; "ei:n:o:z"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80008B6
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_operands], eax
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	[ebp+operand], eax
		cmp	[ebp+echo], 0
		jz	short loc_8000C84
		sub	esp, 8
		push	[ebp+hi_input]	; hi_input
		push	[ebp+lo_input]	; lo_input
		call	input_numbers_option_used
		add	esp, 10h
		test	al, al
		jz	short loc_8000C5D
		sub	esp, 0Ch
		push	offset aCannotCombineE ; "cannot combine -e and	-i options"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000C5D:				; CODE XREF: main+43Aj
		movsx	eax, [ebp+eolbyte]
		sub	esp, 4
		push	eax		; eolbyte
		push	[ebp+n_operands] ; n_operands
		push	[ebp+operand]	; operand
		call	input_from_argv
		add	esp, 10h
		mov	eax, [ebp+n_operands]
		mov	[ebp+n_lines], eax
		mov	eax, [ebp+operand]
		mov	[ebp+line], eax
		jmp	loc_8000DC5
; ---------------------------------------------------------------------------

loc_8000C84:				; CODE XREF: main+425j
		sub	esp, 8
		push	[ebp+hi_input]	; hi_input
		push	[ebp+lo_input]	; lo_input
		call	input_numbers_option_used
		add	esp, 10h
		test	al, al
		jz	short loc_8000CF2
		cmp	[ebp+n_operands], 0
		jz	short loc_8000CDA
		mov	eax, [ebp+operand]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s\n"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CDA:				; CODE XREF: main+49Cj
		mov	eax, [ebp+hi_input]
		sub	eax, [ebp+lo_input]
		add	eax, 1
		mov	[ebp+n_lines], eax
		mov	[ebp+line], 0
		jmp	loc_8000DC5
; ---------------------------------------------------------------------------

loc_8000CF2:				; CODE XREF: main+496j
		mov	eax, [ebp+n_operands]
		test	eax, eax
		jz	loc_8000D9E
		cmp	eax, 1
		jnz	short loc_8000D60
		mov	eax, [ebp+operand]
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80015EB ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_8000DA1
		mov	edx, ds:stdin
		mov	eax, [ebp+operand]
		mov	eax, [eax]
		sub	esp, 4
		push	edx
		push	offset aR	; "r"
		push	eax
		call	freopen_safer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000DA1
		mov	eax, [ebp+operand]
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000DA1
; ---------------------------------------------------------------------------

loc_8000D60:				; CODE XREF: main+4FFj
		mov	eax, [ebp+operand]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperand_0 ; "extra	operand	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000D9E:				; CODE XREF: main+4F6j
		nop
		jmp	short loc_8000DA2
; ---------------------------------------------------------------------------

loc_8000DA1:				; CODE XREF: main+519j	main+53Ej ...
		nop

loc_8000DA2:				; CODE XREF: main+59Ej
		movsx	edx, [ebp+eolbyte]
		mov	eax, ds:stdin
		sub	esp, 4
		lea	ecx, [ebp+input_lines]
		push	ecx		; pline
		push	edx		; eolbyte
		push	eax		; in
		call	read_input
		add	esp, 10h
		mov	[ebp+n_lines], eax
		mov	eax, [ebp+input_lines]
		mov	[ebp+line], eax

loc_8000DC5:				; CODE XREF: main+47Ej	main+4ECj
		mov	eax, [ebp+head_lines]
		cmp	[ebp+n_lines], eax
		cmovbe	eax, [ebp+n_lines]
		mov	[ebp+head_lines], eax
		sub	esp, 8
		push	[ebp+n_lines]
		push	[ebp+head_lines]
		call	randperm_bound
		add	esp, 10h
		sub	esp, 8
		push	eax
		push	[ebp+random_source]
		call	randint_all_new
		add	esp, 10h
		mov	[ebp+randint_source], eax
		cmp	[ebp+randint_source], 0
		jnz	short loc_8000E23
		sub	esp, 0Ch
		push	[ebp+random_source]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000E23:				; CODE XREF: main+5F8j
		movzx	eax, [ebp+echo]
		xor	eax, 1
		test	al, al
		jz	short loc_8000E98
		sub	esp, 8
		push	[ebp+hi_input]	; hi_input
		push	[ebp+lo_input]	; lo_input
		call	input_numbers_option_used
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000E98
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000E70
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000E98

loc_8000E70:				; CODE XREF: main+658j
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000E98:				; CODE XREF: main+62Bj	main+643j ...
		sub	esp, 4
		push	[ebp+n_lines]
		push	[ebp+head_lines]
		push	[ebp+randint_source]
		call	randperm_new
		add	esp, 10h
		mov	[ebp+permutation], eax
		cmp	[ebp+outfile], 0
		jz	short loc_8000EFA
		mov	eax, ds:stdout
		sub	esp, 4
		push	eax
		push	offset aW	; "w"
		push	[ebp+outfile]
		call	freopen_safer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000EFA
		sub	esp, 0Ch
		push	[ebp+outfile]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000EFA:				; CODE XREF: main+6B2j	main+6CFj
		movsx	eax, [ebp+eolbyte]
		sub	esp, 0Ch
		push	eax		; eolbyte
		push	[ebp+permutation] ; permutation
		push	[ebp+lo_input]	; lo_input
		push	[ebp+line]	; line
		push	[ebp+head_lines] ; n_lines
		call	write_permuted_output
		add	esp, 20h
		test	eax, eax
		jz	short loc_8000F42
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000F42:				; CODE XREF: main+717j
		mov	eax, 0
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8000F58
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000F58:				; CODE XREF: main+750j
		lea	esp, [ebp-0Ch]
		pop	ecx
		pop	ebx
		pop	esi
		pop	ebp
		lea	esp, [ecx-4]

locret_8000F62:				; DATA XREF: .eh_frame:0800163Co
					; .eh_frame:08001660o ...
		retn
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000F80h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+83o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+3AFo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]',0Ah ; DATA XREF: usage+54o
		db '  or:  %s -e [OPTION]... [ARG]...',0Ah
		db '  or:  %s -i LO-HI [OPTION]...',0Ah,0
		align 4
; char aWriteARandomPe[]
aWriteARandomPe	db 'Write a random permutation of the input lines to standard output.'
					; DATA XREF: usage+76o
		db 0Ah
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+99o
		db 'ns too.',0Ah,0
		align 4
; char aEEchoTreatEach[]
aEEchoTreatEach	db '  -e, --echo                treat each ARG as an input line',0Ah
					; DATA XREF: usage+BCo
		db '  -i, --input-range=LO-HI   treat each number LO through HI as an'
		db ' input line',0Ah
		db '  -n, --head-count=COUNT    output at most COUNT lines',0Ah
		db '  -o, --output=FILE         write result to FILE instead of stand'
		db 'ard output',0Ah
		db '      --random-source=FILE  get random bytes from FILE',0Ah
		db '  -z, --zero-terminated     end lines with 0 byte, not newline',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+DFo
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+102o
		align 10h
; char aWithNoFileOrWh[]
aWithNoFileOrWh	db 0Ah			; DATA XREF: usage+125o
		db 'With no FILE, or when FILE is -, read standard input.',0Ah,0
aEcho		db 'echo',0             ; DATA XREF: .rodata:long_optso
aInputRange	db 'input-range',0      ; DATA XREF: .rodata:long_optso
aHeadCount	db 'head-count',0       ; DATA XREF: .rodata:long_optso
aOutput		db 'output',0           ; DATA XREF: .rodata:long_optso
aRandomSource	db 'random-source',0    ; DATA XREF: .rodata:long_optso
aZeroTerminated	db 'zero-terminated',0  ; DATA XREF: .rodata:long_optso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optso
		align 10h
; const	option long_opts[9]
long_opts	option <offset aEcho, 0, 0, 65h> ; DATA	XREF: main+3DBo
		option <offset aInputRange, 1, 0, 69h> ; "echo"
		option <offset aHeadCount, 1, 0, 6Eh>
		option <offset aOutput,	1, 0, 6Fh>
		option <offset aRandomSource, 1, 0, 80h>
		option <offset aZeroTerminated,	0, 0, 7Ah>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char format[]
format		db '%lu%c',0            ; DATA XREF: write_permuted_output+B2o
; char locale
locale		db 0			; DATA XREF: main+6Co
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+7Eo
; char aMultipleIOptio[]
aMultipleIOptio	db 'multiple -i options specified',0 ; DATA XREF: main+167o
; char aInvalidInputRa[]
aInvalidInputRa	db 'invalid input range %s',0 ; DATA XREF: main+25Fo
; char aInvalidLineCou[]
aInvalidLineCou	db 'invalid line count %s',0 ; DATA XREF: main+2D6o
		align 4
; char aMultipleOutput[]
aMultipleOutput	db 'multiple output files specified',0 ; DATA XREF: main+317o
; char aMultipleRandom[]
aMultipleRandom	db 'multiple random sources specified',0 ; DATA XREF: main+362o
aPaulEggert	db 'Paul Eggert',0      ; DATA XREF: main+3A9o
aShuf		db 'shuf',0             ; DATA XREF: main+3B4o
; char shortopts[]
shortopts	db 'ei:n:o:z',0         ; DATA XREF: main+3E0o
; char aCannotCombineE[]
aCannotCombineE	db 'cannot combine -e and -i options',0 ; DATA XREF: main+43Fo
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0Ah,0 ; DATA XREF: main+4B4o
; char asc_80015EB[]
asc_80015EB	db '-',0                ; DATA XREF: main+509o
aR		db 'r',0                ; DATA XREF: main+52Eo
; char aS[]
aS		db '%s',0               ; DATA XREF: main+54Do main+612o ...
; char aExtraOperand_0[]
aExtraOperand_0	db 'extra operand %s',0 ; DATA XREF: main+578o
; char aReadError[]
aReadError	db 'read error',0       ; DATA XREF: main+672o
aW		db 'w',0                ; DATA XREF: main+6BDo
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: main+71Co
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 800161Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset locret_8000F62-800259Eh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset locret_8000F62-80024A6h
		dd 14Fh, 80E4100h, 0D420285h, 3874605h,	5830486h, 1Ch
		dd 60h
		dd offset locret_8000F62-8002377h
		dd 20h,	80E4100h, 0D420285h, 0CC55C05h,	404h, 1Ch, 80h
		dd offset locret_8000F62-8002377h
		dd 0D0h, 80E4100h, 0D420285h, 0C5CC0205h, 4040Ch, 1Ch
		dd 0A0h
		dd offset locret_8000F62-80022C7h
		dd 2Dh,	80E4100h, 0D420285h, 0CC56905h,	404h, 20h, 0C0h
		dd offset locret_8000F62-80022BAh
		dd 39Ch, 80E4100h, 0D420285h, 3834705h,	0C5039103h, 4040CC3h
		dd 1Ch,	0E4h
		dd offset locret_8000F62-8001F42h
		dd 0DDh, 80E4100h, 0D420285h, 0C5D90205h, 4040Ch, 38h
		dd 104h
		dd offset locret_8000F62-8001E85h
		dd 762h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 3787502h, 0CC1074Bh, 0C3410001h, 0C541C641h
		dd 4040C43h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+6Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+88p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+73p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+14Ap main+3C7p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: input_from_argv+30p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: input_from_argv+4Dp
		extrn stpcpy:near	; CODE XREF: input_from_argv+79p
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: next_line+1Ap
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: read_input+61p
		extrn fstat64:near	; CODE XREF: read_input+73p
		extrn ftello64:near	; CODE XREF: read_input+B1p
		extrn xalloc_die:near	; CODE XREF: read_input:loc_80004A1p
					; read_input+144p
; void *xrealloc(void *, size_t)
		extrn xrealloc:near	; CODE XREF: read_input+18Ap
; size_t fread_unlocked(void *ptr, size_t size,	size_t n, FILE *stream)
		extrn fread_unlocked:near ; CODE XREF: read_input+1CAp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: read_input+1F6p
					; read_input+371p ...
		extrn xnmalloc:near	; CODE XREF: read_input+2CAp
		extrn __stack_chk_fail:near ; CODE XREF: read_input+392p
					; main+752p
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	write_permuted_output+63p
		extrn set_program_name:near ; CODE XREF: main+61p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+88p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+98p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+A3o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+A8p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+127r	main+13Dr ...
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: main+132p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+17Cp	main+272p ...
		extrn xstrtoul:near	; CODE XREF: main+1A3p	main+1E7p ...
		extrn quote:near	; CODE XREF: main+252p	main+2C9p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+308p	main+353p ...
		extrn Version:dword	; DATA XREF: main:loc_8000B9Ar
		extrn version_etc:near	; CODE XREF: main+3BAp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+3EAp
; int optind
		extrn optind:dword	; DATA XREF: main+3FFr	main+40Dr
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main+51Fr	main+5A5r ...
		extrn freopen_safer:near ; CODE	XREF: main+534p main+6C5p
		extrn randperm_bound:near ; CODE XREF: main+5DAp
		extrn randint_all_new:near ; CODE XREF:	main+5E9p
		extrn quotearg_colon:near ; CODE XREF: main+600p main+6D7p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	main+64Ep
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+663p
		extrn randperm_new:near	; CODE XREF: main+6A3p


		end
