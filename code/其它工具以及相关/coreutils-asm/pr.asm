;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BC80D65F4307CF9809C5F6019BE1A9E0
; Input	CRC32 :	2A4D255B

; File Name   :	D:\coreutils-o\pr.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'pr.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: print_char+4Ap

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+290p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	bad_cast(const char *s)
bad_cast	proc near		; CODE XREF: main+531p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+s]
		pop	ebp
		retn
bad_cast	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: init_header+73p

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int cols_ready_to_print()
cols_ready_to_print proc near		; CODE XREF: print_page+Cp
					; print_page+12Bp ...

q		= dword	ptr -0Ch
i		= dword	ptr -8
n		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+n], 0
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		mov	[ebp+i], 0
		jmp	short loc_80001AF
; ---------------------------------------------------------------------------

loc_800016F:				; CODE XREF: cols_ready_to_print+66j
		mov	eax, [ebp+q]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_80001A3
		mov	eax, [ebp+q]
		mov	eax, [eax+8]
		cmp	eax, 1
		jz	short loc_80001A3
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_80001A7
		mov	eax, [ebp+q]
		mov	eax, [eax+18h]
		test	eax, eax
		jle	short loc_80001A7
		mov	eax, [ebp+q]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jle	short loc_80001A7

loc_80001A3:				; CODE XREF: cols_ready_to_print+26j
					; cols_ready_to_print+31j
		add	[ebp+n], 1

loc_80001A7:				; CODE XREF: cols_ready_to_print+3Cj
					; cols_ready_to_print+46j ...
		add	[ebp+q], 28h
		add	[ebp+i], 1

loc_80001AF:				; CODE XREF: cols_ready_to_print+1Cj
		mov	eax, columns
		cmp	[ebp+i], eax
		jl	short loc_800016F
		mov	eax, [ebp+n]
		leave
		retn
cols_ready_to_print endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	first_last_page(int oi,	char c,	const char *pages)
first_last_page	proc near		; CODE XREF: main+1A6p	main+218p

pages		= dword	ptr -40h
c		= byte ptr -3Ch
p		= dword	ptr -2Ch
err		= dword	ptr -28h
p1		= dword	ptr -24h
first		= qword	ptr -20h
last		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
oi		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		mov	eax, [ebp+arg_8]
		mov	[ebp+pages], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	dword ptr [ebp+last], 0FFFFFFFFh
		mov	dword ptr [ebp+last+4],	0FFFFFFFFh
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+first]
		push	eax
		push	0Ah
		lea	eax, [ebp+p]
		push	eax
		push	[ebp+pages]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_8000231
		cmp	[ebp+err], 2
		jz	short loc_8000231
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	[ebp+pages]
		push	offset long_options
		push	eax
		push	[ebp+oi]
		push	[ebp+err]
		call	xstrtol_fatal

loc_8000231:				; CODE XREF: first_last_page+50j
					; first_last_page+56j
		mov	eax, [ebp+p]
		cmp	eax, [ebp+pages]
		jz	short loc_8000245
		mov	eax, dword ptr [ebp+first]
		mov	edx, dword ptr [ebp+first+4]
		or	eax, edx
		test	eax, eax
		jnz	short loc_800024F

loc_8000245:				; CODE XREF: first_last_page+79j
		mov	eax, 0
		jmp	loc_8000302
; ---------------------------------------------------------------------------

loc_800024F:				; CODE XREF: first_last_page+85j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 3Ah
		jnz	short loc_80002CA
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+p1], eax
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+last]
		push	eax
		push	0Ah
		lea	eax, [ebp+p]
		push	eax
		push	[ebp+p1]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_80002A3
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	[ebp+pages]
		push	offset long_options
		push	eax
		push	[ebp+oi]
		push	[ebp+err]
		call	xstrtol_fatal

loc_80002A3:				; CODE XREF: first_last_page+C8j
		mov	eax, [ebp+p]
		cmp	[ebp+p1], eax
		jz	short loc_80002C3
		mov	ecx, dword ptr [ebp+last]
		mov	ebx, dword ptr [ebp+last+4]
		mov	eax, dword ptr [ebp+first]
		mov	edx, dword ptr [ebp+first+4]
		cmp	ebx, edx
		ja	short loc_80002CA
		cmp	ebx, edx
		jb	short loc_80002C3
		cmp	ecx, eax
		jnb	short loc_80002CA

loc_80002C3:				; CODE XREF: first_last_page+EBj
					; first_last_page+FFj
		mov	eax, 0
		jmp	short loc_8000302
; ---------------------------------------------------------------------------

loc_80002CA:				; CODE XREF: first_last_page+99j
					; first_last_page+FBj ...
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80002DB
		mov	eax, 0
		jmp	short loc_8000302
; ---------------------------------------------------------------------------

loc_80002DB:				; CODE XREF: first_last_page+114j
		mov	eax, dword ptr [ebp+first]
		mov	edx, dword ptr [ebp+first+4]
		mov	dword ptr ds:first_page_number,	eax
		mov	dword ptr ds:first_page_number+4, edx
		mov	eax, dword ptr [ebp+last]
		mov	edx, dword ptr [ebp+last+4]
		mov	dword ptr last_page_number, eax
		mov	dword ptr last_page_number+4, edx
		mov	eax, 1

loc_8000302:				; CODE XREF: first_last_page+8Cj
					; first_last_page+10Aj	...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000313
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000313:				; CODE XREF: first_last_page+14Ej
		mov	ebx, [ebp+var_4]
		leave
		retn
first_last_page	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl parse_column_count(const	char *s)
parse_column_count proc	near		; CODE XREF: main+26Ap	main+70Cp

s		= dword	ptr -1Ch
tmp_long	= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+tmp_long]
		push	eax
		push	0Ah
		push	0
		push	[ebp+s]
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000356
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jg	short loc_8000384

loc_8000356:				; CODE XREF: parse_column_count+35j
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidNumberO ; "invalid number of columns: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000384:				; CODE XREF: parse_column_count+3Cj
		mov	eax, [ebp+tmp_long]
		mov	columns, eax
		mov	ds:explicit_columns, 1
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_80003A5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80003A5:				; CODE XREF: parse_column_count+86j
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_column_count endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl separator_string(const char *optarg_S)
separator_string proc near		; CODE XREF: main+518p	main+565p

optarg_S	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+optarg_S]	; s
		call	strlen
		add	esp, 10h
		mov	ds:col_sep_length, eax
		mov	eax, ds:col_sep_length
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	col_sep_string,	eax
		mov	eax, col_sep_string
		sub	esp, 8
		push	[ebp+optarg_S]	; src
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		nop
		leave
		retn
separator_string endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -4Ch
old_options	= byte ptr -43h
old_w		= byte ptr -42h
old_s		= byte ptr -41h
n_alloc		= dword	ptr -40h
oi		= dword	ptr -3Ch
tmp_long	= dword	ptr -38h
n_files		= dword	ptr -34h
column_count_string= dword ptr -30h
n_digits	= dword	ptr -2Ch
i		= dword	ptr -28h
file_names	= dword	ptr -24h
c		= dword	ptr -20h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 4Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+old_options], 0
		mov	[ebp+old_w], 0
		mov	[ebp+old_s], 0
		mov	[ebp+column_count_string], 0
		mov	[ebp+n_digits],	0
		mov	[ebp+n_alloc], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+n_files], 0
		cmp	dword ptr [ebx], 1
		jle	short loc_80004B4
		mov	eax, [ebx]
		sub	eax, 1
		shl	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		jmp	short loc_80004B9
; ---------------------------------------------------------------------------

loc_80004B4:				; CODE XREF: main+A9j
		mov	eax, 0

loc_80004B9:				; CODE XREF: main+BFj
		mov	[ebp+file_names], eax

loc_80004BC:				; CODE XREF: main+151j	main+6E3j ...
		mov	[ebp+oi], 0FFFFFFFFh
		sub	esp, 0Ch
		lea	eax, [ebp+oi]
		push	eax		; longind
		push	offset long_options ; longopts
		push	offset short_options ; "-0123456789D:FJN:S::TW:abcde::fh:i::l:m"...
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_80004F9
		cmp	[ebp+column_count_string], 0
		jnz	loc_8000AF9
		jmp	loc_8000B15
; ---------------------------------------------------------------------------

loc_80004F9:				; CODE XREF: main+F5j
		mov	eax, [ebp+c]
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_8000549
		mov	eax, [ebp+n_digits]
		lea	edx, [eax+1]
		mov	eax, [ebp+n_alloc]
		cmp	edx, eax
		jb	short loc_8000526
		sub	esp, 8
		lea	eax, [ebp+n_alloc]
		push	eax
		push	[ebp+column_count_string]
		call	x2realloc
		add	esp, 10h
		mov	[ebp+column_count_string], eax

loc_8000526:				; CODE XREF: main+11Cj
		mov	eax, [ebp+n_digits]
		lea	edx, [eax+1]
		mov	[ebp+n_digits],	edx
		mov	edx, [ebp+column_count_string]
		add	eax, edx
		mov	edx, [ebp+c]
		mov	[eax], dl
		mov	edx, [ebp+column_count_string]
		mov	eax, [ebp+n_digits]
		add	eax, edx
		mov	byte ptr [eax],	0
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000549:				; CODE XREF: main+10Fj
		mov	[ebp+n_digits],	0
		mov	eax, [ebp+c]
		add	eax, 83h	; switch 261 cases
		cmp	eax, 104h
		ja	loc_8000ACB	; jumptable 0800056A default case
		mov	eax, ds:off_8003DD0[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_800056C:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, dword ptr ds:first_page_number ; jumptable	0800056A case 1
		mov	edx, dword ptr ds:first_page_number+4
		or	eax, edx
		test	eax, eax
		jnz	short loc_80005AC
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	short loc_80005AC
		mov	eax, ds:optarg
		add	eax, 1
		sub	esp, 4
		push	eax		; pages
		push	2Bh		; c
		push	0FFFFFFFEh	; oi
		call	first_last_page
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	loc_8000AD5

loc_80005AC:				; CODE XREF: main+188j	main+194j
		mov	eax, [ebp+n_files]
		lea	edx, [eax+1]
		mov	[ebp+n_files], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file_names]
		add	edx, eax
		mov	eax, ds:optarg
		mov	[edx], eax
		jmp	loc_8000AD5
; ---------------------------------------------------------------------------

loc_80005CD:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 129
		test	eax, eax
		jnz	short loc_80005FB
		sub	esp, 0Ch
		push	offset aPagesFirst_pag ; "`--pages=FIRST_PAGE[:LAST_PAGE]' missin"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000ADB
; ---------------------------------------------------------------------------

loc_80005FB:				; CODE XREF: main+1E1j
		mov	edx, ds:optarg
		mov	eax, [ebp+oi]
		sub	esp, 4
		push	edx		; pages
		push	0		; c
		push	eax		; oi
		call	first_last_page
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	loc_8000ADB
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidPageRan ; "invalid page range %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000ADB
; ---------------------------------------------------------------------------

loc_8000654:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 128
		sub	esp, 0Ch
		push	eax		; s
		call	parse_column_count
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+column_count_string] ; ptr
		call	free
		add	esp, 10h
		mov	[ebp+column_count_string], 0
		mov	[ebp+n_alloc], 0
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000686:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:print_across_flag, 1	; jumptable 0800056A case 97
		mov	storing_columns, 0
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000699:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:balance_columns, 1 ;	jumptable 0800056A case	98
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80006A5:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:use_cntrl_prefix, 1 ; jumptable 0800056A case 99
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80006B1:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:double_space, 1 ; jumptable 0800056A	case 100
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80006BD:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 68
		mov	ds:date_format,	eax
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80006CC:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 101
		test	eax, eax
		jz	short loc_80006EF
		mov	eax, ds:optarg
		push	offset chars_per_input_tab ; number
		push	offset input_tab_char ;	"\t"
		push	65h		; switch_char
		push	eax		; arg
		call	getoptarg
		add	esp, 10h

loc_80006EF:				; CODE XREF: main+2E0j
		mov	ds:untabify_input, 1
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80006FB:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:use_form_feed, 1 ; jumptable	0800056A cases 70,102
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000707:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 104
		mov	ds:custom_header, eax
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000716:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 105
		test	eax, eax
		jz	short loc_8000739
		mov	eax, ds:optarg
		push	offset chars_per_output_tab ; number
		push	offset output_tab_char ; "\t"
		push	69h		; switch_char
		push	eax		; arg
		call	getoptarg
		add	esp, 10h

loc_8000739:				; CODE XREF: main+32Aj
		mov	ds:tabify_output, 1
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000745:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:join_lines, 1 ; jumptable 0800056A case 74
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000751:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 108
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_long]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_800077A
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jg	short loc_80007AB

loc_800077A:				; CODE XREF: main+37Ej
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aLPage_lengthIn ; "`-l PAGE_LENGTH' invalid number of line"...
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007AB:				; CODE XREF: main+385j
		mov	eax, [ebp+tmp_long]
		mov	lines_per_page,	eax
		nop
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80007B9:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:parallel_files, 1 ; jumptable 0800056A case 109
		mov	storing_columns, 0
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80007CC:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:numbered_lines, 1 ; jumptable 0800056A case 110
		mov	eax, ds:optarg
		test	eax, eax
		jz	loc_8000AE1
		mov	eax, ds:optarg
		push	offset chars_per_number	; number
		push	offset number_separator	; "\t"
		push	6Eh		; switch_char
		push	eax		; arg
		call	getoptarg
		add	esp, 10h
		jmp	loc_8000AE1
; ---------------------------------------------------------------------------

loc_80007FF:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	skip_count, 0	; jumptable 0800056A case 78
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_long]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jz	short loc_8000859
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aNNumberInvalid ; "`-N NUMBER' invalid starting line numbe"...
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000859:				; CODE XREF: main+433j
		mov	eax, [ebp+tmp_long]
		mov	start_line_num,	eax
		nop
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000867:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	eax, ds:optarg	; jumptable 0800056A case 111
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_long]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000890
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jns	short loc_80008C1

loc_8000890:				; CODE XREF: main+494j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aOMarginInvalid ; "`-o MARGIN' invalid line offset: %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008C1:				; CODE XREF: main+49Bj
		mov	eax, [ebp+tmp_long]
		mov	ds:chars_per_margin, eax
		nop
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80008CF:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:ignore_failed_opens,	1 ; jumptable 0800056A case 114
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_80008DB:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	[ebp+old_options], 1 ; jumptable 0800056A case 115
		mov	[ebp+old_s], 1
		movzx	eax, ds:use_col_separator
		xor	eax, 1
		test	al, al
		jz	loc_8000AE7
		mov	eax, ds:optarg
		test	eax, eax
		jz	loc_8000AE7
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; optarg_S
		call	separator_string
		add	esp, 10h
		jmp	loc_8000AE7
; ---------------------------------------------------------------------------

loc_8000918:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	[ebp+old_s], 0	; jumptable 0800056A case 83
		sub	esp, 0Ch
		push	offset locale	; s
		call	bad_cast
		add	esp, 10h
		mov	col_sep_string,	eax
		mov	ds:col_sep_length, 0
		mov	ds:use_col_separator, 1
		mov	eax, ds:optarg
		test	eax, eax
		jz	loc_8000AED
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; optarg_S
		call	separator_string
		add	esp, 10h
		jmp	loc_8000AED
; ---------------------------------------------------------------------------

loc_8000965:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	extremities, 0	; jumptable 0800056A case 116
		mov	ds:keep_FF, 1
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000978:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	extremities, 0	; jumptable 0800056A case 84
		mov	ds:keep_FF, 0
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_800098B:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	ds:use_esc_sequence, 1 ; jumptable 0800056A case 118
		jmp	loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000997:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	[ebp+old_options], 1 ; jumptable 0800056A case 119
		mov	[ebp+old_w], 1
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_long]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_80009C8
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jg	short loc_80009F9

loc_80009C8:				; CODE XREF: main+5CCj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWPage_widthInv ; "`-w PAGE_WIDTH' invalid number of chara"...
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009F9:				; CODE XREF: main+5D3j
		movzx	eax, ds:truncate_lines
		xor	eax, 1
		test	al, al
		jz	loc_8000AF3
		mov	eax, [ebp+tmp_long]
		mov	chars_per_line,	eax
		nop
		jmp	loc_8000AF3
; ---------------------------------------------------------------------------

loc_8000A19:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	[ebp+old_w], 0	; jumptable 0800056A case 87
		mov	ds:truncate_lines, 1
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_long]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000A4D
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jg	short loc_8000A7E

loc_8000A4D:				; CODE XREF: main+651j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWPage_widthI_0 ; "`-W PAGE_WIDTH' invalid number of chara"...
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000A7E:				; CODE XREF: main+658j
		mov	eax, [ebp+tmp_long]
		mov	chars_per_line,	eax
		nop
		jmp	short loc_8000AF4
; ---------------------------------------------------------------------------

loc_8000A89:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		sub	esp, 0Ch	; jumptable 0800056A case -130
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000A93:				; CODE XREF: main+177j
					; DATA XREF: .rodata:off_8003DD0o
		mov	edx, ds:Version	; jumptable 0800056A case -131
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aRolandHuebner ;	"Roland	Huebner"
		push	offset aPeteTermaat ; "Pete TerMaat"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aPr	; "pr"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000ACB:				; CODE XREF: main+16Aj	main+177j
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 0800056A default case
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000AD5:				; CODE XREF: main+1B3j	main+1D5j
		nop
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000ADB:				; CODE XREF: main+203j	main+225j ...
		nop
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000AE1:				; CODE XREF: main+3E7j	main+407j
		nop
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000AE7:				; CODE XREF: main+4FCj	main+509j ...
		nop
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000AED:				; CODE XREF: main+556j	main+56Dj
		nop
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000AF3:				; CODE XREF: main+612j	main+621j
		nop

loc_8000AF4:				; CODE XREF: main+28Ej	main+2A1j ...
		jmp	loc_80004BC
; ---------------------------------------------------------------------------

loc_8000AF9:				; CODE XREF: main+FBj
		sub	esp, 0Ch
		push	[ebp+column_count_string] ; s
		call	parse_column_count
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+column_count_string] ; ptr
		call	free
		add	esp, 10h

loc_8000B15:				; CODE XREF: main+101j
		mov	eax, ds:date_format
		test	eax, eax
		jnz	short loc_8000B57
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B4D
		sub	esp, 0Ch
		push	2
		call	hard_locale
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000B4D
		mov	eax, offset aBEHMY ; "%b %e %H:%M %Y"
		jmp	short loc_8000B52
; ---------------------------------------------------------------------------

loc_8000B4D:				; CODE XREF: main+73Dj	main+751j
		mov	eax, offset aYMDHM ; "%Y-%m-%d %H:%M"

loc_8000B52:				; CODE XREF: main+758j
		mov	ds:date_format,	eax

loc_8000B57:				; CODE XREF: main+729j
		mov	eax, dword ptr ds:first_page_number
		mov	edx, dword ptr ds:first_page_number+4
		or	eax, edx
		test	eax, eax
		jnz	short loc_8000B7C
		mov	dword ptr ds:first_page_number,	1
		mov	dword ptr ds:first_page_number+4, 0

loc_8000B7C:				; CODE XREF: main+773j
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8000BB2
		movzx	eax, ds:explicit_columns
		test	al, al
		jz	short loc_8000BB2
		sub	esp, 0Ch
		push	offset aCannotSpecifyN ; "cannot specify number	of columns when	p"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000BB2:				; CODE XREF: main+792j	main+79Dj
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8000BE8
		movzx	eax, ds:print_across_flag
		test	al, al
		jz	short loc_8000BE8
		sub	esp, 0Ch
		push	offset aCannotSpecifyB ; "cannot specify both printing across and"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000BE8:				; CODE XREF: main+7C8j	main+7D3j
		cmp	[ebp+old_options], 0
		jz	loc_8000CC5
		cmp	[ebp+old_w], 0
		jz	short loc_8000C30
		movzx	eax, ds:parallel_files
		test	al, al
		jnz	short loc_8000C0E
		movzx	eax, ds:explicit_columns
		test	al, al
		jz	short loc_8000C24

loc_8000C0E:				; CODE XREF: main+80Ej
		mov	ds:truncate_lines, 1
		cmp	[ebp+old_s], 0
		jz	short loc_8000C8C
		mov	ds:use_col_separator, 1
		jmp	short loc_8000C8C
; ---------------------------------------------------------------------------

loc_8000C24:				; CODE XREF: main+819j
		mov	ds:join_lines, 1
		jmp	loc_8000CC5
; ---------------------------------------------------------------------------

loc_8000C30:				; CODE XREF: main+803j
		movzx	eax, ds:use_col_separator
		xor	eax, 1
		test	al, al
		jz	loc_8000CC5
		cmp	[ebp+old_s], 0
		jz	short loc_8000CC5
		movzx	eax, ds:parallel_files
		test	al, al
		jnz	short loc_8000C5E
		movzx	eax, ds:explicit_columns
		test	al, al
		jz	short loc_8000CC5

loc_8000C5E:				; CODE XREF: main+85Ej
		movzx	eax, ds:truncate_lines
		xor	eax, 1
		test	al, al
		jz	short loc_8000C85
		mov	ds:join_lines, 1
		mov	eax, ds:col_sep_length
		test	eax, eax
		jle	short loc_8000CC5
		mov	ds:use_col_separator, 1
		jmp	short loc_8000CC5
; ---------------------------------------------------------------------------

loc_8000C85:				; CODE XREF: main+877j
		mov	ds:use_col_separator, 1

loc_8000C8C:				; CODE XREF: main+826j	main+82Fj
		jmp	short loc_8000CC5
; ---------------------------------------------------------------------------

loc_8000C8E:				; CODE XREF: main+8D9j
		mov	eax, [ebp+n_files]
		lea	edx, [eax+1]
		mov	[ebp+n_files], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file_names]
		add	edx, eax
		mov	eax, ds:optind
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax

loc_8000CC5:				; CODE XREF: main+7F9j	main+838j ...
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_8000C8E
		cmp	[ebp+n_files], 0
		jnz	short loc_8000CE5
		sub	esp, 8
		push	0		; av
		push	0		; number_of_files
		call	print_files
		add	esp, 10h
		jmp	short loc_8000D35
; ---------------------------------------------------------------------------

loc_8000CE5:				; CODE XREF: main+8DFj
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8000D03
		sub	esp, 8
		push	[ebp+file_names] ; av
		push	[ebp+n_files]	; number_of_files
		call	print_files
		add	esp, 10h
		jmp	short loc_8000D35
; ---------------------------------------------------------------------------

loc_8000D03:				; CODE XREF: main+8FBj
		mov	[ebp+i], 0
		jmp	short loc_8000D2D
; ---------------------------------------------------------------------------

loc_8000D0C:				; CODE XREF: main+940j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file_names]
		add	eax, edx
		sub	esp, 8
		push	eax		; av
		push	1		; number_of_files
		call	print_files
		add	esp, 10h
		add	[ebp+i], 1

loc_8000D2D:				; CODE XREF: main+917j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jl	short loc_8000D0C

loc_8000D35:				; CODE XREF: main+8F0j	main+90Ej
		call	cleanup
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_8000D83
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000D83
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000D83:				; CODE XREF: main+950j	main+966j
		movzx	eax, ds:failed_opens
		test	al, al
		jz	short loc_8000D98
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000D98:				; CODE XREF: main+999j
		sub	esp, 0Ch
		push	0		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl getoptarg(char *arg, char switch_char, char *character, int *number)
getoptarg	proc near		; CODE XREF: main+2F4p	main+33Ep ...

number		= dword	ptr -28h
character	= dword	ptr -24h
switch_char	= byte ptr -20h
arg		= dword	ptr -1Ch
tmp_long	= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	eax, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+arg], edx
		mov	[ebp+switch_char], al
		mov	eax, [ebp+arg_8]
		mov	[ebp+character], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+number], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8000DEF
		mov	eax, [ebp+arg]
		lea	edx, [eax+1]
		mov	[ebp+arg], edx
		movzx	edx, byte ptr [eax]
		mov	eax, [ebp+character]
		mov	[eax], dl

loc_8000DEF:				; CODE XREF: getoptarg+3Aj
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000E67
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+tmp_long]
		push	eax
		push	0Ah
		push	0
		push	[ebp+arg]
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000E1F
		mov	eax, [ebp+tmp_long]
		test	eax, eax
		jg	short loc_8000E5F

loc_8000E1F:				; CODE XREF: getoptarg+74j
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	esi, eax
		movsx	ebx, [ebp+switch_char]
		sub	esp, 0Ch
		push	offset aCExtraCharacte ; "`-%c' extra characters or invalid numbe"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E5F:				; CODE XREF: getoptarg+7Bj
		mov	edx, [ebp+tmp_long]
		mov	eax, [ebp+number]
		mov	[eax], edx

loc_8000E67:				; CODE XREF: getoptarg+55j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8000E79
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000E79:				; CODE XREF: getoptarg+D0j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
getoptarg	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl init_parameters(int number_of_files)
init_parameters	proc near		; CODE XREF: print_files+Cp

chars_used_by_number= dword ptr	-14h
tmp_i		= dword	ptr -10h
chars_per_default_tab= dword ptr -0Ch
number_of_files	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+chars_used_by_number], 0
		mov	eax, lines_per_page
		sub	eax, 0Ah
		mov	ds:lines_per_body, eax
		mov	eax, ds:lines_per_body
		test	eax, eax
		jg	short loc_8000EB1
		mov	extremities, 0
		mov	ds:keep_FF, 1

loc_8000EB1:				; CODE XREF: init_parameters+21j
		movzx	eax, extremities
		xor	eax, 1
		test	al, al
		jz	short loc_8000EC9
		mov	eax, lines_per_page
		mov	ds:lines_per_body, eax

loc_8000EC9:				; CODE XREF: init_parameters+3Dj
		movzx	eax, ds:double_space
		test	al, al
		jz	short loc_8000EE7
		mov	eax, ds:lines_per_body
		mov	edx, eax
		shr	edx, 1Fh
		add	eax, edx
		sar	eax, 1
		mov	ds:lines_per_body, eax

loc_8000EE7:				; CODE XREF: init_parameters+52j
		cmp	[ebp+number_of_files], 0
		jnz	short loc_8000EF4
		mov	ds:parallel_files, 0

loc_8000EF4:				; CODE XREF: init_parameters+6Bj
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8000F07
		mov	eax, [ebp+number_of_files]
		mov	columns, eax

loc_8000F07:				; CODE XREF: init_parameters+7Dj
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_8000F19
		mov	ds:balance_columns, 1

loc_8000F19:				; CODE XREF: init_parameters+90j
		mov	eax, columns
		cmp	eax, 1
		jle	short loc_8000F99
		movzx	eax, ds:use_col_separator
		xor	eax, 1
		test	al, al
		jz	short loc_8000F65
		movzx	eax, ds:join_lines
		test	al, al
		jz	short loc_8000F48
		mov	eax, line_separator
		mov	col_sep_string,	eax
		jmp	short loc_8000F52
; ---------------------------------------------------------------------------

loc_8000F48:				; CODE XREF: init_parameters+BAj
		mov	eax, column_separator
		mov	col_sep_string,	eax

loc_8000F52:				; CODE XREF: init_parameters+C6j
		mov	ds:col_sep_length, 1
		mov	ds:use_col_separator, 1
		jmp	short loc_8000F89
; ---------------------------------------------------------------------------

loc_8000F65:				; CODE XREF: init_parameters+AFj
		movzx	eax, ds:join_lines
		xor	eax, 1
		test	al, al
		jz	short loc_8000F89
		mov	eax, col_sep_string
		movzx	eax, byte ptr [eax]
		cmp	al, 9
		jnz	short loc_8000F89
		mov	eax, column_separator
		mov	col_sep_string,	eax

loc_8000F89:				; CODE XREF: init_parameters+E3j
					; init_parameters+F1j ...
		mov	ds:truncate_lines, 1
		mov	ds:tabify_output, 1
		jmp	short loc_8000FA0
; ---------------------------------------------------------------------------

loc_8000F99:				; CODE XREF: init_parameters+A1j
		mov	storing_columns, 0

loc_8000FA0:				; CODE XREF: init_parameters+117j
		movzx	eax, ds:join_lines
		test	al, al
		jz	short loc_8000FB2
		mov	ds:truncate_lines, 0

loc_8000FB2:				; CODE XREF: init_parameters+129j
		movzx	eax, ds:numbered_lines
		test	al, al
		jz	loc_800104D
		mov	[ebp+chars_per_default_tab], 8
		mov	eax, start_line_num
		mov	line_count, eax
		movzx	eax, byte ptr number_separator ; "\t"
		cmp	al, 9
		jnz	short loc_8000FFB
		mov	eax, chars_per_number
		cdq
		idiv	[ebp+chars_per_default_tab]
		mov	eax, [ebp+chars_per_default_tab]
		sub	eax, edx
		mov	edx, eax
		mov	eax, chars_per_number
		add	eax, edx
		mov	ds:number_width, eax
		jmp	short loc_8001008
; ---------------------------------------------------------------------------

loc_8000FFB:				; CODE XREF: init_parameters+15Bj
		mov	eax, chars_per_number
		add	eax, 1
		mov	ds:number_width, eax

loc_8001008:				; CODE XREF: init_parameters+179j
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_800101B
		mov	eax, ds:number_width
		mov	[ebp+chars_used_by_number], eax

loc_800101B:				; CODE XREF: init_parameters+191j
		mov	eax, chars_per_number
		mov	[ebp+tmp_i], eax
		mov	ds:power_10, 1
		jmp	short loc_8001047
; ---------------------------------------------------------------------------

loc_800102F:				; CODE XREF: init_parameters+1CBj
		mov	edx, ds:power_10
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	ds:power_10, eax
		sub	[ebp+tmp_i], 1

loc_8001047:				; CODE XREF: init_parameters+1ADj
		cmp	[ebp+tmp_i], 0
		jg	short loc_800102F

loc_800104D:				; CODE XREF: init_parameters+13Bj
		mov	eax, chars_per_line
		sub	eax, [ebp+chars_used_by_number]
		mov	edx, eax
		mov	eax, columns
		lea	ecx, [eax-1]
		mov	eax, ds:col_sep_length
		imul	eax, ecx
		sub	edx, eax
		mov	eax, edx
		mov	ecx, columns
		cdq
		idiv	ecx
		mov	ds:chars_per_column, eax
		mov	eax, ds:chars_per_column
		test	eax, eax
		jg	short loc_80010A2
		sub	esp, 0Ch
		push	offset aPageWidthTooNa ; "page width too narrow"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80010A2:				; CODE XREF: init_parameters+200j
		movzx	eax, ds:numbered_lines
		test	al, al
		jz	short loc_80010D6
		mov	eax, ds:number_buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, chars_per_number
		add	eax, eax
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:number_buff,	eax

loc_80010D6:				; CODE XREF: init_parameters+22Bj
		mov	eax, ds:clump_buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, chars_per_input_tab
		mov	edx, 8
		cmp	eax, 8
		cmovl	eax, edx
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:clump_buff, eax
		nop
		leave
		retn
init_parameters	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	init_fps(int number_of_files, char **av)
init_fps	proc near		; CODE XREF: print_files+1Dp

i		= dword	ptr -1Ch
files_left	= dword	ptr -18h
p		= dword	ptr -14h
firstname	= dword	ptr -10h
firstfp		= dword	ptr -0Ch
number_of_files	= dword	ptr  8
av		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	ds:total_files,	0
		mov	eax, ds:column_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, columns
		sub	esp, 8
		push	28h
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	ds:column_vector, eax
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_80011CA
		mov	eax, [ebp+number_of_files]
		mov	[ebp+files_left], eax
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001193
; ---------------------------------------------------------------------------

loc_800115F:				; CODE XREF: init_fps+93j
		mov	eax, [ebp+av]
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+p]		; p
		push	eax		; name
		call	open_file
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_800118B
		sub	[ebp+p], 28h
		mov	eax, columns
		sub	eax, 1
		mov	columns, eax

loc_800118B:				; CODE XREF: init_fps+6Dj
		add	[ebp+p], 28h
		add	[ebp+av], 4

loc_8001193:				; CODE XREF: init_fps+52j
		mov	eax, [ebp+files_left]
		lea	edx, [eax-1]
		mov	[ebp+files_left], edx
		test	eax, eax
		jnz	short loc_800115F
		mov	eax, columns
		test	eax, eax
		jnz	short loc_80011B3
		mov	eax, 0
		jmp	locret_80012FD
; ---------------------------------------------------------------------------

loc_80011B3:				; CODE XREF: init_fps+9Cj
		sub	esp, 8
		push	0FFFFFFFFh	; desc
		push	offset locale	; filename
		call	init_header
		add	esp, 10h
		jmp	loc_80012EE
; ---------------------------------------------------------------------------

loc_80011CA:				; CODE XREF: init_fps+42j
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		cmp	[ebp+number_of_files], 0
		jle	short loc_800122E
		mov	eax, [ebp+av]
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+p]		; p
		push	eax		; name
		call	open_file
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80011FD
		mov	eax, 0
		jmp	locret_80012FD
; ---------------------------------------------------------------------------

loc_80011FD:				; CODE XREF: init_fps+E6j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	fileno
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+av]
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; desc
		push	eax		; filename
		call	init_header
		add	esp, 10h
		mov	eax, [ebp+p]
		mov	dword ptr [eax+18h], 0
		jmp	short loc_8001292
; ---------------------------------------------------------------------------

loc_800122E:				; CODE XREF: init_fps+CBj
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+4], edx
		mov	edx, ds:stdin
		mov	eax, [ebp+p]
		mov	[eax], edx
		mov	ds:have_read_stdin, 1
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0
		mov	eax, ds:total_files
		add	eax, 1
		mov	ds:total_files,	eax
		sub	esp, 8
		push	0FFFFFFFFh	; desc
		push	offset locale	; filename
		call	init_header
		add	esp, 10h
		mov	eax, [ebp+p]
		mov	dword ptr [eax+18h], 0

loc_8001292:				; CODE XREF: init_fps+121j
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+firstname], eax
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	[ebp+firstfp], eax
		mov	eax, columns
		sub	eax, 1
		mov	[ebp+i], eax
		add	[ebp+p], 28h
		jmp	short loc_80012E8
; ---------------------------------------------------------------------------

loc_80012B4:				; CODE XREF: init_fps+1E1j
		mov	eax, [ebp+p]
		mov	edx, [ebp+firstname]
		mov	[eax+4], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+firstfp]
		mov	[eax], edx
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0
		mov	eax, [ebp+p]
		mov	dword ptr [eax+18h], 0
		sub	[ebp+i], 1
		add	[ebp+p], 28h

loc_80012E8:				; CODE XREF: init_fps+1A7j
		cmp	[ebp+i], 0
		jnz	short loc_80012B4

loc_80012EE:				; CODE XREF: init_fps+BAj
		mov	eax, ds:total_files
		mov	ds:files_ready_to_read,	eax
		mov	eax, 1

locret_80012FD:				; CODE XREF: init_fps+A3j init_fps+EDj
		leave
		retn
init_fps	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void init_funcs()
init_funcs	proc near		; CODE XREF: print_files:loc_800182Ep

i		= dword	ptr -10h
h		= dword	ptr -0Ch
h_next		= dword	ptr -8
p		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, ds:chars_per_margin
		mov	[ebp+h], eax
		movzx	eax, ds:truncate_lines
		xor	eax, 1
		test	al, al
		jz	short loc_8001324
		mov	[ebp+h_next], 0
		jmp	short loc_800135F
; ---------------------------------------------------------------------------

loc_8001324:				; CODE XREF: init_funcs+1Aj
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8001351
		movzx	eax, ds:numbered_lines
		test	al, al
		jz	short loc_8001351
		mov	edx, ds:chars_per_column
		mov	eax, [ebp+h]
		add	edx, eax
		mov	eax, ds:number_width
		add	eax, edx
		mov	[ebp+h_next], eax
		jmp	short loc_800135F
; ---------------------------------------------------------------------------

loc_8001351:				; CODE XREF: init_funcs+2Ej
					; init_funcs+39j
		mov	edx, ds:chars_per_column
		mov	eax, [ebp+h]
		add	eax, edx
		mov	[ebp+h_next], eax

loc_800135F:				; CODE XREF: init_funcs+23j
					; init_funcs+50j
		mov	eax, ds:col_sep_length
		add	[ebp+h], eax
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		mov	[ebp+i], 1
		jmp	loc_800142F
; ---------------------------------------------------------------------------

loc_800137B:				; CODE XREF: init_funcs+138j
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_800139C
		mov	eax, [ebp+p]
		mov	dword ptr [eax+10h], offset store_char
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], offset print_stored
		jmp	short loc_80013B0
; ---------------------------------------------------------------------------

loc_800139C:				; CODE XREF: init_funcs+85j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+10h], offset print_char
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], offset read_line

loc_80013B0:				; CODE XREF: init_funcs+9Bj
		movzx	eax, ds:numbered_lines
		test	al, al
		jz	short loc_80013D6
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jnz	short loc_80013CF
		cmp	[ebp+i], 1
		jnz	short loc_80013D6

loc_80013CF:				; CODE XREF: init_funcs+C8j
		mov	eax, 1
		jmp	short loc_80013DB
; ---------------------------------------------------------------------------

loc_80013D6:				; CODE XREF: init_funcs+BAj
					; init_funcs+CEj
		mov	eax, 0

loc_80013DB:				; CODE XREF: init_funcs+D5j
		and	eax, 1
		mov	edx, [ebp+p]
		mov	[edx+24h], al
		mov	eax, [ebp+p]
		mov	edx, [ebp+h]
		mov	[eax+20h], edx
		movzx	eax, ds:truncate_lines
		xor	eax, 1
		test	al, al
		jz	short loc_800140B
		mov	[ebp+h], 0
		mov	[ebp+h_next], 0
		jmp	short loc_8001427
; ---------------------------------------------------------------------------

loc_800140B:				; CODE XREF: init_funcs+FAj
		mov	edx, ds:col_sep_length
		mov	eax, [ebp+h_next]
		add	eax, edx
		mov	[ebp+h], eax
		mov	edx, ds:chars_per_column
		mov	eax, [ebp+h]
		add	eax, edx
		mov	[ebp+h_next], eax

loc_8001427:				; CODE XREF: init_funcs+10Aj
		add	[ebp+p], 28h
		add	[ebp+i], 1

loc_800142F:				; CODE XREF: init_funcs+77j
		mov	eax, columns
		cmp	[ebp+i], eax
		jl	loc_800137B
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_8001469
		movzx	eax, ds:balance_columns
		test	al, al
		jz	short loc_8001469
		mov	eax, [ebp+p]
		mov	dword ptr [eax+10h], offset store_char
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], offset print_stored
		jmp	short loc_800147D
; ---------------------------------------------------------------------------

loc_8001469:				; CODE XREF: init_funcs+147j
					; init_funcs+152j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+10h], offset print_char
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], offset read_line

loc_800147D:				; CODE XREF: init_funcs+168j
		movzx	eax, ds:numbered_lines
		test	al, al
		jz	short loc_80014A3
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jnz	short loc_800149C
		cmp	[ebp+i], 1
		jnz	short loc_80014A3

loc_800149C:				; CODE XREF: init_funcs+195j
		mov	eax, 1
		jmp	short loc_80014A8
; ---------------------------------------------------------------------------

loc_80014A3:				; CODE XREF: init_funcs+187j
					; init_funcs+19Bj
		mov	eax, 0

loc_80014A8:				; CODE XREF: init_funcs+1A2j
		and	eax, 1
		mov	edx, [ebp+p]
		mov	[edx+24h], al
		mov	eax, [ebp+p]
		mov	edx, [ebp+h]
		mov	[eax+20h], edx
		nop
		leave
		retn
init_funcs	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	open_file(char *name, COLUMN_0 *p)
open_file	proc near		; CODE XREF: init_fps+60p init_fps+D9p

name		= dword	ptr  8
p		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 8
		push	offset asc_8004237 ; "-"
		push	[ebp+name]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001506
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+4], edx
		mov	edx, ds:stdin
		mov	eax, [ebp+p]
		mov	[eax], edx
		mov	ds:have_read_stdin, 1
		jmp	short loc_8001529
; ---------------------------------------------------------------------------

loc_8001506:				; CODE XREF: open_file+1Bj
		mov	eax, [ebp+p]
		mov	edx, [ebp+name]
		mov	[eax+4], edx
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+name]
		call	fopen_safer
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax], edx

loc_8001529:				; CODE XREF: open_file+47j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8001568
		mov	ds:failed_opens, 1
		movzx	eax, ds:ignore_failed_opens
		xor	eax, 1
		test	al, al
		jz	short loc_8001561
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001561:				; CODE XREF: open_file+88j
		mov	eax, 0
		jmp	short locret_800158B
; ---------------------------------------------------------------------------

loc_8001568:				; CODE XREF: open_file+73j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0
		mov	eax, ds:total_files
		add	eax, 1
		mov	ds:total_files,	eax
		mov	eax, 1

locret_800158B:				; CODE XREF: open_file+A9j
		leave
		retn
open_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl close_file(COLUMN_0 *p)
close_file	proc near		; CODE XREF: read_rest_of_line+6Cp
					; skip_read+11Fp ...

q		= dword	ptr -10h
i		= dword	ptr -0Ch
var_4		= dword	ptr -4
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 3
		jz	loc_800168F
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80015D6
		mov	eax, [ebp+p]
		mov	ebx, [eax+4]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80015D6:				; CODE XREF: close_file+29j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	fileno
		add	esp, 10h
		test	eax, eax
		jz	short loc_800161E
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_800161E
		mov	eax, [ebp+p]
		mov	ebx, [eax+4]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800161E:				; CODE XREF: close_file+5Cj
					; close_file+71j
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jz	short loc_800166C
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		mov	eax, columns
		mov	[ebp+i], eax
		jmp	short loc_8001664
; ---------------------------------------------------------------------------

loc_800163E:				; CODE XREF: close_file+DBj
		mov	eax, [ebp+q]
		mov	dword ptr [eax+8], 3
		mov	eax, [ebp+q]
		mov	eax, [eax+18h]
		test	eax, eax
		jnz	short loc_800165C
		mov	eax, [ebp+q]
		mov	dword ptr [eax+1Ch], 0

loc_800165C:				; CODE XREF: close_file+C3j
		add	[ebp+q], 28h
		sub	[ebp+i], 1

loc_8001664:				; CODE XREF: close_file+AFj
		cmp	[ebp+i], 0
		jnz	short loc_800163E
		jmp	short loc_8001680
; ---------------------------------------------------------------------------

loc_800166C:				; CODE XREF: close_file+9Dj
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 3
		mov	eax, [ebp+p]
		mov	dword ptr [eax+1Ch], 0

loc_8001680:				; CODE XREF: close_file+DDj
		mov	eax, ds:files_ready_to_read
		sub	eax, 1
		mov	ds:files_ready_to_read,	eax
		jmp	short loc_8001690
; ---------------------------------------------------------------------------

loc_800168F:				; CODE XREF: close_file+10j
		nop

loc_8001690:				; CODE XREF: close_file+100j
		mov	ebx, [ebp+var_4]
		leave
		retn
close_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl hold_file(COLUMN_0 *p)
hold_file	proc near		; CODE XREF: read_rest_of_line+56p
					; skip_read+109p ...

q		= dword	ptr -8
i		= dword	ptr -4
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jz	short loc_80016EC
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		mov	eax, columns
		mov	[ebp+i], eax
		jmp	short loc_80016E4
; ---------------------------------------------------------------------------

loc_80016BB:				; CODE XREF: hold_file+53j
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_80016D2
		mov	eax, [ebp+q]
		mov	dword ptr [eax+8], 1
		jmp	short loc_80016DC
; ---------------------------------------------------------------------------

loc_80016D2:				; CODE XREF: hold_file+2Fj
		mov	eax, [ebp+q]
		mov	dword ptr [eax+8], 2

loc_80016DC:				; CODE XREF: hold_file+3Bj
		add	[ebp+q], 28h
		sub	[ebp+i], 1

loc_80016E4:				; CODE XREF: hold_file+24j
		cmp	[ebp+i], 0
		jnz	short loc_80016BB
		jmp	short loc_80016F6
; ---------------------------------------------------------------------------

loc_80016EC:				; CODE XREF: hold_file+12j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 2

loc_80016F6:				; CODE XREF: hold_file+55j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+1Ch], 0
		mov	eax, ds:files_ready_to_read
		sub	eax, 1
		mov	ds:files_ready_to_read,	eax
		nop
		leave
		retn
hold_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void reset_status()
reset_status	proc near		; CODE XREF: print_page:loc_8001E9Bp
					; skip_to_page:loc_800291Dp

i		= dword	ptr -8
p		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, columns
		mov	[ebp+i], eax
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001752
; ---------------------------------------------------------------------------

loc_8001728:				; CODE XREF: reset_status+46j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 2
		jnz	short loc_800174A
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 0
		mov	eax, ds:files_ready_to_read
		add	eax, 1
		mov	ds:files_ready_to_read,	eax

loc_800174A:				; CODE XREF: reset_status+21j
		sub	[ebp+i], 1
		add	[ebp+p], 28h

loc_8001752:				; CODE XREF: reset_status+16j
		cmp	[ebp+i], 0
		jnz	short loc_8001728
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_8001786
		mov	eax, ds:column_vector
		mov	eax, [eax+8]
		cmp	eax, 3
		jnz	short loc_800177C
		mov	ds:files_ready_to_read,	0
		jmp	short loc_8001786
; ---------------------------------------------------------------------------

loc_800177C:				; CODE XREF: reset_status+5Ej
		mov	ds:files_ready_to_read,	1

loc_8001786:				; CODE XREF: reset_status+51j
					; reset_status+6Aj
		nop
		leave
		retn
reset_status	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_files(int number_of_files,	char **av)
print_files	proc near		; CODE XREF: main+8E8p	main+906p ...

number_of_files	= dword	ptr  8
av		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+number_of_files] ;	number_of_files
		call	init_parameters
		add	esp, 10h
		sub	esp, 8
		push	[ebp+av]	; av
		push	[ebp+number_of_files] ;	number_of_files
		call	init_fps
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	loc_8001849
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_80017C9
		call	init_store_cols

loc_80017C9:				; CODE XREF: print_files+39j
		mov	eax, dword ptr ds:first_page_number
		mov	edx, dword ptr ds:first_page_number+4
		cmp	edx, 0
		jb	short loc_800181A
		cmp	edx, 0
		ja	short loc_80017E3
		cmp	eax, 1
		jbe	short loc_800181A

loc_80017E3:				; CODE XREF: print_files+53j
		mov	eax, dword ptr ds:first_page_number
		mov	edx, dword ptr ds:first_page_number+4
		sub	esp, 8
		push	edx
		push	eax		; page
		call	skip_to_page
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_800184C
		mov	eax, dword ptr ds:first_page_number
		mov	edx, dword ptr ds:first_page_number+4
		mov	dword ptr ds:page_number, eax
		mov	dword ptr ds:page_number+4, edx
		jmp	short loc_800182E
; ---------------------------------------------------------------------------

loc_800181A:				; CODE XREF: print_files+4Ej
					; print_files+58j
		mov	dword ptr ds:page_number, 1
		mov	dword ptr ds:page_number+4, 0

loc_800182E:				; CODE XREF: print_files+8Fj
		call	init_funcs
		mov	eax, line_count
		mov	ds:line_number,	eax
		nop

loc_800183E:				; CODE XREF: print_files+BCj
		call	print_page
		test	al, al
		jnz	short loc_800183E
		jmp	short locret_800184D
; ---------------------------------------------------------------------------

loc_8001849:				; CODE XREF: print_files+2Aj
		nop
		jmp	short locret_800184D
; ---------------------------------------------------------------------------

loc_800184C:				; CODE XREF: print_files+77j
		nop

locret_800184D:				; CODE XREF: print_files+BEj
					; print_files+C1j
		leave
		retn
print_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl init_header(const char *filename, int desc)
init_header	proc near		; CODE XREF: init_fps+B2p
					; init_fps+10Fp ...

var_98		= timespec ptr -98h
filename	= dword	ptr -8Ch
buf		= dword	ptr -84h
ns		= dword	ptr -80h
tm		= dword	ptr -7Ch
bufsize		= dword	ptr -78h
t		= timespec ptr -74h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
desc		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 94h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+buf], 0
		sub	esp, 8
		push	offset asc_8004237 ; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001898
		mov	[ebp+desc], 0FFFFFFFFh

loc_8001898:				; CODE XREF: init_header+40j
		cmp	[ebp+desc], 0
		js	short loc_80018DE
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	[ebp+desc]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80018DE
		lea	eax, [ebp+var_98]
		sub	esp, 8
		lea	edx, [ebp+st]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_98.tv_sec]
		mov	edx, [ebp+var_98.tv_nsec]
		mov	[ebp+t.tv_sec],	eax
		mov	[ebp+t.tv_nsec], edx
		jmp	short loc_8001908
; ---------------------------------------------------------------------------

loc_80018DE:				; CODE XREF: init_header+4Dj
					; init_header+63j
		mov	eax, ds:timespec_5501.tv_sec
		test	eax, eax
		jnz	short loc_80018F7
		sub	esp, 0Ch
		push	offset timespec_5501
		call	gettime
		add	esp, 10h

loc_80018F7:				; CODE XREF: init_header+96j
		mov	eax, ds:timespec_5501.tv_sec
		mov	edx, ds:timespec_5501.tv_nsec
		mov	[ebp+t.tv_sec],	eax
		mov	[ebp+t.tv_nsec], edx

loc_8001908:				; CODE XREF: init_header+8Dj
		mov	eax, [ebp+t.tv_nsec]
		mov	[ebp+ns], eax
		sub	esp, 0Ch
		lea	eax, [ebp+t]
		push	eax		; timer
		call	localtime
		add	esp, 10h
		mov	[ebp+tm], eax
		cmp	[ebp+tm], 0
		jnz	short loc_8001955
		sub	esp, 0Ch
		push	18h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, [ebp+t.tv_sec]
		push	[ebp+ns]
		push	eax
		push	offset aLd_09d	; "%ld.%09d"
		push	[ebp+buf]	; s
		call	sprintf
		add	esp, 10h
		jmp	short loc_80019AE
; ---------------------------------------------------------------------------

loc_8001955:				; CODE XREF: init_header+D5j
		mov	eax, ds:date_format
		sub	esp, 8
		push	[ebp+ns]
		push	0
		push	[ebp+tm]
		push	eax
		push	0FFFFFFFFh
		push	0
		call	nstrftime
		add	esp, 20h
		add	eax, 1
		mov	[ebp+bufsize], eax
		sub	esp, 0Ch
		push	[ebp+bufsize]	; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, ds:date_format
		sub	esp, 8
		push	[ebp+ns]
		push	0
		push	[ebp+tm]
		push	eax
		push	[ebp+bufsize]
		push	[ebp+buf]
		call	nstrftime
		add	esp, 20h

loc_80019AE:				; CODE XREF: init_header+104j
		mov	eax, ds:date_text
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+buf]
		mov	ds:date_text, eax
		mov	eax, ds:custom_header
		test	eax, eax
		jnz	short loc_80019E8
		cmp	[ebp+desc], 0
		js	short loc_80019E1
		mov	eax, [ebp+filename]
		jmp	short loc_80019ED
; ---------------------------------------------------------------------------

loc_80019E1:				; CODE XREF: init_header+188j
		mov	eax, offset locale
		jmp	short loc_80019ED
; ---------------------------------------------------------------------------

loc_80019E8:				; CODE XREF: init_header+182j
		mov	eax, ds:custom_header

loc_80019ED:				; CODE XREF: init_header+190j
					; init_header+197j
		mov	ds:file_text, eax
		mov	ebx, chars_per_line
		mov	eax, ds:date_text
		sub	esp, 8
		push	0
		push	eax
		call	gnu_mbswidth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ds:file_text
		sub	esp, 8
		push	0
		push	eax
		call	gnu_mbswidth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ebx
		mov	ds:header_width_available, eax
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001A3B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001A3B:				; CODE XREF: init_header+1E5j
		mov	ebx, [ebp+var_4]
		leave
		retn
init_header	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void init_page()
init_page	proc near		; CODE XREF: print_page+7p

j		= dword	ptr -10h
p		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_8001AC2
		call	store_columns
		mov	eax, columns
		sub	eax, 1
		mov	[ebp+j], eax
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001A7F
; ---------------------------------------------------------------------------

loc_8001A6B:				; CODE XREF: init_page+43j
		mov	eax, [ebp+p]
		mov	edx, [eax+18h]
		mov	eax, [ebp+p]
		mov	[eax+1Ch], edx
		sub	[ebp+j], 1
		add	[ebp+p], 28h

loc_8001A7F:				; CODE XREF: init_page+29j
		cmp	[ebp+j], 0
		jnz	short loc_8001A6B
		movzx	eax, ds:balance_columns
		test	al, al
		jz	short loc_8001A9E
		mov	eax, [ebp+p]
		mov	edx, [eax+18h]
		mov	eax, [ebp+p]
		mov	[eax+1Ch], edx
		jmp	short loc_8001B04
; ---------------------------------------------------------------------------

loc_8001A9E:				; CODE XREF: init_page+4Ej
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_8001AB6
		mov	edx, ds:lines_per_body
		mov	eax, [ebp+p]
		mov	[eax+1Ch], edx
		jmp	short loc_8001B04
; ---------------------------------------------------------------------------

loc_8001AB6:				; CODE XREF: init_page+66j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+1Ch], 0
		jmp	short loc_8001B04
; ---------------------------------------------------------------------------

loc_8001AC2:				; CODE XREF: init_page+Fj
		mov	eax, columns
		mov	[ebp+j], eax
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001AFE
; ---------------------------------------------------------------------------

loc_8001AD4:				; CODE XREF: init_page+C2j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_8001AEC
		mov	edx, ds:lines_per_body
		mov	eax, [ebp+p]
		mov	[eax+1Ch], edx
		jmp	short loc_8001AF6
; ---------------------------------------------------------------------------

loc_8001AEC:				; CODE XREF: init_page+9Cj
		mov	eax, [ebp+p]
		mov	dword ptr [eax+1Ch], 0

loc_8001AF6:				; CODE XREF: init_page+AAj
		sub	[ebp+j], 1
		add	[ebp+p], 28h

loc_8001AFE:				; CODE XREF: init_page+92j
		cmp	[ebp+j], 0
		jnz	short loc_8001AD4

loc_8001B04:				; CODE XREF: init_page+5Cj
					; init_page+74j ...
		nop
		leave
		retn
init_page	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl align_column(COLUMN_0 *p)
align_column	proc near		; CODE XREF: print_page+188p
					; print_page+1B7p ...

p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+p]
		mov	eax, [eax+20h]
		mov	ds:padding_not_printed,	eax
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		test	eax, eax
		jle	short loc_8001B50
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		sub	esp, 0Ch
		push	eax		; position
		call	pad_across_to
		add	esp, 10h
		mov	ds:padding_not_printed,	0

loc_8001B50:				; CODE XREF: align_column+22j
		movzx	eax, ds:use_col_separator
		test	al, al
		jz	short loc_8001B60
		call	print_sep_string

loc_8001B60:				; CODE XREF: align_column+52j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_8001B79
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	add_line_number
		add	esp, 10h

loc_8001B79:				; CODE XREF: align_column+62j
		nop
		leave
		retn
align_column	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	print_page()
print_page	proc near		; CODE XREF: print_files:loc_800183Ep

pv		= byte ptr -15h
j		= dword	ptr -14h
lines_left_on_page= dword ptr -10h
p		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		call	init_page
		call	cols_ready_to_print
		test	eax, eax
		jnz	short loc_8001B9B
		mov	eax, 0
		jmp	loc_8001EA5
; ---------------------------------------------------------------------------

loc_8001B9B:				; CODE XREF: print_page+13j
		movzx	eax, extremities
		test	al, al
		jz	short loc_8001BAD
		mov	ds:print_a_header, 1

loc_8001BAD:				; CODE XREF: print_page+28j
		mov	ds:pad_vertically, 0
		mov	[ebp+pv], 0
		mov	eax, ds:lines_per_body
		mov	[ebp+lines_left_on_page], eax
		movzx	eax, ds:double_space
		test	al, al
		jz	loc_8001DC4
		shl	[ebp+lines_left_on_page], 1
		jmp	loc_8001DC4
; ---------------------------------------------------------------------------

loc_8001BD7:				; CODE XREF: print_page+255j
		mov	ds:output_position, 0
		mov	ds:spaces_not_printed, 0
		mov	ds:separators_not_printed, 0
		mov	ds:pad_vertically, 0
		mov	ds:align_empty_cols, 0
		mov	ds:empty_line, 1
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	loc_8001D5E
; ---------------------------------------------------------------------------

loc_8001C1E:				; CODE XREF: print_page+1EAj
		mov	ds:input_position, 0
		mov	eax, [ebp+p]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jg	short loc_8001C41
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 1
		jnz	loc_8001D0E

loc_8001C41:				; CODE XREF: print_page+B4j
		mov	ds:FF_only, 0
		mov	eax, [ebp+p]
		mov	eax, [eax+20h]
		mov	ds:padding_not_printed,	eax
		mov	eax, [ebp+p]
		mov	eax, [eax+0Ch]
		sub	esp, 0Ch
		push	[ebp+p]
		call	eax
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001C79
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	read_rest_of_line
		add	esp, 10h

loc_8001C79:				; CODE XREF: print_page+EDj
		movzx	eax, ds:pad_vertically
		or	al, [ebp+pv]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+pv], al
		mov	eax, [ebp+p]
		mov	eax, [eax+1Ch]
		lea	edx, [eax-1]
		mov	eax, [ebp+p]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+p]
		mov	eax, [eax+1Ch]
		test	eax, eax
		jg	short loc_8001CB4
		call	cols_ready_to_print
		test	eax, eax
		jle	loc_8001D6E

loc_8001CB4:				; CODE XREF: print_page+129j
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8001D3D
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_8001D3D
		movzx	eax, ds:empty_line
		test	al, al
		jz	short loc_8001CDD
		mov	ds:align_empty_cols, 1
		jmp	short loc_8001D3D
; ---------------------------------------------------------------------------

loc_8001CDD:				; CODE XREF: print_page+156j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 3
		jz	short loc_8001CFE
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 2
		jnz	short loc_8001D3D
		movzx	eax, ds:FF_only
		test	al, al
		jz	short loc_8001D3D

loc_8001CFE:				; CODE XREF: print_page+16Aj
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	align_column
		add	esp, 10h
		jmp	short loc_8001D3D
; ---------------------------------------------------------------------------

loc_8001D0E:				; CODE XREF: print_page+BFj
		movzx	eax, ds:parallel_files
		test	al, al
		jz	short loc_8001D3E
		movzx	eax, ds:empty_line
		test	al, al
		jz	short loc_8001D2D
		mov	ds:align_empty_cols, 1
		jmp	short loc_8001D3E
; ---------------------------------------------------------------------------

loc_8001D2D:				; CODE XREF: print_page+1A6j
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	align_column
		add	esp, 10h
		jmp	short loc_8001D3E
; ---------------------------------------------------------------------------

loc_8001D3D:				; CODE XREF: print_page+141j
					; print_page+14Bj ...
		nop

loc_8001D3E:				; CODE XREF: print_page+19Bj
					; print_page+1AFj ...
		movzx	eax, ds:use_col_separator
		test	al, al
		jz	short loc_8001D56
		mov	eax, ds:separators_not_printed
		add	eax, 1
		mov	ds:separators_not_printed, eax

loc_8001D56:				; CODE XREF: print_page+1CBj
		add	[ebp+j], 1
		add	[ebp+p], 28h

loc_8001D5E:				; CODE XREF: print_page+9Dj
		mov	eax, columns
		cmp	[ebp+j], eax
		jle	loc_8001C1E
		jmp	short loc_8001D6F
; ---------------------------------------------------------------------------

loc_8001D6E:				; CODE XREF: print_page+132j
		nop

loc_8001D6F:				; CODE XREF: print_page+1F0j
		movzx	eax, ds:pad_vertically
		test	al, al
		jz	short loc_8001D8B
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	[ebp+lines_left_on_page], 1

loc_8001D8B:				; CODE XREF: print_page+1FCj
		call	cols_ready_to_print
		test	eax, eax
		jg	short loc_8001DA2
		movzx	eax, extremities
		xor	eax, 1
		test	al, al
		jnz	short loc_8001DD9

loc_8001DA2:				; CODE XREF: print_page+216j
		movzx	eax, ds:double_space
		test	al, al
		jz	short loc_8001DC4
		cmp	[ebp+pv], 0
		jz	short loc_8001DC4
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	[ebp+lines_left_on_page], 1

loc_8001DC4:				; CODE XREF: print_page+4Dj
					; print_page+56j ...
		cmp	[ebp+lines_left_on_page], 0
		jle	short loc_8001DDA
		call	cols_ready_to_print
		test	eax, eax
		jg	loc_8001BD7
		jmp	short loc_8001DDA
; ---------------------------------------------------------------------------

loc_8001DD9:				; CODE XREF: print_page+224j
		nop

loc_8001DDA:				; CODE XREF: print_page+24Cj
					; print_page+25Bj
		cmp	[ebp+lines_left_on_page], 0
		jnz	short loc_8001E14
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001E0A
; ---------------------------------------------------------------------------

loc_8001DF1:				; CODE XREF: print_page+296j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_8001E02
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 1

loc_8001E02:				; CODE XREF: print_page+27Dj
		add	[ebp+j], 1
		add	[ebp+p], 28h

loc_8001E0A:				; CODE XREF: print_page+273j
		mov	eax, columns
		cmp	[ebp+j], eax
		jle	short loc_8001DF1

loc_8001E14:				; CODE XREF: print_page+262j
		movzx	eax, [ebp+pv]
		mov	ds:pad_vertically, al
		movzx	eax, ds:pad_vertically
		test	al, al
		jz	short loc_8001E47
		movzx	eax, extremities
		test	al, al
		jz	short loc_8001E47
		mov	eax, [ebp+lines_left_on_page]
		add	eax, 5
		sub	esp, 0Ch
		push	eax		; lines
		call	pad_down
		add	esp, 10h
		jmp	short loc_8001E71
; ---------------------------------------------------------------------------

loc_8001E47:				; CODE XREF: print_page+2AAj
					; print_page+2B5j
		movzx	eax, ds:keep_FF
		test	al, al
		jz	short loc_8001E71
		movzx	eax, ds:print_a_FF
		test	al, al
		jz	short loc_8001E71
		sub	esp, 0Ch
		push	0Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:print_a_FF, 0

loc_8001E71:				; CODE XREF: print_page+2C9j
					; print_page+2D4j ...
		mov	ecx, dword ptr last_page_number
		mov	ebx, dword ptr last_page_number+4
		mov	eax, dword ptr ds:page_number
		mov	edx, dword ptr ds:page_number+4
		cmp	ebx, edx
		ja	short loc_8001E9B
		cmp	ebx, edx
		jb	short loc_8001E94
		cmp	ecx, eax
		jnb	short loc_8001E9B

loc_8001E94:				; CODE XREF: print_page+312j
		mov	eax, 0
		jmp	short loc_8001EA5
; ---------------------------------------------------------------------------

loc_8001E9B:				; CODE XREF: print_page+30Ej
					; print_page+316j
		call	reset_status
		mov	eax, 1

loc_8001EA5:				; CODE XREF: print_page+1Aj
					; print_page+31Dj
		mov	ebx, [ebp+var_4]
		leave
		retn
print_page	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void init_store_cols()
init_store_cols	proc near		; CODE XREF: print_files+3Bp

total_lines	= dword	ptr -10h
chars_if_truncate= dword ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, ds:lines_per_body
		mov	eax, columns
		imul	eax, edx
		mov	[ebp+total_lines], eax
		mov	eax, ds:chars_per_column
		add	eax, 1
		imul	eax, [ebp+total_lines]
		mov	[ebp+chars_if_truncate], eax
		mov	eax, ds:line_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+total_lines]
		add	eax, 1
		shl	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:line_vector,	eax
		mov	eax, ds:end_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+total_lines]
		shl	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:end_vector, eax
		mov	eax, ds:buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, ds:use_col_separator
		test	al, al
		jz	short loc_8001F46
		mov	eax, [ebp+chars_if_truncate]
		add	eax, eax
		jmp	short loc_8001F49
; ---------------------------------------------------------------------------

loc_8001F46:				; CODE XREF: init_store_cols+93j
		mov	eax, [ebp+chars_if_truncate]

loc_8001F49:				; CODE XREF: init_store_cols+9Aj
		mov	ds:buff_allocated, eax
		mov	eax, ds:buff_allocated
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:buff, eax
		nop
		leave
		retn
init_store_cols	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void store_columns()
store_columns	proc near		; CODE XREF: init_page+11p

i		= dword	ptr -20h
j		= dword	ptr -1Ch
line		= dword	ptr -18h
buff_start	= dword	ptr -14h
last_col	= dword	ptr -10h
p		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+line], 0
		mov	ds:buff_current, 0
		mov	[ebp+buff_start], 0
		movzx	eax, ds:balance_columns
		test	al, al
		jz	short loc_8001F9A
		mov	eax, columns
		mov	[ebp+last_col],	eax
		jmp	short loc_8001FA5
; ---------------------------------------------------------------------------

loc_8001F9A:				; CODE XREF: store_columns+27j
		mov	eax, columns
		sub	eax, 1
		mov	[ebp+last_col],	eax

loc_8001FA5:				; CODE XREF: store_columns+31j
		mov	[ebp+i], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8001FC8
; ---------------------------------------------------------------------------

loc_8001FB6:				; CODE XREF: store_columns+67j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+18h], 0
		add	[ebp+i], 1
		add	[ebp+p], 28h

loc_8001FC8:				; CODE XREF: store_columns+4Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+last_col]
		jle	short loc_8001FB6
		mov	[ebp+i], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	loc_80020AD
; ---------------------------------------------------------------------------

loc_8001FE4:				; CODE XREF: store_columns+155j
		mov	edx, [ebp+line]
		mov	eax, [ebp+p]
		mov	[eax+14h], edx
		mov	eax, ds:lines_per_body
		mov	[ebp+j], eax
		jmp	loc_8002092
; ---------------------------------------------------------------------------

loc_8001FFA:				; CODE XREF: store_columns+138j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	loc_800208E
		mov	ds:input_position, 0
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	read_line
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8002035
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	read_rest_of_line
		add	esp, 10h

loc_8002035:				; CODE XREF: store_columns+BEj
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_8002049
		mov	eax, ds:buff_current
		cmp	[ebp+buff_start], eax
		jz	short loc_800208E

loc_8002049:				; CODE XREF: store_columns+D6j
		mov	eax, [ebp+p]
		mov	eax, [eax+18h]
		lea	edx, [eax+1]
		mov	eax, [ebp+p]
		mov	[eax+18h], edx
		mov	eax, ds:line_vector
		mov	edx, [ebp+line]
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+buff_start]
		mov	[edx], eax
		mov	ecx, ds:end_vector
		mov	eax, [ebp+line]
		lea	edx, [eax+1]
		mov	[ebp+line], edx
		shl	eax, 2
		lea	edx, [ecx+eax]
		mov	eax, ds:input_position
		mov	[edx], eax
		mov	eax, ds:buff_current
		mov	[ebp+buff_start], eax

loc_800208E:				; CODE XREF: store_columns+9Bj
					; store_columns+E0j
		sub	[ebp+j], 1

loc_8002092:				; CODE XREF: store_columns+8Ej
		cmp	[ebp+j], 0
		jz	short loc_80020A5
		mov	eax, ds:files_ready_to_read
		test	eax, eax
		jnz	loc_8001FFA

loc_80020A5:				; CODE XREF: store_columns+12Fj
		add	[ebp+i], 1
		add	[ebp+p], 28h

loc_80020AD:				; CODE XREF: store_columns+78j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+last_col]
		jg	short loc_80020C2
		mov	eax, ds:files_ready_to_read
		test	eax, eax
		jnz	loc_8001FE4

loc_80020C2:				; CODE XREF: store_columns+14Cj
		mov	eax, ds:line_vector
		mov	edx, [ebp+line]
		shl	edx, 2
		add	edx, eax
		mov	eax, [ebp+buff_start]
		mov	[edx], eax
		movzx	eax, ds:balance_columns
		test	al, al
		jz	short loc_80020EE
		mov	eax, [ebp+line]
		sub	esp, 0Ch
		push	eax		; total_stored
		call	balance
		add	esp, 10h

loc_80020EE:				; CODE XREF: store_columns+176j
		nop
		leave
		retn
store_columns	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl balance(int total_stored)
balance		proc near		; CODE XREF: store_columns+17Fp

p		= dword	ptr -10h
i		= dword	ptr -0Ch
lines		= dword	ptr -8
first_line	= dword	ptr -4
total_stored	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+first_line], 0
		mov	[ebp+i], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8002155
; ---------------------------------------------------------------------------

loc_800210F:				; CODE XREF: balance+6Cj
		mov	ecx, columns
		mov	eax, [ebp+total_stored]
		cdq
		idiv	ecx
		mov	[ebp+lines], eax
		mov	ecx, columns
		mov	eax, [ebp+total_stored]
		cdq
		idiv	ecx
		mov	eax, edx
		cmp	eax, [ebp+i]
		jl	short loc_8002135
		add	[ebp+lines], 1

loc_8002135:				; CODE XREF: balance+3Ej
		mov	eax, [ebp+p]
		mov	edx, [ebp+lines]
		mov	[eax+18h], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+first_line]
		mov	[eax+14h], edx
		mov	eax, [ebp+lines]
		add	[ebp+first_line], eax
		add	[ebp+i], 1
		add	[ebp+p], 28h

loc_8002155:				; CODE XREF: balance+1Cj
		mov	eax, columns
		cmp	[ebp+i], eax
		jle	short loc_800210F
		nop
		leave
		retn
balance		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl store_char(char c)
store_char	proc near		; DATA XREF: init_funcs+8Ao
					; init_funcs+157o ...

c		= byte ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		mov	edx, ds:buff_current
		mov	eax, ds:buff_allocated
		cmp	edx, eax
		jb	short loc_8002198
		mov	eax, ds:buff
		sub	esp, 8
		push	offset buff_allocated
		push	eax
		call	x2realloc
		add	esp, 10h
		mov	ds:buff, eax

loc_8002198:				; CODE XREF: store_char+19j
		mov	ecx, ds:buff
		mov	eax, ds:buff_current
		lea	edx, [eax+1]
		mov	ds:buff_current, edx
		lea	edx, [ecx+eax]
		movzx	eax, [ebp+c]
		mov	[edx], al
		nop
		leave
		retn
store_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_line_number(COLUMN_0	*p)
add_line_number	proc near		; CODE XREF: align_column+6Ap
					; read_line+297p

i		= dword	ptr -14h
s		= dword	ptr -10h
left_cut	= dword	ptr -0Ch
var_4		= dword	ptr -4
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	edx, ds:line_number
		mov	eax, ds:power_10
		cmp	edx, eax
		jge	short loc_80021F1
		mov	ecx, ds:line_number
		mov	edx, chars_per_number
		mov	eax, ds:number_buff
		push	ecx
		push	edx
		push	offset aD	; "%*d"
		push	eax		; s
		call	sprintf
		add	esp, 10h
		jmp	short loc_800221F
; ---------------------------------------------------------------------------

loc_80021F1:				; CODE XREF: add_line_number+14j
		mov	eax, ds:line_number
		mov	ecx, ds:power_10
		cdq
		idiv	ecx
		mov	[ebp+left_cut],	edx
		mov	edx, chars_per_number
		mov	eax, ds:number_buff
		push	[ebp+left_cut]
		push	edx
		push	offset a0D	; "%0*d"
		push	eax		; s
		call	sprintf
		add	esp, 10h

loc_800221F:				; CODE XREF: add_line_number+37j
		mov	eax, ds:line_number
		add	eax, 1
		mov	ds:line_number,	eax
		mov	eax, ds:number_buff
		mov	[ebp+s], eax
		mov	eax, chars_per_number
		mov	[ebp+i], eax
		jmp	short loc_8002260
; ---------------------------------------------------------------------------

loc_800223E:				; CODE XREF: add_line_number+ACj
		mov	eax, [ebp+p]
		mov	edx, [eax+10h]
		mov	eax, [ebp+s]
		lea	ecx, [eax+1]
		mov	[ebp+s], ecx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax
		call	edx
		add	esp, 10h
		sub	[ebp+i], 1

loc_8002260:				; CODE XREF: add_line_number+84j
		cmp	[ebp+i], 0
		jg	short loc_800223E
		mov	eax, columns
		cmp	eax, 1
		jle	short loc_80022C9
		movzx	eax, byte ptr number_separator ; "\t"
		cmp	al, 9
		jnz	short loc_80022AE
		mov	edx, ds:number_width
		mov	eax, chars_per_number
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+i], eax
		jmp	short loc_800229F
; ---------------------------------------------------------------------------

loc_800228F:				; CODE XREF: add_line_number+F2j
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		sub	esp, 0Ch
		push	20h
		call	eax
		add	esp, 10h

loc_800229F:				; CODE XREF: add_line_number+D5j
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	[ebp+i], edx
		test	eax, eax
		jg	short loc_800228F
		jmp	short loc_8002313
; ---------------------------------------------------------------------------

loc_80022AE:				; CODE XREF: add_line_number+C1j
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		movzx	edx, byte ptr number_separator ; "\t"
		movsx	edx, dl
		sub	esp, 0Ch
		push	edx
		call	eax
		add	esp, 10h
		jmp	short loc_8002313
; ---------------------------------------------------------------------------

loc_80022C9:				; CODE XREF: add_line_number+B6j
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		movzx	edx, byte ptr number_separator ; "\t"
		movsx	edx, dl
		sub	esp, 0Ch
		push	edx
		call	eax
		add	esp, 10h
		movzx	eax, byte ptr number_separator ; "\t"
		cmp	al, 9
		jnz	short loc_8002313
		mov	ecx, chars_per_output_tab
		mov	eax, ds:output_position
		mov	ebx, chars_per_output_tab
		cdq
		idiv	ebx
		mov	eax, edx
		sub	ecx, eax
		mov	edx, ecx
		mov	eax, ds:output_position
		add	eax, edx
		mov	ds:output_position, eax

loc_8002313:				; CODE XREF: add_line_number+F4j
					; add_line_number+10Fj	...
		movzx	eax, ds:truncate_lines
		test	al, al
		jz	short loc_800233E
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jz	short loc_800233E
		mov	edx, ds:input_position
		mov	eax, ds:number_width
		add	eax, edx
		mov	ds:input_position, eax

loc_800233E:				; CODE XREF: add_line_number+164j
					; add_line_number+172j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
add_line_number	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl pad_across_to(int position)
pad_across_to	proc near		; CODE XREF: align_column+37p
					; print_header+29p ...

h		= dword	ptr -0Ch
position	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:output_position
		mov	[ebp+h], eax
		movzx	eax, ds:tabify_output
		test	al, al
		jz	short loc_800237D
		mov	eax, ds:output_position
		mov	edx, [ebp+position]
		sub	edx, eax
		mov	eax, edx
		mov	ds:spaces_not_printed, eax
		jmp	short loc_8002391
; ---------------------------------------------------------------------------

loc_8002370:				; CODE XREF: pad_across_to+43j
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h

loc_800237D:				; CODE XREF: pad_across_to+17j
		add	[ebp+h], 1
		mov	eax, [ebp+h]
		cmp	eax, [ebp+position]
		jle	short loc_8002370
		mov	eax, [ebp+position]
		mov	ds:output_position, eax

loc_8002391:				; CODE XREF: pad_across_to+2Aj
		nop
		leave
		retn
pad_across_to	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl pad_down(int lines)
pad_down	proc near		; CODE XREF: print_page+2C1p

i		= dword	ptr -0Ch
lines		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		movzx	eax, ds:use_form_feed
		test	al, al
		jz	short loc_80023B4
		sub	esp, 0Ch
		push	0Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80023D3
; ---------------------------------------------------------------------------

loc_80023B4:				; CODE XREF: pad_down+Fj
		mov	eax, [ebp+lines]
		mov	[ebp+i], eax
		jmp	short loc_80023CD
; ---------------------------------------------------------------------------

loc_80023BC:				; CODE XREF: pad_down+3Dj
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	[ebp+i], 1

loc_80023CD:				; CODE XREF: pad_down+26j
		cmp	[ebp+i], 0
		jnz	short loc_80023BC

loc_80023D3:				; CODE XREF: pad_down+1Ej
		nop
		leave
		retn
pad_down	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl read_rest_of_line(COLUMN_0 *p)
read_rest_of_line proc near		; CODE XREF: print_page+F5p
					; store_columns+C6p

f		= dword	ptr -10h
c		= dword	ptr -0Ch
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	[ebp+f], eax
		jmp	short loc_800244C
; ---------------------------------------------------------------------------

loc_80023E6:				; CODE XREF: read_rest_of_line+8Bj
		cmp	[ebp+c], 0Ch
		jnz	short loc_8002436
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jz	short loc_8002414
		sub	esp, 8
		push	[ebp+f]		; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h

loc_8002414:				; CODE XREF: read_rest_of_line+2Bj
		movzx	eax, ds:keep_FF
		test	al, al
		jz	short loc_8002426
		mov	ds:print_a_FF, 1

loc_8002426:				; CODE XREF: read_rest_of_line+47j
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	hold_file
		add	esp, 10h
		jmp	short loc_8002463
; ---------------------------------------------------------------------------

loc_8002436:				; CODE XREF: read_rest_of_line+14j
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_800244C
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	close_file
		add	esp, 10h
		jmp	short loc_8002463
; ---------------------------------------------------------------------------

loc_800244C:				; CODE XREF: read_rest_of_line+Ej
					; read_rest_of_line+64j
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jnz	short loc_80023E6

loc_8002463:				; CODE XREF: read_rest_of_line+5Ej
					; read_rest_of_line+74j
		nop
		leave
		retn
read_rest_of_line endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl skip_read(COLUMN_0 *p, int column_number)
skip_read	proc near		; CODE XREF: skip_to_page+52p
					; skip_to_page+A5p

single_ff	= byte ptr -19h
c		= dword	ptr -18h
i		= dword	ptr -14h
q		= dword	ptr -10h
f		= dword	ptr -0Ch
p		= dword	ptr  8
column_number	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	[ebp+f], eax
		mov	[ebp+single_ff], 0
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ch
		jnz	short loc_80024C2
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+25h]
		test	al, al
		jz	short loc_80024C2
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jnz	short loc_80024C2
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax

loc_80024C2:				; CODE XREF: skip_read+27j
					; skip_read+32j ...
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0
		cmp	[ebp+c], 0Ch
		jnz	short loc_80024D3
		mov	[ebp+single_ff], 1

loc_80024D3:				; CODE XREF: skip_read+67j
		movzx	eax, ds:last_line
		test	al, al
		jz	loc_80025A0
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 1
		jmp	loc_80025A0
; ---------------------------------------------------------------------------

loc_80024EE:				; CODE XREF: skip_read+13Ej
		cmp	[ebp+c], 0Ch
		jnz	loc_8002579
		movzx	eax, ds:last_line
		test	al, al
		jz	short loc_8002541
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jz	short loc_800253A
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		mov	eax, columns
		mov	[ebp+i], eax
		jmp	short loc_8002532
; ---------------------------------------------------------------------------

loc_8002523:				; CODE XREF: skip_read+D0j
		mov	eax, [ebp+q]
		mov	byte ptr [eax+25h], 0
		add	[ebp+q], 28h
		sub	[ebp+i], 1

loc_8002532:				; CODE XREF: skip_read+BBj
		cmp	[ebp+i], 0
		jnz	short loc_8002523
		jmp	short loc_8002541
; ---------------------------------------------------------------------------

loc_800253A:				; CODE XREF: skip_read+A9j
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0

loc_8002541:				; CODE XREF: skip_read+9Bj
					; skip_read+D2j
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jz	short loc_8002569
		sub	esp, 8
		push	[ebp+f]		; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h

loc_8002569:				; CODE XREF: skip_read+F0j
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	hold_file
		add	esp, 10h
		jmp	short loc_80025AA
; ---------------------------------------------------------------------------

loc_8002579:				; CODE XREF: skip_read+8Cj
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_800258F
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	close_file
		add	esp, 10h
		jmp	short loc_80025AA
; ---------------------------------------------------------------------------

loc_800258F:				; CODE XREF: skip_read+117j
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax

loc_80025A0:				; CODE XREF: skip_read+76j
					; skip_read+83j
		cmp	[ebp+c], 0Ah
		jnz	loc_80024EE

loc_80025AA:				; CODE XREF: skip_read+111j
					; skip_read+127j
		movzx	eax, skip_count
		test	al, al
		jz	short loc_80025E1
		movzx	eax, ds:parallel_files
		xor	eax, 1
		test	al, al
		jnz	short loc_80025C9
		cmp	[ebp+column_number], 1
		jnz	short loc_80025E1

loc_80025C9:				; CODE XREF: skip_read+15Bj
		movzx	eax, [ebp+single_ff]
		xor	eax, 1
		test	al, al
		jz	short loc_80025E1
		mov	eax, line_count
		add	eax, 1
		mov	line_count, eax

loc_80025E1:				; CODE XREF: skip_read+14Dj
					; skip_read+161j ...
		nop
		leave
		retn
skip_read	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_white_space()
print_white_space proc near		; CODE XREF: print_sep_string+30p
					; print_sep_string+60p	...

h_old		= dword	ptr -14h
goal		= dword	ptr -10h
h_new		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:output_position
		mov	[ebp+h_old], eax
		mov	edx, ds:spaces_not_printed
		mov	eax, [ebp+h_old]
		add	eax, edx
		mov	[ebp+goal], eax
		jmp	short loc_800261F
; ---------------------------------------------------------------------------

loc_8002603:				; CODE XREF: print_white_space+6Cj
		movzx	eax, byte ptr output_tab_char ;	"\t"
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, [ebp+h_new]
		mov	[ebp+h_old], eax

loc_800261F:				; CODE XREF: print_white_space+1Dj
		mov	eax, [ebp+goal]
		sub	eax, [ebp+h_old]
		cmp	eax, 1
		jle	short loc_8002661
		mov	ecx, chars_per_output_tab
		mov	ebx, chars_per_output_tab
		mov	eax, [ebp+h_old]
		cdq
		idiv	ebx
		mov	eax, edx
		sub	ecx, eax
		mov	edx, ecx
		mov	eax, [ebp+h_old]
		add	eax, edx
		mov	[ebp+h_new], eax
		mov	eax, [ebp+h_new]
		cmp	eax, [ebp+goal]
		jle	short loc_8002603
		jmp	short loc_8002661
; ---------------------------------------------------------------------------

loc_8002654:				; CODE XREF: print_white_space+87j
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8002661:				; CODE XREF: print_white_space+44j
					; print_white_space+6Ej
		add	[ebp+h_old], 1
		mov	eax, [ebp+h_old]
		cmp	eax, [ebp+goal]
		jle	short loc_8002654
		mov	eax, [ebp+goal]
		mov	ds:output_position, eax
		mov	ds:spaces_not_printed, 0
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
print_white_space endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_sep_string()
print_sep_string proc near		; CODE XREF: align_column+54p
					; read_line+281p ...

s		= dword	ptr -10h
l		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:col_sep_length
		mov	[ebp+l], eax
		mov	eax, col_sep_string
		mov	[ebp+s], eax
		mov	eax, ds:separators_not_printed
		test	eax, eax
		jg	loc_800273A
		mov	eax, ds:spaces_not_printed
		test	eax, eax
		jle	loc_8002743
		call	print_white_space
		jmp	loc_8002743
; ---------------------------------------------------------------------------

loc_80026BF:				; CODE XREF: print_sep_string+98j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jnz	short loc_80026DC
		add	[ebp+s], 1
		mov	eax, ds:spaces_not_printed
		add	eax, 1
		mov	ds:spaces_not_printed, eax
		jmp	short loc_8002712
; ---------------------------------------------------------------------------

loc_80026DC:				; CODE XREF: print_sep_string+42j
		mov	eax, ds:spaces_not_printed
		test	eax, eax
		jle	short loc_80026EA
		call	print_white_space

loc_80026EA:				; CODE XREF: print_sep_string+5Ej
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:output_position
		add	eax, 1
		mov	ds:output_position, eax

loc_8002712:				; CODE XREF: print_sep_string+55j
					; print_sep_string+BCj
		mov	eax, [ebp+l]
		lea	edx, [eax-1]
		mov	[ebp+l], edx
		test	eax, eax
		jg	short loc_80026BF
		mov	eax, ds:spaces_not_printed
		test	eax, eax
		jle	short loc_800272D
		call	print_white_space

loc_800272D:				; CODE XREF: print_sep_string+A1j
		mov	eax, ds:separators_not_printed
		sub	eax, 1
		mov	ds:separators_not_printed, eax

loc_800273A:				; CODE XREF: print_sep_string+1Dj
		mov	eax, ds:separators_not_printed
		test	eax, eax
		jg	short loc_8002712

loc_8002743:				; CODE XREF: print_sep_string+2Aj
					; print_sep_string+35j
		nop
		leave
		retn
print_sep_string endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_clump(COLUMN_0 *p,	int n, char *clump)
print_clump	proc near		; CODE XREF: read_line+2C5p
					; read_line+3BEp

p		= dword	ptr  8
n		= dword	ptr  0Ch
clump		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		jmp	short loc_800276C
; ---------------------------------------------------------------------------

loc_800274E:				; CODE XREF: print_clump+31j
		mov	eax, [ebp+p]
		mov	edx, [eax+10h]
		mov	eax, [ebp+clump]
		lea	ecx, [eax+1]
		mov	[ebp+clump], ecx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax
		call	edx
		add	esp, 10h

loc_800276C:				; CODE XREF: print_clump+6j
		mov	eax, [ebp+n]
		lea	edx, [eax-1]
		mov	[ebp+n], edx
		test	eax, eax
		jnz	short loc_800274E
		nop
		leave
		retn
print_clump	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_char(char c)
print_char	proc near		; CODE XREF: print_stored+126p
					; DATA XREF: init_funcs+A0o ...

c		= byte ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		movzx	eax, ds:tabify_output
		test	al, al
		jz	short loc_8002806
		cmp	[ebp+c], 20h
		jnz	short loc_80027A9
		mov	eax, ds:spaces_not_printed
		add	eax, 1
		mov	ds:spaces_not_printed, eax
		jmp	short loc_8002816
; ---------------------------------------------------------------------------

loc_80027A9:				; CODE XREF: print_char+1Cj
		mov	eax, ds:spaces_not_printed
		test	eax, eax
		jle	short loc_80027B7
		call	print_white_space

loc_80027B7:				; CODE XREF: print_char+34j
		call	__ctype_b_loc
		mov	ebx, [eax]
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jnz	short loc_80027F9
		cmp	[ebp+c], 8
		jnz	short loc_8002806
		mov	eax, ds:output_position
		sub	eax, 1
		mov	ds:output_position, eax
		jmp	short loc_8002806
; ---------------------------------------------------------------------------

loc_80027F9:				; CODE XREF: print_char+66j
		mov	eax, ds:output_position
		add	eax, 1
		mov	ds:output_position, eax

loc_8002806:				; CODE XREF: print_char+16j
					; print_char+6Cj ...
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8002816:				; CODE XREF: print_char+2Bj
		mov	ebx, [ebp+var_4]
		leave
		retn
print_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	skip_to_page(uintmax_t page)
skip_to_page	proc near		; CODE XREF: print_files+6Ap

page		= qword	ptr -30h
i		= dword	ptr -1Ch
j		= dword	ptr -18h
p		= dword	ptr -14h
n		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+page], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+page+4],	eax
		mov	dword ptr [ebp+n], 1
		mov	dword ptr [ebp+n+4], 0
		jmp	loc_8002968
; ---------------------------------------------------------------------------

loc_8002840:				; CODE XREF: skip_to_page+156j
					; skip_to_page+164j
		mov	[ebp+i], 1
		jmp	short loc_800288B
; ---------------------------------------------------------------------------

loc_8002849:				; CODE XREF: skip_to_page+78j
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_800287D
; ---------------------------------------------------------------------------

loc_800285A:				; CODE XREF: skip_to_page+6Aj
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_8002875
		sub	esp, 8
		push	[ebp+j]		; column_number
		push	[ebp+p]		; p
		call	skip_read
		add	esp, 10h

loc_8002875:				; CODE XREF: skip_to_page+47j
		add	[ebp+j], 1
		add	[ebp+p], 28h

loc_800287D:				; CODE XREF: skip_to_page+3Dj
		mov	eax, columns
		cmp	[ebp+j], eax
		jle	short loc_800285A
		add	[ebp+i], 1

loc_800288B:				; CODE XREF: skip_to_page+2Cj
		mov	eax, ds:lines_per_body
		cmp	[ebp+i], eax
		jl	short loc_8002849
		mov	ds:last_line, 1
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_80028D0
; ---------------------------------------------------------------------------

loc_80028AD:				; CODE XREF: skip_to_page+BDj
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_80028C8
		sub	esp, 8
		push	[ebp+j]		; column_number
		push	[ebp+p]		; p
		call	skip_read
		add	esp, 10h

loc_80028C8:				; CODE XREF: skip_to_page+9Aj
		add	[ebp+j], 1
		add	[ebp+p], 28h

loc_80028D0:				; CODE XREF: skip_to_page+90j
		mov	eax, columns
		cmp	[ebp+j], eax
		jle	short loc_80028AD
		movzx	eax, storing_columns
		test	al, al
		jz	short loc_800291D
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+p], eax
		jmp	short loc_8002913
; ---------------------------------------------------------------------------

loc_80028F6:				; CODE XREF: skip_to_page+100j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 3
		jz	short loc_800290B
		mov	eax, [ebp+p]
		mov	dword ptr [eax+8], 2

loc_800290B:				; CODE XREF: skip_to_page+E4j
		add	[ebp+j], 1
		add	[ebp+p], 28h

loc_8002913:				; CODE XREF: skip_to_page+D9j
		mov	eax, columns
		cmp	[ebp+j], eax
		jle	short loc_80028F6

loc_800291D:				; CODE XREF: skip_to_page+C8j
		call	reset_status
		mov	ds:last_line, 0
		mov	eax, ds:files_ready_to_read
		test	eax, eax
		jg	short loc_8002960
		sub	esp, 0Ch
		push	offset aStartingPageNu ; "starting page	number %llu exceeds page "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	dword ptr [ebp+n+4]
		push	dword ptr [ebp+n]
		push	dword ptr [ebp+page+4]
		push	dword ptr [ebp+page]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	short loc_8002985
; ---------------------------------------------------------------------------

loc_8002960:				; CODE XREF: skip_to_page+115j
		add	dword ptr [ebp+n], 1
		adc	dword ptr [ebp+n+4], 0

loc_8002968:				; CODE XREF: skip_to_page+20j
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		cmp	edx, dword ptr [ebp+page+4]
		jb	loc_8002840
		cmp	edx, dword ptr [ebp+page+4]
		ja	short loc_8002985
		cmp	eax, dword ptr [ebp+page]
		jb	loc_8002840

loc_8002985:				; CODE XREF: skip_to_page+143j
					; skip_to_page+15Fj
		mov	eax, ds:files_ready_to_read
		test	eax, eax
		setnle	al
		leave
		retn
skip_to_page	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_header()
print_header	proc near		; CODE XREF: read_line+DCp
					; read_line+19Ap ...

available_width	= dword	ptr -12Ch
lhs_spaces	= dword	ptr -128h
rhs_spaces	= dword	ptr -124h
page_text	= byte ptr -120h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 130h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	ds:output_position, 0
		mov	eax, ds:chars_per_margin
		sub	esp, 0Ch
		push	eax		; position
		call	pad_across_to
		add	esp, 10h
		call	print_white_space
		mov	eax, dword ptr ds:page_number
		mov	edx, dword ptr ds:page_number+4
		or	eax, edx
		test	eax, eax
		jnz	short loc_80029F8
		sub	esp, 0Ch
		push	offset aPageNumberOver ; "page number overflow"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80029F8:				; CODE XREF: print_header+45j
		mov	ebx, dword ptr ds:page_number
		mov	esi, dword ptr ds:page_number+4
		mov	eax, ebx
		mov	edx, esi
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:page_number, eax
		mov	dword ptr ds:page_number+4, edx
		sub	esp, 0Ch
		push	offset aPageLlu	; "Page	%llu"
		call	gettext
		add	esp, 10h
		push	esi
		push	ebx
		push	eax		; format
		lea	eax, [ebp+page_text]
		push	eax		; s
		call	sprintf
		add	esp, 10h
		mov	ebx, ds:header_width_available
		sub	esp, 8
		push	0
		lea	eax, [ebp+page_text]
		push	eax
		call	gnu_mbswidth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+available_width], eax
		mov	eax, 0
		cmp	[ebp+available_width], 0
		cmovns	eax, [ebp+available_width]
		mov	[ebp+available_width], eax
		mov	eax, [ebp+available_width]
		sar	eax, 1
		mov	[ebp+lhs_spaces], eax
		mov	eax, [ebp+available_width]
		sub	eax, [ebp+lhs_spaces]
		mov	[ebp+rhs_spaces], eax
		mov	ecx, ds:file_text
		mov	edx, ds:date_text
		mov	eax, ds:chars_per_margin
		sub	esp, 8
		lea	ebx, [ebp+page_text]
		push	ebx
		push	offset asc_800386A ; " "
		push	[ebp+rhs_spaces]
		push	ecx
		push	offset asc_800386A ; " "
		push	[ebp+lhs_spaces]
		push	edx
		push	offset locale
		push	eax
		push	offset aSSSSSS	; "\n\n%*s%s%*s%s%*s%s\n\n\n"
		call	printf
		add	esp, 30h
		mov	ds:print_a_header, 0
		mov	ds:output_position, 0
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002B01
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002B01:				; CODE XREF: print_header+169j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
print_header	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	read_line(COLUMN_0 *p)
read_line	proc near		; CODE XREF: store_columns+B1p
					; DATA XREF: init_funcs+AAo ...

c		= dword	ptr -20h
chars		= dword	ptr -1Ch
j		= dword	ptr -18h
q		= dword	ptr -14h
last_input_position= dword ptr -10h
k		= dword	ptr -0Ch
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		mov	eax, ds:input_position
		mov	[ebp+last_input_position], eax
		cmp	[ebp+c], 0Ch
		jnz	short loc_8002B69
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+25h]
		test	al, al
		jz	short loc_8002B69
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jnz	short loc_8002B69
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax

loc_8002B69:				; CODE XREF: read_line+26j
					; read_line+31j ...
		mov	eax, [ebp+p]
		mov	byte ptr [eax+25h], 0
		mov	eax, [ebp+c]
		cmp	eax, 0Ah
		jz	loc_8002C44
		cmp	eax, 0Ch
		jz	short loc_8002B8F
		cmp	eax, 0FFFFFFFFh
		jz	loc_8002C15
		jmp	loc_8002C2D
; ---------------------------------------------------------------------------

loc_8002B8F:				; CODE XREF: read_line+77j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jz	short loc_8002BBD
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h

loc_8002BBD:				; CODE XREF: read_line+9Fj
		mov	ds:FF_only, 1
		movzx	eax, ds:print_a_header
		test	al, al
		jz	short loc_8002BEB
		movzx	eax, storing_columns
		xor	eax, 1
		test	al, al
		jz	short loc_8002BEB
		mov	ds:pad_vertically, 1
		call	print_header
		jmp	short loc_8002BFD
; ---------------------------------------------------------------------------

loc_8002BEB:				; CODE XREF: read_line+C5j
					; read_line+D3j
		movzx	eax, ds:keep_FF
		test	al, al
		jz	short loc_8002BFD
		mov	ds:print_a_FF, 1

loc_8002BFD:				; CODE XREF: read_line+E1j
					; read_line+ECj
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	hold_file
		add	esp, 10h
		mov	eax, 1
		jmp	locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002C15:				; CODE XREF: read_line+7Cj
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	close_file
		add	esp, 10h
		mov	eax, 1
		jmp	locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002C2D:				; CODE XREF: read_line+82j
		mov	eax, [ebp+c]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	char_to_clump
		add	esp, 10h
		mov	[ebp+chars], eax
		jmp	short loc_8002C45
; ---------------------------------------------------------------------------

loc_8002C44:				; CODE XREF: read_line+6Ej
		nop

loc_8002C45:				; CODE XREF: read_line+13Aj
		movzx	eax, ds:truncate_lines
		test	al, al
		jz	short loc_8002C71
		mov	edx, ds:input_position
		mov	eax, ds:chars_per_column
		cmp	edx, eax
		jle	short loc_8002C71
		mov	eax, [ebp+last_input_position]
		mov	ds:input_position, eax
		mov	eax, 0
		jmp	locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002C71:				; CODE XREF: read_line+146j
					; read_line+155j
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		cmp	eax, offset store_char
		jz	loc_8002D8E
		mov	ds:pad_vertically, 1
		movzx	eax, ds:print_a_header
		test	al, al
		jz	short loc_8002CA7
		movzx	eax, storing_columns
		xor	eax, 1
		test	al, al
		jz	short loc_8002CA7
		call	print_header

loc_8002CA7:				; CODE XREF: read_line+18Aj
					; read_line+198j
		movzx	eax, ds:parallel_files
		test	al, al
		jz	loc_8002D46
		movzx	eax, ds:align_empty_cols
		test	al, al
		jz	loc_8002D46
		mov	eax, ds:separators_not_printed
		mov	[ebp+k], eax
		mov	ds:separators_not_printed, 0
		mov	[ebp+j], 1
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		jmp	short loc_8002D0B
; ---------------------------------------------------------------------------

loc_8002CE8:				; CODE XREF: read_line+209j
		sub	esp, 0Ch
		push	[ebp+q]		; p
		call	align_column
		add	esp, 10h
		mov	eax, ds:separators_not_printed
		add	eax, 1
		mov	ds:separators_not_printed, eax
		add	[ebp+j], 1
		add	[ebp+q], 28h

loc_8002D0B:				; CODE XREF: read_line+1DEj
		mov	eax, [ebp+j]
		cmp	eax, [ebp+k]
		jle	short loc_8002CE8
		mov	eax, [ebp+p]
		mov	eax, [eax+20h]
		mov	ds:padding_not_printed,	eax
		movzx	eax, ds:truncate_lines
		test	al, al
		jz	short loc_8002D35
		mov	eax, ds:chars_per_column
		mov	ds:spaces_not_printed, eax
		jmp	short loc_8002D3F
; ---------------------------------------------------------------------------

loc_8002D35:				; CODE XREF: read_line+21Fj
		mov	ds:spaces_not_printed, 0

loc_8002D3F:				; CODE XREF: read_line+22Bj
		mov	ds:align_empty_cols, 0

loc_8002D46:				; CODE XREF: read_line+1A8j
					; read_line+1B7j
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		test	eax, eax
		jle	short loc_8002D7E
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		sub	esp, 0Ch
		push	eax		; position
		call	pad_across_to
		add	esp, 10h
		mov	ds:padding_not_printed,	0

loc_8002D7E:				; CODE XREF: read_line+24Fj
		movzx	eax, ds:use_col_separator
		test	al, al
		jz	short loc_8002D8E
		call	print_sep_string

loc_8002D8E:				; CODE XREF: read_line+174j
					; read_line+27Fj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_8002DA7
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	add_line_number
		add	esp, 10h

loc_8002DA7:				; CODE XREF: read_line+28Fj
		mov	ds:empty_line, 0
		cmp	[ebp+c], 0Ah
		jnz	short loc_8002DBE
		mov	eax, 1
		jmp	locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002DBE:				; CODE XREF: read_line+2AAj
		mov	eax, ds:clump_buff
		sub	esp, 4
		push	eax		; clump
		push	[ebp+chars]	; n
		push	[ebp+p]		; p
		call	print_clump
		add	esp, 10h

loc_8002DD5:				; CODE XREF: read_line+3C6j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		mov	eax, [ebp+c]
		cmp	eax, 0Ah
		jz	short loc_8002DFD
		cmp	eax, 0Ch
		jz	short loc_8002E07
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8002E5C
		jmp	short loc_8002E71
; ---------------------------------------------------------------------------

loc_8002DFD:				; CODE XREF: read_line+2E7j
		mov	eax, 1
		jmp	locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002E07:				; CODE XREF: read_line+2ECj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jz	short loc_8002E35
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h

loc_8002E35:				; CODE XREF: read_line+317j
		movzx	eax, ds:keep_FF
		test	al, al
		jz	short loc_8002E47
		mov	ds:print_a_FF, 1

loc_8002E47:				; CODE XREF: read_line+336j
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	hold_file
		add	esp, 10h
		mov	eax, 1
		jmp	short locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002E5C:				; CODE XREF: read_line+2F1j
		sub	esp, 0Ch
		push	[ebp+p]		; p
		call	close_file
		add	esp, 10h
		mov	eax, 1
		jmp	short locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002E71:				; CODE XREF: read_line+2F3j
		mov	eax, ds:input_position
		mov	[ebp+last_input_position], eax
		mov	eax, [ebp+c]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	char_to_clump
		add	esp, 10h
		mov	[ebp+chars], eax
		movzx	eax, ds:truncate_lines
		test	al, al
		jz	short loc_8002EB7
		mov	edx, ds:input_position
		mov	eax, ds:chars_per_column
		cmp	edx, eax
		jle	short loc_8002EB7
		mov	eax, [ebp+last_input_position]
		mov	ds:input_position, eax
		mov	eax, 0
		jmp	short locret_8002ED3
; ---------------------------------------------------------------------------

loc_8002EB7:				; CODE XREF: read_line+38Fj
					; read_line+39Ej
		mov	eax, ds:clump_buff
		sub	esp, 4
		push	eax		; clump
		push	[ebp+chars]	; n
		push	[ebp+p]		; p
		call	print_clump
		add	esp, 10h
		jmp	loc_8002DD5
; ---------------------------------------------------------------------------

locret_8002ED3:				; CODE XREF: read_line+108j
					; read_line+120j ...
		leave
		retn
read_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	print_stored(COLUMN_0 *p)
print_stored	proc near		; DATA XREF: init_funcs+94o
					; init_funcs+161o

q		= dword	ptr -1Ch
i		= dword	ptr -18h
first		= dword	ptr -14h
line		= dword	ptr -10h
last		= dword	ptr -0Ch
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+p]
		mov	eax, [eax+14h]
		lea	ecx, [eax+1]
		mov	edx, [ebp+p]
		mov	[edx+14h], ecx
		mov	[ebp+line], eax
		mov	eax, ds:buff
		mov	edx, ds:line_vector
		mov	ecx, [ebp+line]
		shl	ecx, 2
		add	edx, ecx
		mov	edx, [edx]
		add	eax, edx
		mov	[ebp+first], eax
		mov	eax, ds:buff
		mov	edx, ds:line_vector
		mov	ecx, [ebp+line]
		add	ecx, 1
		shl	ecx, 2
		add	edx, ecx
		mov	edx, [edx]
		add	eax, edx
		mov	[ebp+last], eax
		mov	ds:pad_vertically, 1
		movzx	eax, ds:print_a_header
		test	al, al
		jz	short loc_8002F3B
		call	print_header

loc_8002F3B:				; CODE XREF: print_stored+5Fj
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 1
		jnz	short loc_8002F9E
		mov	[ebp+i], 1
		mov	eax, ds:column_vector
		mov	[ebp+q], eax
		jmp	short loc_8002F69
; ---------------------------------------------------------------------------

loc_8002F57:				; CODE XREF: print_stored+9Cj
		mov	eax, [ebp+q]
		mov	dword ptr [eax+8], 2
		add	[ebp+i], 1
		add	[ebp+q], 28h

loc_8002F69:				; CODE XREF: print_stored+80j
		mov	eax, columns
		cmp	[ebp+i], eax
		jle	short loc_8002F57
		mov	eax, ds:column_vector
		mov	eax, [eax+1Ch]
		test	eax, eax
		jg	short loc_8002F9E
		movzx	eax, extremities
		xor	eax, 1
		test	al, al
		jz	short loc_8002F94
		mov	ds:pad_vertically, 0

loc_8002F94:				; CODE XREF: print_stored+B6j
		mov	eax, 1
		jmp	locret_800305F
; ---------------------------------------------------------------------------

loc_8002F9E:				; CODE XREF: print_stored+6Fj
					; print_stored+A8j
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		test	eax, eax
		jle	short loc_8002FD6
		mov	edx, ds:padding_not_printed
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		sub	esp, 0Ch
		push	eax		; position
		call	pad_across_to
		add	esp, 10h
		mov	ds:padding_not_printed,	0

loc_8002FD6:				; CODE XREF: print_stored+DAj
		movzx	eax, ds:use_col_separator
		test	al, al
		jz	short loc_8003003
		call	print_sep_string
		jmp	short loc_8003003
; ---------------------------------------------------------------------------

loc_8002FE8:				; CODE XREF: print_stored+134j
		mov	eax, [ebp+first]
		lea	edx, [eax+1]
		mov	[ebp+first], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	print_char
		add	esp, 10h

loc_8003003:				; CODE XREF: print_stored+10Aj
					; print_stored+111j
		mov	eax, [ebp+first]
		cmp	eax, [ebp+last]
		jnz	short loc_8002FE8
		mov	eax, ds:spaces_not_printed
		test	eax, eax
		jnz	short loc_800305A
		mov	eax, [ebp+p]
		mov	edx, [eax+20h]
		mov	eax, ds:end_vector
		mov	ecx, [ebp+line]
		shl	ecx, 2
		add	eax, ecx
		mov	eax, [eax]
		add	eax, edx
		mov	ds:output_position, eax
		mov	eax, [ebp+p]
		mov	edx, [eax+20h]
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, ds:chars_per_margin
		cmp	edx, eax
		jnz	short loc_800305A
		mov	edx, ds:output_position
		mov	eax, ds:col_sep_length
		sub	edx, eax
		mov	eax, edx
		mov	ds:output_position, eax

loc_800305A:				; CODE XREF: print_stored+13Dj
					; print_stored+16Fj
		mov	eax, 1

locret_800305F:				; CODE XREF: print_stored+C4j
		leave
		retn
print_stored	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl char_to_clump(char c)
char_to_clump	proc near		; CODE XREF: read_line+12Fp
					; read_line+37Bp

c		= byte ptr -2Ch
uc		= byte ptr -25h
s		= dword	ptr -24h
i		= dword	ptr -20h
width		= dword	ptr -1Ch
chars		= dword	ptr -18h
chars_per_c	= dword	ptr -14h
esc_buff	= byte ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		movzx	eax, [ebp+c]
		mov	[ebp+uc], al
		mov	eax, ds:clump_buff
		mov	[ebp+s], eax
		mov	[ebp+chars_per_c], 8
		movzx	eax, byte ptr input_tab_char ; "\t"
		cmp	[ebp+c], al
		jnz	short loc_80030A2
		mov	eax, chars_per_input_tab
		mov	[ebp+chars_per_c], eax

loc_80030A2:				; CODE XREF: char_to_clump+37j
		movzx	eax, byte ptr input_tab_char ; "\t"
		cmp	[ebp+c], al
		jz	short loc_80030B4
		cmp	[ebp+c], 9
		jnz	short loc_800310E

loc_80030B4:				; CODE XREF: char_to_clump+4Bj
		mov	eax, ds:input_position
		cdq
		idiv	[ebp+chars_per_c]
		mov	eax, [ebp+chars_per_c]
		sub	eax, edx
		mov	[ebp+width], eax
		movzx	eax, ds:untabify_input
		test	al, al
		jz	short loc_80030F9
		mov	eax, [ebp+width]
		mov	[ebp+i], eax
		jmp	short loc_80030E8
; ---------------------------------------------------------------------------

loc_80030D8:				; CODE XREF: char_to_clump+8Bj
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		mov	byte ptr [eax],	20h
		sub	[ebp+i], 1

loc_80030E8:				; CODE XREF: char_to_clump+75j
		cmp	[ebp+i], 0
		jnz	short loc_80030D8
		mov	eax, [ebp+width]
		mov	[ebp+chars], eax
		jmp	loc_8003291
; ---------------------------------------------------------------------------

loc_80030F9:				; CODE XREF: char_to_clump+6Dj
		mov	eax, [ebp+s]
		movzx	edx, [ebp+c]
		mov	[eax], dl
		mov	[ebp+chars], 1
		jmp	loc_8003291
; ---------------------------------------------------------------------------

loc_800310E:				; CODE XREF: char_to_clump+51j
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+uc]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jnz	loc_800327A
		movzx	eax, ds:use_esc_sequence
		test	al, al
		jz	short loc_800319C
		mov	[ebp+width], 4
		mov	[ebp+chars], 4
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		mov	byte ptr [eax],	5Ch
		movzx	eax, [ebp+uc]
		sub	esp, 4
		push	eax
		push	offset a03o	; "%03o"
		lea	eax, [ebp+esc_buff]
		push	eax		; s
		call	sprintf
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8003191
; ---------------------------------------------------------------------------

loc_8003177:				; CODE XREF: char_to_clump+134j
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		lea	ecx, [ebp+esc_buff]
		mov	edx, [ebp+i]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		add	[ebp+i], 1

loc_8003191:				; CODE XREF: char_to_clump+114j
		cmp	[ebp+i], 2
		jle	short loc_8003177
		jmp	loc_8003291
; ---------------------------------------------------------------------------

loc_800319C:				; CODE XREF: char_to_clump+D8j
		movzx	eax, ds:use_cntrl_prefix
		test	al, al
		jz	loc_8003242
		movzx	eax, [ebp+uc]
		test	al, al
		js	short loc_80031E4
		mov	[ebp+width], 2
		mov	[ebp+chars], 2
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		mov	byte ptr [eax],	5Eh
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		movzx	edx, [ebp+c]
		xor	edx, 40h
		mov	[eax], dl
		jmp	loc_8003291
; ---------------------------------------------------------------------------

loc_80031E4:				; CODE XREF: char_to_clump+150j
		mov	[ebp+width], 4
		mov	[ebp+chars], 4
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		mov	byte ptr [eax],	5Ch
		movzx	eax, [ebp+uc]
		sub	esp, 4
		push	eax
		push	offset a03o	; "%03o"
		lea	eax, [ebp+esc_buff]
		push	eax		; s
		call	sprintf
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_800323A
; ---------------------------------------------------------------------------

loc_8003220:				; CODE XREF: char_to_clump+1DDj
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		lea	ecx, [ebp+esc_buff]
		mov	edx, [ebp+i]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		add	[ebp+i], 1

loc_800323A:				; CODE XREF: char_to_clump+1BDj
		cmp	[ebp+i], 2
		jle	short loc_8003220
		jmp	short loc_8003291
; ---------------------------------------------------------------------------

loc_8003242:				; CODE XREF: char_to_clump+144j
		cmp	[ebp+c], 8
		jnz	short loc_8003261
		mov	[ebp+width], 0FFFFFFFFh
		mov	[ebp+chars], 1
		mov	eax, [ebp+s]
		movzx	edx, [ebp+c]
		mov	[eax], dl
		jmp	short loc_8003291
; ---------------------------------------------------------------------------

loc_8003261:				; CODE XREF: char_to_clump+1E5j
		mov	[ebp+width], 0
		mov	[ebp+chars], 1
		mov	eax, [ebp+s]
		movzx	edx, [ebp+c]
		mov	[eax], dl
		jmp	short loc_8003291
; ---------------------------------------------------------------------------

loc_800327A:				; CODE XREF: char_to_clump+C9j
		mov	[ebp+width], 1
		mov	[ebp+chars], 1
		mov	eax, [ebp+s]
		movzx	edx, [ebp+c]
		mov	[eax], dl

loc_8003291:				; CODE XREF: char_to_clump+93j
					; char_to_clump+A8j ...
		cmp	[ebp+width], 0
		jns	short loc_80032B3
		mov	eax, ds:input_position
		test	eax, eax
		jnz	short loc_80032B3
		mov	[ebp+chars], 0
		mov	ds:input_position, 0
		jmp	short loc_80032E5
; ---------------------------------------------------------------------------

loc_80032B3:				; CODE XREF: char_to_clump+234j
					; char_to_clump+23Dj
		cmp	[ebp+width], 0
		jns	short loc_80032D5
		mov	eax, [ebp+width]
		neg	eax
		mov	edx, eax
		mov	eax, ds:input_position
		cmp	edx, eax
		jl	short loc_80032D5
		mov	ds:input_position, 0
		jmp	short loc_80032E5
; ---------------------------------------------------------------------------

loc_80032D5:				; CODE XREF: char_to_clump+256j
					; char_to_clump+266j
		mov	edx, ds:input_position
		mov	eax, [ebp+width]
		add	eax, edx
		mov	ds:input_position, eax

loc_80032E5:				; CODE XREF: char_to_clump+250j
					; char_to_clump+272j
		mov	eax, [ebp+chars]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80032F9
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80032F9:				; CODE XREF: char_to_clump+291j
		leave
		retn
char_to_clump	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void cleanup()
cleanup		proc near		; CODE XREF: main:loc_8000D35p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:number_buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:clump_buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:column_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:line_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:end_vector
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, ds:buff
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
cleanup		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+69Bp	main+6DDp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80033A7
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80035FF
; ---------------------------------------------------------------------------

loc_80033A7:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPaginateOrColu ; "Paginate or columnate	FILE(s)	for print"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFirst_pageLast ; "  +FIRST_PAGE[:LAST_PAGE], --pages=FIRS"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAAcrossPrintCo ; "  -a,	--across      print columns acros"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDDateFormatFor ; "  -D,	--date-format=FORMAT\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHHeaderHeaderU ; "  -h,	--header=HEADER\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLLengthPage_le ; "  -l,	--length=PAGE_LENGTH\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNSepDigitsNumb ; "  -n[SEP[DIGITS]], --number-lines[=SEP["...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOIndentMarginO ; "  -o,	--indent=MARGIN\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSCharSeparator ; "  -s[CHAR], --separator[=CHAR]\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSstringSepStri ; "  -SSTRING, --sep-string[=STRING]\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTOmitPaginatio ; "  -T,	--omit-pagination\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWPageWidthPage ; "  -W,	--page-width=PAGE_WIDTH\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTIsImpliedIfPa ; "\n-t is implied if PAGE_LENGTH <= 10.	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80035FF:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status

loc_8003605:				; DATA XREF: .eh_frame:08005270o
					; .eh_frame:08005290o ...
		call	exit
usage		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 8003610h
; _Bool	extremities
extremities	db 1			; DATA XREF: main:loc_8000965w
					; main:loc_8000978w ...
; _Bool	storing_columns
storing_columns	db 1			; DATA XREF: cols_ready_to_print+33r
					; main+29Aw ...
		align 4
; int lines_per_page
lines_per_page	dd 42h			; DATA XREF: main+3BBw
					; init_parameters+Dr ...
; int chars_per_line
chars_per_line	dd 48h			; DATA XREF: main+61Bw	main+68Ew ...
; char input_tab_char[2]
input_tab_char	db 9,0			; DATA XREF: main+2ECo
					; char_to_clump+2Dr ...
		align 10h
; int chars_per_input_tab
chars_per_input_tab dd 8		; DATA XREF: main+2E7o
					; init_parameters+267r	...
; char output_tab_char[2]
output_tab_char	db 9,0			; DATA XREF: main+336o
					; print_white_space:loc_8002603r
		align 4
; int chars_per_output_tab
chars_per_output_tab dd	8		; DATA XREF: main+331o
					; add_line_number+135r	...
; int columns
columns		dd 1			; DATA XREF: cols_ready_to_print:loc_80001AFr
					; parse_column_count+6Fw ...
; uintmax_t last_page_number
last_page_number dq 0FFFFFFFFFFFFFFFFh	; DATA XREF: first_last_page+134w
					; print_page:loc_8001E71r ...
; char number_separator[2]
number_separator db 9,0			; DATA XREF: main+3F7o
					; init_parameters+152r	...
		align 4
; int line_count
line_count	dd 1			; DATA XREF: init_parameters+14Dw
					; print_files+AAr ...
; _Bool	skip_count
skip_count	db 1			; DATA XREF: main:loc_80007FFw
					; skip_read:loc_80025AAr
		align 4
; int start_line_num
start_line_num	dd 1			; DATA XREF: main+469w
					; init_parameters+148r
; int chars_per_number
chars_per_number dd 5			; DATA XREF: main+3F2o
					; init_parameters+15Dr	...
; char *col_sep_string
col_sep_string	dd offset locale	; DATA XREF: separator_string+2Dw
					; separator_string+32r	...
; char *column_separator
column_separator dd offset asc_800386A	; DATA XREF: init_parameters:loc_8000F48r
					; init_parameters+FFr
					; " "
; char *line_separator
line_separator	dd offset asc_800386C	; DATA XREF: init_parameters+BCr
_data		ends			; "\t"

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8003658h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; COLUMN_0 *column_vector
column_vector	dd ?			; DATA XREF: cols_ready_to_print+Dr
					; init_fps+10r	...
; char *buff
buff		dd ?			; DATA XREF: init_store_cols+79r
					; init_store_cols+B5w ...
; unsigned int buff_current
buff_current	dd ?			; DATA XREF: store_columns+Dw
					; store_columns+D8r ...
; size_t buff_allocated
buff_allocated	dd ?			; DATA XREF: init_store_cols:loc_8001F49w
					; init_store_cols+A4r ...
; void *line_vector
line_vector	dd ?			; DATA XREF: init_store_cols+26r
					; init_store_cols+4Cw ...
; void *end_vector
end_vector	dd ?			; DATA XREF: init_store_cols+51r
					; init_store_cols+74w ...
; _Bool	parallel_files
parallel_files	db ?			; DATA XREF: main:loc_80007B9w
					; main:loc_8000B7Cr ...
; _Bool	align_empty_cols
align_empty_cols db ?			; DATA XREF: print_page+80w
					; print_page+158w ...
; _Bool	empty_line
empty_line	db ?			; DATA XREF: print_page+87w
					; print_page+14Dr ...
; _Bool	FF_only
FF_only		db ?			; DATA XREF: print_page:loc_8001C41w
					; print_page+177r ...
; _Bool	explicit_columns
explicit_columns db ?			; DATA XREF: parse_column_count+74w
					; main+794r ...
; _Bool	keep_FF
keep_FF		db ?			; DATA XREF: main+579w	main+58Cw ...
; _Bool	print_a_FF
print_a_FF	db ?			; DATA XREF: print_page+2D6r
					; print_page+2EEw ...
; _Bool	print_a_header
print_a_header	db ?			; DATA XREF: print_page+2Aw
					; print_header+14Dw ...
; _Bool	use_form_feed
use_form_feed	db ?			; DATA XREF: main:loc_80006FBw
					; pad_down+6r
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: main+947r	init_fps+146w ...
; _Bool	print_across_flag
print_across_flag db ?			; DATA XREF: main:loc_8000686w
					; main+7CAr
; _Bool	balance_columns
balance_columns	db ?			; DATA XREF: main:loc_8000699w
					; init_parameters+92w ...
; int lines_per_body
lines_per_body	dd ?			; DATA XREF: init_parameters+15w
					; init_parameters+1Ar ...
; _Bool	truncate_lines
truncate_lines	db ?			; DATA XREF: main:loc_80009F9r
					; main+62Aw ...
; _Bool	join_lines
join_lines	db ?			; DATA XREF: main:loc_8000745w
					; main:loc_8000C24w ...
		align 4
; int chars_per_column
chars_per_column dd ?			; DATA XREF: init_parameters+1F4w
					; init_parameters+1F9r	...
; _Bool	untabify_input
untabify_input	db ?			; DATA XREF: main:loc_80006EFw
					; char_to_clump+64r
; _Bool	tabify_output
tabify_output	db ?			; DATA XREF: main:loc_8000739w
					; init_parameters+110w	...
		align 4
; int spaces_not_printed
spaces_not_printed dd ?			; DATA XREF: print_page+65w
					; pad_across_to+25w ...
; int chars_per_margin
chars_per_margin dd ?			; DATA XREF: main+4D1w	init_funcs+6r ...
; int output_position
output_position	dd ?			; DATA XREF: print_page:loc_8001BD7w
					; add_line_number+13Br	...
; int input_position
input_position	dd ?			; DATA XREF: print_page:loc_8001C1Ew
					; store_columns+A1w ...
; _Bool	failed_opens
failed_opens	db ?			; DATA XREF: main:loc_8000D83r
					; open_file+75w
		align 10h
; uintmax_t first_page_number
first_page_number dq ?			; DATA XREF: first_last_page+123w
					; main:loc_800056Cr ...
; int files_ready_to_read
files_ready_to_read dd ?		; DATA XREF: init_fps+1E8w
					; close_file:loc_8001680r ...
		align 10h
; uintmax_t page_number
page_number	dq ?			; DATA XREF: print_files+84w
					; print_files:loc_800181Aw ...
; int line_number
line_number	dd ?			; DATA XREF: print_files+AFw
					; add_line_number+7r ...
; int power_10
power_10	dd ?			; DATA XREF: init_parameters+1A3w
					; init_parameters:loc_800102Fr	...
; _Bool	numbered_lines
numbered_lines	db ?			; DATA XREF: main:loc_80007CCw
					; init_parameters:loc_8000FB2r	...
		align 4
; int number_width
number_width	dd ?			; DATA XREF: init_parameters+174w
					; init_parameters+183w	...
; char *number_buff
number_buff	dd ?			; DATA XREF: init_parameters+22Dr
					; init_parameters+251w	...
; _Bool	use_esc_sequence
use_esc_sequence db ?			; DATA XREF: main:loc_800098Bw
					; char_to_clump+CFr
; _Bool	use_cntrl_prefix
use_cntrl_prefix db ?			; DATA XREF: main:loc_80006A5w
					; char_to_clump:loc_800319Cr
; _Bool	double_space
double_space	db ?			; DATA XREF: main:loc_80006B1w
					; init_parameters:loc_8000EC9r	...
		align 10h
; int total_files
total_files	dd ?			; DATA XREF: init_fps+6w init_fps+15Er ...
; _Bool	ignore_failed_opens
ignore_failed_opens db ?		; DATA XREF: main:loc_80008CFw
					; open_file+7Cr
; _Bool	use_col_separator
use_col_separator db ?			; DATA XREF: main+4F0r	main+548w ...
		align 4
; int col_sep_length
col_sep_length	dd ?			; DATA XREF: separator_string+14w
					; separator_string+19r	...
; int separators_not_printed
separators_not_printed dd ?		; DATA XREF: print_page+6Fw
					; print_page+1CDr ...
; int padding_not_printed
padding_not_printed dd ?		; DATA XREF: align_column+Cw
					; align_column+11r ...
; _Bool	pad_vertically
pad_vertically	db ?			; DATA XREF: print_page:loc_8001BADw
					; print_page+79w ...
		align 4
; char *custom_header
custom_header	dd ?			; DATA XREF: main+319w
					; init_header+17Br ...
; const	char *date_format
date_format	dd ?			; DATA XREF: main+2CFw
					; main:loc_8000B15r ...
; char *date_text
date_text	dd ?			; DATA XREF: init_header:loc_80019AEr
					; init_header+176w ...
; const	char *file_text
file_text	dd ?			; DATA XREF: init_header:loc_80019EDw
					; init_header+1BEr ...
; int header_width_available
header_width_available dd ?		; DATA XREF: init_header+1D5w
					; print_header+AAr
; char *clump_buff
clump_buff	dd ?			; DATA XREF: init_parameters:loc_80010D6r
					; init_parameters+283w	...
; _Bool	last_line
last_line	db ?			; DATA XREF: skip_read:loc_80024D3r
					; skip_read+92r ...
		align 4
; Function-local static	variable
; timespec timespec_5501
timespec_5501	timespec <?>		; DATA XREF: init_header:loc_80018DEr
					; init_header+9Bo ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8003720h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+72o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+6BBo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
; char locale
locale		db 0			; DATA XREF: first_last_page+2Fo
					; first_last_page+A7o ...
asc_800386A	db ' ',0                ; DATA XREF: print_header+122o
					; print_header+12Eo ...
asc_800386C	db 9,0			; DATA XREF: .data:line_separatoro
		align 20h
; char short_options[53]
short_options	db '-0123456789D:FJN:S::TW:abcde::fh:i::l:mn::o:rs::tvw:',0
					; DATA XREF: main+DCo
aPages		db 'pages',0            ; DATA XREF: .rodata:long_optionso
aColumns	db 'columns',0          ; DATA XREF: .rodata:long_optionso
aAcross		db 'across',0           ; DATA XREF: .rodata:long_optionso
aShowControlCha	db 'show-control-chars',0 ; DATA XREF: .rodata:long_optionso
aDoubleSpace	db 'double-space',0     ; DATA XREF: .rodata:long_optionso
aDateFormat	db 'date-format',0      ; DATA XREF: .rodata:long_optionso
aExpandTabs	db 'expand-tabs',0      ; DATA XREF: .rodata:long_optionso
aFormFeed	db 'form-feed',0        ; DATA XREF: .rodata:long_optionso
aHeader		db 'header',0           ; DATA XREF: .rodata:long_optionso
aOutputTabs	db 'output-tabs',0      ; DATA XREF: .rodata:long_optionso
aJoinLines	db 'join-lines',0       ; DATA XREF: .rodata:long_optionso
aLength		db 'length',0           ; DATA XREF: .rodata:long_optionso
aMerge		db 'merge',0            ; DATA XREF: .rodata:long_optionso
aNumberLines	db 'number-lines',0     ; DATA XREF: .rodata:long_optionso
aFirstLineNumbe	db 'first-line-number',0 ; DATA XREF: .rodata:long_optionso
aIndent		db 'indent',0           ; DATA XREF: .rodata:long_optionso
aNoFileWarnings	db 'no-file-warnings',0 ; DATA XREF: .rodata:long_optionso
aSeparator	db 'separator',0        ; DATA XREF: .rodata:long_optionso
aSepString	db 'sep-string',0       ; DATA XREF: .rodata:long_optionso
aOmitHeader	db 'omit-header',0      ; DATA XREF: .rodata:long_optionso
aOmitPagination	db 'omit-pagination',0  ; DATA XREF: .rodata:long_optionso
aShowNonprintin	db 'show-nonprinting',0 ; DATA XREF: .rodata:long_optionso
aWidth		db 'width',0            ; DATA XREF: .rodata:long_optionso
aPageWidth	db 'page-width',0       ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[27]
long_options	option <offset aPages, 1, 0, 81h> ; DATA XREF: first_last_page+62o
					; first_last_page+D4o ...
		option <offset aColumns, 1, 0, 80h> ; "pages"
		option <offset aAcross,	0, 0, 61h>
		option <offset aShowControlCha,	0, 0, 63h>
		option <offset aDoubleSpace, 0,	0, 64h>
		option <offset aDateFormat, 1, 0, 44h>
		option <offset aExpandTabs, 2, 0, 65h>
		option <offset aFormFeed, 0, 0,	66h>
		option <offset aHeader,	1, 0, 68h>
		option <offset aOutputTabs, 2, 0, 69h>
		option <offset aJoinLines, 0, 0, 4Ah>
		option <offset aLength,	1, 0, 6Ch>
		option <offset aMerge, 0, 0, 6Dh>
		option <offset aNumberLines, 2,	0, 6Eh>
		option <offset aFirstLineNumbe,	1, 0, 4Eh>
		option <offset aIndent,	1, 0, 6Fh>
		option <offset aNoFileWarnings,	0, 0, 72h>
		option <offset aSeparator, 2, 0, 73h>
		option <offset aSepString, 2, 0, 53h>
		option <offset aOmitHeader, 0, 0, 74h>
		option <offset aOmitPagination,	0, 0, 54h>
		option <offset aShowNonprintin,	0, 0, 76h>
		option <offset aWidth, 1, 0, 77h>
		option <offset aPageWidth, 1, 0, 57h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of columns: %s',0 ; DATA XREF: parse_column_count+51o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+6Do
		align 4
; char aPagesFirst_pag[]
aPagesFirst_pag	db '`--pages=FIRST_PAGE[:LAST_PAGE]',27h,' missing argument',0
					; DATA XREF: main+1E6o
; char aInvalidPageRan[]
aInvalidPageRan	db 'invalid page range %s',0 ; DATA XREF: main+241o
; char aLPage_lengthIn[]
aLPage_lengthIn	db '`-l PAGE_LENGTH',27h,' invalid number of lines: %s',0
					; DATA XREF: main+39Do
		align 10h
; char aNNumberInvalid[]
aNNumberInvalid	db '`-N NUMBER',27h,' invalid starting line number: %s',0
					; DATA XREF: main+44Bo
		align 10h
; char aOMarginInvalid[]
aOMarginInvalid	db '`-o MARGIN',27h,' invalid line offset: %s',0 ; DATA XREF: main+4B3o
; char aWPage_widthInv[]
aWPage_widthInv	db '`-w PAGE_WIDTH',27h,' invalid number of characters: %s',0
					; DATA XREF: main+5EBo
		align 4
; char aWPage_widthI_0[]
aWPage_widthI_0	db '`-W PAGE_WIDTH',27h,' invalid number of characters: %s',0
					; DATA XREF: main+670o
aRolandHuebner	db 'Roland Huebner',0   ; DATA XREF: main+6B0o
aPeteTermaat	db 'Pete TerMaat',0     ; DATA XREF: main+6B5o
aPr		db 'pr',0               ; DATA XREF: main+6C0o
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: main+72Eo
aBEHMY		db '%b %e %H:%M %Y',0   ; DATA XREF: main+753o
aYMDHM		db '%Y-%m-%d %H:%M',0   ; DATA XREF: main:loc_8000B4Do
		align 4
; char aCannotSpecifyN[]
aCannotSpecifyN	db 'cannot specify number of columns when printing in parallel',0
					; DATA XREF: main+7A2o
		align 4
; char aCannotSpecifyB[]
aCannotSpecifyB	db 'cannot specify both printing across and printing in parallel',0
					; DATA XREF: main+7D8o
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: main+96Bo init_fps+126o ...
off_8003DD0	dd offset loc_8000A93, offset loc_8000A89, offset loc_8000ACB
					; DATA XREF: main+170r
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB ;	jump table for switch statement
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_800056C, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_80006BD, offset loc_8000ACB
		dd offset loc_80006FB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000745, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_80007FF
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000918, offset loc_8000978
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000A19
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000686, offset loc_8000699, offset loc_80006A5
		dd offset loc_80006B1, offset loc_80006CC, offset loc_80006FB
		dd offset loc_8000ACB, offset loc_8000707, offset loc_8000716
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000751
		dd offset loc_80007B9, offset loc_80007CC, offset loc_8000867
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_80008CF
		dd offset loc_80008DB, offset loc_8000965, offset loc_8000ACB
		dd offset loc_800098B, offset loc_8000997, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000ACB, offset loc_8000ACB
		dd offset loc_8000ACB, offset loc_8000654, offset loc_80005CD
; char aCExtraCharacte[]
aCExtraCharacte	db '`-%c',27h,' extra characters or invalid number in the argument: %s',0
					; DATA XREF: getoptarg+94o
; char aPageWidthTooNa[]
aPageWidthTooNa	db 'page width too narrow',0 ; DATA XREF: init_parameters+205o
; char asc_8004237[]
asc_8004237	db '-',0                ; DATA XREF: open_file+9o
					; init_header+2Bo
aR		db 'r',0                ; DATA XREF: open_file+55o
; char format[]
format		db '%s',0               ; DATA XREF: open_file+94o
					; close_file+39o ...
; char aLd_09d[]
aLd_09d		db '%ld.%09d',0         ; DATA XREF: init_header+F1o
; char aD[]
aD		db '%*d',0              ; DATA XREF: add_line_number+29o
; char a0D[]
a0D		db '%0*d',0             ; DATA XREF: add_line_number+59o
; char aStartingPageNu[]
aStartingPageNu	db 'starting page number %llu exceeds page count %llu',0
					; DATA XREF: skip_to_page+11Ao
; char aPageNumberOver[]
aPageNumberOver	db 'page number overflow',0 ; DATA XREF: print_header+4Ao
; char aPageLlu[]
aPageLlu	db 'Page %llu',0        ; DATA XREF: print_header+8Bo
; char aSSSSSS[]
aSSSSSS		db 0Ah			; DATA XREF: print_header+140o
		db 0Ah
		db '%*s%s%*s%s%*s%s',0Ah
		db 0Ah
		db 0Ah,0
; char a03o[]
a03o		db '%03o',0             ; DATA XREF: char_to_clump+FCo
					; char_to_clump+1A5o
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aPaginateOrColu[]
aPaginateOrColu	db 'Paginate or columnate FILE(s) for printing.',0Ah ; DATA XREF: usage+69o
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aFirst_pageLast[]
aFirst_pageLast	db '  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]',0Ah
					; DATA XREF: usage+AFo
		db '                    begin [stop] printing with page FIRST_[LAST_]'
		db 'PAGE',0Ah
		db '  -COLUMN, --columns=COLUMN',0Ah
		db '                    output COLUMN columns and print columns down,'
		db 0Ah
		db '                    unless -a is used. Balance number of lines in'
		db ' the',0Ah
		db '                    columns on each page.',0Ah,0
		align 4
; char aAAcrossPrintCo[]
aAAcrossPrintCo	db '  -a, --across      print columns across rather than down, used t'
					; DATA XREF: usage+D2o
		db 'ogether',0Ah
		db '                    with -COLUMN',0Ah
		db '  -c, --show-control-chars',0Ah
		db '                    use hat notation (^G) and octal backslash not'
		db 'ation',0Ah
		db '  -d, --double-space',0Ah
		db '                    double space the output',0Ah,0
		align 4
; char aDDateFormatFor[]
aDDateFormatFor	db '  -D, --date-format=FORMAT',0Ah ; DATA XREF: usage+F5o
		db '                    use FORMAT for the header date',0Ah
		db '  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]',0Ah
		db '                    expand input CHARs (TABs) to tab WIDTH (8)',0Ah
		db '  -F, -f, --form-feed',0Ah
		db '                    use form feeds instead of newlines to separat'
		db 'e pages',0Ah
		db '                    (by a 3-line page header with -F or a 5-line '
		db 'header',0Ah
		db '                    and trailer without -F)',0Ah,0
; char aHHeaderHeaderU[]
aHHeaderHeaderU	db '  -h, --header=HEADER',0Ah ; DATA XREF: usage+118o
		db '                    use a centered HEADER instead of filename in '
		db 'page header,',0Ah
		db '                    -h "" prints a blank line, don',27h,'t use -h""',0Ah
		db '  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]',0Ah
		db '                    replace spaces with CHARs (TABs) to tab WIDTH'
		db ' (8)',0Ah
		db '  -J, --join-lines  merge full lines, turns off -W line truncatio'
		db 'n, no column',0Ah
		db '                    alignment, --sep-string[=STRING] sets separat'
		db 'ors',0Ah,0
		align 10h
; char aLLengthPage_le[]
aLLengthPage_le	db '  -l, --length=PAGE_LENGTH',0Ah ; DATA XREF: usage+13Bo
		db '                    set the page length to PAGE_LENGTH (66) lines'
		db 0Ah
		db '                    (default number of lines of text 56, and with'
		db ' -F 63)',0Ah
		db '  -m, --merge       print all files in parallel, one in each colu'
		db 'mn,',0Ah
		db '                    truncate lines, but join lines of full length'
		db ' with -J',0Ah,0
		align 4
; char aNSepDigitsNumb[]
aNSepDigitsNumb	db '  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]',0Ah
					; DATA XREF: usage+15Eo
		db '                    number lines, use DIGITS (5) digits, then SEP'
		db ' (TAB),',0Ah
		db '                    default counting starts with 1st line of inpu'
		db 't file',0Ah
		db '  -N, --first-line-number=NUMBER',0Ah
		db '                    start counting with NUMBER at 1st line of fir'
		db 'st',0Ah
		db '                    page printed (see +FIRST_PAGE)',0Ah,0
		align 4
; char aOIndentMarginO[]
aOIndentMarginO	db '  -o, --indent=MARGIN',0Ah ; DATA XREF: usage+181o
		db '                    offset each line with MARGIN (zero) spaces, d'
		db 'o not',0Ah
		db '                    affect -w or -W, MARGIN will be added to PAGE'
		db '_WIDTH',0Ah
		db '  -r, --no-file-warnings',0Ah
		db '                    omit warning when a file cannot be opened',0Ah,0
		align 4
; char aSCharSeparator[]
aSCharSeparator	db '  -s[CHAR], --separator[=CHAR]',0Ah ; DATA XREF: usage+1A4o
		db '                    separate columns by a single character, defau'
		db 'lt for CHAR',0Ah
		db '                    is the <TAB> character without -w and ',27h,'no '
		db 'char',27h,' with -w',0Ah
		db '                    -s[CHAR] turns off line truncation of all 3 c'
		db 'olumn',0Ah
		db '                    options (-COLUMN|-a -COLUMN|-m) except -w is '
		db 'set',0Ah,0
		align 4
; char aSstringSepStri[]
aSstringSepStri	db '  -SSTRING, --sep-string[=STRING]',0Ah ; DATA XREF: usage+1C7o
		db '                    separate columns by STRING,',0Ah
		db '                    without -S: Default separator <TAB> with -J a'
		db 'nd <space>',0Ah
		db '                    otherwise (same as -S" "), no effect on colum'
		db 'n options',0Ah
		db '  -t, --omit-header  omit page headers and trailers',0Ah,0
		align 4
; char aTOmitPaginatio[]
aTOmitPaginatio	db '  -T, --omit-pagination',0Ah ; DATA XREF: usage+1EAo
		db '                    omit page headers and trailers, eliminate any'
		db ' pagination',0Ah
		db '                    by form feeds set in input files',0Ah
		db '  -v, --show-nonprinting',0Ah
		db '                    use octal backslash notation',0Ah
		db '  -w, --width=PAGE_WIDTH',0Ah
		db '                    set page width to PAGE_WIDTH (72) characters '
		db 'for',0Ah
		db '                    multiple text-column output only, -s[char] tu'
		db 'rns off (72)',0Ah,0
		align 10h
; char aWPageWidthPage[]
aWPageWidthPage	db '  -W, --page-width=PAGE_WIDTH',0Ah ; DATA XREF: usage+20Do
		db '                    set page width to PAGE_WIDTH (72) characters '
		db 'always,',0Ah
		db '                    truncate lines, except -J option is set, no i'
		db 'nterference',0Ah
		db '                    with -S or -s',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+230o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+253o
		align 10h
; char aTIsImpliedIfPa[]
aTIsImpliedIfPa	db 0Ah			; DATA XREF: usage+276o
		db '-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE i'
		db 's -, read',0Ah
		db 'standard input.',0Ah,0
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8005250h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8003605-8008875h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8003605-8008883h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8003605-800878Bh
		dd 8, 80E4100h,	0D420285h, 0CC54405h, 404h, 1Ch, 80h
		dd offset loc_8003605-80087A3h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 0A0h
		dd offset loc_8003605-80087A8h
		dd 6Dh,	80E4100h, 0D420285h, 0C5690205h, 4040Ch, 20h, 0C0h
		dd offset loc_8003605-800875Bh
		dd 15Ah, 80E4100h, 0D420285h, 3834405h,	0C5015203h, 4040CC3h
		dd 20h,	0E4h
		dd offset loc_8003605-8008625h
		dd 92h,	80E4100h, 0D420285h, 3834405h, 0C3C58A02h, 4040Ch
		dd 1Ch,	108h
		dd offset loc_8003605-80085B7h
		dd 49h,	80E4100h, 0D420285h, 0C5450205h, 4040Ch, 28h, 128h
		dd offset loc_8003605-800858Eh
		dd 9AFh, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h, 24h, 154h
		dd offset loc_8003605-8007C0Bh
		dd 0DEh, 80E4100h, 0D420285h, 3864505h,	0D3020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 17Ch
		dd offset loc_8003605-8007B55h
		dd 28Bh, 80E4100h, 0D420285h, 2870305h,	4040CC5h, 1Ch
		dd 19Ch
		dd offset loc_8003605-80078EAh
		dd 1F4h, 80E4100h, 0D420285h, 1F00305h,	4040CC5h, 1Ch
		dd 1BCh
		dd offset loc_8003605-8007716h
		dd 1BEh, 80E4100h, 0D420285h, 1BA0305h,	4040CC5h, 1Ch
		dd 1DCh
		dd offset loc_8003605-8007578h
		dd 0D0h, 80E4100h, 0D420285h, 0C5CC0205h, 4040Ch, 20h
		dd 1FCh
		dd offset loc_8003605-80074C8h
		dd 108h, 80E4100h, 0D420285h, 3834405h,	0C5010003h, 4040CC3h
		dd 1Ch,	220h
		dd offset loc_8003605-80073E4h
		dd 7Bh,	80E4100h, 0D420285h, 0C5770205h, 4040Ch, 1Ch, 240h
		dd offset loc_8003605-8007389h
		dd 79h,	80E4100h, 0D420285h, 0C5750205h, 4040Ch, 1Ch, 260h
		dd offset loc_8003605-8007330h
		dd 0C6h, 80E4100h, 0D420285h, 0C5C20205h, 4040Ch, 20h
		dd 280h
		dd offset loc_8003605-800728Ah
		dd 1F1h, 80E4100h, 0D420285h, 3834705h,	0C501E603h, 4040CC3h
		dd 1Ch,	2A4h
		dd offset loc_8003605-80070BDh
		dd 0C7h, 80E4100h, 0D420285h, 0C5C30205h, 4040Ch, 1Ch
		dd 2C4h
		dd offset loc_8003605-8007016h
		dd 75h,	80E4100h, 0D420285h, 0C5710205h, 4040Ch, 20h, 2E4h
		dd offset loc_8003605-8006FC1h
		dd 32Eh, 80E4100h, 0D420285h, 3834405h,	0C5032603h, 4040CC3h
		dd 1Ch,	308h
		dd offset loc_8003605-8006CB7h
		dd 0BDh, 80E4100h, 0D420285h, 0C5B90205h, 4040Ch, 1Ch
		dd 328h
		dd offset loc_8003605-8006C1Ah
		dd 18Ah, 80E4100h, 0D420285h, 1860305h,	4040CC5h, 1Ch
		dd 348h
		dd offset loc_8003605-8006AB0h
		dd 71h,	80E4100h, 0D420285h, 0C56D0205h, 4040Ch, 1Ch, 368h
		dd offset loc_8003605-8006A5Fh
		dd 56h,	80E4100h, 0D420285h, 0C5520205h, 4040Ch, 20h, 388h
		dd offset loc_8003605-8006A29h
		dd 18Ch, 80E4100h, 0D420285h, 3834405h,	0C5018403h, 4040CC3h
		dd 1Ch,	3ACh
		dd offset loc_8003605-80068C1h
		dd 50h,	80E4100h, 0D420285h, 0C54C0205h, 4040Ch, 1Ch, 3CCh
		dd offset loc_8003605-8006891h
		dd 42h,	80E4100h, 0D420285h, 0CC57E05h,	404h, 1Ch, 3ECh
		dd offset loc_8003605-800686Fh
		dd 90h,	80E4100h, 0D420285h, 0C58C0205h, 4040Ch, 1Ch, 40Ch
		dd offset loc_8003605-80067FFh
		dd 17Eh, 80E4100h, 0D420285h, 17A0305h,	4040CC5h, 20h
		dd 42Ch
		dd offset loc_8003605-80066A1h
		dd 0A1h, 80E4100h, 0D420285h, 3834405h,	0C3C59902h, 4040Ch
		dd 1Ch,	450h
		dd offset loc_8003605-8006624h
		dd 0C1h, 80E4100h, 0D420285h, 0C5BD0205h, 4040Ch, 1Ch
		dd 470h
		dd offset loc_8003605-8006583h
		dd 36h,	80E4100h, 0D420285h, 0CC57205h,	404h, 20h, 490h
		dd offset loc_8003605-800656Dh
		dd 9Fh,	80E4100h, 0D420285h, 3834405h, 0C3C59702h, 4040Ch
		dd 1Ch,	4B4h
		dd offset loc_8003605-80064F2h
		dd 176h, 80E4100h, 0D420285h, 1720305h,	4040CC5h, 28h
		dd 4D4h
		dd offset loc_8003605-800639Ch
		dd 177h, 80E4100h, 0D420285h, 3864805h,	69030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 500h
		dd offset loc_8003605-8006251h
		dd 3CDh, 80E4100h, 0D420285h, 3C90305h,	4040CC5h, 1Ch
		dd 520h
		dd offset loc_8003605-8005EA4h
		dd 18Ch, 80E4100h, 0D420285h, 1880305h,	4040CC5h, 1Ch
		dd 540h
		dd offset loc_8003605-8005D38h
		dd 29Ah, 80E4100h, 0D420285h, 2960305h,	4040CC5h, 1Ch
		dd 560h
		dd offset loc_8003605-8005ABEh
		dd 6Fh,	80E4100h, 0D420285h, 0C56B0205h, 4040Ch, 18h, 580h
		dd offset loc_8003605-8005A6Fh
		dd 2A0h, 80E4100h, 0D420285h, 3834405h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; main+6A6r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+62p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn xstrtoumax:near	; CODE XREF: first_last_page+41p
					; first_last_page+B9p
		extrn xstrtol_fatal:near ; CODE	XREF: first_last_page+6Ep
					; first_last_page+E0p
		extrn __stack_chk_fail:near ; CODE XREF: first_last_page+150p
					; parse_column_count+88p ...
		extrn xstrtol:near	; CODE XREF: parse_column_count+2Bp
					; main+374p ...
		extrn quote:near	; CODE XREF: parse_column_count+44p
					; main+234p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: parse_column_count+64p
					; main+1FBp ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: separator_string+Cp
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: separator_string+25p
					; main+B7p ...
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: separator_string+3Ep
		extrn set_program_name:near ; CODE XREF: main+50p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+77p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+87p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+92o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+97p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+E6p
		extrn x2realloc:near	; CODE XREF: main+128p	store_char+29p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+18Ar	main+196r ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: main+278p	main+71Ap ...
		extrn Version:dword	; DATA XREF: main:loc_8000A93r
		extrn version_etc:near	; CODE XREF: main+6C6p
; void exit(int	status)
		extrn exit:near		; CODE XREF: main+6D3p	main+9A0p ...
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: main+733p
		extrn hard_locale:near	; CODE XREF: main+744p
; int optind
		extrn optind:dword	; DATA XREF: main+8B0r	main+8C5r ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main+952r	init_fps+13Br ...
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+95Bp	close_file+67p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: main+97Ap
					; open_file+8Ap ...
		extrn xnmalloc:near	; CODE XREF: init_fps+2Cp
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: init_fps+FBp
					; close_file+52p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: open_file+11p
					; init_header+36p
		extrn fopen_safer:near	; CODE XREF: open_file+5Dp
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	close_file+1Fp
		extrn fstat64:near	; CODE XREF: init_header+59p
		extrn gettime:near	; CODE XREF: init_header+A0p
; struct tm *localtime(const time_t *timer)
		extrn localtime:near	; CODE XREF: init_header+C6p
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: init_header+FCp
					; add_line_number+2Fp ...
		extrn nstrftime:near	; CODE XREF: init_header+11Bp
					; init_header+157p
		extrn gnu_mbswidth:near	; CODE XREF: init_header+1B4p
					; init_header+1C9p ...
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: print_page+203p
					; print_page+23Cp ...
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: read_rest_of_line+1Cp
					; read_rest_of_line+7Cp ...
; int ungetc(int c, FILE *stream)
		extrn ungetc:near	; CODE XREF: read_rest_of_line+36p
					; skip_read+FBp ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: print_char:loc_80027B7p
					; char_to_clump:loc_800310Ep
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p


		end
