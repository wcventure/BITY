;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	38C5B0B364CA3A8940C9B80FB8D04E55
; Input	CRC32 :	6AD0FB4C

; File Name   :	D:\coreutils-o\od.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'od.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl gcd(size_t u, size_t v)
gcd		proc near		; CODE XREF: lcm+9p

t		= dword	ptr -4
u		= dword	ptr  8
v		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h

loc_8000006:				; CODE XREF: gcd+24j
		mov	eax, [ebp+u]
		mov	edx, 0
		div	[ebp+v]
		mov	[ebp+t], edx
		mov	eax, [ebp+v]
		mov	[ebp+u], eax
		mov	eax, [ebp+t]
		mov	[ebp+v], eax
		cmp	[ebp+v], 0
		jnz	short loc_8000006
		mov	eax, [ebp+u]
		leave
		retn
gcd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl lcm(size_t u, size_t v)
lcm		proc near		; CODE XREF: get_lcm+34p

u		= dword	ptr  8
v		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	[ebp+v]		; v
		push	[ebp+u]		; u
		call	gcd
		add	esp, 8
		mov	ecx, eax
		mov	eax, [ebp+v]
		mov	edx, 0
		div	ecx
		imul	eax, [ebp+u]
		leave
		retn
lcm		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+257p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000134
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000134
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000134:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+6F1p	main+72Ep ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_80001A9
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80003C6
; ---------------------------------------------------------------------------

loc_80001A9:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n  or: "...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWriteAnUnambig ; "\nWrite an unambiguous representation, "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAllArgumentsTo ; "All arguments	to long	options	are manda"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAAddressRadixR ; "  -A,	--address-radix=RADIX	decide ho"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNReadBytesByte ; "  -N,	--read-bytes=BYTES	limit dum"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTraditionalFor ; "\nTraditional	format specifications may"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFSameAsTFfSele ; "  -f	 same as -t fF,	select floats\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfFirstAndSeco ; "\nIf first and second	call formats both"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTypeIsMadeUpOf ; "\nTYPE is made up of one or more of the"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDSizeSignedDec ; "  d[SIZE]    signed decimal, SIZE bytes"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSizeIsANumber_ ; "\nSIZE is a number.  For TYPE	in doux, "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRadixIsDForDec ; "\nRADIX is d for decimal, o for octal, "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOptionStringWi ; "Option --string without a number implie"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80003C6:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_s_char(size_t fields, size_t blank, const void *block, const char *fmt_string, int	width, int pad)
print_s_char	proc near		; DATA XREF: decode_one_format+363o

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_8000438
; ---------------------------------------------------------------------------

loc_80003EB:				; CODE XREF: print_s_char+6Dj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_8000438:				; CODE XREF: print_s_char+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_80003EB
		nop
		leave
		retn
print_s_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_char(size_t fields, size_t	blank, const void *block, const	char *fmt_string, int width, int pad)
print_char	proc near		; DATA XREF: decode_one_format:loc_8000EDAo

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_80004AA
; ---------------------------------------------------------------------------

loc_800045D:				; CODE XREF: print_char+6Dj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_80004AA:				; CODE XREF: print_char+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_800045D
		nop
		leave
		retn
print_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_s_short(size_t fields, size_t blank, const	void *block, const char	*fmt_string, int width,	int pad)
print_s_short	proc near		; DATA XREF: decode_one_format+37Ao

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_800051A
; ---------------------------------------------------------------------------

loc_80004CF:				; CODE XREF: print_s_short+6Bj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+2]
		mov	[ebp+p], edx
		movzx	eax, word ptr [eax]
		cwde
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_800051A:				; CODE XREF: print_s_short+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_80004CF
		nop
		leave
		retn
print_s_short	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_short(size_t fields, size_t blank,	const void *block, const char *fmt_string, int width, int pad)
print_short	proc near		; DATA XREF: decode_one_format:loc_8000EF1o

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_800058C
; ---------------------------------------------------------------------------

loc_800053F:				; CODE XREF: print_short+6Dj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+2]
		mov	[ebp+p], edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_800058C:				; CODE XREF: print_short+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_800053F
		nop
		leave
		retn
print_short	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_int(size_t	fields,	size_t blank, const void *block, const char *fmt_string, int width, int	pad)
print_int	proc near		; DATA XREF: decode_one_format:loc_8000EFBo

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_80005FA
; ---------------------------------------------------------------------------

loc_80005B1:				; CODE XREF: print_int+69j
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+4]
		mov	[ebp+p], edx
		mov	eax, [eax]
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_80005FA:				; CODE XREF: print_int+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_80005B1
		nop
		leave
		retn
print_int	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_long(size_t fields, size_t	blank, const void *block, const	char *fmt_string, int width, int pad)
print_long	proc near		; DATA XREF: decode_one_format:loc_8000F04o

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_8000668
; ---------------------------------------------------------------------------

loc_800061F:				; CODE XREF: print_long+69j
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+4]
		mov	[ebp+p], edx
		mov	eax, [eax]
		mov	edx, [ebp+pad_remaining]
		mov	ecx, edx
		sub	ecx, [ebp+next_pad]
		mov	edx, [ebp+width]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_8000668:				; CODE XREF: print_long+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_800061F
		nop
		leave
		retn
print_long	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_long_long(size_t fields, size_t blank, const void *block, const char *fmt_string, int width, int pad)
print_long_long	proc near		; DATA XREF: decode_one_format:loc_8000F0Do

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
var_4		= dword	ptr -4
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_80006D8
; ---------------------------------------------------------------------------

loc_800068E:				; CODE XREF: print_long_long+6Bj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+8]
		mov	[ebp+p], edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+pad_remaining]
		mov	ebx, ecx
		sub	ebx, [ebp+next_pad]
		mov	ecx, [ebp+width]
		add	ecx, ebx
		push	edx
		push	eax
		push	ecx
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_80006D8:				; CODE XREF: print_long_long+19j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_800068E
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
print_long_long	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_float(size_t fields, size_t blank,	const void *block, const char *fmt_string, int width, int pad)
print_float	proc near		; DATA XREF: decode_one_format+4E6o

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_800074C
; ---------------------------------------------------------------------------

loc_8000700:				; CODE XREF: print_float+6Cj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+4]
		mov	[ebp+p], edx
		fld	dword ptr [eax]
		mov	eax, [ebp+pad_remaining]
		sub	eax, [ebp+next_pad]
		mov	edx, eax
		mov	eax, [ebp+width]
		add	eax, edx
		lea	esp, [esp-8]
		fstp	qword ptr [esp]
		push	eax
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_800074C:				; CODE XREF: print_float+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_8000700
		nop
		leave
		retn
print_float	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_double(size_t fields, size_t blank, const void *block, const char *fmt_string, int	width, int pad)
print_double	proc near		; DATA XREF: decode_one_format:loc_800106Do

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_80007BD
; ---------------------------------------------------------------------------

loc_8000771:				; CODE XREF: print_double+6Cj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+8]
		mov	[ebp+p], edx
		fld	qword ptr [eax]
		mov	eax, [ebp+pad_remaining]
		sub	eax, [ebp+next_pad]
		mov	edx, eax
		mov	eax, [ebp+width]
		add	eax, edx
		lea	esp, [esp-8]
		fstp	qword ptr [esp]
		push	eax
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_80007BD:				; CODE XREF: print_double+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_8000771
		nop
		leave
		retn
print_double	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_long_double(size_t	fields,	size_t blank, const void *block, const char *fmt_string, int width, int	pad)
print_long_double proc near		; DATA XREF: decode_one_format:loc_8001084o

p		= dword	ptr -18h
i		= dword	ptr -14h
pad_remaining	= dword	ptr -10h
next_pad	= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
block		= dword	ptr  10h
fmt_string	= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	short loc_8000831
; ---------------------------------------------------------------------------

loc_80007E2:				; CODE XREF: print_long_double+6Fj
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+0Ch]
		mov	[ebp+p], edx
		fld	tbyte ptr [eax]
		mov	eax, [ebp+pad_remaining]
		sub	eax, [ebp+next_pad]
		mov	edx, eax
		mov	eax, [ebp+width]
		add	eax, edx
		sub	esp, 0Ch
		lea	esp, [esp-0Ch]
		fstp	tbyte ptr [esp]
		push	eax
		push	[ebp+fmt_string]
		call	xprintf
		add	esp, 20h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_8000831:				; CODE XREF: print_long_double+18j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	short loc_80007E2
		nop
		leave
		retn
print_long_double endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl dump_hexl_mode_trailer(size_t n_bytes, const char *block)
dump_hexl_mode_trailer proc near	; CODE XREF: write_block+1D3p

c		= byte ptr -0Eh
c2		= byte ptr -0Dh
i		= dword	ptr -0Ch
n_bytes		= dword	ptr  8
block		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:stdout
		push	eax		; stream
		push	3		; n
		push	1		; size
		push	offset asc_8004657 ; "	>"
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, [ebp+n_bytes]
		mov	[ebp+i], eax
		jmp	short loc_80008B0
; ---------------------------------------------------------------------------

loc_8000861:				; CODE XREF: dump_hexl_mode_trailer+78j
		mov	eax, [ebp+block]
		lea	edx, [eax+1]
		mov	[ebp+block], edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8000894
		movzx	eax, [ebp+c]
		jmp	short loc_8000899
; ---------------------------------------------------------------------------

loc_8000894:				; CODE XREF: dump_hexl_mode_trailer+50j
		mov	eax, 2Eh

loc_8000899:				; CODE XREF: dump_hexl_mode_trailer+56j
		mov	[ebp+c2], al
		movzx	eax, [ebp+c2]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	[ebp+i], 1

loc_80008B0:				; CODE XREF: dump_hexl_mode_trailer+23j
		cmp	[ebp+i], 0
		jnz	short loc_8000861
		sub	esp, 0Ch
		push	3Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		leave
		retn
dump_hexl_mode_trailer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_named_ascii(size_t	fields,	size_t blank, const void *block, const char *unused_fmt_string,	int width, int pad)
print_named_ascii proc near		; DATA XREF: decode_one_format+597o

unused_fmt_string= dword ptr -30h
block		= dword	ptr -2Ch
p		= dword	ptr -28h
i		= dword	ptr -24h
pad_remaining	= dword	ptr -20h
s		= dword	ptr -1Ch
next_pad	= dword	ptr -18h
masked_c	= dword	ptr -14h
buf		= byte ptr -0Eh
var_C		= dword	ptr -0Ch
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_8]
		mov	[ebp+block], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+unused_fmt_string], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	loc_8000986
; ---------------------------------------------------------------------------

loc_80008FA:				; CODE XREF: print_named_ascii+C6j
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		and	eax, 7Fh
		mov	[ebp+masked_c],	eax
		cmp	[ebp+masked_c],	7Fh
		jnz	short loc_8000935
		mov	[ebp+s], offset	aDel ; "del"
		jmp	short loc_800095B
; ---------------------------------------------------------------------------

loc_8000935:				; CODE XREF: print_named_ascii+64j
		cmp	[ebp+masked_c],	20h
		jg	short loc_800094B
		mov	eax, [ebp+masked_c]
		shl	eax, 2
		add	eax, offset charname
		mov	[ebp+s], eax
		jmp	short loc_800095B
; ---------------------------------------------------------------------------

loc_800094B:				; CODE XREF: print_named_ascii+73j
		mov	eax, [ebp+masked_c]
		mov	[ebp+buf], al
		mov	[ebp+buf+1], 0
		lea	eax, [ebp+buf]
		mov	[ebp+s], eax

loc_800095B:				; CODE XREF: print_named_ascii+6Dj
					; print_named_ascii+83j
		mov	eax, [ebp+pad_remaining]
		sub	eax, [ebp+next_pad]
		mov	edx, eax
		mov	eax, [ebp+width]
		add	eax, edx
		sub	esp, 4
		push	[ebp+s]
		push	eax
		push	offset aS	; "%*s"
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_8000986:				; CODE XREF: print_named_ascii+2Fj
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	loc_80008FA
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80009A4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80009A4:				; CODE XREF: print_named_ascii+D7j
		leave
		retn
print_named_ascii endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_ascii(size_t fields, size_t blank,	const void *block, const char *unused_fmt_string, int width, int pad)
print_ascii	proc near		; DATA XREF: decode_one_format+5B9o

unused_fmt_string= dword ptr -30h
block		= dword	ptr -2Ch
c		= byte ptr -25h
p		= dword	ptr -24h
i		= dword	ptr -20h
pad_remaining	= dword	ptr -1Ch
s		= dword	ptr -18h
next_pad	= dword	ptr -14h
buf		= byte ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
fields		= dword	ptr  8
blank		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
width		= dword	ptr  18h
pad		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_8]
		mov	[ebp+block], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+unused_fmt_string], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+block]
		mov	[ebp+p], eax
		mov	eax, [ebp+pad]
		mov	[ebp+pad_remaining], eax
		mov	eax, [ebp+fields]
		mov	[ebp+i], eax
		jmp	loc_8000ACE
; ---------------------------------------------------------------------------

loc_80009DB:				; CODE XREF: print_ascii+12Ej
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+pad]
		imul	eax, edx
		mov	edx, 0
		div	[ebp+fields]
		mov	[ebp+next_pad],	eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		movzx	eax, [ebp+c]
		cmp	eax, 0Dh	; switch 14 cases
		ja	short loc_8000A5E ; jumptable 08000A11 default case
		mov	eax, ds:off_8004684[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000A13:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	a0 ; jumptable 08000A11	case 0
		jmp	loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A1F:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aA ; jumptable 08000A11	case 7
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A28:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aB ; jumptable 08000A11	case 8
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A31:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	asc_800466C ; jumptable	08000A11 case 12
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A3A:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aN ; jumptable 08000A11	case 10
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A43:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aR ; jumptable 08000A11	case 13
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A4C:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aT ; jumptable 08000A11	case 9
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A55:				; CODE XREF: print_ascii+6Bj
					; DATA XREF: .rodata:off_8004684o
		mov	[ebp+s], offset	aV ; jumptable 08000A11	case 11
		jmp	short loc_8000AA3
; ---------------------------------------------------------------------------

loc_8000A5E:				; CODE XREF: print_ascii+62j
					; print_ascii+6Bj
					; DATA XREF: ...
		movzx	ebx, [ebp+c]	; jumptable 08000A11 default case
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8000A87
		mov	eax, offset format ; "%c"
		jmp	short loc_8000A8C
; ---------------------------------------------------------------------------

loc_8000A87:				; CODE XREF: print_ascii+D8j
		mov	eax, offset a03o ; "%03o"

loc_8000A8C:				; CODE XREF: print_ascii+DFj
		sub	esp, 4
		push	ebx
		push	eax		; format
		lea	eax, [ebp+buf]
		push	eax		; s
		call	sprintf
		add	esp, 10h
		lea	eax, [ebp+buf]
		mov	[ebp+s], eax

loc_8000AA3:				; CODE XREF: print_ascii+74j
					; print_ascii+80j ...
		mov	eax, [ebp+pad_remaining]
		sub	eax, [ebp+next_pad]
		mov	edx, eax
		mov	eax, [ebp+width]
		add	eax, edx
		sub	esp, 4
		push	[ebp+s]
		push	eax
		push	offset aS	; "%*s"
		call	xprintf
		add	esp, 10h
		mov	eax, [ebp+next_pad]
		mov	[ebp+pad_remaining], eax
		sub	[ebp+i], 1

loc_8000ACE:				; CODE XREF: print_ascii+30j
		mov	eax, [ebp+blank]
		cmp	eax, [ebp+i]
		jb	loc_80009DB
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8000AEC
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000AEC:				; CODE XREF: print_ascii+13Fj
		mov	ebx, [ebp+var_4]
		leave
		retn
print_ascii	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	simple_strtoul(const char *s, const char **p, unsigned int *val)
simple_strtoul	proc near		; CODE XREF: decode_one_format+E9p
					; decode_one_format+413p

sum		= dword	ptr -8
c		= dword	ptr -4
s		= dword	ptr  8
p		= dword	ptr  0Ch
val		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+sum], 0
		jmp	short loc_8000B48
; ---------------------------------------------------------------------------

loc_8000B00:				; CODE XREF: simple_strtoul+66j
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		mov	[ebp+c], eax
		mov	eax, [ebp+c]
		not	eax
		mov	edx, 0CCCCCCCDh
		mul	edx
		mov	eax, edx
		shr	eax, 3
		cmp	eax, [ebp+sum]
		jnb	short loc_8000B32
		mov	eax, 0
		jmp	short locret_8000B6E
; ---------------------------------------------------------------------------

loc_8000B32:				; CODE XREF: simple_strtoul+38j
		mov	edx, [ebp+sum]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+c]
		add	eax, edx
		mov	[ebp+sum], eax

loc_8000B48:				; CODE XREF: simple_strtoul+Dj
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8000B00
		mov	eax, [ebp+p]
		mov	edx, [ebp+s]
		mov	[eax], edx
		mov	eax, [ebp+val]
		mov	edx, [ebp+sum]
		mov	[eax], edx
		mov	eax, 1

locret_8000B6E:				; CODE XREF: simple_strtoul+3Fj
		leave
		retn
simple_strtoul	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	decode_one_format(const	char *s_orig, const char *s, const char	**next,	tspec *tspec)
decode_one_format proc near		; CODE XREF: decode_format_string+87p

tspec		= dword	ptr -48h
next		= dword	ptr -44h
s		= dword	ptr -40h
s_orig		= dword	ptr -3Ch
c		= byte ptr -2Dh
size		= dword	ptr -2Ch
p		= dword	ptr -28h
size_spec	= dword	ptr -24h
fmt		= dword	ptr -20h
pre_fmt_string	= dword	ptr -1Ch
print_function	= dword	ptr -18h
field_width	= dword	ptr -14h
precision	= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 40h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s_orig], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+s], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+next], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+tspec], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		cmp	[ebp+tspec], 0
		jnz	short loc_8000BBA
		push	offset __PRETTY_FUNCTION___5493	; "decode_one_format"
		push	255h		; line
		push	offset file	; "od.c"
		push	offset assertion ; "tspec != NULL"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000BBA:				; CODE XREF: decode_one_format+2Fj
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 61h	; switch 24 cases
		cmp	eax, 17h
		ja	loc_8001139	; jumptable 08000BD6 default case
		mov	eax, ds:off_800482C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000BD8:				; CODE XREF: decode_one_format+66j
					; DATA XREF: .rodata:off_800482Co
		mov	eax, [ebp+s]	; jumptable 08000BD6 cases 100,111,117,120
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 49h
		jz	short loc_8000C2B
		cmp	eax, 49h
		jg	short loc_8000BFF
		cmp	eax, 43h
		jz	short loc_8000C0B
		jmp	short loc_8000C4B
; ---------------------------------------------------------------------------

loc_8000BFF:				; CODE XREF: decode_one_format+86j
		cmp	eax, 4Ch
		jz	short loc_8000C3B
		cmp	eax, 53h
		jz	short loc_8000C1B
		jmp	short loc_8000C4B
; ---------------------------------------------------------------------------

loc_8000C0B:				; CODE XREF: decode_one_format+8Bj
		add	[ebp+s], 1
		mov	[ebp+size], 1
		jmp	loc_8000D0D
; ---------------------------------------------------------------------------

loc_8000C1B:				; CODE XREF: decode_one_format+97j
		add	[ebp+s], 1
		mov	[ebp+size], 2
		jmp	loc_8000D0D
; ---------------------------------------------------------------------------

loc_8000C2B:				; CODE XREF: decode_one_format+81j
		add	[ebp+s], 1
		mov	[ebp+size], 4
		jmp	loc_8000D0D
; ---------------------------------------------------------------------------

loc_8000C3B:				; CODE XREF: decode_one_format+92j
		add	[ebp+s], 1
		mov	[ebp+size], 4
		jmp	loc_8000D0D
; ---------------------------------------------------------------------------

loc_8000C4B:				; CODE XREF: decode_one_format+8Dj
					; decode_one_format+99j
		sub	esp, 4
		lea	eax, [ebp+size]
		push	eax		; val
		lea	eax, [ebp+p]
		push	eax		; p
		push	[ebp+s]		; s
		call	simple_strtoul
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000CA0
		sub	esp, 0Ch
		push	[ebp+s_orig]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidTypeStr ; "invalid type string %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80011D2
; ---------------------------------------------------------------------------

loc_8000CA0:				; CODE XREF: decode_one_format+F6j
		mov	eax, [ebp+p]
		cmp	eax, [ebp+s]
		jnz	short loc_8000CB1
		mov	[ebp+size], 4
		jmp	short loc_8000D0C
; ---------------------------------------------------------------------------

loc_8000CB1:				; CODE XREF: decode_one_format+136j
		mov	eax, [ebp+size]
		cmp	eax, 8
		ja	short loc_8000CC7
		mov	eax, [ebp+size]
		mov	eax, ds:integral_type_size[eax*4]
		test	eax, eax
		jnz	short loc_8000D06

loc_8000CC7:				; CODE XREF: decode_one_format+147j
		mov	ebx, [ebp+size]
		sub	esp, 0Ch
		push	[ebp+s_orig]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidTypeS_0 ; "invalid type string %s;\nthis	system do"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_80011D2
; ---------------------------------------------------------------------------

loc_8000D06:				; CODE XREF: decode_one_format+155j
		mov	eax, [ebp+p]
		mov	[ebp+s], eax

loc_8000D0C:				; CODE XREF: decode_one_format+13Fj
		nop

loc_8000D0D:				; CODE XREF: decode_one_format+A6j
					; decode_one_format+B6j ...
		mov	eax, [ebp+size]
		mov	eax, ds:integral_type_size[eax*4]
		mov	[ebp+size_spec], eax
		movsx	eax, [ebp+c]
		cmp	eax, 6Fh
		jz	short loc_8000D99
		cmp	eax, 6Fh
		jg	short loc_8000D32
		cmp	eax, 64h
		jz	short loc_8000D49
		jmp	loc_8000E83
; ---------------------------------------------------------------------------

loc_8000D32:				; CODE XREF: decode_one_format+1B6j
		cmp	eax, 75h
		jz	loc_8000DE9
		cmp	eax, 78h
		jz	loc_8000E36
		jmp	loc_8000E83
; ---------------------------------------------------------------------------

loc_8000D49:				; CODE XREF: decode_one_format+1BBj
		mov	[ebp+fmt], 0
		mov	eax, [ebp+size]
		mov	eax, ds:bytes_to_signed_dec_digits[eax*4]
		mov	[ebp+field_width], eax
		cmp	[ebp+size_spec], 5
		jz	short loc_8000D77
		cmp	[ebp+size_spec], 4
		jnz	short loc_8000D70
		mov	eax, offset aLd	; "ld"
		jmp	short loc_8000D7C
; ---------------------------------------------------------------------------

loc_8000D70:				; CODE XREF: decode_one_format+1F7j
		mov	eax, offset aD	; "d"
		jmp	short loc_8000D7C
; ---------------------------------------------------------------------------

loc_8000D77:				; CODE XREF: decode_one_format+1F1j
		mov	eax, offset aLld ; "lld"

loc_8000D7C:				; CODE XREF: decode_one_format+1FEj
					; decode_one_format+205j
		mov	edx, [ebp+tspec]
		add	edx, 0Ch
		sub	esp, 4
		push	eax
		push	offset aS_0	; "%%*%s"
		push	edx		; s
		call	sprintf
		add	esp, 10h
		jmp	loc_8000E88
; ---------------------------------------------------------------------------

loc_8000D99:				; CODE XREF: decode_one_format+1B1j
		mov	[ebp+fmt], 2
		cmp	[ebp+size_spec], 5
		jz	short loc_8000DBA
		cmp	[ebp+size_spec], 4
		jnz	short loc_8000DB3
		mov	eax, offset aLo	; "lo"
		jmp	short loc_8000DBF
; ---------------------------------------------------------------------------

loc_8000DB3:				; CODE XREF: decode_one_format+23Aj
		mov	eax, offset aO	; "o"
		jmp	short loc_8000DBF
; ---------------------------------------------------------------------------

loc_8000DBA:				; CODE XREF: decode_one_format+234j
		mov	eax, offset aLlo ; "llo"

loc_8000DBF:				; CODE XREF: decode_one_format+241j
					; decode_one_format+248j
		mov	edx, [ebp+size]
		mov	edx, ds:bytes_to_oct_digits[edx*4]
		mov	[ebp+field_width], edx
		mov	edx, [ebp+tspec]
		add	edx, 0Ch
		push	eax
		push	[ebp+field_width]
		push	offset a_DS	; "%%*.%d%s"
		push	edx		; s
		call	sprintf
		add	esp, 10h
		jmp	loc_8000E88
; ---------------------------------------------------------------------------

loc_8000DE9:				; CODE XREF: decode_one_format+1C5j
		mov	[ebp+fmt], 1
		mov	eax, [ebp+size]
		mov	eax, ds:bytes_to_unsigned_dec_digits[eax*4]
		mov	[ebp+field_width], eax
		cmp	[ebp+size_spec], 5
		jz	short loc_8000E17
		cmp	[ebp+size_spec], 4
		jnz	short loc_8000E10
		mov	eax, offset aLu	; "lu"
		jmp	short loc_8000E1C
; ---------------------------------------------------------------------------

loc_8000E10:				; CODE XREF: decode_one_format+297j
		mov	eax, offset aU	; "u"
		jmp	short loc_8000E1C
; ---------------------------------------------------------------------------

loc_8000E17:				; CODE XREF: decode_one_format+291j
		mov	eax, offset aLlu ; "llu"

loc_8000E1C:				; CODE XREF: decode_one_format+29Ej
					; decode_one_format+2A5j
		mov	edx, [ebp+tspec]
		add	edx, 0Ch
		sub	esp, 4
		push	eax
		push	offset aS_0	; "%%*%s"
		push	edx		; s
		call	sprintf
		add	esp, 10h
		jmp	short loc_8000E88
; ---------------------------------------------------------------------------

loc_8000E36:				; CODE XREF: decode_one_format+1CEj
		mov	[ebp+fmt], 3
		cmp	[ebp+size_spec], 5
		jz	short loc_8000E57
		cmp	[ebp+size_spec], 4
		jnz	short loc_8000E50
		mov	eax, offset aLx	; "lx"
		jmp	short loc_8000E5C
; ---------------------------------------------------------------------------

loc_8000E50:				; CODE XREF: decode_one_format+2D7j
		mov	eax, offset asc_8004762	; "x"
		jmp	short loc_8000E5C
; ---------------------------------------------------------------------------

loc_8000E57:				; CODE XREF: decode_one_format+2D1j
		mov	eax, offset aLlx ; "llx"

loc_8000E5C:				; CODE XREF: decode_one_format+2DEj
					; decode_one_format+2E5j
		mov	edx, [ebp+size]
		mov	edx, ds:bytes_to_hex_digits[edx*4]
		mov	[ebp+field_width], edx
		mov	edx, [ebp+tspec]
		add	edx, 0Ch
		push	eax
		push	[ebp+field_width]
		push	offset a_DS	; "%%*.%d%s"
		push	edx		; s
		call	sprintf
		add	esp, 10h
		jmp	short loc_8000E88
; ---------------------------------------------------------------------------

loc_8000E83:				; CODE XREF: decode_one_format+1BDj
					; decode_one_format+1D4j
		call	abort
; ---------------------------------------------------------------------------

loc_8000E88:				; CODE XREF: decode_one_format+224j
					; decode_one_format+274j ...
		mov	eax, [ebp+tspec]
		add	eax, 0Ch
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		cmp	eax, 8
		jbe	short loc_8000EB8
		push	offset __PRETTY_FUNCTION___5493	; "decode_one_format"
		push	2B7h		; line
		push	offset file	; "od.c"
		push	offset aStrlenTspecFmt ; "strlen (tspec->fmt_string) < FMT_BYTES_"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000EB8:				; CODE XREF: decode_one_format+32Dj
		cmp	[ebp+size_spec], 5 ; switch 6 cases
		ja	short loc_8000F16 ; jumptable 08000ECB default case
		mov	eax, [ebp+size_spec]
		shl	eax, 2
		add	eax, offset off_800488C
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000ECD:				; CODE XREF: decode_one_format+35Bj
					; DATA XREF: .rodata:off_800488Co
		cmp	[ebp+fmt], 0	; jumptable 08000ECB case 1
		jnz	short loc_8000EDA
		mov	eax, offset print_s_char
		jmp	short loc_8000EDF
; ---------------------------------------------------------------------------

loc_8000EDA:				; CODE XREF: decode_one_format+361j
		mov	eax, offset print_char

loc_8000EDF:				; CODE XREF: decode_one_format+368j
		mov	[ebp+print_function], eax
		jmp	short loc_8000F1B
; ---------------------------------------------------------------------------

loc_8000EE4:				; CODE XREF: decode_one_format+35Bj
					; DATA XREF: .rodata:off_800488Co
		cmp	[ebp+fmt], 0	; jumptable 08000ECB case 2
		jnz	short loc_8000EF1
		mov	eax, offset print_s_short
		jmp	short loc_8000EF6
; ---------------------------------------------------------------------------

loc_8000EF1:				; CODE XREF: decode_one_format+378j
		mov	eax, offset print_short

loc_8000EF6:				; CODE XREF: decode_one_format+37Fj
		mov	[ebp+print_function], eax
		jmp	short loc_8000F1B
; ---------------------------------------------------------------------------

loc_8000EFB:				; CODE XREF: decode_one_format+35Bj
					; DATA XREF: .rodata:off_800488Co
		mov	[ebp+print_function], offset print_int ; jumptable 08000ECB case 3
		jmp	short loc_8000F1B
; ---------------------------------------------------------------------------

loc_8000F04:				; CODE XREF: decode_one_format+35Bj
					; DATA XREF: .rodata:off_800488Co
		mov	[ebp+print_function], offset print_long	; jumptable 08000ECB case 4
		jmp	short loc_8000F1B
; ---------------------------------------------------------------------------

loc_8000F0D:				; CODE XREF: decode_one_format+35Bj
					; DATA XREF: .rodata:off_800488Co
		mov	[ebp+print_function], offset print_long_long ; jumptable 08000ECB case 5
		jmp	short loc_8000F1B
; ---------------------------------------------------------------------------

loc_8000F16:				; CODE XREF: decode_one_format+34Cj
					; decode_one_format+35Bj
					; DATA XREF: ...
		call	abort		; jumptable 08000ECB default case
; ---------------------------------------------------------------------------

loc_8000F1B:				; CODE XREF: decode_one_format+372j
					; decode_one_format+389j ...
		jmp	loc_800117C
; ---------------------------------------------------------------------------

loc_8000F20:				; CODE XREF: decode_one_format+66j
					; DATA XREF: .rodata:off_800482Co
		mov	[ebp+fmt], 4	; jumptable 08000BD6 case 102
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 46h
		jz	short loc_8000F45
		cmp	eax, 4Ch
		jz	short loc_8000F65
		cmp	eax, 44h
		jz	short loc_8000F55
		jmp	short loc_8000F75
; ---------------------------------------------------------------------------

loc_8000F45:				; CODE XREF: decode_one_format+3C7j
		add	[ebp+s], 1
		mov	[ebp+size], 4
		jmp	loc_8001037
; ---------------------------------------------------------------------------

loc_8000F55:				; CODE XREF: decode_one_format+3D1j
		add	[ebp+s], 1
		mov	[ebp+size], 8
		jmp	loc_8001037
; ---------------------------------------------------------------------------

loc_8000F65:				; CODE XREF: decode_one_format+3CCj
		add	[ebp+s], 1
		mov	[ebp+size], 0Ch
		jmp	loc_8001037
; ---------------------------------------------------------------------------

loc_8000F75:				; CODE XREF: decode_one_format+3D3j
		sub	esp, 4
		lea	eax, [ebp+size]
		push	eax		; val
		lea	eax, [ebp+p]
		push	eax		; p
		push	[ebp+s]		; s
		call	simple_strtoul
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000FCA
		sub	esp, 0Ch
		push	[ebp+s_orig]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidTypeStr ; "invalid type string %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80011D2
; ---------------------------------------------------------------------------

loc_8000FCA:				; CODE XREF: decode_one_format+420j
		mov	eax, [ebp+p]
		cmp	eax, [ebp+s]
		jnz	short loc_8000FDB
		mov	[ebp+size], 8
		jmp	short loc_8001036
; ---------------------------------------------------------------------------

loc_8000FDB:				; CODE XREF: decode_one_format+460j
		mov	eax, [ebp+size]
		cmp	eax, 0Ch
		ja	short loc_8000FF1
		mov	eax, [ebp+size]
		mov	eax, ds:fp_type_size[eax*4]
		test	eax, eax
		jnz	short loc_8001030

loc_8000FF1:				; CODE XREF: decode_one_format+471j
		mov	ebx, [ebp+size]
		sub	esp, 0Ch
		push	[ebp+s_orig]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidTypeS_1 ; "invalid type string %s;\nthis	system do"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_80011D2
; ---------------------------------------------------------------------------

loc_8001030:				; CODE XREF: decode_one_format+47Fj
		mov	eax, [ebp+p]
		mov	[ebp+s], eax

loc_8001036:				; CODE XREF: decode_one_format+469j
		nop

loc_8001037:				; CODE XREF: decode_one_format+3E0j
					; decode_one_format+3F0j ...
		mov	eax, [ebp+size]
		mov	eax, ds:fp_type_size[eax*4]
		mov	[ebp+size_spec], eax
		mov	eax, [ebp+size_spec]
		cmp	eax, 7
		jz	short loc_800106D
		cmp	eax, 8
		jz	short loc_8001084
		cmp	eax, 6
		jnz	short loc_800109B
		mov	[ebp+print_function], offset print_float
		mov	[ebp+pre_fmt_string], offset a_De ; "%%*.%de"
		mov	[ebp+precision], 6
		jmp	short loc_80010A0
; ---------------------------------------------------------------------------

loc_800106D:				; CODE XREF: decode_one_format+4DAj
		mov	[ebp+print_function], offset print_double
		mov	[ebp+pre_fmt_string], offset a_De ; "%%*.%de"
		mov	[ebp+precision], 0Fh
		jmp	short loc_80010A0
; ---------------------------------------------------------------------------

loc_8001084:				; CODE XREF: decode_one_format+4DFj
		mov	[ebp+print_function], offset print_long_double
		mov	[ebp+pre_fmt_string], offset a_Dle ; "%%*.%dLe"
		mov	[ebp+precision], 12h
		jmp	short loc_80010A0
; ---------------------------------------------------------------------------

loc_800109B:				; CODE XREF: decode_one_format+4E4j
		call	abort
; ---------------------------------------------------------------------------

loc_80010A0:				; CODE XREF: decode_one_format+4FBj
					; decode_one_format+512j ...
		mov	eax, [ebp+precision]
		add	eax, 8
		mov	[ebp+field_width], eax
		mov	eax, [ebp+tspec]
		add	eax, 0Ch
		sub	esp, 4
		push	[ebp+precision]
		push	[ebp+pre_fmt_string] ; format
		push	eax		; s
		call	sprintf
		add	esp, 10h
		mov	eax, [ebp+tspec]
		add	eax, 0Ch
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		cmp	eax, 8
		jbe	loc_800117B
		push	offset __PRETTY_FUNCTION___5493	; "decode_one_format"
		push	322h		; line
		push	offset file	; "od.c"
		push	offset aStrlenTspecFmt ; "strlen (tspec->fmt_string) < FMT_BYTES_"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80010F5:				; CODE XREF: decode_one_format+66j
					; DATA XREF: .rodata:off_800482Co
		add	[ebp+s], 1	; jumptable 08000BD6 case 97
		mov	[ebp+fmt], 5
		mov	[ebp+size_spec], 1
		mov	[ebp+print_function], offset print_named_ascii
		mov	[ebp+field_width], 3
		jmp	short loc_800117C
; ---------------------------------------------------------------------------

loc_8001117:				; CODE XREF: decode_one_format+66j
					; DATA XREF: .rodata:off_800482Co
		add	[ebp+s], 1	; jumptable 08000BD6 case 99
		mov	[ebp+fmt], 6
		mov	[ebp+size_spec], 1
		mov	[ebp+print_function], offset print_ascii
		mov	[ebp+field_width], 3
		jmp	short loc_800117C
; ---------------------------------------------------------------------------

loc_8001139:				; CODE XREF: decode_one_format+59j
					; decode_one_format+66j
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 08000BD6 default case
		push	[ebp+s_orig]
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	ebx, al
		sub	esp, 0Ch
		push	offset aInvalidCharact ; "invalid character `%c' in type string %"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	short loc_80011D2
; ---------------------------------------------------------------------------

loc_800117B:				; CODE XREF: decode_one_format+566j
		nop

loc_800117C:				; CODE XREF: decode_one_format:loc_8000F1Bj
					; decode_one_format+5A5j ...
		mov	eax, [ebp+tspec]
		mov	edx, [ebp+size_spec]
		mov	[eax+4], edx
		mov	eax, [ebp+tspec]
		mov	edx, [ebp+fmt]
		mov	[eax], edx
		mov	eax, [ebp+tspec]
		mov	edx, [ebp+print_function]
		mov	[eax+8], edx
		mov	eax, [ebp+tspec]
		mov	edx, [ebp+field_width]
		mov	[eax+18h], edx
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 7Ah
		setz	dl
		mov	eax, [ebp+tspec]
		mov	[eax+15h], dl
		mov	eax, [ebp+tspec]
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jz	short loc_80011BF
		add	[ebp+s], 1

loc_80011BF:				; CODE XREF: decode_one_format+649j
		cmp	[ebp+next], 0
		jz	short loc_80011CD
		mov	eax, [ebp+next]
		mov	edx, [ebp+s]
		mov	[eax], edx

loc_80011CD:				; CODE XREF: decode_one_format+653j
		mov	eax, 1

loc_80011D2:				; CODE XREF: decode_one_format+12Bj
					; decode_one_format+191j ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80011E3
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80011E3:				; CODE XREF: decode_one_format+66Cj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
decode_one_format endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	open_next_file()
open_next_file	proc near		; CODE XREF: skip+26Fp	read_char+5Bp ...

ok		= byte ptr -9
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[ebp+ok], 1

loc_80011F5:				; CODE XREF: open_next_file+C5j
		mov	eax, ds:file_list
		mov	eax, [eax]
		mov	ds:input_filename, eax
		mov	eax, ds:input_filename
		test	eax, eax
		jnz	short loc_8001213
		movzx	eax, [ebp+ok]
		jmp	loc_80012E6
; ---------------------------------------------------------------------------

loc_8001213:				; CODE XREF: open_next_file+1Ej
		mov	eax, ds:file_list
		add	eax, 4
		mov	ds:file_list, eax
		mov	eax, ds:input_filename
		sub	esp, 8
		push	offset asc_8003824 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001262
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ds:input_filename, eax
		mov	eax, ds:stdin
		mov	ds:in_stream, eax
		mov	ds:have_read_stdin, 1
		jmp	short loc_80012A8
; ---------------------------------------------------------------------------

loc_8001262:				; CODE XREF: open_next_file+4Ej
		mov	eax, ds:input_filename
		sub	esp, 8
		push	offset aR_0	; "r"
		push	eax
		call	fopen64
		add	esp, 10h
		mov	ds:in_stream, eax
		mov	eax, ds:in_stream
		test	eax, eax
		jnz	short loc_80012A8
		mov	ebx, ds:input_filename
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS_1	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_80012A8:				; CODE XREF: open_next_file+76j
					; open_next_file+9Aj
		mov	eax, ds:in_stream
		test	eax, eax
		jz	loc_80011F5
		movzx	eax, ds:limit_bytes_to_format
		test	al, al
		jz	short loc_80012E2
		movzx	eax, ds:flag_dump_strings
		xor	eax, 1
		test	al, al
		jz	short loc_80012E2
		mov	eax, ds:in_stream
		push	0		; n
		push	2		; modes
		push	0		; buf
		push	eax		; stream
		call	setvbuf
		add	esp, 10h

loc_80012E2:				; CODE XREF: open_next_file+D4j
					; open_next_file+E2j
		movzx	eax, [ebp+ok]

loc_80012E6:				; CODE XREF: open_next_file+24j
		mov	ebx, [ebp+var_4]
		leave
		retn
open_next_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	check_and_close(int in_errno)
check_and_close	proc near		; CODE XREF: skip+250p	read_char+42p ...

ok		= byte ptr -9
var_4		= dword	ptr -4
in_errno	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[ebp+ok], 1
		mov	eax, ds:in_stream
		test	eax, eax
		jz	loc_80013D3
		mov	eax, ds:in_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001373
		mov	ebx, ds:input_filename
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+in_errno]	; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, ds:file_list
		sub	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8003824 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800136D
		mov	eax, ds:in_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h

loc_800136D:				; CODE XREF: check_and_close+6Fj
		mov	[ebp+ok], 0
		jmp	short loc_80013C9
; ---------------------------------------------------------------------------

loc_8001373:				; CODE XREF: check_and_close+2Bj
		mov	eax, ds:file_list
		sub	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8003824 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80013C9
		mov	eax, ds:in_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_80013C9
		mov	ebx, ds:input_filename
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS_1	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_80013C9:				; CODE XREF: check_and_close+86j
					; check_and_close+A5j ...
		mov	ds:in_stream, 0

loc_80013D3:				; CODE XREF: check_and_close+12j
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_800140C
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_800140C:				; CODE XREF: check_and_close+FBj
		movzx	eax, [ebp+ok]
		mov	ebx, [ebp+var_4]
		leave
		retn
check_and_close	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	decode_format_string(const char	*s)
decode_format_string proc near		; CODE XREF: main+3FEp	main+440p ...

s		= dword	ptr -1Ch
next		= dword	ptr -14h
s_orig		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+s]
		mov	[ebp+s_orig], eax
		cmp	[ebp+s], 0
		jnz	loc_80014E6
		push	offset __PRETTY_FUNCTION___5546	; "decode_format_string"
		push	3A6h		; line
		push	offset file	; "od.c"
		push	offset aSNull	; "s !=	NULL"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001455:				; CODE XREF: decode_format_string+D9j
		mov	edx, ds:n_specs_allocated
		mov	eax, ds:n_specs
		cmp	edx, eax
		ja	short loc_8001481
		mov	eax, ds:spec
		sub	esp, 4
		push	20h
		push	offset n_specs_allocated
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	ds:spec, eax

loc_8001481:				; CODE XREF: decode_format_string+4Dj
		mov	eax, ds:spec
		mov	edx, ds:n_specs
		shl	edx, 5
		add	eax, edx
		push	eax		; tspec
		lea	eax, [ebp+next]
		push	eax		; next
		push	[ebp+s]		; s
		push	[ebp+s_orig]	; s_orig
		call	decode_one_format
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80014B2
		mov	eax, 0
		jmp	short loc_80014F9
; ---------------------------------------------------------------------------

loc_80014B2:				; CODE XREF: decode_format_string+94j
		mov	eax, [ebp+next]
		cmp	[ebp+s], eax
		jnz	short loc_80014D3
		push	offset __PRETTY_FUNCTION___5546	; "decode_format_string"
		push	3B2h		; line
		push	offset file	; "od.c"
		push	offset aSNext	; "s !=	next"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80014D3:				; CODE XREF: decode_format_string+A3j
		mov	eax, [ebp+next]
		mov	[ebp+s], eax
		mov	eax, ds:n_specs
		add	eax, 1
		mov	ds:n_specs, eax

loc_80014E6:				; CODE XREF: decode_format_string+21j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001455
		mov	eax, 1

loc_80014F9:				; CODE XREF: decode_format_string+9Bj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_800150A
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_800150A:				; CODE XREF: decode_format_string+EEj
		leave
		retn
decode_format_string endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	skip(uintmax_t n_skip)
skip		proc near		; CODE XREF: main+BBCp

n_skip		= qword	ptr -2090h
ok		= byte ptr -2079h
in_errno	= dword	ptr -2078h
n_bytes_to_read	= dword	ptr -2074h
n_bytes_read	= dword	ptr -2070h
file_stats	= stat ptr -206Ch
buf		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 2094h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n_skip],	eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n_skip+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	[ebp+in_errno],	0
		mov	eax, dword ptr [ebp+n_skip+4]
		or	eax, dword ptr [ebp+n_skip]
		test	eax, eax
		jnz	loc_8001797
		mov	eax, 1
		jmp	loc_80017DB
; ---------------------------------------------------------------------------

loc_8001562:				; CODE XREF: skip+292j
		mov	eax, ds:in_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	fileno
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		lea	eax, [ebp+file_stats]
		push	eax
		push	edx
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	loc_800172E
		mov	eax, [ebp+file_stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8001658
		mov	eax, dword ptr [ebp+file_stats.st_size]
		mov	edx, dword ptr [ebp+file_stats.st_size+4]
		test	edx, edx
		js	loc_8001658
		test	edx, edx
		jg	short loc_80015C7
		cmp	eax, 0
		jbe	loc_8001658

loc_80015C7:				; CODE XREF: skip+B0j
		mov	eax, dword ptr [ebp+file_stats.st_size]
		mov	edx, dword ptr [ebp+file_stats.st_size+4]
		cmp	edx, dword ptr [ebp+n_skip+4]
		ja	short loc_8001608
		cmp	edx, dword ptr [ebp+n_skip+4]
		jb	short loc_80015EB
		cmp	eax, dword ptr [ebp+n_skip]
		jnb	short loc_8001608

loc_80015EB:				; CODE XREF: skip+D5j
		mov	eax, dword ptr [ebp+file_stats.st_size]
		mov	edx, dword ptr [ebp+file_stats.st_size+4]
		sub	dword ptr [ebp+n_skip],	eax
		sbb	dword ptr [ebp+n_skip+4], edx
		jmp	loc_800171C
; ---------------------------------------------------------------------------

loc_8001608:				; CODE XREF: skip+CDj skip+DDj
		mov	eax, dword ptr [ebp+n_skip]
		mov	edx, dword ptr [ebp+n_skip+4]
		mov	ecx, ds:in_stream
		push	1
		push	edx
		push	eax
		push	ecx
		call	rpl_fseeko
		add	esp, 10h
		test	eax, eax
		jz	short loc_800163F
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+in_errno],	eax
		mov	[ebp+ok], 0

loc_800163F:				; CODE XREF: skip+11Dj
		mov	dword ptr [ebp+n_skip],	0
		mov	dword ptr [ebp+n_skip+4], 0
		jmp	loc_800171C
; ---------------------------------------------------------------------------

loc_8001658:				; CODE XREF: skip+94j skip+A8j ...
		mov	[ebp+n_bytes_to_read], 2000h
		jmp	loc_8001708
; ---------------------------------------------------------------------------

loc_8001667:				; CODE XREF: skip+20Aj
		mov	eax, [ebp+n_bytes_to_read]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_skip+4]
		jb	short loc_8001696
		cmp	edx, dword ptr [ebp+n_skip+4]
		ja	short loc_800168A
		cmp	eax, dword ptr [ebp+n_skip]
		jbe	short loc_8001696

loc_800168A:				; CODE XREF: skip+174j
		mov	eax, dword ptr [ebp+n_skip]
		mov	[ebp+n_bytes_to_read], eax

loc_8001696:				; CODE XREF: skip+16Cj	skip+17Cj
		mov	eax, ds:in_stream
		push	eax		; stream
		push	[ebp+n_bytes_to_read] ;	n
		push	1		; size
		lea	eax, [ebp+buf]
		push	eax		; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+n_bytes_read], eax
		mov	eax, [ebp+n_bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+n_skip],	eax
		sbb	dword ptr [ebp+n_skip+4], edx
		mov	eax, [ebp+n_bytes_read]
		cmp	eax, [ebp+n_bytes_to_read]
		jz	short loc_8001708
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+in_errno],	eax
		mov	[ebp+ok], 0
		mov	dword ptr [ebp+n_skip],	0
		mov	dword ptr [ebp+n_skip+4], 0
		jmp	short loc_800171C
; ---------------------------------------------------------------------------

loc_8001708:				; CODE XREF: skip+156j	skip+1D0j
		mov	eax, dword ptr [ebp+n_skip+4]
		or	eax, dword ptr [ebp+n_skip]
		test	eax, eax
		jnz	loc_8001667

loc_800171C:				; CODE XREF: skip+F7j skip+147j ...
		mov	eax, dword ptr [ebp+n_skip+4]
		or	eax, dword ptr [ebp+n_skip]
		test	eax, eax
		jnz	short loc_8001753
		jmp	short loc_80017A4
; ---------------------------------------------------------------------------

loc_800172E:				; CODE XREF: skip+7Ej
		mov	ebx, ds:input_filename
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS_1	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8001753:				; CODE XREF: skip+21Ej
		sub	esp, 0Ch
		push	[ebp+in_errno]	; in_errno
		call	check_and_close
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		call	open_next_file
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001797:				; CODE XREF: skip+46j
		mov	eax, ds:in_stream
		test	eax, eax
		jnz	loc_8001562

loc_80017A4:				; CODE XREF: skip+220j
		mov	eax, dword ptr [ebp+n_skip+4]
		or	eax, dword ptr [ebp+n_skip]
		test	eax, eax
		jz	short loc_80017D4
		sub	esp, 0Ch
		push	offset aCannotSkipPast ; "cannot skip past end of combined input"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80017D4:				; CODE XREF: skip+2A6j
		movzx	eax, [ebp+ok]

loc_80017DB:				; CODE XREF: skip+51j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80017EC
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80017EC:				; CODE XREF: skip+2D9j
		mov	ebx, [ebp+var_4]
		leave
		retn
skip		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_address_none(uintmax_t address, char c)
format_address_none proc near		; DATA XREF: main:loc_80027D4o
					; main+AB1o

c		= byte ptr -0Ch
address		= qword	ptr -8
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	dword ptr [ebp+address], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+address+4], edx
		mov	[ebp+c], al
		nop
		leave
		retn
format_address_none endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_address_std(uintmax_t address, char c)
format_address_std proc	near		; CODE XREF: format_address_paren+30p
					; format_address_label+25p
					; DATA XREF: ...

c		= byte ptr -44h
address		= qword	ptr -40h
p		= dword	ptr -30h
pbound		= dword	ptr -2Ch
buf		= byte ptr -25h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	dword ptr [ebp+address], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+address+4], edx
		mov	[ebp+c], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		lea	eax, [ebp+buf]
		add	eax, 19h
		mov	[ebp+p], eax
		sub	[ebp+p], 1
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	0
		sub	[ebp+p], 1
		mov	eax, [ebp+p]
		movzx	edx, [ebp+c]
		mov	[eax], dl
		mov	eax, ds:address_pad_len
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+p]
		add	eax, edx
		mov	[ebp+pbound], eax
		mov	eax, ds:address_base
		cmp	eax, 0Ah
		jz	short loc_80018B3
		cmp	eax, 10h
		jz	loc_80018FB
		cmp	eax, 8
		jnz	loc_800193B

loc_800187D:				; CODE XREF: format_address_std+A0j
		sub	[ebp+p], 1
		mov	eax, dword ptr [ebp+address]
		and	eax, 7
		add	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax], dl
		mov	eax, dword ptr [ebp+address]
		mov	edx, dword ptr [ebp+address+4]
		shrd	eax, edx, 3
		shr	edx, 3
		mov	dword ptr [ebp+address], eax
		mov	dword ptr [ebp+address+4], edx
		mov	eax, dword ptr [ebp+address+4]
		or	eax, dword ptr [ebp+address]
		test	eax, eax
		jnz	short loc_800187D
		jmp	loc_800193B
; ---------------------------------------------------------------------------

loc_80018B3:				; CODE XREF: format_address_std+5Dj
					; format_address_std+EBj
		sub	[ebp+p], 1
		mov	eax, dword ptr [ebp+address]
		mov	edx, dword ptr [ebp+address+4]
		push	0
		push	0Ah
		push	edx
		push	eax
		call	__umoddi3
		add	esp, 10h
		add	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax], dl
		mov	eax, dword ptr [ebp+address]
		mov	edx, dword ptr [ebp+address+4]
		push	0
		push	0Ah
		push	edx
		push	eax
		call	__udivdi3
		add	esp, 10h
		mov	dword ptr [ebp+address], eax
		mov	dword ptr [ebp+address+4], edx
		mov	eax, dword ptr [ebp+address+4]
		or	eax, dword ptr [ebp+address]
		test	eax, eax
		jnz	short loc_80018B3
		jmp	short loc_800193B
; ---------------------------------------------------------------------------

loc_80018FB:				; CODE XREF: format_address_std+62j
					; format_address_std+12Cj
		sub	[ebp+p], 1
		mov	eax, dword ptr [ebp+address]
		and	eax, 0Fh
		mov	ecx, eax
		mov	eax, dword ptr [ebp+address+4]
		and	eax, 0
		mov	ebx, eax
		lea	eax, a0123456789abcd[ecx] ; "0123456789abcdef"
		movzx	edx, byte ptr [eax]
		mov	eax, [ebp+p]
		mov	[eax], dl
		mov	eax, dword ptr [ebp+address]
		mov	edx, dword ptr [ebp+address+4]
		shrd	eax, edx, 4
		shr	edx, 4
		mov	dword ptr [ebp+address], eax
		mov	dword ptr [ebp+address+4], edx
		mov	eax, dword ptr [ebp+address+4]
		or	eax, dword ptr [ebp+address]
		test	eax, eax
		jnz	short loc_80018FB
		nop

loc_800193B:				; CODE XREF: format_address_std+6Bj
					; format_address_std+A2j ...
		jmp	short loc_8001947
; ---------------------------------------------------------------------------

loc_800193D:				; CODE XREF: format_address_std+141j
		sub	[ebp+p], 1
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	30h

loc_8001947:				; CODE XREF: format_address_std:loc_800193Bj
		mov	eax, [ebp+pbound]
		cmp	eax, [ebp+p]
		jb	short loc_800193D
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax
		push	[ebp+p]
		call	fputs_unlocked
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001975
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001975:				; CODE XREF: format_address_std+162j
		mov	ebx, [ebp+var_4]
		leave
		retn
format_address_std endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_address_paren(uintmax_t address, char c)
format_address_paren proc near		; CODE XREF: format_address_label+4Dp
					; DATA XREF: main+ACCo

c		= byte ptr -14h
address		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	dword ptr [ebp+address], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+address+4], edx
		mov	[ebp+c], al
		sub	esp, 0Ch
		push	28h		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 4
		push	29h		; c
		push	dword ptr [ebp+address+4]
		push	dword ptr [ebp+address]	; address
		call	format_address_std
		add	esp, 10h
		cmp	[ebp+c], 0
		jz	short loc_80019C8
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h

loc_80019C8:				; CODE XREF: format_address_paren+3Cj
		nop
		leave
		retn
format_address_paren endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl format_address_label(uintmax_t address, char c)
format_address_label proc near		; DATA XREF: main:loc_8003056o

c		= byte ptr -14h
address		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	dword ptr [ebp+address], edx
		mov	edx, [ebp+arg_4]
		mov	dword ptr [ebp+address+4], edx
		mov	[ebp+c], al
		sub	esp, 4
		push	20h		; c
		push	dword ptr [ebp+address+4]
		push	dword ptr [ebp+address]	; address
		call	format_address_std
		add	esp, 10h
		movsx	esi, [ebp+c]
		mov	ecx, dword ptr ds:pseudo_offset
		mov	ebx, dword ptr ds:pseudo_offset+4
		mov	eax, dword ptr [ebp+address]
		mov	edx, dword ptr [ebp+address+4]
		add	eax, ecx
		adc	edx, ebx
		sub	esp, 4
		push	esi		; c
		push	edx
		push	eax		; address
		call	format_address_paren
		add	esp, 10h
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
format_address_label endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_block(uintmax_t current_offset, size_t n_bytes, const char	*prev_block, const char	*curr_block)
write_block	proc near		; CODE XREF: dump+139p	dump+1EFp ...

current_offset	= qword	ptr -40h
i		= dword	ptr -30h
datum_width	= dword	ptr -2Ch
fields_per_block= dword	ptr -28h
blank_fields	= dword	ptr -24h
field_width	= dword	ptr -20h
pad_width	= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
n_bytes		= dword	ptr  10h
prev_block	= dword	ptr  14h
curr_block	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+current_offset],	eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+current_offset+4], eax
		movzx	eax, abbreviate_duplicate_blocks
		test	al, al
		jz	short loc_8001AA6
		movzx	eax, first_5607
		xor	eax, 1
		test	al, al
		jz	short loc_8001AA6
		mov	eax, ds:bytes_per_block
		cmp	[ebp+n_bytes], eax
		jnz	short loc_8001AA6
		mov	eax, ds:bytes_per_block
		sub	esp, 4
		push	eax		; n
		push	[ebp+curr_block] ; s2
		push	[ebp+prev_block] ; s1
		call	memcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001AA6
		movzx	eax, ds:prev_pair_equal_5608
		test	al, al
		jnz	loc_8001C22
		sub	esp, 0Ch
		push	offset s	; "*"
		call	puts
		add	esp, 10h
		mov	ds:prev_pair_equal_5608, 1
		jmp	loc_8001C22
; ---------------------------------------------------------------------------

loc_8001AA6:				; CODE XREF: write_block+1Ej
					; write_block+2Cj ...
		mov	ds:prev_pair_equal_5608, 0
		mov	[ebp+i], 0
		jmp	loc_8001C14
; ---------------------------------------------------------------------------

loc_8001AB9:				; CODE XREF: write_block+1F4j
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+4]
		mov	eax, ds:width_bytes[eax*4]
		mov	[ebp+datum_width], eax
		mov	eax, ds:bytes_per_block
		mov	ebx, [ebp+datum_width]
		mov	edx, 0
		div	ebx
		mov	[ebp+fields_per_block],	eax
		mov	eax, ds:bytes_per_block
		sub	eax, [ebp+n_bytes]
		mov	esi, [ebp+datum_width]
		mov	edx, 0
		div	esi
		mov	[ebp+blank_fields], eax
		cmp	[ebp+i], 0
		jnz	short loc_8001B17
		mov	eax, ds:format_address
		sub	esp, 4
		push	0		; char
		push	dword ptr [ebp+current_offset+4]
		push	dword ptr [ebp+current_offset] ; uintmax_t
		call	eax ; format_address
		add	esp, 10h
		jmp	short loc_8001B32
; ---------------------------------------------------------------------------

loc_8001B17:				; CODE XREF: write_block+D6j
		mov	eax, ds:address_pad_len
		sub	esp, 4
		push	offset locale
		push	eax
		push	offset aS	; "%*s"
		call	printf
		add	esp, 10h

loc_8001B32:				; CODE XREF: write_block+EDj
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+8]
		mov	edx, ds:spec
		mov	ecx, [ebp+i]
		shl	ecx, 5
		add	edx, ecx
		mov	esi, [edx+1Ch]
		mov	edx, ds:spec
		mov	ecx, [ebp+i]
		shl	ecx, 5
		add	edx, ecx
		mov	ebx, [edx+18h]
		mov	edx, ds:spec
		mov	ecx, [ebp+i]
		shl	ecx, 5
		add	edx, ecx
		lea	edi, [edx+0Ch]
		mov	ecx, [ebp+blank_fields]
		mov	edx, [ebp+fields_per_block]
		sub	esp, 8
		push	esi
		push	ebx
		push	edi
		push	[ebp+curr_block]
		push	ecx
		push	edx
		call	eax
		add	esp, 20h
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jz	short loc_8001C03
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+18h]
		mov	[ebp+field_width], eax
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+1Ch]
		imul	eax, [ebp+blank_fields]
		cdq
		idiv	[ebp+fields_per_block]
		mov	[ebp+pad_width], eax
		mov	eax, [ebp+blank_fields]
		imul	eax, [ebp+field_width]
		mov	edx, eax
		mov	eax, [ebp+pad_width]
		add	eax, edx
		sub	esp, 4
		push	offset locale
		push	eax
		push	offset aS	; "%*s"
		call	printf
		add	esp, 10h
		sub	esp, 8
		push	[ebp+curr_block] ; block
		push	[ebp+n_bytes]	; n_bytes
		call	dump_hexl_mode_trailer
		add	esp, 10h

loc_8001C03:				; CODE XREF: write_block+176j
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		add	[ebp+i], 1

loc_8001C14:				; CODE XREF: write_block+8Cj
		mov	eax, ds:n_specs
		cmp	[ebp+i], eax
		jb	loc_8001AB9

loc_8001C22:				; CODE XREF: write_block+5Cj
					; write_block+79j
		mov	first_5607, 0
		nop
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
write_block	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	read_char(int *c)
read_char	proc near		; CODE XREF: dump_strings+C4p
					; dump_strings+16Dp

ok		= byte ptr -9
c		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+ok], 1
		mov	eax, [ebp+c]
		mov	dword ptr [eax], 0FFFFFFFFh
		jmp	short loc_8001CA3
; ---------------------------------------------------------------------------

loc_8001C47:				; CODE XREF: read_char+78j
		mov	eax, ds:in_stream
		sub	esp, 0Ch
		push	eax		; stream
		call	fgetc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+c]
		mov	[eax], edx
		mov	eax, [ebp+c]
		mov	eax, [eax]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001CAE
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; in_errno
		call	check_and_close
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		call	open_next_file
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001CA3:				; CODE XREF: read_char+13j
		mov	eax, ds:in_stream
		test	eax, eax
		jnz	short loc_8001C47
		jmp	short loc_8001CAF
; ---------------------------------------------------------------------------

loc_8001CAE:				; CODE XREF: read_char+35j
		nop

loc_8001CAF:				; CODE XREF: read_char+7Aj
		movzx	eax, [ebp+ok]
		leave
		retn
read_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	read_block(size_t n, char *block, size_t *n_bytes_in_buffer)
read_block	proc near		; CODE XREF: dump+C6p dump+180p

ok		= byte ptr -11h
n_needed	= dword	ptr -10h
n_read		= dword	ptr -0Ch
n		= dword	ptr  8
block		= dword	ptr  0Ch
n_bytes_in_buffer= dword ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+ok], 1
		cmp	[ebp+n], 0
		jz	short loc_8001CCF
		mov	eax, ds:bytes_per_block
		cmp	[ebp+n], eax
		jbe	short loc_8001CE8

loc_8001CCF:				; CODE XREF: read_block+Ej
		push	offset __PRETTY_FUNCTION___5631	; "read_block"
		push	4D0h		; line
		push	offset file	; "od.c"
		push	offset a0NNBytes_per_b ; "0 < n	&& n <=	bytes_per_block"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001CE8:				; CODE XREF: read_block+18j
		mov	eax, [ebp+n_bytes_in_buffer]
		mov	dword ptr [eax], 0
		cmp	[ebp+n], 0
		jnz	loc_8001D86
		mov	eax, 1
		jmp	locret_8001D9A
; ---------------------------------------------------------------------------

loc_8001D05:				; CODE XREF: read_block+D8j
		mov	eax, [ebp+n_bytes_in_buffer]
		mov	eax, [eax]
		mov	edx, [ebp+n]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_needed],	eax
		mov	eax, ds:in_stream
		mov	edx, [ebp+n_bytes_in_buffer]
		mov	ecx, [edx]
		mov	edx, [ebp+block]
		add	edx, ecx
		push	eax		; stream
		push	[ebp+n_needed]	; n
		push	1		; size
		push	edx		; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+n_read], eax
		mov	eax, [ebp+n_bytes_in_buffer]
		mov	edx, [eax]
		mov	eax, [ebp+n_read]
		add	edx, eax
		mov	eax, [ebp+n_bytes_in_buffer]
		mov	[eax], edx
		mov	eax, [ebp+n_read]
		cmp	eax, [ebp+n_needed]
		jz	short loc_8001D95
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; in_errno
		call	check_and_close
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		call	open_next_file
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001D86:				; CODE XREF: read_block+40j
		mov	eax, ds:in_stream
		test	eax, eax
		jnz	loc_8001D05
		jmp	short loc_8001D96
; ---------------------------------------------------------------------------

loc_8001D95:				; CODE XREF: read_block+95j
		nop

loc_8001D96:				; CODE XREF: read_block+DEj
		movzx	eax, [ebp+ok]

locret_8001D9A:				; CODE XREF: read_block+4Bj
		leave
		retn
read_block	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int get_lcm()
get_lcm		proc near		; CODE XREF: dump+22Fp	main+C1Dp

i		= dword	ptr -8
l_c_m		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+l_c_m], 1
		mov	[ebp+i], 0
		jmp	short loc_8001DDF
; ---------------------------------------------------------------------------

loc_8001DB2:				; CODE XREF: get_lcm+4Bj
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+4]
		mov	eax, ds:width_bytes[eax*4]
		mov	edx, eax
		mov	eax, [ebp+l_c_m]
		push	edx		; v
		push	eax		; u
		call	lcm
		add	esp, 8
		mov	[ebp+l_c_m], eax
		add	[ebp+i], 1

loc_8001DDF:				; CODE XREF: get_lcm+14j
		mov	eax, ds:n_specs
		cmp	[ebp+i], eax
		jb	short loc_8001DB2
		mov	eax, [ebp+l_c_m]
		leave
		retn
get_lcm		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	parse_old_offset(const char *s,	uintmax_t *offset)
parse_old_offset proc near		; CODE XREF: main+807p	main+8A3p ...

radix		= dword	ptr -0Ch
s		= dword	ptr  8
offset		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8001E05
		mov	eax, 0
		jmp	short locret_8001E84
; ---------------------------------------------------------------------------

loc_8001E05:				; CODE XREF: parse_old_offset+Ej
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	short loc_8001E13
		add	[ebp+s], 1

loc_8001E13:				; CODE XREF: parse_old_offset+1Fj
		sub	esp, 8
		push	2Eh		; c
		push	[ebp+s]		; s
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001E30
		mov	[ebp+radix], 0Ah
		jmp	short loc_8001E64
; ---------------------------------------------------------------------------

loc_8001E30:				; CODE XREF: parse_old_offset+37j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 30h
		jnz	short loc_8001E5D
		mov	eax, [ebp+s]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 78h
		jz	short loc_8001E54
		mov	eax, [ebp+s]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 58h
		jnz	short loc_8001E5D

loc_8001E54:				; CODE XREF: parse_old_offset+57j
		mov	[ebp+radix], 10h
		jmp	short loc_8001E64
; ---------------------------------------------------------------------------

loc_8001E5D:				; CODE XREF: parse_old_offset+4Aj
					; parse_old_offset+64j
		mov	[ebp+radix], 8

loc_8001E64:				; CODE XREF: parse_old_offset+40j
					; parse_old_offset+6Dj
		sub	esp, 0Ch
		push	offset aBb	; "Bb"
		push	[ebp+offset]
		push	[ebp+radix]
		push	0
		push	[ebp+s]
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		setz	al

locret_8001E84:				; CODE XREF: parse_old_offset+15j
		leave
		retn
parse_old_offset endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	dump()
dump		proc near		; CODE XREF: main:loc_800330Cp

idx		= byte ptr -32h
ok		= byte ptr -31h
n_bytes_read	= dword	ptr -30h
n_needed	= dword	ptr -2Ch
l_c_m		= dword	ptr -28h
bytes_to_write	= dword	ptr -24h
current_offset	= qword	ptr -20h
block		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+idx], 0
		mov	[ebp+ok], 1
		mov	eax, ds:bytes_per_block
		sub	esp, 8
		push	eax
		push	2
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+block], eax
		mov	edx, [ebp+block]
		mov	eax, ds:bytes_per_block
		add	eax, edx
		mov	[ebp+block+4], eax
		mov	eax, dword ptr ds:n_bytes_to_skip
		mov	edx, dword ptr ds:n_bytes_to_skip+4
		mov	dword ptr [ebp+current_offset],	eax
		mov	dword ptr [ebp+current_offset+4], edx
		movzx	eax, ds:limit_bytes_to_format
		test	al, al
		jz	loc_8001FF0

loc_8001EE3:				; CODE XREF: dump+165j
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		cmp	dword ptr [ebp+current_offset+4], edx
		jb	short loc_8001F09
		cmp	dword ptr [ebp+current_offset+4], edx
		ja	short loc_8001EFD
		cmp	dword ptr [ebp+current_offset],	eax
		jb	short loc_8001F09

loc_8001EFD:				; CODE XREF: dump+70j
		mov	[ebp+n_bytes_read], 0
		jmp	loc_80020AA
; ---------------------------------------------------------------------------

loc_8001F09:				; CODE XREF: dump+6Bj dump+75j
		mov	eax, ds:bytes_per_block
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		sub	eax, dword ptr [ebp+current_offset]
		sbb	edx, dword ptr [ebp+current_offset+4]
		cmp	ebx, edx
		jb	short loc_8001F36
		cmp	ebx, edx
		ja	short loc_8001F32
		cmp	ecx, eax
		jbe	short loc_8001F36

loc_8001F32:				; CODE XREF: dump+A6j
		mov	ecx, eax
		mov	ebx, edx

loc_8001F36:				; CODE XREF: dump+A2j dump+AAj
		mov	[ebp+n_needed],	ecx
		movzx	eax, [ebp+idx]
		mov	eax, [ebp+eax*4+block]
		sub	esp, 4
		lea	edx, [ebp+n_bytes_read]
		push	edx		; n_bytes_in_buffer
		push	eax		; block
		push	[ebp+n_needed]	; n
		call	read_block
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:bytes_per_block
		cmp	edx, eax
		jb	loc_80020A6
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:bytes_per_block
		cmp	edx, eax
		jz	short loc_8001F9A
		push	offset __PRETTY_FUNCTION___5660	; "dump"
		push	542h		; line
		push	offset file	; "od.c"
		push	offset aN_bytes_readBy ; "n_bytes_read == bytes_per_block"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001F9A:				; CODE XREF: dump+F9j
		movzx	eax, [ebp+idx]
		mov	ecx, [ebp+eax*4+block]
		movzx	eax, [ebp+idx]
		xor	eax, 1
		movzx	eax, al
		mov	edx, [ebp+eax*4+block]
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 0Ch
		push	ecx		; curr_block
		push	edx		; prev_block
		push	eax		; n_bytes
		push	dword ptr [ebp+current_offset+4]
		push	dword ptr [ebp+current_offset] ; current_offset
		call	write_block
		add	esp, 20h
		mov	eax, [ebp+n_bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+current_offset],	eax
		adc	dword ptr [ebp+current_offset+4], edx
		movzx	eax, [ebp+idx]
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+idx], al
		and	[ebp+idx], 1
		jmp	loc_8001EE3
; ---------------------------------------------------------------------------

loc_8001FF0:				; CODE XREF: dump+57j dump+21Bj
		movzx	eax, [ebp+idx]
		mov	edx, [ebp+eax*4+block]
		mov	eax, ds:bytes_per_block
		sub	esp, 4
		lea	ecx, [ebp+n_bytes_read]
		push	ecx		; n_bytes_in_buffer
		push	edx		; block
		push	eax		; n
		call	read_block
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:bytes_per_block
		cmp	edx, eax
		jb	short loc_80020A9
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:bytes_per_block
		cmp	edx, eax
		jz	short loc_8002050
		push	offset __PRETTY_FUNCTION___5660	; "dump"
		push	550h		; line
		push	offset file	; "od.c"
		push	offset aN_bytes_readBy ; "n_bytes_read == bytes_per_block"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8002050:				; CODE XREF: dump+1AFj
		movzx	eax, [ebp+idx]
		mov	ecx, [ebp+eax*4+block]
		movzx	eax, [ebp+idx]
		xor	eax, 1
		movzx	eax, al
		mov	edx, [ebp+eax*4+block]
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 0Ch
		push	ecx		; curr_block
		push	edx		; prev_block
		push	eax		; n_bytes
		push	dword ptr [ebp+current_offset+4]
		push	dword ptr [ebp+current_offset] ; current_offset
		call	write_block
		add	esp, 20h
		mov	eax, [ebp+n_bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+current_offset],	eax
		adc	dword ptr [ebp+current_offset+4], edx
		movzx	eax, [ebp+idx]
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+idx], al
		and	[ebp+idx], 1
		jmp	loc_8001FF0
; ---------------------------------------------------------------------------

loc_80020A6:				; CODE XREF: dump+E9j
		nop
		jmp	short loc_80020AA
; ---------------------------------------------------------------------------

loc_80020A9:				; CODE XREF: dump+1A3j
		nop

loc_80020AA:				; CODE XREF: dump+7Ej dump+221j
		mov	eax, [ebp+n_bytes_read]
		test	eax, eax
		jz	loc_800213C
		call	get_lcm
		mov	[ebp+l_c_m], eax
		mov	edx, [ebp+n_bytes_read]
		mov	eax, [ebp+l_c_m]
		add	eax, edx
		sub	eax, 1
		mov	ebx, [ebp+l_c_m]
		mov	edx, 0
		div	ebx
		mov	edx, eax
		mov	eax, [ebp+l_c_m]
		imul	eax, edx
		mov	[ebp+bytes_to_write], eax
		mov	eax, [ebp+n_bytes_read]
		mov	edx, [ebp+bytes_to_write]
		sub	edx, eax
		movzx	eax, [ebp+idx]
		mov	ecx, [ebp+eax*4+block]
		mov	eax, [ebp+n_bytes_read]
		add	eax, ecx
		sub	esp, 4
		push	edx		; n
		push	0		; c
		push	eax		; s
		call	memset
		add	esp, 10h
		movzx	eax, [ebp+idx]
		mov	ecx, [ebp+eax*4+block]
		movzx	eax, [ebp+idx]
		xor	eax, 1
		movzx	eax, al
		mov	edx, [ebp+eax*4+block]
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 0Ch
		push	ecx		; curr_block
		push	edx		; prev_block
		push	eax		; n_bytes
		push	dword ptr [ebp+current_offset+4]
		push	dword ptr [ebp+current_offset] ; current_offset
		call	write_block
		add	esp, 20h
		mov	eax, [ebp+n_bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+current_offset],	eax
		adc	dword ptr [ebp+current_offset+4], edx

loc_800213C:				; CODE XREF: dump+229j
		mov	eax, ds:format_address
		sub	esp, 4
		push	0Ah		; char
		push	dword ptr [ebp+current_offset+4]
		push	dword ptr [ebp+current_offset] ; uintmax_t
		call	eax ; format_address
		add	esp, 10h
		movzx	eax, ds:limit_bytes_to_format
		test	al, al
		jz	short loc_8002194
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		cmp	dword ptr [ebp+current_offset+4], edx
		jb	short loc_8002194
		cmp	dword ptr [ebp+current_offset+4], edx
		ja	short loc_8002176
		cmp	dword ptr [ebp+current_offset],	eax
		jb	short loc_8002194

loc_8002176:				; CODE XREF: dump+2E9j
		sub	esp, 0Ch
		push	0		; in_errno
		call	check_and_close
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8002194:				; CODE XREF: dump+2D4j	dump+2E4j ...
		mov	eax, [ebp+block]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_80021B8
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80021B8:				; CODE XREF: dump+32Bj
		mov	ebx, [ebp+var_4]
		leave
		retn
dump		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	dump_strings()
dump_strings	proc near		; CODE XREF: main+D84p

ok		= byte ptr -29h
bufsize		= dword	ptr -28h
c		= dword	ptr -24h
buf		= dword	ptr -20h
i		= dword	ptr -1Ch
address		= qword	ptr -18h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:string_min
		mov	edx, 64h
		cmp	eax, 64h
		cmovb	eax, edx
		mov	[ebp+bufsize], eax
		mov	eax, [ebp+bufsize]
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, dword ptr ds:n_bytes_to_skip
		mov	edx, dword ptr ds:n_bytes_to_skip+4
		mov	dword ptr [ebp+address], eax
		mov	dword ptr [ebp+address+4], edx
		mov	[ebp+ok], 1

tryline:				; CODE XREF: dump_strings+120j
					; dump_strings+1D0j ...
		movzx	eax, ds:limit_bytes_to_format
		test	al, al
		jz	short loc_8002271
		mov	eax, ds:string_min
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		cmp	ebx, edx
		ja	loc_8002536
		cmp	ebx, edx
		jb	short loc_8002240
		cmp	ecx, eax
		ja	loc_8002536

loc_8002240:				; CODE XREF: dump_strings+79j
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		mov	ecx, ds:string_min
		mov	ebx, 0
		sub	eax, ecx
		sbb	edx, ebx
		cmp	edx, dword ptr [ebp+address+4]
		jb	loc_8002536
		cmp	edx, dword ptr [ebp+address+4]
		ja	short loc_8002271
		cmp	eax, dword ptr [ebp+address]
		jbe	loc_8002536

loc_8002271:				; CODE XREF: dump_strings+56j
					; dump_strings+A9j
		mov	[ebp+i], 0
		jmp	short loc_80022F3
; ---------------------------------------------------------------------------

loc_800227A:				; CODE XREF: dump_strings+13Ej
		sub	esp, 0Ch
		lea	eax, [ebp+c]
		push	eax		; c
		call	read_char
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	dword ptr [ebp+address], 1
		adc	dword ptr [ebp+address+4], 0
		mov	eax, [ebp+c]
		test	eax, eax
		jns	short loc_80022C0
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		jmp	loc_8002566
; ---------------------------------------------------------------------------

loc_80022C0:				; CODE XREF: dump_strings+EAj
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jnz	short loc_80022E2
		jmp	tryline
; ---------------------------------------------------------------------------

loc_80022E2:				; CODE XREF: dump_strings+11Ej
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	edx, [ebp+c]
		mov	[eax], dl
		add	[ebp+i], 1

loc_80022F3:				; CODE XREF: dump_strings+BBj
		mov	eax, ds:string_min
		cmp	[ebp+i], eax
		jb	loc_800227A
		jmp	loc_80023A5
; ---------------------------------------------------------------------------

loc_8002306:				; CODE XREF: dump_strings+1F4j
					; dump_strings+208j ...
		mov	eax, [ebp+bufsize]
		cmp	[ebp+i], eax
		jnz	short loc_8002323
		sub	esp, 8
		lea	eax, [ebp+bufsize]
		push	eax
		push	[ebp+buf]
		call	x2realloc
		add	esp, 10h
		mov	[ebp+buf], eax

loc_8002323:				; CODE XREF: dump_strings+14Fj
		sub	esp, 0Ch
		lea	eax, [ebp+c]
		push	eax		; c
		call	read_char
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	dword ptr [ebp+address], 1
		adc	dword ptr [ebp+address+4], 0
		mov	eax, [ebp+c]
		test	eax, eax
		jns	short loc_8002369
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		jmp	loc_8002566
; ---------------------------------------------------------------------------

loc_8002369:				; CODE XREF: dump_strings+193j
		mov	eax, [ebp+c]
		test	eax, eax
		jz	short loc_80023DB
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jnz	short loc_8002392
		jmp	tryline
; ---------------------------------------------------------------------------

loc_8002392:				; CODE XREF: dump_strings+1CEj
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		mov	edx, [ebp+buf]
		add	eax, edx
		mov	edx, [ebp+c]
		mov	[eax], dl

loc_80023A5:				; CODE XREF: dump_strings+144j
		movzx	eax, ds:limit_bytes_to_format
		xor	eax, 1
		test	al, al
		jnz	loc_8002306
		mov	eax, dword ptr ds:end_offset
		mov	edx, dword ptr ds:end_offset+4
		cmp	dword ptr [ebp+address+4], edx
		jb	loc_8002306
		cmp	dword ptr [ebp+address+4], edx
		ja	short loc_80023DC
		cmp	dword ptr [ebp+address], eax
		jb	loc_8002306
		jmp	short loc_80023DC
; ---------------------------------------------------------------------------

loc_80023DB:				; CODE XREF: dump_strings+1B1j
		nop

loc_80023DC:				; CODE XREF: dump_strings+211j
					; dump_strings+21Cj
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	esi, ds:format_address
		mov	eax, [ebp+i]
		mov	edx, 0
		mov	ecx, dword ptr [ebp+address]
		mov	ebx, dword ptr [ebp+address+4]
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		add	eax, 0FFFFFFFFh
		adc	edx, 0FFFFFFFFh
		sub	esp, 4
		push	20h		; char
		push	edx
		push	eax		; uintmax_t
		call	esi ; format_address
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	loc_8002508
; ---------------------------------------------------------------------------

loc_8002421:				; CODE XREF: dump_strings+361j
		mov	eax, [ebp+c]
		sub	eax, 7		; switch 7 cases
		cmp	eax, 6
		ja	loc_80024EE	; jumptable 08002437 default case
		mov	eax, ds:off_8004964[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8002439:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 7
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aA	; "\\a"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	loc_8002504
; ---------------------------------------------------------------------------

loc_8002455:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 8
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aB	; "\\b"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	loc_8002504
; ---------------------------------------------------------------------------

loc_8002471:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 12
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_800466C ; "\\f"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8002504
; ---------------------------------------------------------------------------

loc_800248A:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 10
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aN	; "\\n"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8002504
; ---------------------------------------------------------------------------

loc_80024A3:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 13
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aR	; "\\r"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8002504
; ---------------------------------------------------------------------------

loc_80024BC:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 9
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aT	; "\\t"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8002504
; ---------------------------------------------------------------------------

loc_80024D5:				; CODE XREF: dump_strings+27Aj
					; DATA XREF: .rodata:off_8004964o
		mov	eax, ds:stdout	; jumptable 08002437 case 11
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aV	; "\\v"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8002504
; ---------------------------------------------------------------------------

loc_80024EE:				; CODE XREF: dump_strings+26Dj
		mov	edx, ds:stdout	; jumptable 08002437 default case
		mov	eax, [ebp+c]
		sub	esp, 8
		push	edx		; stream
		push	eax		; c
		call	putc_unlocked
		add	esp, 10h

loc_8002504:				; CODE XREF: dump_strings+293j
					; dump_strings+2AFj ...
		add	[ebp+i], 1

loc_8002508:				; CODE XREF: dump_strings+25Fj
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+c], eax
		mov	eax, [ebp+c]
		test	eax, eax
		jnz	loc_8002421
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	tryline
; ---------------------------------------------------------------------------

loc_8002536:				; CODE XREF: dump_strings+71j
					; dump_strings+7Dj ...
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; in_errno
		call	check_and_close
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		movzx	eax, [ebp+ok]

loc_8002566:				; CODE XREF: dump_strings+FEj
					; dump_strings+1A7j
		mov	esi, [ebp+var_C]
		xor	esi, large gs:14h
		jz	short loc_8002577
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002577:				; CODE XREF: dump_strings+3B3j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
dump_strings	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -6Ch
modern		= byte ptr -67h
width_specified	= byte ptr -66h
ok		= byte ptr -65h
n_files		= dword	ptr -64h
i		= dword	ptr -60h
desired_width	= dword	ptr -5Ch
width_per_block	= dword	ptr -58h
c		= dword	ptr -54h
s_err		= dword	ptr -50h
l_c_m		= dword	ptr -4Ch
fields_per_block= dword	ptr -48h
block_width	= dword	ptr -44h
fields_per_block_0= dword ptr -40h
block_width_0	= dword	ptr -3Ch
o1		= qword	ptr -38h
o2		= qword	ptr -30h
pseudo_start	= qword	ptr -28h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 6Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+modern], 0
		mov	[ebp+width_specified], 0
		mov	[ebp+ok], 1
		mov	[ebp+width_per_block], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_800262A
; ---------------------------------------------------------------------------

loc_8002618:				; CODE XREF: main+B0j
		mov	eax, [ebp+i]
		mov	ds:integral_type_size[eax*4], 0
		add	[ebp+i], 1

loc_800262A:				; CODE XREF: main+98j
		cmp	[ebp+i], 8
		jbe	short loc_8002618
		mov	ds:integral_type_size+4, 1
		mov	ds:integral_type_size+8, 2
		mov	ds:integral_type_size+10h, 3
		mov	ds:integral_type_size+10h, 4
		mov	ds:integral_type_size+20h, 5
		mov	[ebp+i], 0
		jmp	short loc_800267D
; ---------------------------------------------------------------------------

loc_800266B:				; CODE XREF: main+103j
		mov	eax, [ebp+i]
		mov	ds:fp_type_size[eax*4],	0
		add	[ebp+i], 1

loc_800267D:				; CODE XREF: main+EBj
		cmp	[ebp+i], 0Ch
		jbe	short loc_800266B
		mov	ds:fp_type_size+10h, 6
		mov	ds:fp_type_size+30h, 8
		mov	ds:fp_type_size+20h, 7
		mov	ds:n_specs, 0
		mov	ds:n_specs_allocated, 0
		mov	ds:spec, 0
		mov	ds:format_address, offset format_address_std
		mov	ds:address_base, 8
		mov	ds:address_pad_len, 7
		mov	ds:flag_dump_strings, 0

loc_80026E4:				; CODE XREF: main+734j
					; main:loc_8002CB8j
		mov	dword ptr [ebp+o1], 0FFFFFFFFh
		sub	esp, 0Ch
		lea	eax, [ebp+o1]
		push	eax		; longind
		push	offset long_options ; longopts
		push	offset short_options ; "A:aBbcDdeFfHhIij:LlN:OoS:st:vw::Xx"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8002726
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jnz	loc_8002CBD
		jmp	loc_8002CC7
; ---------------------------------------------------------------------------

loc_8002726:				; CODE XREF: main+192j
		mov	eax, [ebp+c]
		add	eax, 83h	; switch 260 cases
		cmp	eax, 103h
		ja	loc_8002CA7	; jumptable 08002740 default case
		mov	eax, ds:off_8004AF4[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8002742:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 65
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 6Eh
		jz	short loc_80027D4
		cmp	eax, 6Eh
		jg	short loc_8002765
		cmp	eax, 64h
		jz	short loc_8002771
		jmp	loc_80027EA
; ---------------------------------------------------------------------------

loc_8002765:				; CODE XREF: main+1DBj
		cmp	eax, 6Fh
		jz	short loc_8002794
		cmp	eax, 78h
		jz	short loc_80027B4
		jmp	short loc_80027EA
; ---------------------------------------------------------------------------

loc_8002771:				; CODE XREF: main+1E0j
		mov	ds:format_address, offset format_address_std
		mov	ds:address_base, 0Ah
		mov	ds:address_pad_len, 7
		jmp	loc_8002814
; ---------------------------------------------------------------------------

loc_8002794:				; CODE XREF: main+1EAj
		mov	ds:format_address, offset format_address_std
		mov	ds:address_base, 8
		mov	ds:address_pad_len, 7
		jmp	short loc_8002814
; ---------------------------------------------------------------------------

loc_80027B4:				; CODE XREF: main+1EFj
		mov	ds:format_address, offset format_address_std
		mov	ds:address_base, 10h
		mov	ds:address_pad_len, 6
		jmp	short loc_8002814
; ---------------------------------------------------------------------------

loc_80027D4:				; CODE XREF: main+1D6j
		mov	ds:format_address, offset format_address_none
		mov	ds:address_pad_len, 0
		jmp	short loc_8002814
; ---------------------------------------------------------------------------

loc_80027EA:				; CODE XREF: main+1E2j	main+1F1j
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		movsx	esi, al
		sub	esp, 0Ch
		push	offset aInvalidOutputA ; "invalid output address radix `%c'; it m"...
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		nop

loc_8002814:				; CODE XREF: main+211j	main+234j ...
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002819:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 106
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset multipliers_5711	; "bEGKkMmPTYZ0"
		push	offset n_bytes_to_skip
		push	0
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 0
		jz	loc_8002CB1
		mov	ecx, ds:optarg
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, dword ptr [ebp+o1]
		sub	esp, 0Ch
		push	ecx
		push	offset long_options
		push	edx
		push	eax
		push	[ebp+s_err]
		call	xstrtol_fatal

loc_800286B:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 78
		mov	ds:limit_bytes_to_format, 1
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset multipliers_5711	; "bEGKkMmPTYZ0"
		push	offset max_bytes_to_format
		push	0
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 0
		jz	loc_8002CB7
		mov	ecx, ds:optarg
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, dword ptr [ebp+o1]
		sub	esp, 0Ch
		push	ecx
		push	offset long_options
		push	edx
		push	eax
		push	[ebp+s_err]
		call	xstrtol_fatal

loc_80028C4:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 83
		mov	eax, ds:optarg
		test	eax, eax
		jnz	short loc_80028E0
		mov	ds:string_min, 3
		jmp	loc_8002963
; ---------------------------------------------------------------------------

loc_80028E0:				; CODE XREF: main+351j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset multipliers_5711	; "bEGKkMmPTYZ0"
		lea	edx, [ebp+o2]
		push	edx
		push	0
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 0
		jz	short loc_8002929
		mov	ecx, ds:optarg
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, dword ptr [ebp+o1]
		sub	esp, 0Ch
		push	ecx
		push	offset long_options
		push	edx
		push	eax
		push	[ebp+s_err]
		call	xstrtol_fatal

loc_8002929:				; CODE XREF: main+387j
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		cmp	edx, 0
		jbe	short loc_8002958
		mov	esi, ds:optarg
		sub	esp, 0Ch
		push	offset aSIsTooLarge ; "%s is too large"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002958:				; CODE XREF: main+3B4j
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		mov	ds:string_min, eax

loc_8002963:				; CODE XREF: main+35Dj
		mov	ds:flag_dump_strings, 1
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_800296F:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 116
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; s
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_800299A:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 118
		mov	abbreviate_duplicate_blocks, 0
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_80029AA:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	ds:traditional,	1 ; jumptable 08002740 case 128
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_80029B6:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 97
		push	offset aA_0	; "a"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_80029DC:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 98
		push	offset aO1	; "o1"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002A02:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 99
		push	offset aC_0	; "c"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002A28:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 68
		push	offset aU4	; "u4"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002A4E:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 100
		push	offset aU2	; "u2"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002A74:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 cases 70,101
		push	offset aFd	; "fD"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002A9A:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 102
		push	offset aFf	; "fF"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002AC0:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 cases 72,88
		push	offset aX4	; "x4"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002AE6:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 105
		push	offset aDi	; "dI"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002B0C:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 cases 73,76,108
		push	offset aDl	; "dL"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002B32:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 79
		push	offset aO4	; "o4"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002B58:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 cases 66,111
		push	offset aO2	; "o2"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002B7E:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case 115
		push	offset aD2	; "d2"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002BA4:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 cases 104,120
		push	offset aX2	; "x2"
		call	decode_format_string
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002BCA:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	[ebp+modern], 1	; jumptable 08002740 case 119
		mov	[ebp+width_specified], 1
		mov	eax, ds:optarg
		test	eax, eax
		jnz	short loc_8002BE7
		mov	[ebp+desired_width], 20h
		jmp	loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002BE7:				; CODE XREF: main+65Bj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+o2]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 0
		jz	short loc_8002C30
		mov	ecx, ds:optarg
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, dword ptr [ebp+o1]
		sub	esp, 0Ch
		push	ecx
		push	offset long_options
		push	edx
		push	eax
		push	[ebp+s_err]
		call	xstrtol_fatal

loc_8002C30:				; CODE XREF: main+68Ej
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		cmp	edx, 0
		jbe	short loc_8002C5F
		mov	esi, ds:optarg
		sub	esp, 0Ch
		push	offset aSIsTooLarge ; "%s is too large"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002C5F:				; CODE XREF: main+6BBj
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		mov	[ebp+desired_width], eax
		jmp	short loc_8002CB8
; ---------------------------------------------------------------------------

loc_8002C6A:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		sub	esp, 0Ch	; jumptable 08002740 case -130
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002C74:				; CODE XREF: main+1C2j
					; DATA XREF: .rodata:off_8004AF4o
		mov	edx, ds:Version	; jumptable 08002740 case -131
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aOd	; "od"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002CA7:				; CODE XREF: main+1B5j	main+1C2j
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 08002740 default case
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002CB1:				; CODE XREF: main+2C5j
		nop
		jmp	loc_80026E4
; ---------------------------------------------------------------------------

loc_8002CB7:				; CODE XREF: main+31Ej
		nop

loc_8002CB8:				; CODE XREF: main:loc_8002814j
					; main+3ECj ...
		jmp	loc_80026E4
; ---------------------------------------------------------------------------

loc_8002CBD:				; CODE XREF: main+19Dj
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002CC7:				; CODE XREF: main+1A3j
		movzx	eax, ds:flag_dump_strings
		test	al, al
		jz	short loc_8002CFB
		mov	eax, ds:n_specs
		test	eax, eax
		jz	short loc_8002CFB
		sub	esp, 0Ch
		push	offset aNoTypeMayBeSpe ; "no type may be specified when	dumping	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002CFB:				; CODE XREF: main+752j	main+75Bj
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_files], eax
		movzx	eax, [ebp+modern]
		xor	eax, 1
		test	al, al
		jnz	short loc_8002D23
		movzx	eax, ds:traditional
		test	al, al
		jz	loc_800301F

loc_8002D23:				; CODE XREF: main+794j
		mov	eax, [ebp+n_files]
		cmp	eax, 2
		jz	loc_8002DB3
		cmp	eax, 3
		jz	loc_8002EDB
		cmp	eax, 1
		jnz	loc_8002FA0
		movzx	eax, ds:traditional
		test	al, al
		jnz	short loc_8002D6A
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	loc_8002F99

loc_8002D6A:				; CODE XREF: main+7CCj
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+o1]
		push	edx		; offset
		push	eax		; s
		call	parse_old_offset
		add	esp, 10h
		test	al, al
		jz	loc_8002F99
		mov	eax, dword ptr [ebp+o1]
		mov	edx, dword ptr [ebp+o1+4]
		mov	dword ptr ds:n_bytes_to_skip, eax
		mov	dword ptr ds:n_bytes_to_skip+4,	edx
		sub	[ebp+n_files], 1
		add	[ebp+argv], 4
		jmp	loc_8002F99
; ---------------------------------------------------------------------------

loc_8002DB3:				; CODE XREF: main+7ABj
		movzx	eax, ds:traditional
		test	al, al
		jnz	short loc_8002E03
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jz	short loc_8002E03
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_8002F9C

loc_8002E03:				; CODE XREF: main+83Ej	main+85Bj
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+o2]
		push	edx		; offset
		push	eax		; s
		call	parse_old_offset
		add	esp, 10h
		test	al, al
		jz	loc_8002F9C
		movzx	eax, ds:traditional
		test	al, al
		jz	short loc_8002E94
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+o1]
		push	edx		; offset
		push	eax		; s
		call	parse_old_offset
		add	esp, 10h
		test	al, al
		jz	short loc_8002E94
		mov	eax, dword ptr [ebp+o1]
		mov	edx, dword ptr [ebp+o1+4]
		mov	dword ptr ds:n_bytes_to_skip, eax
		mov	dword ptr ds:n_bytes_to_skip+4,	edx
		mov	ds:flag_pseudo_start, 1
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		mov	dword ptr [ebp+pseudo_start], eax
		mov	dword ptr [ebp+pseudo_start+4],	edx
		add	[ebp+argv], 8
		sub	[ebp+n_files], 2
		jmp	loc_8002F9C
; ---------------------------------------------------------------------------

loc_8002E94:				; CODE XREF: main+8BCj	main+8E3j
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		mov	dword ptr ds:n_bytes_to_skip, eax
		mov	dword ptr ds:n_bytes_to_skip+4,	edx
		sub	[ebp+n_files], 1
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	edx, eax
		mov	eax, ds:optind
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+argv], 4
		jmp	loc_8002F9C
; ---------------------------------------------------------------------------

loc_8002EDB:				; CODE XREF: main+7B4j
		movzx	eax, ds:traditional
		test	al, al
		jz	loc_8002F9F
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+o1]
		push	edx		; offset
		push	eax		; s
		call	parse_old_offset
		add	esp, 10h
		test	al, al
		jz	loc_8002F9F
		mov	eax, ds:optind
		add	eax, 2
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+o2]
		push	edx		; offset
		push	eax		; s
		call	parse_old_offset
		add	esp, 10h
		test	al, al
		jz	short loc_8002F9F
		mov	eax, dword ptr [ebp+o1]
		mov	edx, dword ptr [ebp+o1+4]
		mov	dword ptr ds:n_bytes_to_skip, eax
		mov	dword ptr ds:n_bytes_to_skip+4,	edx
		mov	ds:flag_pseudo_start, 1
		mov	eax, dword ptr [ebp+o2]
		mov	edx, dword ptr [ebp+o2+4]
		mov	dword ptr [ebp+pseudo_start], eax
		mov	dword ptr [ebp+pseudo_start+4],	edx
		mov	eax, ds:optind
		add	eax, 2
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	edx, eax
		mov	eax, ds:optind
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+argv], 8
		sub	[ebp+n_files], 2
		jmp	short loc_8002F9F
; ---------------------------------------------------------------------------

loc_8002F99:				; CODE XREF: main+7E6j	main+811j ...
		nop
		jmp	short loc_8002FA0
; ---------------------------------------------------------------------------

loc_8002F9C:				; CODE XREF: main+87Fj	main+8ADj ...
		nop
		jmp	short loc_8002FA0
; ---------------------------------------------------------------------------

loc_8002F9F:				; CODE XREF: main+966j	main+994j ...
		nop

loc_8002FA0:				; CODE XREF: main+7BDj	main+A1Cj ...
		movzx	eax, ds:traditional
		test	al, al
		jz	short loc_800301F
		cmp	[ebp+n_files], 1
		jle	short loc_800301F
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aCompatibilityM ; "compatibility	mode supports at most one"...
		call	gettext
		add	esp, 10h
		push	eax
		push	offset aS_2	; "%s\n"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800301F:				; CODE XREF: main+79Fj	main+A2Bj ...
		movzx	eax, ds:flag_pseudo_start
		test	al, al
		jz	short loc_8003060
		mov	eax, ds:format_address
		cmp	eax, offset format_address_none
		jnz	short loc_8003056
		mov	ds:address_base, 8
		mov	ds:address_pad_len, 7
		mov	ds:format_address, offset format_address_paren
		jmp	short loc_8003060
; ---------------------------------------------------------------------------

loc_8003056:				; CODE XREF: main+AB6j
		mov	ds:format_address, offset format_address_label

loc_8003060:				; CODE XREF: main+AAAj	main+AD6j
		movzx	eax, ds:limit_bytes_to_format
		test	al, al
		jz	short loc_80030D4
		mov	ecx, dword ptr ds:n_bytes_to_skip
		mov	ebx, dword ptr ds:n_bytes_to_skip+4
		mov	eax, dword ptr ds:max_bytes_to_format
		mov	edx, dword ptr ds:max_bytes_to_format+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:end_offset, eax
		mov	dword ptr ds:end_offset+4, edx
		mov	ecx, dword ptr ds:end_offset
		mov	ebx, dword ptr ds:end_offset+4
		mov	eax, dword ptr ds:n_bytes_to_skip
		mov	edx, dword ptr ds:n_bytes_to_skip+4
		cmp	ebx, edx
		ja	short loc_80030D4
		cmp	ebx, edx
		jb	short loc_80030B4
		cmp	ecx, eax
		jnb	short loc_80030D4

loc_80030B4:				; CODE XREF: main+B30j
		sub	esp, 0Ch
		push	offset aSkipBytesReadB ; "skip-bytes + read-bytes is too large"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80030D4:				; CODE XREF: main+AEBj	main+B2Cj ...
		mov	eax, ds:n_specs
		test	eax, eax
		jnz	short loc_80030ED
		sub	esp, 0Ch
		push	offset aOs	; "oS"
		call	decode_format_string
		add	esp, 10h

loc_80030ED:				; CODE XREF: main+B5Dj
		cmp	[ebp+n_files], 0
		jle	short loc_800310B
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	ds:file_list, eax
		jmp	short loc_8003115
; ---------------------------------------------------------------------------

loc_800310B:				; CODE XREF: main+B73j
		mov	ds:file_list, offset default_file_list

loc_8003115:				; CODE XREF: main+B8Bj
		call	open_next_file
		mov	[ebp+ok], al
		mov	eax, ds:in_stream
		test	eax, eax
		jz	loc_8003324
		mov	eax, dword ptr ds:n_bytes_to_skip
		mov	edx, dword ptr ds:n_bytes_to_skip+4
		sub	esp, 8
		push	edx
		push	eax		; n_skip
		call	skip
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	eax, ds:in_stream
		test	eax, eax
		jz	loc_8003327
		movzx	eax, ds:flag_pseudo_start
		test	al, al
		jz	short loc_8003186
		mov	eax, dword ptr ds:n_bytes_to_skip
		mov	edx, dword ptr ds:n_bytes_to_skip+4
		mov	ecx, dword ptr [ebp+pseudo_start]
		mov	ebx, dword ptr [ebp+pseudo_start+4]
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		jmp	short loc_8003190
; ---------------------------------------------------------------------------

loc_8003186:				; CODE XREF: main+BEBj
		mov	eax, 0
		mov	edx, 0

loc_8003190:				; CODE XREF: main+C06j
		mov	dword ptr ds:pseudo_offset, eax
		mov	dword ptr ds:pseudo_offset+4, edx
		call	get_lcm
		mov	[ebp+l_c_m], eax
		cmp	[ebp+width_specified], 0
		jz	short loc_80031FC
		cmp	[ebp+desired_width], 0
		jz	short loc_80031CC
		mov	ecx, [ebp+l_c_m]
		mov	eax, [ebp+desired_width]
		mov	edx, 0
		div	ecx
		mov	eax, edx
		test	eax, eax
		jnz	short loc_80031CC
		mov	eax, [ebp+desired_width]
		mov	ds:bytes_per_block, eax
		jmp	short loc_800321E
; ---------------------------------------------------------------------------

loc_80031CC:				; CODE XREF: main+C2Fj	main+C42j
		sub	esp, 0Ch
		push	offset aWarningInvalid ; "warning: invalid width %lu; using %d in"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+l_c_m]
		push	[ebp+desired_width]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, [ebp+l_c_m]
		mov	ds:bytes_per_block, eax
		jmp	short loc_800321E
; ---------------------------------------------------------------------------

loc_80031FC:				; CODE XREF: main+C29j
		cmp	[ebp+l_c_m], 0Fh
		jg	short loc_8003216
		mov	eax, 10h
		cdq
		idiv	[ebp+l_c_m]
		imul	eax, [ebp+l_c_m]
		mov	ds:bytes_per_block, eax
		jmp	short loc_800321E
; ---------------------------------------------------------------------------

loc_8003216:				; CODE XREF: main+C82j
		mov	eax, [ebp+l_c_m]
		mov	ds:bytes_per_block, eax

loc_800321E:				; CODE XREF: main+C4Cj	main+C7Cj ...
		mov	[ebp+i], 0
		jmp	short loc_800327C
; ---------------------------------------------------------------------------

loc_8003227:				; CODE XREF: main+D06j
		mov	eax, ds:bytes_per_block
		mov	edx, ds:spec
		mov	ecx, [ebp+i]
		shl	ecx, 5
		add	edx, ecx
		mov	edx, [edx+4]
		mov	edx, ds:width_bytes[edx*4]
		mov	esi, edx
		mov	edx, 0
		div	esi
		mov	[ebp+fields_per_block],	eax
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+18h]
		add	eax, 1
		imul	eax, [ebp+fields_per_block]
		mov	[ebp+block_width], eax
		mov	eax, [ebp+block_width]
		cmp	[ebp+width_per_block], eax
		jnb	short loc_8003278
		mov	eax, [ebp+block_width]
		mov	[ebp+width_per_block], eax

loc_8003278:				; CODE XREF: main+CF2j
		add	[ebp+i], 1

loc_800327C:				; CODE XREF: main+CA7j
		mov	eax, ds:n_specs
		cmp	[ebp+i], eax
		jb	short loc_8003227
		mov	[ebp+i], 0
		jmp	short loc_80032ED
; ---------------------------------------------------------------------------

loc_800328F:				; CODE XREF: main+D77j
		mov	eax, ds:bytes_per_block
		mov	edx, ds:spec
		mov	ecx, [ebp+i]
		shl	ecx, 5
		add	edx, ecx
		mov	edx, [edx+4]
		mov	edx, ds:width_bytes[edx*4]
		mov	esi, edx
		mov	edx, 0
		div	esi
		mov	[ebp+fields_per_block_0], eax
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	eax, [eax+18h]
		imul	eax, [ebp+fields_per_block_0]
		mov	[ebp+block_width_0], eax
		mov	eax, ds:spec
		mov	edx, [ebp+i]
		shl	edx, 5
		add	eax, edx
		mov	edx, [ebp+block_width_0]
		mov	ecx, [ebp+width_per_block]
		sub	ecx, edx
		mov	edx, ecx
		mov	[eax+1Ch], edx
		add	[ebp+i], 1

loc_80032ED:				; CODE XREF: main+D0Fj
		mov	eax, ds:n_specs
		cmp	[ebp+i], eax
		jb	short loc_800328F
		movzx	eax, ds:flag_dump_strings
		test	al, al
		jz	short loc_800330C
		call	dump_strings
		movzx	eax, al
		jmp	short loc_8003314
; ---------------------------------------------------------------------------

loc_800330C:				; CODE XREF: main+D82j
		call	dump
		movzx	eax, al

loc_8003314:				; CODE XREF: main+D8Cj
		movzx	edx, [ebp+ok]
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	short cleanup
; ---------------------------------------------------------------------------

loc_8003324:				; CODE XREF: main+BA6j
		nop
		jmp	short cleanup
; ---------------------------------------------------------------------------

loc_8003327:				; CODE XREF: main+BDCj
		nop

cleanup:				; CODE XREF: main+DA4j	main+DA7j
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_8003371
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8003371
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8003371:				; CODE XREF: main+DB3j	main+DC9j
		cmp	[ebp+ok], 0
		jz	short loc_800337E
		mov	eax, 0
		jmp	short loc_8003383
; ---------------------------------------------------------------------------

loc_800337E:				; CODE XREF: main+DF7j
		mov	eax, 1

loc_8003383:				; CODE XREF: main+DFEj
		sub	esp, 0Ch
		push	eax		; status

loc_8003387:				; DATA XREF: .eh_frame:08004F74o
					; .eh_frame:08004F94o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
		assume cs:_data
		;org 800338Ch
; _Bool	abbreviate_duplicate_blocks
abbreviate_duplicate_blocks db 1	; DATA XREF: write_block+15r main+420w
; Function-local static	variable
; _Bool	first_5607
first_5607	db 1			; DATA XREF: write_block+20r
					; write_block:loc_8001C22w
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 80033A0h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; int address_base
address_base	dd ?			; DATA XREF: format_address_std+55r
					; main+14Bw ...
; int address_pad_len
address_pad_len	dd ?			; DATA XREF: format_address_std+44r
					; write_block:loc_8001B17r ...
; size_t string_min
string_min	dd ?			; DATA XREF: dump_strings+13r
					; dump_strings+58r ...
; _Bool	flag_dump_strings
flag_dump_strings db ?			; DATA XREF: open_next_file+D6r
					; main+15Fw ...
; _Bool	traditional
traditional	db ?			; DATA XREF: main:loc_80029AAw
					; main+796r ...
; _Bool	flag_pseudo_start
flag_pseudo_start db ?			; DATA XREF: main+8F6w	main+9D5w ...
		align 10h
; uintmax_t pseudo_offset
pseudo_offset	dq ?			; DATA XREF: format_address_label+31r
					; main:loc_8003190w ...
; void (*format_address)(uintmax_t, char)
format_address	dd ?			; DATA XREF: write_block+D8r
					; dump:loc_800213Cr ...
		align 10h
; uintmax_t n_bytes_to_skip
n_bytes_to_skip	dq ?			; DATA XREF: dump+3Dr dump_strings+38r ...
; _Bool	limit_bytes_to_format
limit_bytes_to_format db ?		; DATA XREF: open_next_file+CBr
					; dump+4Er ...
		align 10h
; uintmax_t max_bytes_to_format
max_bytes_to_format dq ?		; DATA XREF: main+305o	main+AF9r ...
; uintmax_t end_offset
end_offset	dq ?			; DATA XREF: dump:loc_8001EE3r
					; dump+8Fr ...
; tspec	*spec
spec		dd ?			; DATA XREF: decode_format_string+4Fr
					; decode_format_string+67w ...
; size_t n_specs
n_specs		dd ?			; DATA XREF: decode_format_string+46r
					; decode_format_string+71r ...
; size_t n_specs_allocated
n_specs_allocated dd ?			; DATA XREF: decode_format_string:loc_8001455r
					; decode_format_string+59o ...
; size_t bytes_per_block
bytes_per_block	dd ?			; DATA XREF: write_block+2Er
					; write_block+38r ...
; const	char *input_filename
input_filename	dd ?			; DATA XREF: open_next_file+12w
					; open_next_file+17r ...
; const	char *const *file_list
file_list	dd ?			; DATA XREF: open_next_file:loc_80011F5r
					; open_next_file:loc_8001213r ...
; FILE *in_stream
in_stream	dd ?			; DATA XREF: open_next_file+6Aw
					; open_next_file+8Ew ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: open_next_file+6Fw
					; main:cleanupr
		align 10h
; size_spec integral_type_size[9]
integral_type_size dd 9	dup(?)		; DATA XREF: decode_one_format+14Cr
					; decode_one_format+1A0r ...
		align 20h
; size_spec fp_type_size[13]
fp_type_size	dd 0Dh dup(?)		; DATA XREF: decode_one_format+476r
					; decode_one_format+4CAr ...
; Function-local static	variable
; _Bool	prev_pair_equal_5608
prev_pair_equal_5608 db	?		; DATA XREF: write_block+53r
					; write_block+72w ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8003480h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+64o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+70Co
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 20h
; const	unsigned int bytes_to_oct_digits[17]
bytes_to_oct_digits dd 0, 3, 6,	8, 0Bh,	0Eh, 10h, 13h, 16h, 19h, 1Bh, 1Eh
					; DATA XREF: decode_one_format+252r
		dd 20h,	23h, 26h, 29h, 2Bh
		align 20h
; const	unsigned int bytes_to_signed_dec_digits[17]
bytes_to_signed_dec_digits dd 1, 4, 6, 8, 0Bh, 0Dh, 10h, 12h, 14h, 17h,	19h, 1Ch
					; DATA XREF: decode_one_format+1E3r
		dd 1Eh,	21h, 23h, 25h, 28h
		align 20h
; const	unsigned int bytes_to_unsigned_dec_digits[17]
bytes_to_unsigned_dec_digits dd	0, 3, 5, 8, 0Ah, 0Dh, 0Fh, 11h,	14h, 16h, 19h, 1Bh
					; DATA XREF: decode_one_format+283r
		dd 1Dh,	20h, 22h, 25h, 27h
		align 20h
; const	unsigned int bytes_to_hex_digits[17]
bytes_to_hex_digits dd 0, 2, 4,	6, 8, 0Ah, 0Ch,	0Eh, 10h, 12h, 14h, 16h, 18h
					; DATA XREF: decode_one_format+2EFr
		dd 1Ah,	1Ch, 1Eh, 20h
		align 20h
; size_t width_bytes
width_bytes	dd 0FFFFFFFFh, 1, 2, 2 dup(4), 8, 4, 8,	0Ch ; DATA XREF: write_block+A1r
					; get_lcm+26r ...
		align 20h
; char charname[132]
charname	db 6Eh,	75h, 6Ch, 0, 73h, 6Fh, 68h, 0, 73h, 74h, 78h, 0
					; DATA XREF: print_named_ascii+7Bo
		db 65h,	74h, 78h, 0, 65h, 6Fh, 74h, 0, 65h, 6Eh, 71h, 0
		db 61h,	63h, 6Bh, 0, 62h, 65h, 6Ch, 0, 62h, 73h, 2 dup(0)
		db 68h,	74h, 2 dup(0), 6Eh, 6Ch, 2 dup(0), 76h,	74h, 2 dup(0)
		db 2 dup(66h), 2 dup(0), 63h, 72h, 2 dup(0), 73h, 6Fh
		db 2 dup(0), 73h, 69h, 2 dup(0), 64h, 6Ch, 65h,	0, 64h
		db 63h,	31h, 0,	64h, 63h, 32h, 0, 64h, 63h, 33h, 0, 64h
		db 63h,	34h, 0,	6Eh, 61h, 6Bh, 0, 73h, 79h, 6Eh, 0, 65h
		db 74h,	62h, 0,	63h, 61h, 6Eh, 0, 65h, 6Dh, 2 dup(0), 73h
		db 75h,	62h, 0,	65h, 73h, 63h, 0, 66h, 73h, 2 dup(0), 67h
		db 73h,	2 dup(0), 72h, 73h, 2 dup(0), 75h, 73h,	2 dup(0)
		db 73h,	70h, 2 dup(0)
; char asc_8003824[2]
asc_8003824	db '-',0                ; DATA XREF: open_next_file+3Eo
					; check_and_close+5Fo ...
		align 4
; const	char *const default_file_list[2]
default_file_list dd offset asc_8003824, 0 ; DATA XREF:	main:loc_800310Bo
					; "-"
		align 20h
; char short_options[35]
short_options	db 'A:aBbcDdeFfHhIij:LlN:OoS:st:vw::Xx',0 ; DATA XREF: main+179o
aSkipBytes	db 'skip-bytes',0       ; DATA XREF: .rodata:long_optionso
aAddressRadix	db 'address-radix',0    ; DATA XREF: .rodata:long_optionso
aReadBytes	db 'read-bytes',0       ; DATA XREF: .rodata:long_optionso
aFormat		db 'format',0           ; DATA XREF: .rodata:long_optionso
aOutputDuplicat	db 'output-duplicates',0 ; DATA XREF: .rodata:long_optionso
aStrings	db 'strings',0          ; DATA XREF: .rodata:long_optionso
aTraditional	db 'traditional',0      ; DATA XREF: .rodata:long_optionso
aWidth		db 'width',0            ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[11]
long_options	option <offset aSkipBytes, 1, 0, 6Ah> ;	DATA XREF: main+174o
					; main+2DEo ...
		option <offset aAddressRadix, 1, 0, 41h> ; "skip-bytes"
		option <offset aReadBytes, 1, 0, 4Eh>
		option <offset aFormat,	1, 0, 74h>
		option <offset aOutputDuplicat,	0, 0, 76h>
		option <offset aStrings, 2, 0, 53h>
		option <offset aTraditional, 0,	0, 80h>
		option <offset aWidth, 2, 0, 77h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah ; DATA XREF: usage+54o
		db '  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]',0Ah
		db '  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][L'
		db 'ABEL][.][b]]',0Ah,0
		align 4
; char aWriteAnUnambig[]
aWriteAnUnambig	db 0Ah			; DATA XREF: usage+76o
		db 'Write an unambiguous representation, octal bytes by default,',0Ah
		db 'of FILE to standard output.  With more than one FILE argument,',0Ah
		db 'concatenate them in the listed order to form the input.',0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
		align 4
; char aAllArgumentsTo[]
aAllArgumentsTo	db 'All arguments to long options are mandatory for short options.',0Ah,0
					; DATA XREF: usage+99o
; char aAAddressRadixR[]
aAAddressRadixR	db '  -A, --address-radix=RADIX   decide how file offsets are printed'
					; DATA XREF: usage+BCo
		db 0Ah
		db '  -j, --skip-bytes=BYTES      skip BYTES input bytes first',0Ah,0
		align 4
; char aNReadBytesByte[]
aNReadBytesByte	db '  -N, --read-bytes=BYTES      limit dump to BYTES input bytes',0Ah
					; DATA XREF: usage+DFo
		db '  -S, --strings[=BYTES]       output strings of at least BYTES gr'
		db 'aphic chars',0Ah
		db '  -t, --format=TYPE           select output format or formats',0Ah
		db '  -v, --output-duplicates     do not use * to mark line suppressi'
		db 'on',0Ah
		db '  -w, --width[=BYTES]         output BYTES bytes per output line',0Ah
		db '      --traditional           accept arguments in traditional for'
		db 'm',0Ah,0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+102o
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+125o
		align 4
; char aTraditionalFor[]
aTraditionalFor	db 0Ah			; DATA XREF: usage+148o
		db 'Traditional format specifications may be intermixed; they accumul'
		db 'ate:',0Ah
		db '  -a   same as -t a,  select named characters, ignoring high-orde'
		db 'r bit',0Ah
		db '  -b   same as -t o1, select octal bytes',0Ah
		db '  -c   same as -t c,  select ASCII characters or backslash escape'
		db 's',0Ah
		db '  -d   same as -t u2, select unsigned decimal 2-byte units',0Ah,0
		align 10h
; char aFSameAsTFfSele[]
aFSameAsTFfSele	db '  -f   same as -t fF, select floats',0Ah ; DATA XREF: usage+16Bo
		db '  -i   same as -t dI, select decimal ints',0Ah
		db '  -l   same as -t dL, select decimal longs',0Ah
		db '  -o   same as -t o2, select octal 2-byte units',0Ah
		db '  -s   same as -t d2, select decimal 2-byte units',0Ah
		db '  -x   same as -t x2, select hexadecimal 2-byte units',0Ah,0
		align 4
; char aIfFirstAndSeco[]
aIfFirstAndSeco	db 0Ah			; DATA XREF: usage+18Eo
		db 'If first and second call formats both apply, the second format is'
		db ' assumed',0Ah
		db 'if the last operand begins with + or (if there are 2 operands) a '
		db 'digit.',0Ah
		db 'An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address',0Ah
		db 'at first byte printed, incremented when dump is progressing.',0Ah
		db 'For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;',0Ah
		db 'suffixes may be . for octal and b for multiply by 512.',0Ah,0
		align 4
; char aTypeIsMadeUpOf[]
aTypeIsMadeUpOf	db 0Ah			; DATA XREF: usage+1B1o
		db 'TYPE is made up of one or more of these specifications:',0Ah
		db 0Ah
		db '  a          named character, ignoring high-order bit',0Ah
		db '  c          ASCII character or backslash escape',0Ah,0
		align 10h
; char aDSizeSignedDec[]
aDSizeSignedDec	db '  d[SIZE]    signed decimal, SIZE bytes per integer',0Ah
					; DATA XREF: usage+1D4o
		db '  f[SIZE]    floating point, SIZE bytes per integer',0Ah
		db '  o[SIZE]    octal, SIZE bytes per integer',0Ah
		db '  u[SIZE]    unsigned decimal, SIZE bytes per integer',0Ah
		db '  x[SIZE]    hexadecimal, SIZE bytes per integer',0Ah,0
		align 4
; char aSizeIsANumber_[]
aSizeIsANumber_	db 0Ah			; DATA XREF: usage+1F7o
		db 'SIZE is a number.  For TYPE in doux, SIZE may also be C for',0Ah
		db 'sizeof(char), S for sizeof(short), I for sizeof(int) or L for',0Ah
		db 'sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float)'
		db ', D',0Ah
		db 'for sizeof(double) or L for sizeof(long double).',0Ah,0
		align 10h
; char aRadixIsDForDec[]
aRadixIsDForDec	db 0Ah			; DATA XREF: usage+21Ao
		db 'RADIX is d for decimal, o for octal, x for hexadecimal or n for n'
		db 'one.',0Ah
		db 'BYTES is hexadecimal with 0x or 0X prefix, and may have a multipl'
		db 'ier suffix:',0Ah
		db 'b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,',0Ah
		db 'GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.'
		db 0Ah
		db 'Adding a z suffix to any type displays printable characters at th'
		db 'e end of each',0Ah
		db 'output line.',0Ah,0
		align 4
; char aOptionStringWi[]
aOptionStringWi	db 'Option --string without a number implies 3; option --width withou'
					; DATA XREF: usage+23Do
		db 't a number',0Ah
		db 'implies 32.  By default, od uses -A o -t oS -w16.',0Ah,0
asc_8004657	db '  >',0              ; DATA XREF: dump_hexl_mode_trailer+10o
aDel		db 'del',0              ; DATA XREF: print_named_ascii+66o
; char aS[]
aS		db '%*s',0              ; DATA XREF: print_named_ascii+A9o
					; print_ascii+111o ...
a0		db '\0',0               ; DATA XREF: print_ascii:loc_8000A13o
aA		db '\a',0               ; DATA XREF: print_ascii:loc_8000A1Fo
					; dump_strings+286o
aB		db '\b',0               ; DATA XREF: print_ascii:loc_8000A28o
					; dump_strings+2A2o
asc_800466C	db '\f',0               ; DATA XREF: print_ascii:loc_8000A31o
					; dump_strings+2BEo
aN		db '\n',0               ; DATA XREF: print_ascii:loc_8000A3Ao
					; dump_strings+2D7o
aR		db '\r',0               ; DATA XREF: print_ascii:loc_8000A43o
					; dump_strings+2F0o
aT		db '\t',0               ; DATA XREF: print_ascii:loc_8000A4Co
					; dump_strings+309o
aV		db '\v',0               ; DATA XREF: print_ascii:loc_8000A55o
					; dump_strings+322o
; char format[]
format		db '%c',0               ; DATA XREF: print_ascii+DAo
a03o		db '%03o',0             ; DATA XREF: print_ascii:loc_8000A87o
		align 4
off_8004684	dd offset loc_8000A13	; DATA XREF: print_ascii+64r
		dd offset loc_8000A5E	; jump table for switch	statement
		dd offset loc_8000A5E
		dd offset loc_8000A5E
		dd offset loc_8000A5E
		dd offset loc_8000A5E
		dd offset loc_8000A5E
		dd offset loc_8000A1F
		dd offset loc_8000A28
		dd offset loc_8000A4C
		dd offset loc_8000A3A
		dd offset loc_8000A55
		dd offset loc_8000A31
		dd offset loc_8000A43
; char file[]
file		db 'od.c',0             ; DATA XREF: decode_one_format+3Bo
					; decode_one_format+339o ...
; char assertion[]
assertion	db 'tspec != NULL',0    ; DATA XREF: decode_one_format+40o
; char aInvalidTypeStr[]
aInvalidTypeStr	db 'invalid type string %s',0 ; DATA XREF: decode_one_format+10Bo
					; decode_one_format+435o
		align 4
; char aInvalidTypeS_0[]
aInvalidTypeS_0	db 'invalid type string %s;',0Ah ; DATA XREF: decode_one_format+16Do
		db 'this system doesn',27h,'t provide a %lu-byte integral type',0
aLd		db 'ld',0               ; DATA XREF: decode_one_format+1F9o
aD		db 'd',0                ; DATA XREF: decode_one_format:loc_8000D70o
aLld		db 'lld',0              ; DATA XREF: decode_one_format:loc_8000D77o
; char aS_0[]
aS_0		db '%%*%s',0            ; DATA XREF: decode_one_format+216o
					; decode_one_format+2B6o
aLo		db 'lo',0               ; DATA XREF: decode_one_format+23Co
aO		db 'o',0                ; DATA XREF: decode_one_format:loc_8000DB3o
aLlo		db 'llo',0              ; DATA XREF: decode_one_format:loc_8000DBAo
; char a_DS[]
a_DS		db '%%*.%d%s',0         ; DATA XREF: decode_one_format+266o
					; decode_one_format+303o
aLu		db 'lu',0               ; DATA XREF: decode_one_format+299o
aU		db 'u',0                ; DATA XREF: decode_one_format:loc_8000E10o
aLlu		db 'llu',0              ; DATA XREF: decode_one_format:loc_8000E17o
aLx		db 'lx',0               ; DATA XREF: decode_one_format+2D9o
asc_8004762	db 'x',0                ; DATA XREF: decode_one_format:loc_8000E50o
aLlx		db 'llx',0              ; DATA XREF: decode_one_format:loc_8000E57o
; char aStrlenTspecFmt[]
aStrlenTspecFmt	db 'strlen (tspec->fmt_string) < FMT_BYTES_ALLOCATED',0
					; DATA XREF: decode_one_format+33Eo
					; decode_one_format+57Bo
		align 4
; char aInvalidTypeS_1[]
aInvalidTypeS_1	db 'invalid type string %s;',0Ah ; DATA XREF: decode_one_format+497o
		db 'this system doesn',27h,'t provide a %lu-byte floating point type',0
a_De		db '%%*.%de',0          ; DATA XREF: decode_one_format+4EDo
					; decode_one_format+504o
a_Dle		db '%%*.%dLe',0         ; DATA XREF: decode_one_format+51Bo
; char aInvalidCharact[]
aInvalidCharact	db 'invalid character `%c',27h,' in type string %s',0
					; DATA XREF: decode_one_format+5E5o
		align 4
off_800482C	dd offset loc_80010F5	; DATA XREF: decode_one_format+5Fr
		dd offset loc_8001139	; jump table for switch	statement
		dd offset loc_8001117
		dd offset loc_8000BD8
		dd offset loc_8001139
		dd offset loc_8000F20
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8000BD8
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8000BD8
		dd offset loc_8001139
		dd offset loc_8001139
		dd offset loc_8000BD8
off_800488C	dd offset loc_8000F16	; DATA XREF: decode_one_format+354o
		dd offset loc_8000ECD	; jump table for switch	statement
		dd offset loc_8000EE4
		dd offset loc_8000EFB
		dd offset loc_8000F04
		dd offset loc_8000F0D
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: open_next_file+53o
					; main+DCEo
aR_0		db 'r',0                ; DATA XREF: open_next_file+80o
; char aS_1[]
aS_1		db '%s',0               ; DATA XREF: open_next_file+AAo
					; check_and_close+CAo ...
; char aSReadError[]
aSReadError	db '%s: read error',0   ; DATA XREF: check_and_close+36o
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: check_and_close+100o
; char aSNull[]
aSNull		db 's != NULL',0        ; DATA XREF: decode_format_string+36o
; char aSNext[]
aSNext		db 's != next',0        ; DATA XREF: decode_format_string+B4o
		align 4
; char aCannotSkipPast[]
aCannotSkipPast	db 'cannot skip past end of combined input',0 ; DATA XREF: skip+2ABo
a0123456789abcd	db '0123456789abcdef',0 ; DATA XREF: format_address_std+103o
; char s[]
s		db '*',0                ; DATA XREF: write_block+65o
; char locale
locale		db 0			; DATA XREF: write_block+F7o
					; write_block+1B7o ...
; char a0NNBytes_per_b[]
a0NNBytes_per_b	db '0 < n && n <= bytes_per_block',0 ; DATA XREF: read_block+29o
aBb		db 'Bb',0               ; DATA XREF: parse_old_offset+79o
; char aN_bytes_readBy[]
aN_bytes_readBy	db 'n_bytes_read == bytes_per_block',0 ; DATA XREF: dump+10Ao
					; dump+1C0o
off_8004964	dd offset loc_8002439	; DATA XREF: dump_strings+273r
		dd offset loc_8002455	; jump table for switch	statement
		dd offset loc_80024BC
		dd offset loc_800248A
		dd offset loc_80024D5
		dd offset loc_8002471
		dd offset loc_80024A3
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+5Fo
; char aInvalidOutputA[]
aInvalidOutputA	db 'invalid output address radix `%c',27h,'; it must be one character fr'
					; DATA XREF: main+27Ao
		db 'om [doxn]',0
; char aSIsTooLarge[]
aSIsTooLarge	db '%s is too large',0  ; DATA XREF: main+3BFo main+6C6o
; char aA_0[]
aA_0		db 'a',0                ; DATA XREF: main+43Bo
; char aO1[]
aO1		db 'o1',0               ; DATA XREF: main+461o
; char aC_0[]
aC_0		db 'c',0                ; DATA XREF: main+487o
; char aU4[]
aU4		db 'u4',0               ; DATA XREF: main+4ADo
; char aU2[]
aU2		db 'u2',0               ; DATA XREF: main+4D3o
; char aFd[]
aFd		db 'fD',0               ; DATA XREF: main+4F9o
; char aFf[]
aFf		db 'fF',0               ; DATA XREF: main+51Fo
; char aX4[]
aX4		db 'x4',0               ; DATA XREF: main+545o
; char aDi[]
aDi		db 'dI',0               ; DATA XREF: main+56Bo
; char aDl[]
aDl		db 'dL',0               ; DATA XREF: main+591o
; char aO4[]
aO4		db 'o4',0               ; DATA XREF: main+5B7o
; char aO2[]
aO2		db 'o2',0               ; DATA XREF: main+5DDo
; char aD2[]
aD2		db 'd2',0               ; DATA XREF: main+603o
; char aX2[]
aX2		db 'x2',0               ; DATA XREF: main+629o
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+706o
aOd		db 'od',0               ; DATA XREF: main+711o
; char aNoTypeMayBeSpe[]
aNoTypeMayBeSpe	db 'no type may be specified when dumping strings',0 ; DATA XREF: main+760o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+A5Ao
		align 4
; char aCompatibilityM[]
aCompatibilityM	db 'compatibility mode supports at most one file',0 ; DATA XREF: main+A78o
; char aS_2[]
aS_2		db '%s',0Ah,0           ; DATA XREF: main+A86o
		align 4
; char aSkipBytesReadB[]
aSkipBytesReadB	db 'skip-bytes + read-bytes is too large',0 ; DATA XREF: main+B39o
; char aOs[]
aOs		db 'oS',0               ; DATA XREF: main+B62o
; char aWarningInvalid[]
aWarningInvalid	db 'warning: invalid width %lu; using %d instead',0 ; DATA XREF: main+C51o
		align 4
off_8004AF4	dd offset loc_8002C74, offset loc_8002C6A, offset loc_8002CA7
					; DATA XREF: main+1BBr
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7 ;	jump table for switch statement
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002742, offset loc_8002B58
		dd offset loc_8002CA7, offset loc_8002A28, offset loc_8002CA7
		dd offset loc_8002A74, offset loc_8002CA7, offset loc_8002AC0
		dd offset loc_8002B0C, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002B0C, offset loc_8002CA7, offset loc_800286B
		dd offset loc_8002B32, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_80028C4, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002AC0, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_80029B6, offset loc_80029DC, offset loc_8002A02
		dd offset loc_8002A4E, offset loc_8002A74, offset loc_8002A9A
		dd offset loc_8002CA7, offset loc_8002BA4, offset loc_8002AE6
		dd offset loc_8002819, offset loc_8002CA7, offset loc_8002B0C
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002B58
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002B7E, offset loc_800296F, offset loc_8002CA7
		dd offset loc_800299A, offset loc_8002BCA, offset loc_8002BA4
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_8002CA7, offset loc_8002CA7
		dd offset loc_8002CA7, offset loc_80029AA
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5493[18]
__PRETTY_FUNCTION___5493 db 'decode_one_format',0 ; DATA XREF: decode_one_format+31o
					; decode_one_format+32Fo ...
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5546[21]
__PRETTY_FUNCTION___5546 db 'decode_format_string',0 ; DATA XREF: decode_format_string+27o
					; decode_format_string+A5o
		align 10h
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5631[11]
__PRETTY_FUNCTION___5631 db 'read_block',0 ; DATA XREF: read_block:loc_8001CCFo
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5660[5]
__PRETTY_FUNCTION___5660 db 'dump',0    ; DATA XREF: dump+FBo dump+1B1o
		align 4
; Function-local static	variable
; const	char multipliers_5711[13]
multipliers_5711 db 'bEGKkMmPTYZ0',0    ; DATA XREF: main+2A7o main+300o ...
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8004F54h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8003387-80082FBh
		dd 2Bh,	80E4100h, 0D420285h, 0CC56705h,	404h, 1Ch, 3Ch
		dd offset loc_8003387-80082F0h
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 20h, 5Ch
		dd offset loc_8003387-80082EDh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	80h
		dd offset loc_8003387-80081F5h
		dd 267h, 80E4100h, 0D420285h, 3874605h,	5830486h, 1Ch
		dd 0A0h
		dd offset loc_8003387-8007FAEh
		dd 72h,	80E4100h, 0D420285h, 0C56E0205h, 4040Ch, 1Ch, 0C0h
		dd offset loc_8003387-8007F5Ch
		dd 72h,	80E4100h, 0D420285h, 0C56E0205h, 4040Ch, 1Ch, 0E0h
		dd offset loc_8003387-8007F0Ah
		dd 70h,	80E4100h, 0D420285h, 0C56C0205h, 4040Ch, 1Ch, 100h
		dd offset loc_8003387-8007EBAh
		dd 72h,	80E4100h, 0D420285h, 0C56E0205h, 4040Ch, 1Ch, 120h
		dd offset loc_8003387-8007E68h
		dd 6Eh,	80E4100h, 0D420285h, 0C56A0205h, 4040Ch, 1Ch, 140h
		dd offset loc_8003387-8007E1Ah
		dd 6Eh,	80E4100h, 0D420285h, 0C56A0205h, 4040Ch, 20h, 160h
		dd offset loc_8003387-8007DCCh
		dd 73h,	80E4100h, 0D420285h, 3834405h, 0C3C56B02h, 4040Ch
		dd 1Ch,	184h
		dd offset loc_8003387-8007D7Dh
		dd 71h,	80E4100h, 0D420285h, 0C56D0205h, 4040Ch, 1Ch, 1A4h
		dd offset loc_8003387-8007D2Ch
		dd 71h,	80E4100h, 0D420285h, 0C56D0205h, 4040Ch, 1Ch, 1C4h
		dd offset loc_8003387-8007CDBh
		dd 74h,	80E4100h, 0D420285h, 0C5700205h, 4040Ch, 1Ch, 1E4h
		dd offset loc_8003387-8007C87h
		dd 8Ah,	80E4100h, 0D420285h, 0C5860205h, 4040Ch, 1Ch, 204h
		dd offset loc_8003387-8007C1Dh
		dd 0E0h, 80E4100h, 0D420285h, 0C5DC0205h, 4040Ch, 20h
		dd 224h
		dd offset loc_8003387-8007B5Dh
		dd 14Bh, 80E4100h, 0D420285h, 3834405h,	0C5014303h, 4040CC3h
		dd 1Ch,	248h
		dd offset loc_8003387-8007A36h
		dd 7Fh,	80E4100h, 0D420285h, 0C57B0205h, 4040Ch, 28h, 268h
		dd offset loc_8003387-80079D7h
		dd 67Ah, 80E4100h, 0D420285h, 3864505h,	6F030483h, 0C641C306h
		dd 40CC541h, 4,	20h, 294h
		dd offset loc_8003387-8007389h
		dd 101h, 80E4100h, 0D420285h, 3834405h,	0C3C5F902h, 4040Ch
		dd 20h,	2B8h
		dd offset loc_8003387-80072ACh
		dd 12Ah, 80E4100h, 0D420285h, 3834405h,	0C5012203h, 4040CC3h
		dd 1Ch,	2DCh
		dd offset loc_8003387-80071A6h
		dd 0F7h, 80E4100h, 0D420285h, 0C5F30205h, 4040Ch, 20h
		dd 2FCh
		dd offset loc_8003387-80070CFh
		dd 2E5h, 80E4100h, 0D420285h, 3834705h,	0C502DA03h, 4040CC3h
		dd 1Ch,	320h
		dd offset loc_8003387-8006E0Eh
		dd 1Bh,	80E4100h, 0D420285h, 0CC55705h,	404h, 20h, 340h
		dd offset loc_8003387-8006E13h
		dd 16Eh, 80E4100h, 0D420285h, 3834405h,	0C5016603h, 4040CC3h
		dd 1Ch,	364h
		dd offset loc_8003387-8006CC9h
		dd 51h,	80E4100h, 0D420285h, 0C54D0205h, 4040Ch, 24h, 384h
		dd offset loc_8003387-8006C98h
		dd 5Dh,	80E4100h, 0D420285h, 3864505h, 52020483h, 41C641C3h
		dd 4040CC5h, 2Ch, 3ACh
		dd offset loc_8003387-8006C63h
		dd 20Ah, 80E4100h, 0D420285h, 3874605h,	5830486h, 0C301FD03h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 3DCh
		dd offset loc_8003387-8006A89h
		dd 83h,	80E4100h, 0D420285h, 0C57F0205h, 4040Ch, 1Ch, 3FCh
		dd offset loc_8003387-8006A26h
		dd 0E7h, 80E4100h, 0D420285h, 0C5E30205h, 4040Ch, 1Ch
		dd 41Ch
		dd offset loc_8003387-800695Fh
		dd 52h,	80E4100h, 0D420285h, 0C54E0205h, 4040Ch, 1Ch, 43Ch
		dd offset loc_8003387-800692Dh
		dd 98h,	80E4100h, 0D420285h, 0C5940205h, 4040Ch, 20h, 45Ch
		dd offset loc_8003387-80068B5h
		dd 337h, 80E4100h, 0D420285h, 3834405h,	0C5032F03h, 4040CC3h
		dd 28h,	480h
		dd offset loc_8003387-80065A2h
		dd 3C1h, 80E4100h, 0D420285h, 3864505h,	0B6030483h, 0C641C303h
		dd 40CC541h, 4,	28h, 4ACh
		dd offset loc_8003387-800620Dh
		dd 0E0Eh, 10C4400h, 5104700h, 45007502h, 7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+6Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+88p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+54p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+262p main+724p ...
		extrn xprintf:near	; CODE XREF: print_s_char+55p
					; print_char+55p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	dump_hexl_mode_trailer+15p
					; dump_strings+28Bp ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: dump_hexl_mode_trailer+34p
					; print_ascii+BCp ...
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: dump_hexl_mode_trailer+68p
					; dump_hexl_mode_trailer+7Fp ...
		extrn __stack_chk_fail:near ; CODE XREF: print_named_ascii+D9p
					; print_ascii+141p ...
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: print_ascii+EFp
					; decode_one_format+21Cp ...
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: decode_one_format+45p
					; decode_one_format+343p ...
		extrn quote:near	; CODE XREF: decode_one_format+FEp
					; decode_one_format+160p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: decode_one_format+11Ep
					; decode_one_format+184p ...
; void abort(void)
		extrn abort:near	; CODE XREF: decode_one_format:loc_8000E83p
					; decode_one_format:loc_8000F16p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: decode_one_format+322p
					; decode_one_format+55Bp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: open_next_file+44p
					; check_and_close+65p ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: open_next_file+65r
					; main+DB5r
		extrn fopen64:near	; CODE XREF: open_next_file+86p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: open_next_file+A2p
					; check_and_close+C2p ...
; int setvbuf(FILE *stream, char *buf, int modes, size_t n)
		extrn setvbuf:near	; CODE XREF: open_next_file+F0p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	check_and_close+21p
					; check_and_close+F1p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: check_and_close+7Ap
					; check_and_close+B0p ...
		extrn x2nrealloc:near	; CODE XREF: decode_format_string+5Fp
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: skip+5Fp
		extrn fstat64:near	; CODE XREF: skip+74p
		extrn rpl_fseeko:near	; CODE XREF: skip+113p
; size_t fread_unlocked(void *ptr, size_t size,	size_t n, FILE *stream)
		extrn fread_unlocked:near ; CODE XREF: skip+19Fp
					; read_block+75p
		extrn __umoddi3:near	; CODE XREF: format_address_std+B7p
		extrn __udivdi3:near	; CODE XREF: format_address_std+D5p
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: write_block+47p
; int puts(const char *s)
		extrn puts:near		; CODE XREF: write_block+6Ap
; int fgetc(FILE *stream)
		extrn fgetc:near	; CODE XREF: read_char+1Ep
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: parse_old_offset+2Dp
		extrn xstrtoumax:near	; CODE XREF: parse_old_offset+89p
					; main+2B6p ...
		extrn xnmalloc:near	; CODE XREF: dump+25p
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: dump+273p
; void free(void *ptr)
		extrn free:near		; CODE XREF: dump+315p
					; dump_strings+F2p ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: dump_strings+2Dp
		extrn x2realloc:near	; CODE XREF: dump_strings+15Bp
; int putc_unlocked(int	c, FILE	*stream)
		extrn putc_unlocked:near ; CODE	XREF: dump_strings+33Fp
		extrn set_program_name:near ; CODE XREF: main+42p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+69p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+79p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+84o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+89p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+183p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+1C8r
					; main:loc_80027EAr ...
		extrn xstrtol_fatal:near ; CODE	XREF: main+2E8p main+341p ...
		extrn Version:dword	; DATA XREF: main:loc_8002C74r
		extrn version_etc:near	; CODE XREF: main+717p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8002CFBr
					; main+7CEr ...


		end
