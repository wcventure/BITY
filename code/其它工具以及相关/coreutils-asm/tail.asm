;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	FC7C7B16CD776336AE13C6258C7E5F6E
; Input	CRC32 :	4B9E6765

; File Name   :	D:\coreutils-o\tail.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'tail.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl timespec_cmp(timespec a, timespec	b)
timespec_cmp	proc near		; CODE XREF: tail_forever+375p
					; check_fspec+18Fp

a		= timespec ptr	8
b		= timespec ptr	10h

		push	ebp
		mov	ebp, esp
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jl	short loc_800003F
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jg	short loc_8000038
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		jl	short loc_8000031
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		setnle	al
		movzx	eax, al
		jmp	short loc_8000044
; ---------------------------------------------------------------------------

loc_8000031:				; CODE XREF: timespec_cmp+1Fj
		mov	eax, 0FFFFFFFFh
		jmp	short loc_8000044
; ---------------------------------------------------------------------------

loc_8000038:				; CODE XREF: timespec_cmp+15j
		mov	eax, 1
		jmp	short loc_8000044
; ---------------------------------------------------------------------------

loc_800003F:				; CODE XREF: timespec_cmp+Bj
		mov	eax, 0FFFFFFFFh

loc_8000044:				; CODE XREF: timespec_cmp+2Fj
					; timespec_cmp+36j ...
		pop	ebp
		retn
timespec_cmp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+1D9p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_800012C
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800012C
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_800012C:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: record_open_fd+4Cp
					; tail_forever+350p ...

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: parse_options+37Ep
					; parse_options+3EAp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80001BA
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800035B
; ---------------------------------------------------------------------------

loc_80001BA:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aPrintTheLastDL ; "Print	the last %d lines of each FILE to"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	0Ah
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCBytesKOutputT ; "  -c,	--bytes=K	     output the	l"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFFollowNameDes ; "  -f,	--follow[={name|descriptor}]\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aNLinesKOutputT ; "  -n,	--lines=K	     output the	l"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	5
		push	0Ah
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPidPidWithFTer ; "	--pid=PID	     with -f, ter"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSSleepInterval ; "  -s,	--sleep-interval=N   with -f, sle"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfTheFirstChar ; "\nIf the first character of K	(the numb"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithFollowFTai ; "With --follow	(-f), tail defaults to fo"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800035B:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	valid_file_spec(const File_spec	*f)
valid_file_spec	proc near		; CODE XREF: recheck+8Ep

f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		cmp	eax, 0FFFFFFFFh
		setz	al
		movzx	edx, al
		mov	eax, [ebp+f]
		mov	eax, [eax+30h]
		test	eax, eax
		setz	al
		movzx	eax, al
		xor	eax, edx
		test	eax, eax
		setnz	al
		pop	ebp
		retn
valid_file_spec	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl pretty_name(const	File_spec *f)
pretty_name	proc near		; CODE XREF: recheck+12Bp recheck+181p ...

f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80003C1
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		jmp	short locret_80003C6
; ---------------------------------------------------------------------------

loc_80003C1:				; CODE XREF: pretty_name+1Ej
		mov	eax, [ebp+f]
		mov	eax, [eax]

locret_80003C6:				; CODE XREF: pretty_name+30j
		leave
		retn
pretty_name	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl xwrite_stdout(const char	*buffer, size_t	n_bytes)
xwrite_stdout	proc near		; CODE XREF: dump_remainder+11Fp
					; file_lines+2DFp ...

var_4		= dword	ptr -4
buffer		= dword	ptr  8
n_bytes		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+n_bytes], 0
		jz	short loc_8000417
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+n_bytes]	; n
		push	1		; size
		push	[ebp+buffer]	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000417
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000417:				; CODE XREF: xwrite_stdout+Bj
					; xwrite_stdout+25j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
xwrite_stdout	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl record_open_fd(File_spec	*f, int	fd, off_t size,	const stat *st,	int blocking)
record_open_fd	proc near		; CODE XREF: recheck+4DFp
					; tail_file+33Fp

var_30		= timespec ptr -30h
size		= qword	ptr -28h
st		= dword	ptr -20h
f		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
blocking	= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+size], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+size+4],	eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+st], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+f]
		mov	edx, [ebp+fd]
		mov	[eax+2Ch], edx
		mov	ecx, [ebp+f]
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		mov	ebx, [ebp+f]
		lea	eax, [ebp+var_30]
		push	[ebp+st]	; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 4
		mov	eax, [ebp+var_30.tv_sec]
		mov	edx, [ebp+var_30.tv_nsec]
		mov	[ebx+0Ch], eax
		mov	[ebx+10h], edx
		mov	eax, [ebp+st]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+f]
		mov	[ecx+14h], eax
		mov	[ecx+18h], edx
		mov	eax, [ebp+st]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	ecx, [ebp+f]
		mov	[ecx+1Ch], eax
		mov	[ecx+20h], edx
		mov	eax, [ebp+st]
		mov	edx, [eax+10h]
		mov	eax, [ebp+f]
		mov	[eax+24h], edx
		mov	eax, [ebp+f]
		mov	edx, [ebp+blocking]
		mov	[eax+34h], edx
		mov	eax, [ebp+f]
		mov	dword ptr [eax+44h], 0
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+f]
		mov	byte ptr [eax+28h], 0
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_80004DF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80004DF:				; CODE XREF: record_open_fd+BBj
		mov	ebx, [ebp+var_4]
		leave
		retn
record_open_fd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl close_fd(int fd,	const char *filename)
close_fd	proc near		; CODE XREF: recheck+2F4p recheck+317p ...

var_4		= dword	ptr -4
fd		= dword	ptr  8
filename	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+fd], 0FFFFFFFFh
		jz	short loc_8000537
		cmp	[ebp+fd], 0
		jz	short loc_8000537
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000537
		sub	esp, 0Ch
		push	offset aClosingSFdD ; "closing %s (fd=%d)"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	[ebp+fd]
		push	[ebp+filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8000537:				; CODE XREF: close_fd+Bj close_fd+11j	...
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
close_fd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_header(const char *pretty_filename)
write_header	proc near		; CODE XREF: tail_forever+57Dp
					; check_fspec+1C0p ...

pretty_filename	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, first_file_5431
		test	al, al
		jz	short loc_8000555
		mov	eax, offset locale
		jmp	short loc_800055A
; ---------------------------------------------------------------------------

loc_8000555:				; CODE XREF: write_header+Fj
		mov	eax, offset asc_800580A	; "\n"

loc_800055A:				; CODE XREF: write_header+16j
		sub	esp, 4
		push	[ebp+pretty_filename]
		push	eax
		push	offset format	; "%s==> %s <==\n"
		call	printf
		add	esp, 10h
		mov	first_file_5431, 0
		nop
		leave
		retn
write_header	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl dump_remainder(const char *pretty_filename,	int fd,	uintmax_t n_bytes)
dump_remainder	proc near		; CODE XREF: file_lines+31Dp
					; file_lines+3B6p ...

n_bytes		= qword	ptr -2038h
pretty_filename	= dword	ptr -202Ch
n		= dword	ptr -2028h
bytes_read	= dword	ptr -2024h
n_written	= qword	ptr -2020h
n_remaining	= qword	ptr -2018h
buffer		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2030h
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		mov	dword ptr [ebp+n_remaining], eax
		mov	dword ptr [ebp+n_remaining+4], edx
		mov	dword ptr [ebp+n_written], 0
		mov	dword ptr [ebp+n_written+4], 0

loc_80005D5:				; CODE XREF: dump_remainder+156j
					; dump_remainder+19Dj
		mov	eax, dword ptr [ebp+n_remaining]
		mov	edx, dword ptr [ebp+n_remaining+4]
		cmp	edx, 0
		jb	short loc_80005FC
		cmp	edx, 0
		ja	short loc_80005F2
		cmp	eax, 2000h
		jbe	short loc_80005FC

loc_80005F2:				; CODE XREF: dump_remainder+71j
		mov	eax, 2000h
		mov	edx, 0

loc_80005FC:				; CODE XREF: dump_remainder+6Cj
					; dump_remainder+78j
		mov	[ebp+n], eax
		sub	esp, 4
		push	[ebp+n]
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_800067A
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 0Bh
		jz	loc_800071A
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_800071A
; ---------------------------------------------------------------------------

loc_800067A:				; CODE XREF: dump_remainder+B2j
		cmp	[ebp+bytes_read], 0
		jz	loc_800071D
		sub	esp, 8
		push	[ebp+bytes_read] ; n_bytes
		lea	eax, [ebp+buffer]
		push	eax		; buffer
		call	xwrite_stdout
		add	esp, 10h
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+n_written], eax
		adc	dword ptr [ebp+n_written+4], edx
		mov	eax, dword ptr [ebp+n_bytes+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+n_bytes]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	loc_80005D5
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+n_remaining], eax
		sbb	dword ptr [ebp+n_remaining+4], edx
		mov	eax, dword ptr [ebp+n_remaining+4]
		or	eax, dword ptr [ebp+n_remaining]
		test	eax, eax
		jz	short loc_800071E
		mov	eax, dword ptr [ebp+n_bytes+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+n_bytes]
		xor	eax, 0FFFFFFFEh
		or	eax, edx
		test	eax, eax
		jz	short loc_800071E
		jmp	loc_80005D5
; ---------------------------------------------------------------------------

loc_800071A:				; CODE XREF: dump_remainder+BEj
					; dump_remainder+FDj
		nop
		jmp	short loc_800071E
; ---------------------------------------------------------------------------

loc_800071D:				; CODE XREF: dump_remainder+109j
		nop

loc_800071E:				; CODE XREF: dump_remainder+181j
					; dump_remainder+19Bj ...
		mov	eax, dword ptr [ebp+n_written]
		mov	edx, dword ptr [ebp+n_written+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800073B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800073B:				; CODE XREF: dump_remainder+1BCj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
dump_remainder	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; off_t	__cdecl	xlseek(int fd, off_t offset, int whence, const char *filename)
xlseek		proc near		; CODE XREF: file_lines+16Ap
					; file_lines+397p ...

filename	= dword	ptr -44h
offset		= qword	ptr -40h
s		= dword	ptr -34h
new_offset	= qword	ptr -30h
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
whence		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+offset],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+offset+4], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+filename],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		push	[ebp+whence]
		push	dword ptr [ebp+offset+4]
		push	dword ptr [ebp+offset]
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+new_offset], eax
		mov	dword ptr [ebp+new_offset+4], edx
		cmp	dword ptr [ebp+new_offset+4], 0
		js	short loc_80007A1
		mov	eax, dword ptr [ebp+new_offset]
		mov	edx, dword ptr [ebp+new_offset+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	loc_8000872
		jmp	loc_800086D
; ---------------------------------------------------------------------------

loc_80007A1:				; CODE XREF: xlseek+42j
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+offset+4]
		push	dword ptr [ebp+offset]
		call	offtostr
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+whence]
		cmp	eax, 1
		jz	short loc_80007FE
		cmp	eax, 2
		jz	short loc_800082E
		test	eax, eax
		jnz	loc_800085E
		sub	esp, 0Ch
		push	offset aSCannotSeekToO ; "%s: cannot seek to offset %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	[ebp+s]
		push	[ebp+filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	short loc_8000863
; ---------------------------------------------------------------------------

loc_80007FE:				; CODE XREF: xlseek+7Dj
		sub	esp, 0Ch
		push	offset aSCannotSeekToR ; "%s: cannot seek to relative offset %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	[ebp+s]
		push	[ebp+filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	short loc_8000863
; ---------------------------------------------------------------------------

loc_800082E:				; CODE XREF: xlseek+82j
		sub	esp, 0Ch
		push	offset aSCannotSeekToE ; "%s: cannot seek to end-relative offset "...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	[ebp+s]
		push	[ebp+filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	short loc_8000863
; ---------------------------------------------------------------------------

loc_800085E:				; CODE XREF: xlseek+86j
		call	abort
; ---------------------------------------------------------------------------

loc_8000863:				; CODE XREF: xlseek+BAj xlseek+EAj ...
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800086D:				; CODE XREF: xlseek+5Aj
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000872:				; CODE XREF: xlseek+54j
		mov	ebx, [ebp+var_4]
		leave
		retn
xlseek		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	file_lines(const char *pretty_filename,	int fd,	uintmax_t n_lines, off_t start_pos, off_t end_pos, uintmax_t *read_pos)
file_lines	proc near		; CODE XREF: tail_lines+1F0p

var_2070	= dword	ptr -2070h
var_206C	= dword	ptr -206Ch
var_2068	= dword	ptr -2068h
var_2064	= dword	ptr -2064h
var_2060	= dword	ptr -2060h
var_205C	= dword	ptr -205Ch
end_pos		= qword	ptr -2058h
start_pos	= qword	ptr -2050h
n_lines		= qword	ptr -2048h
read_pos	= dword	ptr -2040h
pretty_filename	= dword	ptr -203Ch
bytes_read	= dword	ptr -2034h
n		= dword	ptr -2030h
nl		= dword	ptr -202Ch
pos		= qword	ptr -2028h
buffer		= byte ptr -201Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 206Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [ebp+start_pos], eax
		mov	eax, [ebp+arg_14]
		mov	dword ptr [ebp+start_pos+4], eax
		mov	eax, [ebp+arg_18]
		mov	dword ptr [ebp+end_pos], eax
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [ebp+end_pos+4], eax
		mov	eax, [ebp+arg_20]
		mov	[ebp+read_pos],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		mov	dword ptr [ebp+pos], eax
		mov	dword ptr [ebp+pos+4], edx
		mov	eax, dword ptr [ebp+n_lines+4]
		or	eax, dword ptr [ebp+n_lines]
		test	eax, eax
		jnz	short loc_8000908
		mov	eax, 1
		jmp	loc_8000D32
; ---------------------------------------------------------------------------

loc_8000908:				; CODE XREF: file_lines+85j
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		sub	eax, dword ptr [ebp+start_pos]
		sbb	edx, dword ptr [ebp+start_pos+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, ebx
		sar	eax, 1Fh
		cdq
		mov	edi, ecx
		xor	edi, eax
		mov	[ebp+var_2068],	edi
		mov	edi, ebx
		xor	edi, edx
		mov	[ebp+var_2064],	edi
		mov	ecx, [ebp+var_2068]
		mov	ebx, [ebp+var_2064]
		sub	ecx, eax
		sbb	ebx, edx
		mov	edi, ecx
		and	edi, 1FFFh
		mov	[ebp+var_2060],	edi
		mov	edi, ebx
		and	edi, 0
		mov	[ebp+var_205C],	edi
		mov	esi, [ebp+var_2060]
		xor	esi, eax
		mov	[ebp+var_2070],	esi
		mov	edi, [ebp+var_205C]
		xor	edi, edx
		mov	[ebp+var_206C],	edi
		mov	ebx, [ebp+var_2070]
		mov	esi, [ebp+var_206C]
		sub	ebx, eax
		sbb	esi, edx
		mov	eax, ebx
		mov	edx, esi
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_80009B0
		mov	[ebp+bytes_read], 2000h

loc_80009B0:				; CODE XREF: file_lines+12Dj
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+pos], eax
		sbb	dword ptr [ebp+pos+4], edx
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	0		; whence
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos] ; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		sub	esp, 4
		push	[ebp+bytes_read]
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8000A56
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D32
; ---------------------------------------------------------------------------

loc_8000A56:				; CODE XREF: file_lines+19Aj
		mov	ecx, [ebp+bytes_read]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		cmp	[ebp+bytes_read], 0
		jz	short loc_8000AA8
		mov	eax, [ebp+bytes_read]
		sub	eax, 1
		movzx	eax, [ebp+eax+buffer]
		cmp	al, 0Ah
		jz	short loc_8000AA8
		add	dword ptr [ebp+n_lines], 0FFFFFFFFh
		adc	dword ptr [ebp+n_lines+4], 0FFFFFFFFh

loc_8000AA8:				; CODE XREF: file_lines+20Cj
					; file_lines+221j ...
		mov	eax, [ebp+bytes_read]
		mov	[ebp+n], eax
		jmp	loc_8000BC4
; ---------------------------------------------------------------------------

loc_8000AB9:				; CODE XREF: file_lines+354j
		sub	esp, 4
		push	[ebp+n]
		push	0Ah
		lea	eax, [ebp+buffer]
		push	eax
		call	memrchr
		add	esp, 10h
		mov	[ebp+nl], eax
		cmp	[ebp+nl], 0
		jz	loc_8000BD3
		mov	edx, [ebp+nl]
		lea	eax, [ebp+buffer]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n], eax
		mov	eax, dword ptr [ebp+n_lines]
		mov	edx, dword ptr [ebp+n_lines+4]
		mov	ecx, eax
		mov	ebx, edx
		add	ecx, 0FFFFFFFFh
		adc	ebx, 0FFFFFFFFh
		mov	dword ptr [ebp+n_lines], ecx
		mov	dword ptr [ebp+n_lines+4], ebx
		or	eax, edx
		test	eax, eax
		jnz	loc_8000BC4
		mov	eax, [ebp+bytes_read]
		sub	eax, 1
		cmp	eax, [ebp+n]
		jz	short loc_8000B5E
		mov	eax, [ebp+bytes_read]
		sub	eax, [ebp+n]
		lea	edx, [eax-1]
		mov	eax, [ebp+nl]
		add	eax, 1
		sub	esp, 8
		push	edx		; n_bytes
		push	eax		; buffer
		call	xwrite_stdout
		add	esp, 10h

loc_8000B5E:				; CODE XREF: file_lines+2C0j
		mov	ecx, [ebp+bytes_read]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		add	ecx, eax
		adc	ebx, edx
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		sub	eax, ecx
		sbb	edx, ebx
		push	edx
		push	eax		; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, 1
		jmp	loc_8000D32
; ---------------------------------------------------------------------------

loc_8000BC4:				; CODE XREF: file_lines+23Dj
					; file_lines+2ABj
		cmp	[ebp+n], 0
		jnz	loc_8000AB9
		jmp	short loc_8000BD4
; ---------------------------------------------------------------------------

loc_8000BD3:				; CODE XREF: file_lines+269j
		nop

loc_8000BD4:				; CODE XREF: file_lines+35Aj
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+start_pos+4]
		xor	eax, dword ptr [ebp+start_pos]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000C5E
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	0		; whence
		push	dword ptr [ebp+start_pos+4]
		push	dword ptr [ebp+start_pos] ; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		push	edx
		push	eax		; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr [ebp+start_pos]
		mov	edx, dword ptr [ebp+start_pos+4]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, 1
		jmp	loc_8000D32
; ---------------------------------------------------------------------------

loc_8000C5E:				; CODE XREF: file_lines+37Bj
		add	dword ptr [ebp+pos], 0FFFFE000h
		adc	dword ptr [ebp+pos+4], 0FFFFFFFFh
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	0		; whence
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos] ; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8000CFA
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8000D32
; ---------------------------------------------------------------------------

loc_8000CFA:				; CODE XREF: file_lines+441j
		mov	ecx, [ebp+bytes_read]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		cmp	[ebp+bytes_read], 0
		jnz	loc_8000AA8
		mov	eax, 1

loc_8000D32:				; CODE XREF: file_lines+8Cj
					; file_lines+1DAj ...
		mov	edx, [ebp+var_1C]
		xor	edx, large gs:14h
		jz	short loc_8000D43
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000D43:				; CODE XREF: file_lines+4C5j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
file_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	pipe_lines(const char *pretty_filename,	int fd,	uintmax_t n_lines, uintmax_t *read_pos)
pipe_lines	proc near		; CODE XREF: tail_lines+254p

n_lines		= qword	ptr -40h
ok		= byte ptr -31h
first		= dword	ptr -30h
last		= dword	ptr -2Ch
tmp		= dword	ptr -28h
total_lines	= dword	ptr -24h
p		= dword	ptr -20h
beg		= dword	ptr -1Ch
j		= dword	ptr -18h
n_read		= dword	ptr -14h
buffer_end	= dword	ptr -10h
buffer_end_0	= dword	ptr -0Ch
pretty_filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
read_pos	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 40h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	[ebp+total_lines], 0
		mov	[ebp+ok], 1
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+last], eax
		mov	eax, [ebp+last]
		mov	[ebp+first], eax
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2004h], 0
		mov	eax, [ebp+first]
		mov	edx, [eax+2004h]
		mov	eax, [ebp+first]
		mov	[eax+2000h], edx
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2008h], 0
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax

loc_8000DC2:				; CODE XREF: pipe_lines+1C0j
					; pipe_lines+21Fj ...
		mov	eax, [ebp+tmp]
		sub	esp, 4
		push	2000h
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0
		jz	loc_8000F87
		cmp	[ebp+n_read], 0FFFFFFFFh
		jz	loc_8000F87
		mov	eax, [ebp+tmp]
		mov	edx, [ebp+n_read]
		mov	[eax+2000h], edx
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+n_read]
		mov	ebx, 0
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+tmp]
		mov	dword ptr [eax+2004h], 0
		mov	eax, [ebp+tmp]
		mov	dword ptr [eax+2008h], 0
		mov	edx, [ebp+tmp]
		mov	eax, [ebp+n_read]
		add	eax, edx
		mov	[ebp+buffer_end], eax
		mov	eax, [ebp+tmp]
		mov	[ebp+p], eax
		jmp	short loc_8000E5E
; ---------------------------------------------------------------------------

loc_8000E45:				; CODE XREF: pipe_lines+135j
		add	[ebp+p], 1
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		lea	edx, [eax+1]
		mov	eax, [ebp+tmp]
		mov	[eax+2004h], edx

loc_8000E5E:				; CODE XREF: pipe_lines+F8j
		mov	edx, [ebp+buffer_end]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+p]		; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	short loc_8000E45
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		add	[ebp+total_lines], eax
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		add	eax, edx
		cmp	eax, 1FFFh
		ja	short loc_8000F10
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	ecx, [ebp+last]
		mov	ebx, [ecx+2000h]
		mov	ecx, [ebp+last]
		add	ecx, ebx
		sub	esp, 4
		push	edx		; n
		push	eax		; src
		push	ecx		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+last]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	edx, eax
		mov	eax, [ebp+last]
		mov	[eax+2000h], edx
		mov	eax, [ebp+last]
		mov	edx, [eax+2004h]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		add	edx, eax
		mov	eax, [ebp+last]
		mov	[eax+2004h], edx
		jmp	loc_8000DC2
; ---------------------------------------------------------------------------

loc_8000F10:				; CODE XREF: pipe_lines+15Cj
		mov	eax, [ebp+last]
		mov	edx, [ebp+tmp]
		mov	[eax+2008h], edx
		mov	eax, [ebp+last]
		mov	eax, [eax+2008h]
		mov	[ebp+last], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_lines+4]
		jb	short loc_8000F6F
		cmp	edx, dword ptr [ebp+n_lines+4]
		ja	short loc_8000F4C
		cmp	eax, dword ptr [ebp+n_lines]
		jbe	short loc_8000F6F

loc_8000F4C:				; CODE XREF: pipe_lines+1FAj
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		sub	[ebp+total_lines], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2008h]
		mov	[ebp+first], eax
		jmp	loc_8000DC2
; ---------------------------------------------------------------------------

loc_8000F6F:				; CODE XREF: pipe_lines+1F5j
					; pipe_lines+1FFj
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax
		jmp	loc_8000DC2
; ---------------------------------------------------------------------------

loc_8000F87:				; CODE XREF: pipe_lines+95j
					; pipe_lines+9Fj
		sub	esp, 0Ch
		push	[ebp+tmp]	; ptr
		call	free
		add	esp, 10h
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8000FDA
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	free_lbuffers
; ---------------------------------------------------------------------------

loc_8000FDA:				; CODE XREF: pipe_lines+24Ej
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		test	eax, eax
		jz	loc_8001149
		mov	eax, dword ptr [ebp+n_lines+4]
		or	eax, dword ptr [ebp+n_lines]
		test	eax, eax
		jz	loc_800114C
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		lea	edx, [eax-1]
		mov	eax, [ebp+last]
		movzx	eax, byte ptr [eax+edx]
		cmp	al, 0Ah
		jz	short loc_8001029
		mov	eax, [ebp+last]
		mov	eax, [eax+2004h]
		lea	edx, [eax+1]
		mov	eax, [ebp+last]
		mov	[eax+2004h], edx
		add	[ebp+total_lines], 1

loc_8001029:				; CODE XREF: pipe_lines+2C3j
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		jmp	short loc_8001049
; ---------------------------------------------------------------------------

loc_8001031:				; CODE XREF: pipe_lines+316j
					; pipe_lines+320j
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		sub	[ebp+total_lines], eax
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax

loc_8001049:				; CODE XREF: pipe_lines+2E4j
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_lines+4]
		ja	short loc_8001031
		cmp	edx, dword ptr [ebp+n_lines+4]
		jb	short loc_800106D
		cmp	eax, dword ptr [ebp+n_lines]
		ja	short loc_8001031

loc_800106D:				; CODE XREF: pipe_lines+31Bj
		mov	eax, [ebp+tmp]
		mov	[ebp+beg], eax
		mov	edx, [ebp+tmp]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	eax, edx
		mov	[ebp+buffer_end_0], eax
		mov	eax, [ebp+total_lines]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_lines+4]
		jb	short loc_80010F5
		cmp	edx, dword ptr [ebp+n_lines+4]
		ja	short loc_800109B
		cmp	eax, dword ptr [ebp+n_lines]
		jbe	short loc_80010F5

loc_800109B:				; CODE XREF: pipe_lines+349j
		mov	eax, dword ptr [ebp+n_lines]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+j], eax
		jmp	short loc_80010EF
; ---------------------------------------------------------------------------

loc_80010AA:				; CODE XREF: pipe_lines+3A8j
		mov	edx, [ebp+buffer_end_0]
		mov	eax, [ebp+beg]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+beg]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+beg], eax
		cmp	[ebp+beg], 0
		jnz	short loc_80010E7
		push	offset __PRETTY_FUNCTION___5508	; "pipe_lines"
		push	2A2h		; line
		push	offset file	; "tail.c"
		push	offset assertion ; "beg"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80010E7:				; CODE XREF: pipe_lines+381j
		add	[ebp+beg], 1
		sub	[ebp+j], 1

loc_80010EF:				; CODE XREF: pipe_lines+35Dj
		cmp	[ebp+j], 0
		jnz	short loc_80010AA

loc_80010F5:				; CODE XREF: pipe_lines+344j
					; pipe_lines+34Ej
		mov	edx, [ebp+buffer_end_0]
		mov	eax, [ebp+beg]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 8
		push	eax		; n_bytes
		push	[ebp+beg]	; buffer
		call	xwrite_stdout
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax
		jmp	short loc_8001141
; ---------------------------------------------------------------------------

loc_800111C:				; CODE XREF: pipe_lines+3FAj
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		sub	esp, 8
		push	edx		; n_bytes
		push	eax		; buffer
		call	xwrite_stdout
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax

loc_8001141:				; CODE XREF: pipe_lines+3CFj
		cmp	[ebp+tmp], 0
		jnz	short loc_800111C
		jmp	short loc_800116F
; ---------------------------------------------------------------------------

loc_8001149:				; CODE XREF: pipe_lines+29Aj
		nop
		jmp	short loc_800116F
; ---------------------------------------------------------------------------

loc_800114C:				; CODE XREF: pipe_lines+2A8j
		nop

free_lbuffers:				; CODE XREF: pipe_lines+28Aj
		jmp	short loc_800116F
; ---------------------------------------------------------------------------

loc_800114F:				; CODE XREF: pipe_lines+428j
		mov	eax, [ebp+first]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax
		sub	esp, 0Ch
		push	[ebp+first]	; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	[ebp+first], eax

loc_800116F:				; CODE XREF: pipe_lines+3FCj
					; pipe_lines+3FFj ...
		cmp	[ebp+first], 0
		jnz	short loc_800114F
		movzx	eax, [ebp+ok]
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
pipe_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	pipe_bytes(const char *pretty_filename,	int fd,	uintmax_t n_bytes, uintmax_t *read_pos)
pipe_bytes	proc near		; CODE XREF: tail_bytes+340p

n_bytes		= qword	ptr -30h
ok		= byte ptr -21h
first		= dword	ptr -20h
last		= dword	ptr -1Ch
tmp		= dword	ptr -18h
i		= dword	ptr -14h
total_bytes	= dword	ptr -10h
n_read		= dword	ptr -0Ch
pretty_filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
read_pos	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	[ebp+total_bytes], 0
		mov	[ebp+ok], 1
		sub	esp, 0Ch
		push	2008h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+last], eax
		mov	eax, [ebp+last]
		mov	[ebp+first], eax
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2000h], 0
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2004h], 0
		sub	esp, 0Ch
		push	2008h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax

loc_80011E5:				; CODE XREF: pipe_bytes+134j
					; pipe_bytes+193j ...
		mov	eax, [ebp+tmp]
		sub	esp, 4
		push	2000h
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0
		jz	loc_8001330
		cmp	[ebp+n_read], 0FFFFFFFFh
		jz	loc_8001330
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+n_read]
		mov	ebx, 0
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+tmp]
		mov	edx, [ebp+n_read]
		mov	[eax+2000h], edx
		mov	eax, [ebp+tmp]
		mov	dword ptr [eax+2004h], 0
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	[ebp+total_bytes], eax
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		add	eax, edx
		cmp	eax, 1FFFh
		ja	short loc_80012B9
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	ecx, [ebp+last]
		mov	ebx, [ecx+2000h]
		mov	ecx, [ebp+last]
		add	ecx, ebx
		sub	esp, 4
		push	edx		; n
		push	eax		; src
		push	ecx		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+last]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	edx, eax
		mov	eax, [ebp+last]
		mov	[eax+2000h], edx
		jmp	loc_80011E5
; ---------------------------------------------------------------------------

loc_80012B9:				; CODE XREF: pipe_bytes+EDj
		mov	eax, [ebp+last]
		mov	edx, [ebp+tmp]
		mov	[eax+2004h], edx
		mov	eax, [ebp+last]
		mov	eax, [eax+2004h]
		mov	[ebp+last], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2000h]
		mov	edx, [ebp+total_bytes]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_bytes+4]
		jb	short loc_8001318
		cmp	edx, dword ptr [ebp+n_bytes+4]
		ja	short loc_80012F5
		cmp	eax, dword ptr [ebp+n_bytes]
		jbe	short loc_8001318

loc_80012F5:				; CODE XREF: pipe_bytes+16Ej
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2000h]
		sub	[ebp+total_bytes], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		mov	[ebp+first], eax
		jmp	loc_80011E5
; ---------------------------------------------------------------------------

loc_8001318:				; CODE XREF: pipe_bytes+169j
					; pipe_bytes+173j
		sub	esp, 0Ch
		push	2008h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax
		jmp	loc_80011E5
; ---------------------------------------------------------------------------

loc_8001330:				; CODE XREF: pipe_bytes+83j
					; pipe_bytes+8Dj
		sub	esp, 0Ch
		push	[ebp+tmp]	; ptr
		call	free
		add	esp, 10h
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8001383
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	free_cbuffers
; ---------------------------------------------------------------------------

loc_8001383:				; CODE XREF: pipe_bytes+1C2j
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		jmp	short loc_80013A3
; ---------------------------------------------------------------------------

loc_800138B:				; CODE XREF: pipe_bytes+23Bj
					; pipe_bytes+245j
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		sub	[ebp+total_bytes], eax
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		mov	[ebp+tmp], eax

loc_80013A3:				; CODE XREF: pipe_bytes+209j
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		mov	edx, [ebp+total_bytes]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_bytes+4]
		ja	short loc_800138B
		cmp	edx, dword ptr [ebp+n_bytes+4]
		jb	short loc_80013C7
		cmp	eax, dword ptr [ebp+n_bytes]
		ja	short loc_800138B

loc_80013C7:				; CODE XREF: pipe_bytes+240j
		mov	eax, [ebp+total_bytes]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_bytes+4]
		jb	short loc_80013ED
		cmp	edx, dword ptr [ebp+n_bytes+4]
		ja	short loc_80013DE
		cmp	eax, dword ptr [ebp+n_bytes]
		jbe	short loc_80013ED

loc_80013DE:				; CODE XREF: pipe_bytes+257j
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, [ebp+total_bytes]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+i], eax
		jmp	short loc_80013F4
; ---------------------------------------------------------------------------

loc_80013ED:				; CODE XREF: pipe_bytes+252j
					; pipe_bytes+25Cj
		mov	[ebp+i], 0

loc_80013F4:				; CODE XREF: pipe_bytes+26Bj
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		sub	eax, [ebp+i]
		mov	ecx, [ebp+tmp]
		mov	edx, [ebp+i]
		add	edx, ecx
		sub	esp, 8
		push	eax		; n_bytes
		push	edx		; buffer
		call	xwrite_stdout
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		mov	[ebp+tmp], eax
		jmp	short loc_8001448
; ---------------------------------------------------------------------------

loc_8001423:				; CODE XREF: pipe_bytes+2CCj
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		sub	esp, 8
		push	edx		; n_bytes
		push	eax		; buffer
		call	xwrite_stdout
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		mov	[ebp+tmp], eax

loc_8001448:				; CODE XREF: pipe_bytes+2A1j
		cmp	[ebp+tmp], 0
		jnz	short loc_8001423

free_cbuffers:				; CODE XREF: pipe_bytes+1FEj
		jmp	short loc_8001470
; ---------------------------------------------------------------------------

loc_8001450:				; CODE XREF: pipe_bytes+2F4j
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		mov	[ebp+tmp], eax
		sub	esp, 0Ch
		push	[ebp+first]	; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	[ebp+first], eax

loc_8001470:				; CODE XREF: pipe_bytes:free_cbuffersj
		cmp	[ebp+first], 0
		jnz	short loc_8001450
		movzx	eax, [ebp+ok]
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
pipe_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl start_bytes(const	char *pretty_filename, int fd, uintmax_t n_bytes, uintmax_t *read_pos)
start_bytes	proc near		; CODE XREF: tail_bytes+139p

n_bytes		= qword	ptr -2028h
read_pos	= dword	ptr -2020h
pretty_filename	= dword	ptr -201Ch
bytes_read	= dword	ptr -2014h
n_remaining	= dword	ptr -2010h
buffer		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2020h
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+read_pos],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_80015CB
; ---------------------------------------------------------------------------

loc_80014C0:				; CODE XREF: start_bytes+158j
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_80014F3
		mov	eax, 0FFFFFFFFh
		jmp	loc_80015E7
; ---------------------------------------------------------------------------

loc_80014F3:				; CODE XREF: start_bytes+66j
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_800153F
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	loc_80015E7
; ---------------------------------------------------------------------------

loc_800153F:				; CODE XREF: start_bytes+79j
		mov	eax, [ebp+bytes_read]
		shl	eax, 3
		add	[ebp+read_pos],	eax
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_bytes+4]
		ja	short loc_800158A
		cmp	edx, dword ptr [ebp+n_bytes+4]
		jb	short loc_8001571
		cmp	eax, dword ptr [ebp+n_bytes]
		ja	short loc_800158A

loc_8001571:				; CODE XREF: start_bytes+E6j
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+n_bytes], eax
		sbb	dword ptr [ebp+n_bytes+4], edx
		jmp	short loc_80015CB
; ---------------------------------------------------------------------------

loc_800158A:				; CODE XREF: start_bytes+DEj
					; start_bytes+EEj
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, [ebp+bytes_read]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_remaining], eax
		cmp	[ebp+n_remaining], 0
		jz	short loc_80015E1
		lea	edx, [ebp+buffer]
		mov	eax, dword ptr [ebp+n_bytes]
		add	eax, edx
		sub	esp, 8
		push	[ebp+n_remaining] ; n_bytes
		push	eax		; buffer
		call	xwrite_stdout
		add	esp, 10h
		jmp	short loc_80015E1
; ---------------------------------------------------------------------------

loc_80015CB:				; CODE XREF: start_bytes+3Aj
					; start_bytes+107j
		mov	eax, dword ptr [ebp+n_bytes+4]
		or	eax, dword ptr [ebp+n_bytes]
		test	eax, eax
		jnz	loc_80014C0
		jmp	short loc_80015E2
; ---------------------------------------------------------------------------

loc_80015E1:				; CODE XREF: start_bytes+126j
					; start_bytes+148j
		nop

loc_80015E2:				; CODE XREF: start_bytes+15Ej
		mov	eax, 0

loc_80015E7:				; CODE XREF: start_bytes+6Dj
					; start_bytes+B9j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80015F8
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80015F8:				; CODE XREF: start_bytes+170j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
start_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl start_lines(const	char *pretty_filename, int fd, uintmax_t n_lines, uintmax_t *read_pos)
start_lines	proc near		; CODE XREF: tail_lines+BCp

n_lines		= qword	ptr -2028h
read_pos	= dword	ptr -2020h
pretty_filename	= dword	ptr -201Ch
p		= dword	ptr -2018h
bytes_read	= dword	ptr -2014h
buffer_end	= dword	ptr -2010h
buffer		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2020h
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+read_pos],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, dword ptr [ebp+n_lines+4]
		or	eax, dword ptr [ebp+n_lines]
		test	eax, eax
		jnz	short loc_8001653
		mov	eax, 0
		jmp	loc_80017B1
; ---------------------------------------------------------------------------

loc_8001653:				; CODE XREF: start_lines+48j
					; start_lines+1ADj
		lea	eax, [ebp+buffer]
		mov	[ebp+p], eax
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		lea	edx, [ebp+buffer]
		mov	eax, [ebp+bytes_read]
		add	eax, edx
		mov	[ebp+buffer_end], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_80016A6
		mov	eax, 0FFFFFFFFh
		jmp	loc_80017B1
; ---------------------------------------------------------------------------

loc_80016A6:				; CODE XREF: start_lines+9Bj
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_80016F2
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	loc_80017B1
; ---------------------------------------------------------------------------

loc_80016F2:				; CODE XREF: start_lines+AEj
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+bytes_read]
		mov	ebx, 0
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	short loc_8001775
; ---------------------------------------------------------------------------

loc_8001719:				; CODE XREF: start_lines+1A7j
		add	[ebp+p], 1
		add	dword ptr [ebp+n_lines], 0FFFFFFFFh
		adc	dword ptr [ebp+n_lines+4], 0FFFFFFFFh
		mov	eax, dword ptr [ebp+n_lines+4]
		or	eax, dword ptr [ebp+n_lines]
		test	eax, eax
		jnz	short loc_8001775
		mov	eax, [ebp+p]
		cmp	eax, [ebp+buffer_end]
		jnb	short loc_800176E
		mov	edx, [ebp+buffer_end]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 8
		push	eax		; n_bytes
		push	[ebp+p]		; buffer
		call	xwrite_stdout
		add	esp, 10h

loc_800176E:				; CODE XREF: start_lines+14Bj
		mov	eax, 0
		jmp	short loc_80017B1
; ---------------------------------------------------------------------------

loc_8001775:				; CODE XREF: start_lines+118j
					; start_lines+13Dj
		mov	edx, [ebp+buffer_end]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+p]		; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	loc_8001719
		jmp	loc_8001653
; ---------------------------------------------------------------------------

loc_80017B1:				; CODE XREF: start_lines+4Fj
					; start_lines+A2j ...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_80017C2
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80017C2:				; CODE XREF: start_lines+1BCj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
start_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	fremote(int fd,	const char *name)
fremote		proc near		; CODE XREF: recheck+25Fp
					; tail_file+35Fp

name		= dword	ptr -6Ch
remote		= byte ptr -65h
err		= dword	ptr -64h
buf		= statfs ptr -60h
var_C		= dword	ptr -0Ch
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 70h
		mov	eax, [ebp+arg_4]
		mov	[ebp+name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+remote], 1
		sub	esp, 8
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+fd]
		call	fstatfs64
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_800183C
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotDetermin ; "cannot determine location of %s. revert"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_80018BC
; ---------------------------------------------------------------------------

loc_800183C:				; CODE XREF: fremote+36j
		mov	eax, [ebp+buf.f_type]
		cmp	eax, 5346414Fh
		jz	short loc_80018BB
		cmp	eax, 5346414Fh
		jg	short loc_8001882
		cmp	eax, 564Ch
		jz	short loc_80018BB
		cmp	eax, 564Ch
		jg	short loc_800186B
		cmp	eax, 0FF534D42h
		jz	short loc_80018BB
		cmp	eax, 517Bh
		jz	short loc_80018BB
		jmp	short loc_80018B5
; ---------------------------------------------------------------------------

loc_800186B:				; CODE XREF: fremote+90j
		cmp	eax, 1161970h
		jz	short loc_80018BB
		cmp	eax, 0BD00BD0h
		jz	short loc_80018BB
		cmp	eax, 6969h
		jz	short loc_80018BB
		jmp	short loc_80018B5
; ---------------------------------------------------------------------------

loc_8001882:				; CODE XREF: fremote+82j
		cmp	eax, 6B414653h
		jz	short loc_80018BB
		cmp	eax, 6B414653h
		jg	short loc_80018A0
		cmp	eax, 65735543h
		jz	short loc_80018BB
		cmp	eax, 65735546h
		jz	short loc_80018BB
		jmp	short loc_80018B5
; ---------------------------------------------------------------------------

loc_80018A0:				; CODE XREF: fremote+C5j
		cmp	eax, 73757245h
		jz	short loc_80018BB
		cmp	eax, 7461636Fh
		jz	short loc_80018BB
		cmp	eax, 6E667364h
		jz	short loc_80018BB

loc_80018B5:				; CODE XREF: fremote+A0j fremote+B7j ...
		mov	[ebp+remote], 0
		jmp	short loc_80018BC
; ---------------------------------------------------------------------------

loc_80018BB:				; CODE XREF: fremote+7Bj fremote+89j ...
		nop

loc_80018BC:				; CODE XREF: fremote+6Ej fremote+F0j
		movzx	eax, [ebp+remote]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_80018D1
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80018D1:				; CODE XREF: fremote+101j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
fremote		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl recheck(File_spec *f, _Bool blocking)
recheck		proc near		; CODE XREF: tail_forever+F3p
					; tail_forever+40Dp ...

blocking	= byte ptr -80h
f		= dword	ptr -7Ch
ok		= byte ptr -78h
new_file	= byte ptr -77h
is_stdin	= byte ptr -76h
was_tailable	= byte ptr -75h
prev_errnum	= dword	ptr -74h
fd		= dword	ptr -70h
new_stats	= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+f], edx
		mov	[ebp+blocking],	al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+2Ah]
		mov	[ebp+was_tailable], al
		mov	eax, [ebp+f]
		mov	eax, [eax+30h]
		mov	[ebp+prev_errnum], eax
		cmp	[ebp+is_stdin],	0
		jz	short loc_8001939
		mov	eax, 0
		jmp	short loc_800195D
; ---------------------------------------------------------------------------

loc_8001939:				; CODE XREF: recheck+58j
		cmp	[ebp+blocking],	0
		jz	short loc_8001946
		mov	edx, 0
		jmp	short loc_800194B
; ---------------------------------------------------------------------------

loc_8001946:				; CODE XREF: recheck+65j
		mov	edx, 800h

loc_800194B:				; CODE XREF: recheck+6Cj
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		call	open_safer
		add	esp, 10h

loc_800195D:				; CODE XREF: recheck+5Fj
		mov	[ebp+fd], eax
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	valid_file_spec
		add	esp, 10h
		test	al, al
		jnz	short loc_800198B
		push	offset __PRETTY_FUNCTION___5607	; "recheck"
		push	3A9h		; line
		push	offset file	; "tail.c"
		push	offset aValid_file_spe ; "valid_file_spec (f)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800198B:				; CODE XREF: recheck+98j
		movzx	eax, ds:reopen_inaccessible_files
		xor	eax, 1
		test	al, al
		jnz	short loc_800199F
		cmp	[ebp+fd], 0FFFFFFFFh
		jz	short loc_80019A6

loc_800199F:				; CODE XREF: recheck+BFj
		mov	eax, 1
		jmp	short loc_80019AB
; ---------------------------------------------------------------------------

loc_80019A6:				; CODE XREF: recheck+C5j
		mov	eax, 0

loc_80019AB:				; CODE XREF: recheck+CCj
		and	eax, 1
		mov	edx, [ebp+f]
		mov	[edx+2Ah], al
		cmp	[ebp+fd], 0FFFFFFFFh
		jz	short loc_80019D4
		sub	esp, 8
		lea	eax, [ebp+new_stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jns	loc_8001A80

loc_80019D4:				; CODE XREF: recheck+E0j
		mov	[ebp+ok], 0
		call	__errno_location
		mov	edx, [eax]
		mov	eax, [ebp+f]
		mov	[eax+30h], edx
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax+2Ah]
		xor	eax, 1
		test	al, al
		jz	short loc_8001A43
		cmp	[ebp+was_tailable], 0
		jz	loc_8001BA7
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasBecomeInac ; "%s has become	inaccessible"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	eax, [eax+30h]
		push	ebx
		push	edx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8001BA7
; ---------------------------------------------------------------------------

loc_8001A43:				; CODE XREF: recheck+119j
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, [ebp+prev_errnum]
		jz	loc_8001BA7
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8001BA7
; ---------------------------------------------------------------------------

loc_8001A80:				; CODE XREF: recheck+F6j
		mov	eax, [ebp+new_stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	loc_8001B14
		mov	eax, [ebp+new_stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jz	short loc_8001B14
		mov	eax, [ebp+new_stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jz	short loc_8001B14
		mov	eax, [ebp+new_stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jz	short loc_8001B14
		mov	[ebp+ok], 0
		mov	eax, [ebp+f]
		mov	dword ptr [eax+30h], 0FFFFFFFFh
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasBeenReplac ; "%s has been replaced with an untailable"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	byte ptr [eax+28h], 1
		jmp	loc_8001BA8
; ---------------------------------------------------------------------------

loc_8001B14:				; CODE XREF: recheck+1B5j recheck+1C8j ...
		movzx	eax, ds:disable_inotify
		xor	eax, 1
		test	al, al
		jz	short loc_8001B9B
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 8
		push	eax		; name
		push	[ebp+fd]	; fd
		call	fremote
		add	esp, 10h
		test	al, al
		jz	short loc_8001B9B
		mov	[ebp+ok], 0
		mov	eax, [ebp+f]
		mov	dword ptr [eax+30h], 0FFFFFFFFh
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasBeenRepl_0 ; "%s has been replaced with a remote file"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	byte ptr [eax+28h], 1
		mov	eax, [ebp+f]
		mov	byte ptr [eax+29h], 1
		jmp	short loc_8001BA8
; ---------------------------------------------------------------------------

loc_8001B9B:				; CODE XREF: recheck+248j recheck+269j
		mov	eax, [ebp+f]
		mov	dword ptr [eax+30h], 0
		jmp	short loc_8001BA8
; ---------------------------------------------------------------------------

loc_8001BA7:				; CODE XREF: recheck+11Fj recheck+166j ...
		nop

loc_8001BA8:				; CODE XREF: recheck+237j recheck+2C1j ...
		mov	[ebp+new_file],	0
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8001C06
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 8
		push	eax		; filename
		push	[ebp+fd]	; fd
		call	close_fd
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		sub	esp, 8
		push	edx		; filename
		push	eax		; fd
		call	close_fd
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		jmp	loc_8001D8E
; ---------------------------------------------------------------------------

loc_8001C06:				; CODE XREF: recheck+2DDj
		cmp	[ebp+prev_errnum], 0
		jz	short loc_8001C79
		cmp	[ebp+prev_errnum], 2
		jz	short loc_8001C79
		mov	[ebp+new_file],	1
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8001C3A
		push	offset __PRETTY_FUNCTION___5607	; "recheck"
		push	3E9h		; line
		push	offset file	; "tail.c"
		push	offset aFFd1	; "f->fd == -1"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001C3A:				; CODE XREF: recheck+347j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasBecomeAcce ; "%s has become	accessible"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8001D8E
; ---------------------------------------------------------------------------

loc_8001C79:				; CODE XREF: recheck+332j recheck+338j
		mov	eax, [ebp+f]
		mov	ecx, [eax+1Ch]
		mov	ebx, [eax+20h]
		mov	eax, dword ptr [ebp+new_stats.st_ino]
		mov	edx, dword ptr [ebp+new_stats.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8001CB3
		mov	eax, [ebp+f]
		mov	ecx, [eax+14h]
		mov	ebx, [eax+18h]
		mov	eax, dword ptr [ebp+new_stats.st_dev]
		mov	edx, dword ptr [ebp+new_stats.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	loc_8001D60

loc_8001CB3:				; CODE XREF: recheck+3BAj
		mov	[ebp+new_file],	1
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001D01
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasAppearedFo ; "%s has appeared;  following end of new "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8001D8E
; ---------------------------------------------------------------------------

loc_8001D01:				; CODE XREF: recheck+3E8j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		sub	esp, 8
		push	edx		; filename
		push	eax		; fd
		call	close_fd
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasBeenRepl_1 ; "%s has been replaced;	 following end of"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001D8E
; ---------------------------------------------------------------------------

loc_8001D60:				; CODE XREF: recheck+3D5j
		mov	eax, [ebp+f]
		mov	eax, [eax+2Ch]
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001D71
		mov	[ebp+new_file],	1
		jmp	short loc_8001D8E
; ---------------------------------------------------------------------------

loc_8001D71:				; CODE XREF: recheck+491j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 8
		push	eax		; filename
		push	[ebp+fd]	; fd
		call	close_fd
		add	esp, 10h

loc_8001D8E:				; CODE XREF: recheck+329j recheck+39Cj ...
		cmp	[ebp+new_file],	0
		jz	short loc_8001DE2
		cmp	[ebp+is_stdin],	0
		jz	short loc_8001DA1
		mov	eax, 0FFFFFFFFh
		jmp	short loc_8001DA5
; ---------------------------------------------------------------------------

loc_8001DA1:				; CODE XREF: recheck+4C0j
		movzx	eax, [ebp+blocking]

loc_8001DA5:				; CODE XREF: recheck+4C7j
		sub	esp, 8
		push	eax		; blocking
		lea	eax, [ebp+new_stats]
		push	eax		; st
		push	0
		push	0		; size
		push	[ebp+fd]	; fd
		push	[ebp+f]		; f
		call	record_open_fd
		add	esp, 20h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; filename
		push	0		; whence
		push	0
		push	0		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h

loc_8001DE2:				; CODE XREF: recheck+4BAj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001DF4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001DF4:				; CODE XREF: recheck+515j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
recheck		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	any_live_files(const File_spec *f, size_t n_files)
any_live_files	proc near		; CODE XREF: tail_forever+662p

i		= dword	ptr -4
f		= dword	ptr  8
n_files		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8001E27
; ---------------------------------------------------------------------------

loc_8001E0A:				; CODE XREF: any_live_files+32j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+2Ch]
		test	eax, eax
		js	short loc_8001E23
		mov	eax, 1
		jmp	short locret_8001E34
; ---------------------------------------------------------------------------

loc_8001E23:				; CODE XREF: any_live_files+1Fj
		add	[ebp+i], 1

loc_8001E27:				; CODE XREF: any_live_files+Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8001E0A
		mov	eax, 0

locret_8001E34:				; CODE XREF: any_live_files+26j
		leave
		retn
any_live_files	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl tail_forever(File_spec *f, size_t n_files, double sleep_interval)
tail_forever	proc near		; CODE XREF: main+3F3p

var_C0		= timespec ptr -0C0h
sleep_interval	= qword	ptr -0B8h
f		= dword	ptr -0ACh
writer_is_dead	= byte ptr -9Fh
any_input	= byte ptr -9Eh
blocking	= byte ptr -9Dh
last		= dword	ptr -9Ch
i		= dword	ptr -98h
fd		= dword	ptr -94h
name		= dword	ptr -90h
mode		= dword	ptr -8Ch
old_flags	= dword	ptr -88h
new_flags	= dword	ptr -84h
bytes_read	= qword	ptr -80h
b		= timespec ptr -74h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
n_files		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0C0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+sleep_interval],	eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+sleep_interval+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:pid
		test	eax, eax
		jnz	short loc_8001E9C
		mov	eax, follow_mode
		cmp	eax, 2
		jnz	short loc_8001E9C
		cmp	[ebp+n_files], 1
		jnz	short loc_8001E9C
		mov	eax, [ebp+f]
		mov	eax, [eax+24h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8001E9C
		mov	eax, 1
		jmp	short loc_8001EA1
; ---------------------------------------------------------------------------

loc_8001E9C:				; CODE XREF: tail_forever+38j
					; tail_forever+42j ...
		mov	eax, 0

loc_8001EA1:				; CODE XREF: tail_forever+64j
		mov	[ebp+blocking],	al
		and	[ebp+blocking],	1
		mov	[ebp+writer_is_dead], 0
		mov	eax, [ebp+n_files]
		sub	eax, 1
		mov	[ebp+last], eax

loc_8001EC1:				; CODE XREF: tail_forever+704j
					; tail_forever+768j ...
		mov	[ebp+any_input], 0
		mov	[ebp+i], 0
		jmp	loc_800247D
; ---------------------------------------------------------------------------

loc_8001ED7:				; CODE XREF: tail_forever+650j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+28h]
		test	al, al
		jnz	loc_8002472
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+2Ch]
		test	eax, eax
		jns	short loc_8001F36
		movzx	eax, [ebp+blocking]
		mov	edx, [ebp+i]
		imul	ecx, edx, 4Ch
		mov	edx, [ebp+f]
		add	edx, ecx
		sub	esp, 8
		push	eax		; blocking
		push	edx		; f
		call	recheck
		add	esp, 10h
		jmp	loc_8002476
; ---------------------------------------------------------------------------

loc_8001F36:				; CODE XREF: tail_forever+D4j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+2Ch]
		mov	[ebp+fd], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; f
		call	pretty_name
		add	esp, 10h
		mov	[ebp+name], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+24h]
		mov	[ebp+mode], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax+34h]
		movzx	eax, [ebp+blocking]
		cmp	edx, eax
		jz	loc_8002095
		sub	esp, 8
		push	3
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+old_flags], eax
		cmp	[ebp+blocking],	0
		jz	short loc_8001FD9
		mov	eax, 0
		jmp	short loc_8001FDE
; ---------------------------------------------------------------------------

loc_8001FD9:				; CODE XREF: tail_forever+19Aj
		mov	eax, 800h

loc_8001FDE:				; CODE XREF: tail_forever+1A1j
		or	eax, [ebp+old_flags]
		mov	[ebp+new_flags], eax
		cmp	[ebp+old_flags], 0
		js	short loc_800201F
		mov	eax, [ebp+new_flags]
		cmp	eax, [ebp+old_flags]
		jz	short loc_800207A
		sub	esp, 4
		push	[ebp+new_flags]
		push	4
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_800207A

loc_800201F:				; CODE XREF: tail_forever+1BBj
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+24h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_800204B
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8002078

loc_800204B:				; CODE XREF: tail_forever+207j
		sub	esp, 0Ch
		push	offset aSCannotChangeN ; "%s: cannot change nonblocking	mode"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+name]
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002095
; ---------------------------------------------------------------------------

loc_8002078:				; CODE XREF: tail_forever+213j
		jmp	short loc_8002095
; ---------------------------------------------------------------------------

loc_800207A:				; CODE XREF: tail_forever+1C9j
					; tail_forever+1E7j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	edx, eax
		movzx	eax, [ebp+blocking]
		mov	[edx+34h], eax

loc_8002095:				; CODE XREF: tail_forever+174j
					; tail_forever+240j ...
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+34h]
		test	eax, eax
		jnz	loc_80023C7
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002120
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ebx, [edx+eax]
		call	__errno_location
		mov	eax, [eax]
		mov	[ebx+30h], eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+name]
		push	offset aS	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8002476
; ---------------------------------------------------------------------------

loc_8002120:				; CODE XREF: tail_forever+292j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax+24h]
		mov	eax, [ebp+stats.st_mode]
		cmp	edx, eax
		jnz	loc_800226F
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_800217B
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	ecx, [eax+4]
		mov	ebx, [eax+8]
		mov	eax, dword ptr [ebp+stats.st_size]
		mov	edx, dword ptr [ebp+stats.st_size+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	loc_800226F

loc_800217B:				; CODE XREF: tail_forever+316j
		lea	eax, [ebp+b]
		sub	esp, 8
		lea	edx, [ebp+stats]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		push	[ebp+b.tv_nsec]
		push	[ebp+b.tv_sec]	; b
		push	dword ptr [eax+10h]
		push	dword ptr [eax+0Ch] ; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_800226F
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	esi, [edx+eax]
		mov	eax, [esi+44h]
		mov	edx, [esi+48h]
		mov	ecx, eax
		mov	ebx, edx
		add	ecx, 1
		adc	ebx, 0
		mov	[esi+44h], ecx
		mov	[esi+48h], ebx
		mov	ecx, dword ptr max_n_unchanged_stats_between_opens
		mov	ebx, dword ptr max_n_unchanged_stats_between_opens+4
		cmp	edx, ebx
		jb	loc_8002475
		cmp	edx, ebx
		ja	short loc_8002203
		cmp	eax, ecx
		jb	loc_8002475

loc_8002203:				; CODE XREF: tail_forever+3C3j
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	loc_8002475
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+34h]
		test	eax, eax
		setnz	al
		movzx	eax, al
		mov	edx, [ebp+i]
		imul	ecx, edx, 4Ch
		mov	edx, [ebp+f]
		add	edx, ecx
		sub	esp, 8
		push	eax		; blocking
		push	edx		; f
		call	recheck
		add	esp, 10h
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	dword ptr [eax+44h], 0
		mov	dword ptr [eax+48h], 0
		jmp	loc_8002475
; ---------------------------------------------------------------------------

loc_800226F:				; CODE XREF: tail_forever+303j
					; tail_forever+33Fj ...
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ebx, [edx+eax]
		lea	eax, [ebp+var_C0]
		sub	esp, 8
		lea	edx, [ebp+stats]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_C0.tv_sec]
		mov	edx, [ebp+var_C0.tv_nsec]
		mov	[ebx+0Ch], eax
		mov	[ebx+10h], edx
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	edx, eax
		mov	eax, [ebp+stats.st_mode]
		mov	[edx+24h], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	dword ptr [eax+44h], 0
		mov	dword ptr [eax+48h], 0
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8002391
		mov	ecx, dword ptr [ebp+stats.st_size]
		mov	ebx, dword ptr [ebp+stats.st_size+4]
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax+8]
		mov	eax, [eax+4]
		cmp	ebx, edx
		jg	short loc_8002391
		cmp	ebx, edx
		jl	short loc_800231E
		cmp	ecx, eax
		jnb	short loc_8002391

loc_800231E:				; CODE XREF: tail_forever+4E2j
		sub	esp, 0Ch
		push	offset aSFileTruncated ; "%s: file truncated"
		call	gettext
		add	esp, 10h
		push	[ebp+name]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+i]
		mov	[ebp+last], eax
		mov	eax, dword ptr [ebp+stats.st_size]
		mov	edx, dword ptr [ebp+stats.st_size+4]
		sub	esp, 0Ch
		push	[ebp+name]	; filename
		push	0		; whence
		push	edx
		push	eax		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ecx, [edx+eax]
		mov	eax, dword ptr [ebp+stats.st_size]
		mov	edx, dword ptr [ebp+stats.st_size+4]
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		jmp	loc_8002476
; ---------------------------------------------------------------------------

loc_8002391:				; CODE XREF: tail_forever+4B9j
					; tail_forever+4DEj ...
		mov	eax, [ebp+i]
		cmp	eax, [ebp+last]
		jz	short loc_80023C7
		movzx	eax, ds:print_headers
		test	al, al
		jz	short loc_80023BB
		sub	esp, 0Ch
		push	[ebp+name]	; pretty_filename
		call	write_header
		add	esp, 10h

loc_80023BB:				; CODE XREF: tail_forever+572j
		mov	eax, [ebp+i]
		mov	[ebp+last], eax

loc_80023C7:				; CODE XREF: tail_forever+275j
					; tail_forever+567j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+34h]
		test	eax, eax
		jz	short loc_80023EB
		mov	eax, 0FFFFFFFEh
		mov	edx, 0FFFFFFFFh
		jmp	short loc_80023F5
; ---------------------------------------------------------------------------

loc_80023EB:				; CODE XREF: tail_forever+5A7j
		mov	eax, 0FFFFFFFFh
		mov	edx, 0FFFFFFFFh

loc_80023F5:				; CODE XREF: tail_forever+5B3j
		push	edx
		push	eax		; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+name]	; pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	dword ptr [ebp+bytes_read], eax
		mov	dword ptr [ebp+bytes_read+4], edx
		movzx	edx, [ebp+any_input]
		mov	eax, dword ptr [ebp+bytes_read]
		or	eax, dword ptr [ebp+bytes_read+4]
		test	eax, eax
		setnz	al
		movzx	eax, al
		or	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+any_input], al
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ecx, [edx+eax]
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax+8]
		mov	eax, [eax+4]
		mov	ebx, eax
		mov	esi, edx
		mov	eax, dword ptr [ebp+bytes_read]
		mov	edx, dword ptr [ebp+bytes_read+4]
		add	eax, ebx
		adc	edx, esi
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		jmp	short loc_8002476
; ---------------------------------------------------------------------------

loc_8002472:				; CODE XREF: tail_forever+B8j
		nop
		jmp	short loc_8002476
; ---------------------------------------------------------------------------

loc_8002475:				; CODE XREF: tail_forever+3BBj
					; tail_forever+3C7j ...
		nop

loc_8002476:				; CODE XREF: tail_forever+FBj
					; tail_forever+2E5j ...
		add	[ebp+i], 1

loc_800247D:				; CODE XREF: tail_forever+9Cj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	loc_8001ED7
		sub	esp, 8
		push	[ebp+n_files]	; n_files
		push	[ebp+f]		; f
		call	any_live_files
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80024DA
		movzx	eax, ds:reopen_inaccessible_files
		xor	eax, 1
		test	al, al
		jz	short loc_80024DA
		sub	esp, 0Ch
		push	offset aNoFilesRemaini ; "no files remaining"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_80025F1
; ---------------------------------------------------------------------------

loc_80024DA:				; CODE XREF: tail_forever+66Fj
					; tail_forever+67Dj
		movzx	eax, [ebp+any_input]
		xor	eax, 1
		test	al, al
		jnz	short loc_80024F1
		cmp	[ebp+blocking],	0
		jz	short loc_800252E

loc_80024F1:				; CODE XREF: tail_forever+6B0j
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_800252E
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800252E:				; CODE XREF: tail_forever+6B9j
					; tail_forever+6CEj
		movzx	eax, [ebp+any_input]
		xor	eax, 1
		test	al, al
		jz	loc_8001EC1
		cmp	[ebp+writer_is_dead], 0
		jnz	loc_80025F0
		mov	eax, ds:pid
		test	eax, eax
		jz	short loc_8002580
		mov	eax, ds:pid
		sub	esp, 8
		push	0		; sig
		push	eax		; pid
		call	kill
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002580
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8002580
		mov	eax, 1
		jmp	short loc_8002585
; ---------------------------------------------------------------------------

loc_8002580:				; CODE XREF: tail_forever+71Ej
					; tail_forever+735j ...
		mov	eax, 0

loc_8002585:				; CODE XREF: tail_forever+748j
		mov	[ebp+writer_is_dead], al
		and	[ebp+writer_is_dead], 1
		movzx	eax, [ebp+writer_is_dead]
		xor	eax, 1
		test	al, al
		jz	loc_8001EC1
		sub	esp, 8
		push	dword ptr [ebp+sleep_interval+4]
		push	dword ptr [ebp+sleep_interval]
		call	xnanosleep
		add	esp, 10h
		test	eax, eax
		jz	loc_8001EC1
		sub	esp, 0Ch
		push	offset aCannotReadReal ; "cannot read realtime clock"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8001EC1
; ---------------------------------------------------------------------------

loc_80025F0:				; CODE XREF: tail_forever+711j
		nop

loc_80025F1:				; CODE XREF: tail_forever+69Fj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002603
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002603:				; CODE XREF: tail_forever+7C6j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tail_forever	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	any_remote_file(const File_spec	*f, size_t n_files)
any_remote_file	proc near		; CODE XREF: main+321p

i		= dword	ptr -4
f		= dword	ptr  8
n_files		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8002649
; ---------------------------------------------------------------------------

loc_8002619:				; CODE XREF: any_remote_file+45j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+2Ch]
		test	eax, eax
		js	short loc_8002645
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+29h]
		test	al, al
		jz	short loc_8002645
		mov	eax, 1
		jmp	short locret_8002656
; ---------------------------------------------------------------------------

loc_8002645:				; CODE XREF: any_remote_file+1Fj
					; any_remote_file+32j
		add	[ebp+i], 1

loc_8002649:				; CODE XREF: any_remote_file+Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8002619
		mov	eax, 0

locret_8002656:				; CODE XREF: any_remote_file+39j
		leave
		retn
any_remote_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tailable_stdin(const File_spec *f, size_t n_files)
tailable_stdin	proc near		; CODE XREF: main+30Cp

i		= dword	ptr -0Ch
f		= dword	ptr  8
n_files		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_80026AA
; ---------------------------------------------------------------------------

loc_8002667:				; CODE XREF: tailable_stdin+58j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+28h]
		xor	eax, 1
		test	al, al
		jz	short loc_80026A6
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80026A6
		mov	eax, 1
		jmp	short locret_80026B7
; ---------------------------------------------------------------------------

loc_80026A6:				; CODE XREF: tailable_stdin+23j
					; tailable_stdin+45j
		add	[ebp+i], 1

loc_80026AA:				; CODE XREF: tailable_stdin+Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8002667
		mov	eax, 0

locret_80026B7:				; CODE XREF: tailable_stdin+4Cj
		leave
		retn
tailable_stdin	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl wd_hasher(const void *entry, size_t tabsize)
wd_hasher	proc near		; DATA XREF: tail_forever_inotify+72o

spec		= dword	ptr -4
entry		= dword	ptr  8
tabsize		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+entry]
		mov	[ebp+spec], eax
		mov	eax, [ebp+spec]
		mov	eax, [eax+38h]
		mov	edx, 0
		div	[ebp+tabsize]
		mov	eax, edx
		leave
		retn
wd_hasher	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wd_comparator(const void *e1, const void *e2)
wd_comparator	proc near		; DATA XREF: tail_forever_inotify+6Do

spec1		= dword	ptr -8
spec2		= dword	ptr -4
e1		= dword	ptr  8
e2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+e1]
		mov	[ebp+spec1], eax
		mov	eax, [ebp+e2]
		mov	[ebp+spec2], eax
		mov	eax, [ebp+spec1]
		mov	edx, [eax+38h]
		mov	eax, [ebp+spec2]
		mov	eax, [eax+38h]
		cmp	edx, eax
		setz	al
		leave
		retn
wd_comparator	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_fspec(File_spec *fspec, int wd, int *prev_wd)
check_fspec	proc near		; CODE XREF: tail_forever_inotify+44Cp
					; tail_forever_inotify+A5Ap

prev_wd		= dword	ptr -90h
fspec		= dword	ptr -8Ch
name		= dword	ptr -84h
bytes_read	= qword	ptr -80h
b		= timespec ptr -74h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
wd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fspec], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+prev_wd], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+fspec]	; f
		call	pretty_name
		add	esp, 10h
		mov	[ebp+name], eax
		mov	eax, [ebp+fspec]
		mov	eax, [eax+2Ch]
		sub	esp, 8
		lea	edx, [ebp+stats]
		push	edx
		push	eax
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002795
		mov	eax, [ebp+fspec]
		mov	eax, [eax+2Ch]
		sub	esp, 8
		push	[ebp+name]	; filename
		push	eax		; fd
		call	close_fd
		add	esp, 10h
		mov	eax, [ebp+fspec]
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		call	__errno_location
		mov	edx, [eax]
		mov	eax, [ebp+fspec]
		mov	[eax+30h], edx
		jmp	loc_8002957
; ---------------------------------------------------------------------------

loc_8002795:				; CODE XREF: check_fspec+5Aj
		mov	eax, [ebp+fspec]
		mov	eax, [eax+24h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8002833
		mov	ecx, dword ptr [ebp+stats.st_size]
		mov	ebx, dword ptr [ebp+stats.st_size+4]
		mov	eax, [ebp+fspec]
		mov	edx, [eax+8]
		mov	eax, [eax+4]
		cmp	ebx, edx
		jg	short loc_8002833
		cmp	ebx, edx
		jl	short loc_80027CC
		cmp	ecx, eax
		jnb	short loc_8002833

loc_80027CC:				; CODE XREF: check_fspec+CAj
		sub	esp, 0Ch
		push	offset aSFileTruncated ; "%s: file truncated"
		call	gettext
		add	esp, 10h
		push	[ebp+name]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+prev_wd]
		mov	edx, [ebp+wd]
		mov	[eax], edx
		mov	eax, dword ptr [ebp+stats.st_size]
		mov	edx, dword ptr [ebp+stats.st_size+4]
		mov	ecx, [ebp+fspec]
		mov	ecx, [ecx+2Ch]
		sub	esp, 0Ch
		push	[ebp+name]	; filename
		push	0		; whence
		push	edx
		push	eax		; offset
		push	ecx		; fd
		call	xlseek
		add	esp, 20h
		mov	eax, dword ptr [ebp+stats.st_size]
		mov	edx, dword ptr [ebp+stats.st_size+4]
		mov	ecx, [ebp+fspec]
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		jmp	short loc_800289B
; ---------------------------------------------------------------------------

loc_8002833:				; CODE XREF: check_fspec+ACj
					; check_fspec+C6j ...
		mov	eax, [ebp+fspec]
		mov	eax, [eax+24h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_800289B
		mov	ecx, dword ptr [ebp+stats.st_size]
		mov	ebx, dword ptr [ebp+stats.st_size+4]
		mov	eax, [ebp+fspec]
		mov	edx, [eax+8]
		mov	eax, [eax+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_800289B
		lea	eax, [ebp+b]
		sub	esp, 8
		lea	edx, [ebp+stats]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		push	[ebp+b.tv_nsec]
		push	[ebp+b.tv_sec]	; b
		mov	eax, [ebp+fspec]
		push	dword ptr [eax+10h]
		push	dword ptr [eax+0Ch] ; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jz	loc_8002956

loc_800289B:				; CODE XREF: check_fspec+135j
					; check_fspec+14Aj ...
		mov	eax, [ebp+prev_wd]
		mov	eax, [eax]
		cmp	eax, [ebp+wd]
		jz	short loc_80028CF
		movzx	eax, ds:print_headers
		test	al, al
		jz	short loc_80028C4
		sub	esp, 0Ch
		push	[ebp+name]	; pretty_filename
		call	write_header
		add	esp, 10h

loc_80028C4:				; CODE XREF: check_fspec+1B5j
		mov	eax, [ebp+prev_wd]
		mov	edx, [ebp+wd]
		mov	[eax], edx

loc_80028CF:				; CODE XREF: check_fspec+1AAj
		mov	eax, [ebp+fspec]
		mov	eax, [eax+2Ch]
		push	0FFFFFFFFh
		push	0FFFFFFFFh	; n_bytes
		push	eax		; fd
		push	[ebp+name]	; pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	dword ptr [ebp+bytes_read], eax
		mov	dword ptr [ebp+bytes_read+4], edx
		mov	eax, [ebp+fspec]
		mov	edx, [eax+8]
		mov	eax, [eax+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr [ebp+bytes_read]
		mov	edx, dword ptr [ebp+bytes_read+4]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+fspec]
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002957
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002957
; ---------------------------------------------------------------------------

loc_8002956:				; CODE XREF: check_fspec+199j
		nop

loc_8002957:				; CODE XREF: check_fspec+94j
					; check_fspec+22Ej ...
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002968
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002968:				; CODE XREF: check_fspec+265j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
check_fspec	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl tail_forever_inotify(int	wd, File_spec *f, size_t n_files, double sleep_interval)
tail_forever_inotify proc near		; CODE XREF: main+3D1p

var_150		= dword	ptr -150h
var_14C		= dword	ptr -14Ch
sleep_interval	= qword	ptr -148h
var_140		= word ptr -140h
var_13E		= word ptr -13Eh
f		= dword	ptr -13Ch
found_watchable	= byte ptr -133h
writer_is_dead	= byte ptr -132h
prev		= byte ptr -131h
prev_wd		= dword	ptr -130h
max_realloc	= dword	ptr -12Ch
evlen		= dword	ptr -128h
evbuf		= dword	ptr -124h
evbuf_off	= dword	ptr -120h
len		= dword	ptr -11Ch
i		= dword	ptr -118h
fspec		= dword	ptr -114h
j		= dword	ptr -110h
wd_to_name	= dword	ptr -10Ch
fnlen		= dword	ptr -108h
dirlen		= dword	ptr -104h
__d0		= dword	ptr -100h
__d1		= dword	ptr -0FCh
file_change	= dword	ptr -0F8h
ev		= dword	ptr -0F4h
new_wd		= dword	ptr -0F0h
prev_0		= dword	ptr -0ECh
key		= File_spec ptr	-0E8h
rfd		= fd_set ptr -9Ch
var_1C		= dword	ptr -1Ch
wd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
n_files		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 14Ch
		mov	eax, [ebp+arg_4]
		mov	[ebp+f], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+sleep_interval],	eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [ebp+sleep_interval+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+max_realloc], 3
		mov	[ebp+found_watchable], 0
		mov	[ebp+writer_is_dead], 0
		mov	[ebp+evlen], 0
		mov	[ebp+evbuf_off], 0
		mov	[ebp+len], 0
		sub	esp, 0Ch
		push	0
		push	offset wd_comparator
		push	offset wd_hasher
		push	0
		push	[ebp+n_files]
		call	hash_initialize
		add	esp, 20h
		mov	[ebp+wd_to_name], eax
		cmp	[ebp+wd_to_name], 0
		jnz	short loc_8002A07
		call	xalloc_die

loc_8002A07:				; CODE XREF: tail_forever_inotify+91j
		mov	[ebp+i], 0
		jmp	loc_8002D1D
; ---------------------------------------------------------------------------

loc_8002A16:				; CODE XREF: tail_forever_inotify+3B7j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+28h]
		xor	eax, 1
		test	al, al
		jz	loc_8002D16
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+fnlen], eax
		mov	eax, [ebp+evlen]
		cmp	eax, [ebp+fnlen]
		jnb	short loc_8002A75
		mov	eax, [ebp+fnlen]
		mov	[ebp+evlen], eax

loc_8002A75:				; CODE XREF: tail_forever_inotify+F8j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	dword ptr [eax+38h], 0FFFFFFFFh
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	loc_8002C23
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	dir_len
		add	esp, 10h
		mov	[ebp+dirlen], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+dirlen]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+prev], al
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ebx, [edx+eax]
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ecx, eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	ecx, eax
		mov	eax, ecx
		mov	[ebx+40h], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+dirlen]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ebx, [edx+eax]
		cmp	[ebp+dirlen], 0
		jz	short loc_8002B7F
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		jmp	short loc_8002B84
; ---------------------------------------------------------------------------

loc_8002B7F:				; CODE XREF: tail_forever_inotify+1F9j
		mov	eax, offset a_	; "."

loc_8002B84:				; CODE XREF: tail_forever_inotify+20Ej
		sub	esp, 4
		push	184h		; mask
		push	eax		; name
		push	[ebp+wd]	; fd
		call	inotify_add_watch
		add	esp, 10h
		mov	[ebx+3Ch], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+dirlen]
		add	edx, eax
		movzx	eax, [ebp+prev]
		mov	[edx], al
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+3Ch]
		test	eax, eax
		jns	short loc_8002C23
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotWatchPar ; "cannot watch parent directory	of %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8002D16
; ---------------------------------------------------------------------------

loc_8002C23:				; CODE XREF: tail_forever_inotify+126j
					; tail_forever_inotify+266j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		lea	ebx, [edx+eax]
		mov	ecx, 0C06h
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		push	ecx		; mask
		push	eax		; name
		push	[ebp+wd]	; fd
		call	inotify_add_watch
		add	esp, 10h
		mov	[ebx+38h], eax
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+38h]
		test	eax, eax
		jns	short loc_8002CE0
		call	__errno_location
		mov	edx, [eax]
		mov	eax, [ebp+i]
		imul	ecx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, ecx
		mov	eax, [eax+30h]
		cmp	edx, eax
		jz	short loc_8002D15
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotWatchS ; "cannot watch %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002D15
; ---------------------------------------------------------------------------

loc_8002CE0:				; CODE XREF: tail_forever_inotify+307j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		sub	esp, 8
		push	eax
		push	[ebp+wd_to_name]
		call	hash_insert
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002D0C
		call	xalloc_die

loc_8002D0C:				; CODE XREF: tail_forever_inotify+396j
		mov	[ebp+found_watchable], 1
		jmp	short loc_8002D16
; ---------------------------------------------------------------------------

loc_8002D15:				; CODE XREF: tail_forever_inotify+326j
					; tail_forever_inotify+36Fj
		nop

loc_8002D16:				; CODE XREF: tail_forever_inotify+C1j
					; tail_forever_inotify+2AFj ...
		add	[ebp+i], 1

loc_8002D1D:				; CODE XREF: tail_forever_inotify+A2j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	loc_8002A16
		mov	eax, follow_mode
		cmp	eax, 2
		jnz	short loc_8002D48
		movzx	eax, [ebp+found_watchable]
		xor	eax, 1
		test	al, al
		jnz	loc_80033EE

loc_8002D48:				; CODE XREF: tail_forever_inotify+3C5j
		mov	eax, [ebp+n_files]
		imul	eax, 4Ch
		lea	edx, [eax-4Ch]
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+38h]
		mov	[ebp+prev_wd], eax
		mov	[ebp+i], 0
		jmp	short loc_8002DCA
; ---------------------------------------------------------------------------

loc_8002D6E:				; CODE XREF: tail_forever_inotify+464j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+28h]
		xor	eax, 1
		test	al, al
		jz	short loc_8002DC3
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+38h]
		mov	edx, [ebp+i]
		imul	ecx, edx, 4Ch
		mov	edx, [ebp+f]
		add	ecx, edx
		sub	esp, 4
		lea	edx, [ebp+prev_wd]
		push	edx		; prev_wd
		push	eax		; wd
		push	ecx		; fspec
		call	check_fspec
		add	esp, 10h

loc_8002DC3:				; CODE XREF: tail_forever_inotify+419j
		add	[ebp+i], 1

loc_8002DCA:				; CODE XREF: tail_forever_inotify+3FDj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8002D6E
		add	[ebp+evlen], 11h
		sub	esp, 0Ch
		push	[ebp+evlen]	; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+evbuf], eax

loc_8002DF3:				; CODE XREF: tail_forever_inotify+A62j
					; tail_forever_inotify+A68j ...
		mov	eax, ds:pid
		test	eax, eax
		jz	loc_8002FB8
		cmp	[ebp+writer_is_dead], 0
		jz	short loc_8002E13
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002E13:				; CODE XREF: tail_forever_inotify+498j
		mov	eax, ds:pid
		sub	esp, 8
		push	0		; sig
		push	eax		; pid
		call	kill
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002E3D
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8002E3D
		mov	eax, 1
		jmp	short loc_8002E42
; ---------------------------------------------------------------------------

loc_8002E3D:				; CODE XREF: tail_forever_inotify+4B9j
					; tail_forever_inotify+4C5j
		mov	eax, 0

loc_8002E42:				; CODE XREF: tail_forever_inotify+4CCj
		mov	[ebp+writer_is_dead], al
		and	[ebp+writer_is_dead], 1
		cmp	[ebp+writer_is_dead], 0
		jz	short loc_8002E70
		mov	dword ptr [ebp+key.size], 0
		mov	eax, dword ptr [ebp+key.size]
		mov	[ebp+key.name],	eax
		jmp	short loc_8002EEA
; ---------------------------------------------------------------------------

loc_8002E70:				; CODE XREF: tail_forever_inotify+4E7j
		fld	[ebp+sleep_interval]
		fnstcw	[ebp+var_13E]
		movzx	eax, [ebp+var_13E]
		mov	ah, 0Ch
		mov	[ebp+var_140], ax
		fldcw	[ebp+var_140]
		fistp	[ebp+var_14C]
		fldcw	[ebp+var_13E]
		mov	eax, [ebp+var_14C]
		mov	[ebp+key.name],	eax
		mov	eax, [ebp+key.name]
		mov	[ebp+var_150], eax
		fild	[ebp+var_150]
		fld	[ebp+sleep_interval]
		fsubrp	st(1), st
		fld	ds:dbl_8005E20
		fmulp	st(1), st
		fldcw	[ebp+var_140]
		fistp	[ebp+var_14C]
		fldcw	[ebp+var_13E]
		mov	eax, [ebp+var_14C]
		mov	dword ptr [ebp+key.size], eax

loc_8002EEA:				; CODE XREF: tail_forever_inotify+4FFj
		mov	ebx, 0
		mov	edx, 20h
		lea	eax, [ebp+rfd]
		mov	ecx, edx
		mov	edx, eax
		mov	edi, edx
		mov	eax, ebx
		cld
		rep stosd
		mov	edx, edi
		mov	[ebp+__d0], ecx
		mov	[ebp+__d1], edx
		mov	eax, [ebp+wd]
		lea	edx, [eax+1Fh]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 5
		mov	edx, eax
		mov	ebx, [ebp+edx*4+rfd.fds_bits]
		mov	eax, [ebp+wd]
		mov	ecx, eax
		sar	ecx, 1Fh
		shr	ecx, 1Bh
		add	eax, ecx
		and	eax, 1Fh
		sub	eax, ecx
		mov	esi, 1
		mov	ecx, eax
		shl	esi, cl
		mov	eax, esi
		or	eax, ebx
		mov	[ebp+edx*4+rfd.fds_bits], eax
		mov	eax, [ebp+wd]
		lea	edx, [eax+1]
		sub	esp, 0Ch
		lea	eax, [ebp+key]
		push	eax		; timeout
		push	0		; exceptfds
		push	0		; writefds
		lea	eax, [ebp+rfd]
		push	eax		; readfds
		push	edx		; nfds
		call	select
		add	esp, 20h
		mov	[ebp+file_change], eax
		cmp	[ebp+file_change], 0
		jz	loc_80033D6
		cmp	[ebp+file_change], 0FFFFFFFFh
		jnz	short loc_8002FB8
		sub	esp, 0Ch
		push	offset aErrorMonitorin ; "error	monitoring inotify event"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002FB8:				; CODE XREF: tail_forever_inotify+48Bj
					; tail_forever_inotify+61Fj
		mov	eax, [ebp+len]
		cmp	eax, [ebp+evbuf_off]
		ja	loc_8003091
		sub	esp, 4
		push	[ebp+evlen]
		push	[ebp+evbuf]
		push	[ebp+wd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+len], eax
		mov	[ebp+evbuf_off], 0
		cmp	[ebp+len], 0
		jz	short loc_8003012
		cmp	[ebp+len], 0FFFFFFFFh
		jnz	short loc_8003057
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_8003057

loc_8003012:				; CODE XREF: tail_forever_inotify+68Cj
		mov	eax, [ebp+max_realloc]
		lea	edx, [eax-1]
		mov	[ebp+max_realloc], edx
		test	eax, eax
		jz	short loc_8003057
		mov	[ebp+len], 0
		shl	[ebp+evlen], 1
		sub	esp, 8
		push	[ebp+evlen]	; size_t
		push	[ebp+evbuf]	; void *
		call	xrealloc
		add	esp, 10h
		mov	[ebp+evbuf], eax
		jmp	loc_80033E9
; ---------------------------------------------------------------------------

loc_8003057:				; CODE XREF: tail_forever_inotify+695j
					; tail_forever_inotify+6A1j ...
		cmp	[ebp+len], 0
		jz	short loc_8003069
		cmp	[ebp+len], 0FFFFFFFFh
		jnz	short loc_8003091

loc_8003069:				; CODE XREF: tail_forever_inotify+6EFj
		sub	esp, 0Ch
		push	offset aErrorReadingIn ; "error	reading	inotify	event"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8003091:				; CODE XREF: tail_forever_inotify+655j
					; tail_forever_inotify+6F8j
		mov	edx, [ebp+evbuf]
		mov	eax, [ebp+evbuf_off]
		add	eax, edx
		mov	[ebp+ev], eax
		mov	eax, [ebp+ev]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+evbuf_off]
		add	eax, edx
		add	eax, 10h
		mov	[ebp+evbuf_off], eax
		mov	eax, [ebp+ev]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	loc_80032E9
		mov	[ebp+j], 0
		jmp	short loc_8003146
; ---------------------------------------------------------------------------

loc_80030DC:				; CODE XREF: tail_forever_inotify+7E0j
		mov	eax, [ebp+j]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax+3Ch]
		mov	eax, [ebp+ev]
		mov	eax, [eax]
		cmp	edx, eax
		jnz	short loc_800313F
		mov	eax, [ebp+j]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+j]
		imul	ecx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, ecx
		mov	eax, [eax+40h]
		add	edx, eax
		mov	eax, [ebp+ev]
		add	eax, 10h
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003153

loc_800313F:				; CODE XREF: tail_forever_inotify+78Bj
		add	[ebp+j], 1

loc_8003146:				; CODE XREF: tail_forever_inotify+76Bj
		mov	eax, [ebp+j]
		cmp	eax, [ebp+n_files]
		jb	short loc_80030DC
		jmp	short loc_8003154
; ---------------------------------------------------------------------------

loc_8003153:				; CODE XREF: tail_forever_inotify+7CEj
		nop

loc_8003154:				; CODE XREF: tail_forever_inotify+7E2j
		mov	eax, [ebp+j]
		cmp	eax, [ebp+n_files]
		jz	loc_80033DC
		mov	ecx, 0C06h
		mov	eax, [ebp+j]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		push	ecx		; mask
		push	eax		; name
		push	[ebp+wd]	; fd
		call	inotify_add_watch
		add	esp, 10h
		mov	[ebp+new_wd], eax
		cmp	[ebp+new_wd], 0
		jns	short loc_80031E6
		mov	eax, [ebp+j]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotWatchS ; "cannot watch %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_80033E9
; ---------------------------------------------------------------------------

loc_80031E6:				; CODE XREF: tail_forever_inotify+829j
		mov	eax, [ebp+j]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	[ebp+fspec], eax
		sub	esp, 8
		push	[ebp+fspec]
		push	[ebp+wd_to_name]
		call	hash_delete
		add	esp, 10h
		mov	eax, [ebp+fspec]
		mov	edx, [ebp+new_wd]
		mov	[eax+38h], edx
		sub	esp, 8
		push	[ebp+fspec]
		push	[ebp+wd_to_name]
		call	hash_delete
		add	esp, 10h
		mov	[ebp+prev_0], eax
		cmp	[ebp+prev_0], 0
		jz	short loc_80032AA
		mov	eax, [ebp+prev_0]
		cmp	eax, [ebp+fspec]
		jz	short loc_80032AA
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	short loc_8003274
		sub	esp, 8
		push	0		; blocking
		push	[ebp+prev_0]	; f
		call	recheck
		add	esp, 10h

loc_8003274:				; CODE XREF: tail_forever_inotify+8F0j
		mov	eax, [ebp+prev_0]
		mov	dword ptr [eax+38h], 0FFFFFFFFh
		sub	esp, 0Ch
		push	[ebp+prev_0]	; f
		call	pretty_name
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+prev_0]
		mov	eax, [eax+2Ch]
		sub	esp, 8
		push	edx		; filename
		push	eax		; fd
		call	close_fd
		add	esp, 10h

loc_80032AA:				; CODE XREF: tail_forever_inotify+8D8j
					; tail_forever_inotify+8E6j
		sub	esp, 8
		push	[ebp+fspec]
		push	[ebp+wd_to_name]
		call	hash_insert
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80032CA
		call	xalloc_die

loc_80032CA:				; CODE XREF: tail_forever_inotify+954j
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	short loc_8003315
		sub	esp, 8
		push	0		; blocking
		push	[ebp+fspec]	; f
		call	recheck
		add	esp, 10h
		jmp	short loc_8003315
; ---------------------------------------------------------------------------

loc_80032E9:				; CODE XREF: tail_forever_inotify+75Bj
		mov	eax, [ebp+ev]
		mov	eax, [eax]
		mov	[ebp+key.wd], eax
		sub	esp, 8
		lea	eax, [ebp+key]
		push	eax
		push	[ebp+wd_to_name]
		call	hash_lookup
		add	esp, 10h
		mov	[ebp+fspec], eax

loc_8003315:				; CODE XREF: tail_forever_inotify+963j
					; tail_forever_inotify+978j
		cmp	[ebp+fspec], 0
		jz	loc_80033E2
		mov	eax, [ebp+ev]
		mov	eax, [eax+4]
		and	eax, 0C04h
		test	eax, eax
		jz	short loc_80033B0
		mov	eax, [ebp+ev]
		mov	eax, [eax+4]
		and	eax, 400h
		test	eax, eax
		jnz	short loc_8003362
		mov	eax, [ebp+ev]
		mov	eax, [eax+4]
		and	eax, 800h
		test	eax, eax
		jz	short loc_8003391
		mov	eax, follow_mode
		cmp	eax, 2
		jnz	short loc_8003391

loc_8003362:				; CODE XREF: tail_forever_inotify+9D5j
		mov	eax, [ebp+fspec]
		mov	eax, [eax+38h]
		sub	esp, 8
		push	eax		; wd
		push	[ebp+wd]	; fd
		call	inotify_rm_watch
		add	esp, 10h
		sub	esp, 8
		push	[ebp+fspec]
		push	[ebp+wd_to_name]
		call	hash_delete
		add	esp, 10h

loc_8003391:				; CODE XREF: tail_forever_inotify+9E7j
					; tail_forever_inotify+9F1j
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	short loc_80033E8
		sub	esp, 8
		push	0		; blocking
		push	[ebp+fspec]	; f
		call	recheck
		add	esp, 10h
		jmp	short loc_80033E8
; ---------------------------------------------------------------------------

loc_80033B0:				; CODE XREF: tail_forever_inotify+9C3j
		mov	eax, [ebp+ev]
		mov	eax, [eax]
		sub	esp, 4
		lea	edx, [ebp+prev_wd]
		push	edx		; prev_wd
		push	eax		; wd
		push	[ebp+fspec]	; fspec
		call	check_fspec
		add	esp, 10h
		jmp	loc_8002DF3
; ---------------------------------------------------------------------------

loc_80033D6:				; CODE XREF: tail_forever_inotify+612j
		nop
		jmp	loc_8002DF3
; ---------------------------------------------------------------------------

loc_80033DC:				; CODE XREF: tail_forever_inotify+7EEj
		nop
		jmp	loc_8002DF3
; ---------------------------------------------------------------------------

loc_80033E2:				; CODE XREF: tail_forever_inotify+9ADj
		nop
		jmp	loc_8002DF3
; ---------------------------------------------------------------------------

loc_80033E8:				; CODE XREF: tail_forever_inotify+A2Aj
					; tail_forever_inotify+A3Fj
		nop

loc_80033E9:				; CODE XREF: tail_forever_inotify+6E3j
					; tail_forever_inotify+872j
		jmp	loc_8002DF3
; ---------------------------------------------------------------------------

loc_80033EE:				; CODE XREF: tail_forever_inotify+3D3j
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8003400
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003400:				; CODE XREF: tail_forever_inotify+A8Aj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
tail_forever_inotify endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tail_bytes(const char *pretty_filename,	int fd,	uintmax_t n_bytes, uintmax_t *read_pos)
tail_bytes	proc near		; CODE XREF: tail+5Bp

n_bytes		= qword	ptr -0B8h
read_pos	= dword	ptr -0B0h
pretty_filename	= dword	ptr -0ACh
t		= dword	ptr -9Ch
current_pos	= qword	ptr -98h
end_pos		= qword	ptr -90h
diff		= qword	ptr -88h
bytes_remaining	= qword	ptr -80h
nb		= qword	ptr -78h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0B0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+read_pos],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_800349B
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8003757
; ---------------------------------------------------------------------------

loc_800349B:				; CODE XREF: tail_bytes+4Ej
		movzx	eax, ds:from_start
		test	al, al
		jz	loc_800359E
		movzx	eax, ds:presume_input_pipe
		xor	eax, 1
		test	al, al
		jz	short loc_8003523
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8003523
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		test	edx, edx
		js	short loc_8003523
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	1		; whence
		push	edx
		push	eax		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	eax, [ebp+read_pos]
		mov	ecx, [eax]
		mov	ebx, [eax+4]
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	short loc_8003566
; ---------------------------------------------------------------------------

loc_8003523:				; CODE XREF: tail_bytes+AEj
					; tail_bytes+BDj ...
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_bytes+4]
		push	dword ptr [ebp+n_bytes]	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	start_bytes
		add	esp, 20h
		mov	[ebp+t], eax
		cmp	[ebp+t], 0
		jz	short loc_8003566
		mov	eax, [ebp+t]
		shr	eax, 1Fh
		jmp	loc_8003757
; ---------------------------------------------------------------------------

loc_8003566:				; CODE XREF: tail_bytes+119j
					; tail_bytes+14Ej
		push	0FFFFFFFFh
		push	0FFFFFFFFh	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	loc_8003752
; ---------------------------------------------------------------------------

loc_800359E:				; CODE XREF: tail_bytes+9Cj
		movzx	eax, ds:presume_input_pipe
		xor	eax, 1
		test	al, al
		jz	loc_800372A
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_800372A
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		test	edx, edx
		js	loc_800372A
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	1		; whence
		push	0
		push	0		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	dword ptr [ebp+current_pos], eax
		mov	dword ptr [ebp+current_pos+4], edx
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	2		; whence
		push	0
		push	0		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	dword ptr [ebp+end_pos], eax
		mov	dword ptr [ebp+end_pos+4], edx
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		sub	eax, dword ptr [ebp+current_pos]
		sbb	edx, dword ptr [ebp+current_pos+4]
		mov	dword ptr [ebp+diff], eax
		mov	dword ptr [ebp+diff+4],	edx
		mov	eax, dword ptr [ebp+diff]
		mov	edx, dword ptr [ebp+diff+4]
		test	edx, edx
		jns	short loc_8003661
		mov	eax, 0
		mov	edx, 0

loc_8003661:				; CODE XREF: tail_bytes+24Dj
		mov	dword ptr [ebp+bytes_remaining], eax
		mov	dword ptr [ebp+bytes_remaining+4], edx
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		mov	dword ptr [ebp+nb], eax
		mov	dword ptr [ebp+nb+4], edx
		mov	eax, dword ptr [ebp+bytes_remaining]
		mov	edx, dword ptr [ebp+bytes_remaining+4]
		cmp	edx, dword ptr [ebp+nb+4]
		jg	short loc_80036BD
		cmp	edx, dword ptr [ebp+nb+4]
		jl	short loc_800368E
		cmp	eax, dword ptr [ebp+nb]
		ja	short loc_80036BD

loc_800368E:				; CODE XREF: tail_bytes+27Fj
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	0		; whence
		push	dword ptr [ebp+current_pos+4]
		push	dword ptr [ebp+current_pos] ; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	short loc_80036ED
; ---------------------------------------------------------------------------

loc_80036BD:				; CODE XREF: tail_bytes+27Aj
					; tail_bytes+284j
		mov	eax, dword ptr [ebp+nb]
		mov	edx, dword ptr [ebp+nb+4]
		neg	eax
		adc	edx, 0
		neg	edx
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	2		; whence
		push	edx
		push	eax		; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx

loc_80036ED:				; CODE XREF: tail_bytes+2B3j
		push	dword ptr [ebp+n_bytes+4]
		push	dword ptr [ebp+n_bytes]	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	short loc_8003752
; ---------------------------------------------------------------------------

loc_800372A:				; CODE XREF: tail_bytes+1A2j
					; tail_bytes+1B5j ...
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_bytes+4]
		push	dword ptr [ebp+n_bytes]	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	pipe_bytes
		add	esp, 20h
		jmp	short loc_8003757
; ---------------------------------------------------------------------------

loc_8003752:				; CODE XREF: tail_bytes+191j
					; tail_bytes+320j
		mov	eax, 1

loc_8003757:				; CODE XREF: tail_bytes+8Ej
					; tail_bytes+159j ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8003768
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003768:				; CODE XREF: tail_bytes+359j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tail_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tail_lines(const char *pretty_filename,	int fd,	uintmax_t n_lines, uintmax_t *read_pos)
tail_lines	proc near		; CODE XREF: tail+3Fp

n_lines		= qword	ptr -98h
read_pos	= dword	ptr -90h
pretty_filename	= dword	ptr -8Ch
t		= dword	ptr -84h
start_pos	= qword	ptr -80h
end_pos		= qword	ptr -78h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+read_pos],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003802
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80039D3
; ---------------------------------------------------------------------------

loc_8003802:				; CODE XREF: tail_lines+4Ej
		movzx	eax, ds:from_start
		test	al, al
		jz	short loc_8003888
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_lines+4]
		push	dword ptr [ebp+n_lines]	; n_lines
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	start_lines
		add	esp, 20h
		mov	[ebp+t], eax
		cmp	[ebp+t], 0
		jz	short loc_8003850
		mov	eax, [ebp+t]
		shr	eax, 1Fh
		jmp	loc_80039D3
; ---------------------------------------------------------------------------

loc_8003850:				; CODE XREF: tail_lines+D1j
		push	0FFFFFFFFh
		push	0FFFFFFFFh	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	dump_remainder
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+read_pos]
		mov	edx, [eax+4]
		mov	eax, [eax]
		add	eax, ecx
		adc	edx, ebx
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	loc_80039CE
; ---------------------------------------------------------------------------

loc_8003888:				; CODE XREF: tail_lines+9Cj
		mov	dword ptr [ebp+start_pos], 0FFFFFFFFh
		mov	dword ptr [ebp+start_pos+4], 0FFFFFFFFh
		movzx	eax, ds:presume_input_pipe
		xor	eax, 1
		test	al, al
		jz	loc_8003975
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8003975
		push	1
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+start_pos], eax
		mov	dword ptr [ebp+start_pos+4], edx
		mov	eax, dword ptr [ebp+start_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+start_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	loc_8003975
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+end_pos], eax
		mov	dword ptr [ebp+end_pos+4], edx
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		cmp	edx, dword ptr [ebp+start_pos+4]
		jl	short loc_8003975
		cmp	edx, dword ptr [ebp+start_pos+4]
		jg	short loc_8003916
		cmp	eax, dword ptr [ebp+start_pos]
		jbe	short loc_8003975

loc_8003916:				; CODE XREF: tail_lines+1A0j
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		mov	ecx, [ebp+read_pos]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, dword ptr [ebp+end_pos+4]
		or	eax, dword ptr [ebp+end_pos]
		test	eax, eax
		jz	loc_80039CD
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+end_pos+4]
		push	dword ptr [ebp+end_pos]	; end_pos
		push	dword ptr [ebp+start_pos+4]
		push	dword ptr [ebp+start_pos] ; start_pos
		push	dword ptr [ebp+n_lines+4]
		push	dword ptr [ebp+n_lines]	; n_lines
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	file_lines
		add	esp, 30h
		xor	eax, 1
		test	al, al
		jz	short loc_80039CD
		mov	eax, 0
		jmp	short loc_80039D3
; ---------------------------------------------------------------------------

loc_8003975:				; CODE XREF: tail_lines+133j
					; tail_lines+146j ...
		mov	eax, dword ptr [ebp+start_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+start_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	short loc_80039A5
		sub	esp, 0Ch
		push	[ebp+pretty_filename] ;	filename
		push	0		; whence
		push	dword ptr [ebp+start_pos+4]
		push	dword ptr [ebp+start_pos] ; offset
		push	[ebp+fd]	; fd
		call	xlseek
		add	esp, 20h

loc_80039A5:				; CODE XREF: tail_lines+218j
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_lines+4]
		push	dword ptr [ebp+n_lines]	; n_lines
		push	[ebp+fd]	; fd
		push	[ebp+pretty_filename] ;	pretty_filename
		call	pipe_lines
		add	esp, 20h
		jmp	short loc_80039D3
; ---------------------------------------------------------------------------

loc_80039CD:				; CODE XREF: tail_lines+1C0j
					; tail_lines+1FDj
		nop

loc_80039CE:				; CODE XREF: tail_lines+114j
		mov	eax, 1

loc_80039D3:				; CODE XREF: tail_lines+8Ej
					; tail_lines+DCj ...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_80039E4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80039E4:				; CODE XREF: tail_lines+26Ej
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tail_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tail(const char	*filename, int fd, uintmax_t n_units, uintmax_t	*read_pos)
tail		proc near		; CODE XREF: tail_file+1B1p

n_units		= qword	ptr -10h
filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
read_pos	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_units], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_units+4], eax
		mov	eax, [ebp+read_pos]
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 0
		movzx	eax, ds:count_lines
		test	al, al
		jz	short loc_8003A34
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_lines
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; pretty_filename
		call	tail_lines
		add	esp, 20h
		jmp	short locret_8003A4E
; ---------------------------------------------------------------------------

loc_8003A34:				; CODE XREF: tail+2Bj
		sub	esp, 0Ch
		push	[ebp+read_pos]	; read_pos
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_bytes
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; pretty_filename
		call	tail_bytes
		add	esp, 20h

locret_8003A4E:				; CODE XREF: tail+47j
		leave
		retn
tail		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tail_file(File_spec *f,	uintmax_t n_units)
tail_file	proc near		; CODE XREF: main+2B6p

n_units		= qword	ptr -98h
f		= dword	ptr -8Ch
ok		= byte ptr -7Eh
is_stdin	= byte ptr -7Dh
fd		= dword	ptr -7Ch
read_pos	= qword	ptr -78h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n_units], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_units+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_8003AB8
		mov	ds:have_read_stdin, 1
		mov	[ebp+fd], 0
		jmp	short loc_8003AD1
; ---------------------------------------------------------------------------

loc_8003AB8:				; CODE XREF: tail_file+56j
		mov	eax, [ebp+f]
		mov	eax, [eax]
		sub	esp, 8
		push	0
		push	eax
		call	open_safer
		add	esp, 10h
		mov	[ebp+fd], eax

loc_8003AD1:				; CODE XREF: tail_file+66j
		movzx	eax, ds:reopen_inaccessible_files
		xor	eax, 1
		test	al, al
		jnz	short loc_8003AE5
		cmp	[ebp+fd], 0FFFFFFFFh
		jz	short loc_8003AEC

loc_8003AE5:				; CODE XREF: tail_file+8Dj
		mov	eax, 1
		jmp	short loc_8003AF1
; ---------------------------------------------------------------------------

loc_8003AEC:				; CODE XREF: tail_file+93j
		mov	eax, 0

loc_8003AF1:				; CODE XREF: tail_file+9Aj
		and	eax, 1
		mov	edx, [ebp+f]
		mov	[edx+2Ah], al
		cmp	[ebp+fd], 0FFFFFFFFh
		jnz	loc_8003BAF
		movzx	eax, ds:forever
		test	al, al
		jz	short loc_8003B61
		mov	eax, [ebp+f]
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		call	__errno_location
		mov	edx, [eax]
		mov	eax, [ebp+f]
		mov	[eax+30h], edx
		mov	eax, [ebp+f]
		mov	byte ptr [eax+28h], 0
		mov	eax, [ebp+f]
		mov	dword ptr [eax+1Ch], 0
		mov	dword ptr [eax+20h], 0
		mov	eax, [ebp+f]
		mov	dword ptr [eax+14h], 0
		mov	dword ptr [eax+18h], 0

loc_8003B61:				; CODE XREF: tail_file+C0j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	loc_8003E2A
; ---------------------------------------------------------------------------

loc_8003BAF:				; CODE XREF: tail_file+B1j
		movzx	eax, ds:print_headers
		test	al, al
		jz	short loc_8003BD7
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; pretty_filename
		call	write_header
		add	esp, 10h

loc_8003BD7:				; CODE XREF: tail_file+168j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		mov	edx, eax
		sub	esp, 0Ch
		lea	eax, [ebp+read_pos]
		push	eax		; read_pos
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_units
		push	[ebp+fd]	; fd
		push	edx		; filename
		call	tail
		add	esp, 20h
		mov	[ebp+ok], al
		movzx	eax, ds:forever
		test	al, al
		jz	loc_8003DC4
		movzx	eax, [ebp+ok]
		lea	edx, [eax-1]
		mov	eax, [ebp+f]
		mov	[eax+30h], edx
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jns	short loc_8003C9F
		mov	[ebp+ok], 0
		call	__errno_location
		mov	edx, [eax]
		mov	eax, [ebp+f]
		mov	[eax+30h], edx
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_8003D27
; ---------------------------------------------------------------------------

loc_8003C9F:				; CODE XREF: tail_file+1EFj
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8003D27
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jz	short loc_8003D27
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jz	short loc_8003D27
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jz	short loc_8003D27
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCannotFollowE ; "%s: cannot follow end	of this	type of	f"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		mov	eax, [ebp+f]
		mov	dword ptr [eax+30h], 0FFFFFFFFh
		mov	eax, [ebp+f]
		mov	byte ptr [eax+28h], 1

loc_8003D27:				; CODE XREF: tail_file+24Aj
					; tail_file+25Cj ...
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8003D64
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 8
		push	eax		; filename
		push	[ebp+fd]	; fd
		call	close_fd
		add	esp, 10h
		mov	eax, [ebp+f]
		mov	dword ptr [eax+2Ch], 0FFFFFFFFh
		jmp	loc_8003E2A
; ---------------------------------------------------------------------------

loc_8003D64:				; CODE XREF: tail_file+2E0j
		cmp	[ebp+is_stdin],	0
		jz	short loc_8003D71
		mov	ecx, 0FFFFFFFFh
		jmp	short loc_8003D76
; ---------------------------------------------------------------------------

loc_8003D71:				; CODE XREF: tail_file+318j
		mov	ecx, 1

loc_8003D76:				; CODE XREF: tail_file+31Fj
		mov	eax, dword ptr [ebp+read_pos]
		mov	edx, dword ptr [ebp+read_pos+4]
		sub	esp, 8
		push	ecx		; blocking
		lea	ecx, [ebp+stats]
		push	ecx		; st
		push	edx
		push	eax		; size
		push	[ebp+fd]	; fd
		push	[ebp+f]		; f
		call	record_open_fd
		add	esp, 20h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 8
		push	eax		; name
		push	[ebp+fd]	; fd
		call	fremote
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+f]
		mov	[eax+29h], dl
		jmp	short loc_8003E2A
; ---------------------------------------------------------------------------

loc_8003DC4:				; CODE XREF: tail_file+1C5j
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8003E2A
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003E2A
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	pretty_name
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8003E2A:				; CODE XREF: tail_file+15Aj
					; tail_file+30Fj ...
		movzx	eax, [ebp+ok]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8003E3F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003E3F:				; CODE XREF: tail_file+3E8j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tail_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	parse_obsolete_option(int argc,	char *const *argv, uintmax_t *n_units)
parse_obsolete_option proc near		; CODE XREF: main+D4p

t_from_start	= byte ptr -1Ch
t_count_lines	= byte ptr -1Bh
t_forever	= byte ptr -1Ah
obsolete_usage	= byte ptr -19h
p		= dword	ptr -18h
default_count	= dword	ptr -14h
n_string	= dword	ptr -10h
n_string_end	= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
argv		= dword	ptr  0Ch
n_units		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+default_count], 0Ah
		mov	[ebp+t_count_lines], 1
		mov	[ebp+t_forever], 0
		cmp	[ebp+argc], 2
		jz	short loc_8003EBC
		cmp	[ebp+argc], 3
		jnz	short loc_8003E89
		mov	eax, [ebp+argv]
		add	eax, 8
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_8003EBC
		mov	eax, [ebp+argv]
		add	eax, 8
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8003EBC

loc_8003E89:				; CODE XREF: parse_obsolete_option+20j
		cmp	[ebp+argc], 2
		jle	short loc_8003EB2
		cmp	[ebp+argc], 4
		jg	short loc_8003EB2
		mov	eax, [ebp+argv]
		add	eax, 8
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8005B67 ; "--"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003EBC

loc_8003EB2:				; CODE XREF: parse_obsolete_option+47j
					; parse_obsolete_option+4Dj
		mov	eax, 0
		jmp	loc_8004040
; ---------------------------------------------------------------------------

loc_8003EBC:				; CODE XREF: parse_obsolete_option+1Aj
					; parse_obsolete_option+2Fj ...
		call	posix2_version
		cmp	eax, 30DAFh
		setle	al
		mov	[ebp+obsolete_usage], al
		mov	eax, [ebp+argv]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 2Bh
		jz	short loc_8003EF8
		cmp	eax, 2Dh
		jz	short loc_8003F13
		mov	eax, 0
		jmp	loc_8004040
; ---------------------------------------------------------------------------

loc_8003EF8:				; CODE XREF: parse_obsolete_option+A1j
		movzx	eax, [ebp+obsolete_usage]
		xor	eax, 1
		test	al, al
		jz	short loc_8003F0D
		mov	eax, 0
		jmp	loc_8004040
; ---------------------------------------------------------------------------

loc_8003F0D:				; CODE XREF: parse_obsolete_option+BBj
		mov	[ebp+t_from_start], 1
		jmp	short loc_8003F47
; ---------------------------------------------------------------------------

loc_8003F13:				; CODE XREF: parse_obsolete_option+A6j
		movzx	eax, [ebp+obsolete_usage]
		xor	eax, 1
		test	al, al
		jz	short loc_8003F42
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 63h
		setz	al
		movzx	edx, al
		mov	eax, [ebp+p]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8003F42
		mov	eax, 0
		jmp	loc_8004040
; ---------------------------------------------------------------------------

loc_8003F42:				; CODE XREF: parse_obsolete_option+D6j
					; parse_obsolete_option+F0j
		mov	[ebp+t_from_start], 0
		nop

loc_8003F47:				; CODE XREF: parse_obsolete_option+CBj
		mov	eax, [ebp+p]
		mov	[ebp+n_string],	eax
		jmp	short loc_8003F53
; ---------------------------------------------------------------------------

loc_8003F4F:				; CODE XREF: parse_obsolete_option+11Cj
		add	[ebp+p], 1

loc_8003F53:				; CODE XREF: parse_obsolete_option+107j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8003F4F
		mov	eax, [ebp+p]
		mov	[ebp+n_string_end], eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 63h
		jz	short loc_8003F86
		cmp	eax, 6Ch
		jz	short loc_8003F8A
		cmp	eax, 62h
		jnz	short loc_8003F8F
		shl	[ebp+default_count], 9

loc_8003F86:				; CODE XREF: parse_obsolete_option+130j
		mov	[ebp+t_count_lines], 0

loc_8003F8A:				; CODE XREF: parse_obsolete_option+135j
		add	[ebp+p], 1
		nop

loc_8003F8F:				; CODE XREF: parse_obsolete_option+13Aj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 66h
		jnz	short loc_8003FA1
		mov	[ebp+t_forever], 1
		add	[ebp+p], 1

loc_8003FA1:				; CODE XREF: parse_obsolete_option+151j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8003FB5
		mov	eax, 0
		jmp	loc_8004040
; ---------------------------------------------------------------------------

loc_8003FB5:				; CODE XREF: parse_obsolete_option+163j
		mov	eax, [ebp+n_string]
		cmp	eax, [ebp+n_string_end]
		jnz	short loc_8003FCB
		mov	eax, [ebp+default_count]
		cdq
		mov	ecx, [ebp+n_units]
		mov	[ecx], eax
		mov	[ecx+4], edx
		jmp	short loc_8004020
; ---------------------------------------------------------------------------

loc_8003FCB:				; CODE XREF: parse_obsolete_option+175j
		sub	esp, 0Ch
		push	offset aB	; "b"
		push	[ebp+n_units]
		push	0Ah
		push	0
		push	[ebp+n_string]
		call	xstrtoumax
		add	esp, 20h
		and	eax, 0FFFFFFFDh
		test	eax, eax
		jz	short loc_8004020
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aNumberInSIsToo ; "number in %s is too large"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8004020:				; CODE XREF: parse_obsolete_option+183j
					; parse_obsolete_option+1A4j
		movzx	eax, [ebp+t_from_start]
		mov	ds:from_start, al
		movzx	eax, [ebp+t_count_lines]
		mov	ds:count_lines,	al
		movzx	eax, [ebp+t_forever]
		mov	ds:forever, al
		mov	eax, 1

loc_8004040:				; CODE XREF: parse_obsolete_option+71j
					; parse_obsolete_option+ADj ...
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_obsolete_option endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl parse_options(int argc, char **argv, uintmax_t *n_units,	header_mode *header_mode, double *sleep_interval)
parse_options	proc near		; CODE XREF: main+103p

sleep_interval	= dword	ptr -38h
header_mode	= dword	ptr -34h
n_units		= dword	ptr -30h
argv		= dword	ptr -2Ch
c		= dword	ptr -24h
s_err		= dword	ptr -20h
s_err_0		= dword	ptr -1Ch
s		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_4]
		mov	[ebp+argv], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+n_units], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+header_mode], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+sleep_interval], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004074:				; CODE XREF: parse_options+413j
		mov	eax, [ebp+c]
		cmp	eax, 71h
		jz	loc_800433F
		cmp	eax, 71h
		jg	short loc_80040E1
		cmp	eax, 39h
		jg	short loc_80040AE
		cmp	eax, 30h
		jge	loc_800440A
		cmp	eax, 0FFFFFF7Dh
		jz	loc_80043C8
		cmp	eax, 0FFFFFF7Eh
		jz	loc_80043BE
		jmp	loc_800442A
; ---------------------------------------------------------------------------

loc_80040AE:				; CODE XREF: parse_options+43j
		cmp	eax, 63h
		jz	loc_8004163
		cmp	eax, 63h
		jg	short loc_80040CA
		cmp	eax, 46h
		jz	loc_8004146
		jmp	loc_800442A
; ---------------------------------------------------------------------------

loc_80040CA:				; CODE XREF: parse_options+75j
		cmp	eax, 66h
		jz	loc_8004213
		cmp	eax, 6Eh
		jz	loc_8004163
		jmp	loc_800442A
; ---------------------------------------------------------------------------

loc_80040E1:				; CODE XREF: parse_options+3Ej
		cmp	eax, 81h
		jz	loc_8004278
		cmp	eax, 81h
		jg	short loc_8004115
		cmp	eax, 76h
		jz	loc_80043B3
		cmp	eax, 80h
		jz	loc_800426C
		cmp	eax, 73h
		jz	loc_800434D
		jmp	loc_800442A
; ---------------------------------------------------------------------------

loc_8004115:				; CODE XREF: parse_options+ACj
		cmp	eax, 83h
		jz	loc_8004333
		cmp	eax, 83h
		jl	loc_80042D4
		cmp	eax, 84h
		jz	loc_8004213
		cmp	eax, 85h
		jz	loc_80042C8
		jmp	loc_800442A
; ---------------------------------------------------------------------------

loc_8004146:				; CODE XREF: parse_options+7Aj
		mov	ds:forever, 1
		mov	follow_mode, 1
		mov	ds:reopen_inaccessible_files, 1
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004163:				; CODE XREF: parse_options+6Cj
					; parse_options+91j
		cmp	[ebp+c], 6Eh
		setz	al
		mov	ds:count_lines,	al
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	short loc_8004184
		mov	ds:from_start, 1
		jmp	short loc_800419D
; ---------------------------------------------------------------------------

loc_8004184:				; CODE XREF: parse_options+134j
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_800419D
		mov	eax, ds:optarg
		add	eax, 1
		mov	ds:optarg, eax

loc_800419D:				; CODE XREF: parse_options+13Dj
					; parse_options+149j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset aBkkmmgtpezy0 ; "bkKmMGTPEZY0"
		push	[ebp+n_units]
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 0
		jz	loc_8004434
		cmp	[ebp+c], 6Eh
		jnz	short loc_80041E1
		sub	esp, 0Ch
		push	offset aInvalidNumberO ; "invalid number of lines"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_80041F3
; ---------------------------------------------------------------------------

loc_80041E1:				; CODE XREF: parse_options+186j
		sub	esp, 0Ch
		push	offset aInvalidNumbe_0 ; "invalid number of bytes"
		call	gettext
		add	esp, 10h
		mov	edx, eax

loc_80041F3:				; CODE XREF: parse_options+19Aj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	edx
		push	eax
		push	offset aSS_0	; "%s: %s"
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004213:				; CODE XREF: parse_options+88j
					; parse_options+EBj
		mov	ds:forever, 1
		mov	eax, ds:optarg
		test	eax, eax
		jnz	short loc_8004232
		mov	follow_mode, 2
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004232:				; CODE XREF: parse_options+1DCj
		mov	edx, ds:argmatch_die
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset follow_mode_map
		push	offset follow_mode_string
		push	eax
		push	offset aFollow	; "--follow"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:follow_mode_map[eax*4]
		mov	follow_mode, eax
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_800426C:				; CODE XREF: parse_options+BCj
		mov	ds:reopen_inaccessible_files, 1
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004278:				; CODE XREF: parse_options+A1j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		push	offset max_n_unchanged_stats_between_opens
		push	0Ah
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jz	loc_8004434
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidMaximu ; "%s: invalid maximum number of	unchanged"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_80042C8:				; CODE XREF: parse_options+F6j
		mov	ds:disable_inotify, 1
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_80042D4:				; CODE XREF: parse_options+E0j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+s]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		mov	[ebp+s_err_0], eax
		cmp	[ebp+s_err_0], 0
		jnz	short loc_8004302
		mov	eax, dword ptr [ebp+s]
		test	eax, eax
		jns	short loc_8004326

loc_8004302:				; CODE XREF: parse_options+2B4j
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidPid ; "%s: invalid PID"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8004326:				; CODE XREF: parse_options+2BBj
		mov	eax, dword ptr [ebp+s]
		mov	ds:pid,	eax
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_8004333:				; CODE XREF: parse_options+D5j
		mov	ds:presume_input_pipe, 1
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_800433F:				; CODE XREF: parse_options+35j
		mov	eax, [ebp+header_mode]
		mov	dword ptr [eax], 2
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_800434D:				; CODE XREF: parse_options+C5j
		mov	eax, ds:optarg
		push	offset c_strtod
		lea	edx, [ebp+s]
		push	edx
		push	0
		push	eax
		call	xstrtod
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_8004382
		fld	[ebp+s]
		fldz
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		setnb	al
		xor	eax, 1
		test	al, al
		jz	short loc_80043A6

loc_8004382:				; CODE XREF: parse_options+326j
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSInvalidNumber ; "%s: invalid number of	seconds"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80043A6:				; CODE XREF: parse_options+33Bj
		fld	[ebp+s]
		mov	eax, [ebp+sleep_interval]
		fstp	qword ptr [eax]
		jmp	loc_8004434
; ---------------------------------------------------------------------------

loc_80043B3:				; CODE XREF: parse_options+B1j
		mov	eax, [ebp+header_mode]
		mov	dword ptr [eax], 1
		jmp	short loc_8004434
; ---------------------------------------------------------------------------

loc_80043BE:				; CODE XREF: parse_options+5Ej
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80043C8:				; CODE XREF: parse_options+53j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	offset aIanLanceTaylor ; "Ian Lance Taylor"
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aPaulRubin ; "Paul Rubin"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aTail	; "tail"
		push	eax
		call	version_etc
		add	esp, 30h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800440A:				; CODE XREF: parse_options+48j
		sub	esp, 0Ch
		push	offset aOptionUsedInIn ; "option used in invalid context -- %c"
		call	gettext
		add	esp, 10h
		push	[ebp+c]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800442A:				; CODE XREF: parse_options+64j
					; parse_options+80j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8004434:				; CODE XREF: parse_options+2Aj
					; parse_options+119j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "c:n:fFqs:v0123456789"
		push	[ebp+argv]	; argv
		push	[ebp+argc]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8004074
		movzx	eax, ds:reopen_inaccessible_files
		test	al, al
		jz	short loc_8004493
		mov	eax, follow_mode
		cmp	eax, 1
		jz	short loc_8004493
		sub	esp, 0Ch
		push	offset aWarningRetryIs ; "warning: --retry is useful mainly when "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8004493:				; CODE XREF: parse_options+422j
					; parse_options+42Cj
		mov	eax, ds:pid
		test	eax, eax
		jz	short loc_80044CC
		movzx	eax, ds:forever
		xor	eax, 1
		test	al, al
		jz	short loc_80044CC
		sub	esp, 0Ch
		push	offset aWarningPidIgno ; "warning: PID ignored;	--pid=PID is usef"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8004522
; ---------------------------------------------------------------------------

loc_80044CC:				; CODE XREF: parse_options+455j
					; parse_options+463j
		mov	eax, ds:pid
		test	eax, eax
		jz	short loc_8004522
		mov	eax, ds:pid
		sub	esp, 8
		push	0		; sig
		push	eax		; pid
		call	kill
		add	esp, 10h
		test	eax, eax
		jz	short loc_8004522
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 26h
		jnz	short loc_8004522
		sub	esp, 0Ch
		push	offset aWarningPidPidI ; "warning: --pid=PID is	not supported on "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:pid,	0

loc_8004522:				; CODE XREF: parse_options+485j
					; parse_options+48Ej ...
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8004534
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8004534:				; CODE XREF: parse_options+4E8j
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_options	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl ignore_fifo_and_pipe(File_spec	*f, size_t n_files)
ignore_fifo_and_pipe proc near		; CODE XREF: main+2F3p

is_a_fifo_or_pipe= byte	ptr -11h
n_viable	= dword	ptr -10h
i		= dword	ptr -0Ch
f		= dword	ptr  8
n_files		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+n_viable],	0
		mov	[ebp+i], 0
		jmp	loc_80045E8
; ---------------------------------------------------------------------------

loc_8004552:				; CODE XREF: ignore_fifo_and_pipe+B5j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80045BD
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		movzx	eax, byte ptr [eax+28h]
		xor	eax, 1
		test	al, al
		jz	short loc_80045BD
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+2Ch]
		test	eax, eax
		js	short loc_80045BD
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	eax, [eax+24h]
		and	eax, 0F000h
		cmp	eax, 1000h
		jnz	short loc_80045BD
		mov	eax, 1
		jmp	short loc_80045C2
; ---------------------------------------------------------------------------

loc_80045BD:				; CODE XREF: ignore_fifo_and_pipe+39j
					; ignore_fifo_and_pipe+4Fj ...
		mov	eax, 0

loc_80045C2:				; CODE XREF: ignore_fifo_and_pipe+82j
		mov	[ebp+is_a_fifo_or_pipe], al
		and	[ebp+is_a_fifo_or_pipe], 1
		cmp	[ebp+is_a_fifo_or_pipe], 0
		jz	short loc_80045E0
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+f]
		add	eax, edx
		mov	byte ptr [eax+28h], 1
		jmp	short loc_80045E4
; ---------------------------------------------------------------------------

loc_80045E0:				; CODE XREF: ignore_fifo_and_pipe+94j
		add	[ebp+n_viable],	1

loc_80045E4:				; CODE XREF: ignore_fifo_and_pipe+A5j
		add	[ebp+i], 1

loc_80045E8:				; CODE XREF: ignore_fifo_and_pipe+14j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	loc_8004552
		mov	eax, [ebp+n_viable]
		leave
		retn
ignore_fifo_and_pipe endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -4Ch
ok		= byte ptr -3Bh
found_hyphen	= byte ptr -3Ah
obsolete_option	= byte ptr -39h
header_mode	= dword	ptr -38h
n_files		= dword	ptr -34h
file		= dword	ptr -30h
i		= dword	ptr -2Ch
F		= dword	ptr -28h
wd		= dword	ptr -24h
n_units		= qword	ptr -20h
sleep_interval	= qword	ptr -18h
var_C		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 50h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+header_mode], 0
		mov	[ebp+ok], 1
		mov	dword ptr [ebp+n_units], 0Ah
		mov	dword ptr [ebp+n_units+4], 0
		fld1
		fstp	[ebp+sleep_interval]
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:have_read_stdin, 0
		mov	ds:count_lines,	1
		mov	ds:print_headers, 0
		movzx	eax, ds:print_headers
		mov	ds:from_start, al
		movzx	eax, ds:from_start
		mov	ds:forever, al
		sub	esp, 4
		lea	eax, [ebp+n_units]
		push	eax		; n_units
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	parse_obsolete_option
		add	esp, 10h
		mov	[ebp+obsolete_option], al
		movzx	eax, [ebp+obsolete_option]
		sub	[ebx], eax
		movzx	eax, [ebp+obsolete_option]
		shl	eax, 2
		add	[ebp+argv], eax
		sub	esp, 0Ch
		lea	eax, [ebp+sleep_interval]
		push	eax		; sleep_interval
		lea	eax, [ebp+header_mode]
		push	eax		; header_mode
		lea	eax, [ebp+n_units]
		push	eax		; n_units
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	parse_options
		add	esp, 20h
		movzx	eax, ds:from_start
		test	al, al
		jz	short loc_800472D
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		or	eax, edx
		test	eax, eax
		jz	short loc_800472D
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		add	eax, 0FFFFFFFFh
		adc	edx, 0FFFFFFFFh
		mov	dword ptr [ebp+n_units], eax
		mov	dword ptr [ebp+n_units+4], edx

loc_800472D:				; CODE XREF: main+114j	main+120j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_800475A
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_files], eax
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	[ebp+file], eax
		jmp	short loc_8004768
; ---------------------------------------------------------------------------

loc_800475A:				; CODE XREF: main+13Bj
		mov	[ebp+n_files], 1
		mov	[ebp+file], offset dummy_stdin_5843

loc_8004768:				; CODE XREF: main+15Fj
		mov	[ebp+found_hyphen], 0
		mov	[ebp+i], 0
		jmp	short loc_80047A3
; ---------------------------------------------------------------------------

loc_8004775:				; CODE XREF: main+1B0j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80057D9 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800479F
		mov	[ebp+found_hyphen], 1

loc_800479F:				; CODE XREF: main+1A0j
		add	[ebp+i], 1

loc_80047A3:				; CODE XREF: main+17Aj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8004775
		cmp	[ebp+found_hyphen], 0
		jz	short loc_80047EB
		mov	eax, follow_mode
		cmp	eax, 1
		jnz	short loc_80047EB
		sub	esp, 0Ch
		push	offset asc_80057D9 ; "-"
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotFollowSB ; "cannot follow	%s by name"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80047EB:				; CODE XREF: main+1B6j	main+1C0j
		movzx	eax, ds:forever
		test	al, al
		jz	short loc_800482D
		cmp	[ebp+found_hyphen], 0
		jz	short loc_800482D
		sub	esp, 0Ch
		push	0		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_800482D
		sub	esp, 0Ch
		push	offset aWarningFollowi ; "warning: following standard input indef"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800482D:				; CODE XREF: main+1FBj	main+201j ...
		sub	esp, 8
		push	4Ch
		push	[ebp+n_files]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+F], eax
		mov	[ebp+i], 0
		jmp	short loc_800486B
; ---------------------------------------------------------------------------

loc_8004849:				; CODE XREF: main+278j
		mov	eax, [ebp+i]
		imul	edx, eax, 4Ch
		mov	eax, [ebp+F]
		add	edx, eax
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+i], 1

loc_800486B:				; CODE XREF: main+24Ej
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8004849
		mov	eax, [ebp+header_mode]
		cmp	eax, 1
		jz	short loc_8004888
		mov	eax, [ebp+header_mode]
		test	eax, eax
		jnz	short loc_800488F
		cmp	[ebp+n_files], 1
		jbe	short loc_800488F

loc_8004888:				; CODE XREF: main+280j
		mov	ds:print_headers, 1

loc_800488F:				; CODE XREF: main+287j	main+28Dj
		mov	[ebp+i], 0
		jmp	short loc_80048CC
; ---------------------------------------------------------------------------

loc_8004898:				; CODE XREF: main+2D9j
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		mov	ecx, [ebp+i]
		imul	ebx, ecx, 4Ch
		mov	ecx, [ebp+F]
		add	ecx, ebx
		sub	esp, 4
		push	edx
		push	eax		; n_units
		push	ecx		; f
		call	tail_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	[ebp+i], 1

loc_80048CC:				; CODE XREF: main+29Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jb	short loc_8004898
		movzx	eax, ds:forever
		test	al, al
		jz	loc_80049F4
		sub	esp, 8
		push	[ebp+n_files]	; n_files
		push	[ebp+F]		; f
		call	ignore_fifo_and_pipe
		add	esp, 10h
		test	eax, eax
		jz	loc_80049F4
		sub	esp, 8
		push	[ebp+n_files]	; n_files
		push	[ebp+F]		; f
		call	tailable_stdin
		add	esp, 10h
		test	al, al
		jnz	short loc_8004926
		sub	esp, 8
		push	[ebp+n_files]	; n_files
		push	[ebp+F]		; f
		call	any_remote_file
		add	esp, 10h
		test	al, al
		jz	short loc_800492D

loc_8004926:				; CODE XREF: main+316j
		mov	ds:disable_inotify, 1

loc_800492D:				; CODE XREF: main+32Bj
		movzx	eax, ds:disable_inotify
		xor	eax, 1
		test	al, al
		jz	loc_80049DC
		call	inotify_init
		mov	[ebp+wd], eax
		cmp	[ebp+wd], 0
		jns	short loc_8004977
		sub	esp, 0Ch
		push	offset aInotifyCannotB ; "inotify cannot be used, reverting to po"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_80049DC
; ---------------------------------------------------------------------------

loc_8004977:				; CODE XREF: main+352j
		mov	eax, ds:stdout
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80049B4
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80049B4:				; CODE XREF: main+391j
		fld	[ebp+sleep_interval]
		sub	esp, 0Ch
		lea	esp, [esp-8]
		fstp	qword ptr [esp]	; sleep_interval
		push	[ebp+n_files]	; n_files
		push	[ebp+F]		; f
		push	[ebp+wd]	; wd
		call	tail_forever_inotify
		add	esp, 20h
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80049DC:				; CODE XREF: main+340j	main+37Cj
		fld	[ebp+sleep_interval]
		lea	esp, [esp-8]
		fstp	qword ptr [esp]	; sleep_interval
		push	[ebp+n_files]	; n_files
		push	[ebp+F]		; f
		call	tail_forever
		add	esp, 10h

loc_80049F4:				; CODE XREF: main+2E4j	main+2FDj
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_8004A2A
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_8004A2A
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_80057D9 ; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8004A2A:				; CODE XREF: main+404j	main+415j
		cmp	[ebp+ok], 0
		jz	short loc_8004A37
		mov	eax, 0
		jmp	short loc_8004A3C
; ---------------------------------------------------------------------------

loc_8004A37:				; CODE XREF: main+435j
		mov	eax, 1

loc_8004A3C:				; CODE XREF: main+43Cj
		sub	esp, 0Ch
		push	eax		; status

loc_8004A40:				; DATA XREF: .eh_frame:08005E48o
					; .eh_frame:08005E68o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 8004A48h
; Follow_mode follow_mode
follow_mode	dd Follow_descriptor	; DATA XREF: tail_forever+3Ar
					; tail_forever:loc_8002203r ...
		align 10h
; uintmax_t max_n_unchanged_stats_between_opens
max_n_unchanged_stats_between_opens dq 5 ; DATA	XREF: tail_forever+3ADr
					; parse_options+240o ...
; Function-local static	variable
; _Bool	first_file_5431
first_file_5431	db 1			; DATA XREF: write_header+6r
					; write_header+31w
		align 4
; Function-local static	variable
; char *dummy_stdin_5843
dummy_stdin_5843 dd offset asc_80057D9	; DATA XREF: main+168o
_data		ends			; "-"

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8004A60h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; _Bool	reopen_inaccessible_files
reopen_inaccessible_files db ?		; DATA XREF: recheck:loc_800198Br
					; tail_forever+671r ...
; _Bool	count_lines
count_lines	db ?			; DATA XREF: tail+22r
					; parse_obsolete_option+1E7w ...
; _Bool	forever
forever		db ?			; DATA XREF: tail_file+B7r
					; tail_file+1BCr ...
; _Bool	from_start
from_start	db ?			; DATA XREF: tail_bytes:loc_800349Br
					; tail_lines:loc_8003802r ...
; _Bool	print_headers
print_headers	db ?			; DATA XREF: tail_forever+569r
					; check_fspec+1ACr ...
		align 4
; pid_t	pid
pid		dd ?			; DATA XREF: tail_forever+31r
					; tail_forever+717r ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: tail_file+58w main+9Bw ...
; _Bool	presume_input_pipe
presume_input_pipe db ?			; DATA XREF: tail_bytes+A2r
					; tail_bytes:loc_800359Er ...
; _Bool	disable_inotify
disable_inotify	db ?			; DATA XREF: recheck:loc_8001B14r
					; parse_options:loc_80042C8w ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8004A80h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+6Eo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; parse_options+3A8o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aDescriptor	db 'descriptor',0       ; DATA XREF: .rodata:follow_mode_stringo
aName		db 'name',0             ; DATA XREF: .rodata:follow_mode_stringo
		align 4
; const	char *const follow_mode_string[3]
follow_mode_string dd offset aDescriptor, offset aName,	0 ; DATA XREF: parse_options+203o
					; "descriptor"
; const	Follow_mode follow_mode_map[2]
follow_mode_map	dd Follow_descriptor, Follow_name ; DATA XREF: parse_options+1FEo
					; parse_options+216r
		public inotify_wd_mask
; const	uint32_t inotify_wd_mask
inotify_wd_mask	dd 0C06h
aBytes		db 'bytes',0            ; DATA XREF: .rodata:long_optionso
aFollow_0	db 'follow',0           ; DATA XREF: .rodata:long_optionso
aLines		db 'lines',0            ; DATA XREF: .rodata:long_optionso
aMaxUnchangedSt	db 'max-unchanged-stats',0 ; DATA XREF: .rodata:long_optionso
aDisableInotify	db '-disable-inotify',0 ; DATA XREF: .rodata:long_optionso
aPid		db 'pid',0              ; DATA XREF: .rodata:long_optionso
aPresumeInputPi	db '-presume-input-pipe',0 ; DATA XREF: .rodata:long_optionso
aQuiet		db 'quiet',0            ; DATA XREF: .rodata:long_optionso
aRetry		db 'retry',0            ; DATA XREF: .rodata:long_optionso
aSilent		db 'silent',0           ; DATA XREF: .rodata:long_optionso
aSleepInterval	db 'sleep-interval',0   ; DATA XREF: .rodata:long_optionso
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[15]
long_options	option <offset aBytes, 1, 0, 63h> ; DATA XREF: parse_options+3F4o
		option <offset aFollow_0, 2, 0,	84h> ; "bytes"
		option <offset aLines, 1, 0, 6Eh>
		option <offset aMaxUnchangedSt,	1, 0, 81h>
		option <offset aDisableInotify,	0, 0, 85h>
		option <offset aPid, 1,	0, 82h>
		option <offset aPresumeInputPi,	0, 0, 83h>
		option <offset aQuiet, 0, 0, 71h>
		option <offset aRetry, 0, 0, 80h>
		option <offset aSilent,	0, 0, 71h>
		option <offset aSleepInterval, 1, 0, 73h>
		option <offset aVerbose, 0, 0, 76h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aPrintTheLastDL[]
aPrintTheLastDL	db 'Print the last %d lines of each FILE to standard output.',0Ah
					; DATA XREF: usage+63o
		db 'With more than one FILE, precede each with a header giving the fi'
		db 'le name.',0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+87o
		db 'ns too.',0Ah,0
		align 4
; char aCBytesKOutputT[]
aCBytesKOutputT	db '  -c, --bytes=K            output the last K bytes; alternatively'
					; DATA XREF: usage+AAo
		db ', use -c +K',0Ah
		db '                           to output bytes starting with the Kth '
		db 'of each file',0Ah,0
; char aFFollowNameDes[]
aFFollowNameDes	db '  -f, --follow[={name|descriptor}]',0Ah ; DATA XREF: usage+CDo
		db '                           output appended data as the file grows'
		db ';',0Ah
		db '                           -f, --follow, and --follow=descriptor '
		db 'are',0Ah
		db '                           equivalent',0Ah
		db '  -F                       same as --follow=name --retry',0Ah,0
		align 4
; char aNLinesKOutputT[]
aNLinesKOutputT	db '  -n, --lines=K            output the last K lines, instead of th'
					; DATA XREF: usage+EAo
		db 'e last %d;',0Ah
		db '                           or use -n +K to output lines starting '
		db 'with the Kth',0Ah
		db '      --max-unchanged-stats=N',0Ah
		db '                           with --follow=name, reopen a FILE whic'
		db 'h has not',0Ah
		db '                           changed size after N (default %d) iter'
		db 'ations',0Ah
		db '                           to see if it has been unlinked or rena'
		db 'med',0Ah
		db '                           (this is the usual case of rotated log'
		db ' files)',0Ah,0
		align 4
; char aPidPidWithFTer[]
aPidPidWithFTer	db '      --pid=PID            with -f, terminate after process ID, P'
					; DATA XREF: usage+110o
		db 'ID dies',0Ah
		db '  -q, --quiet, --silent    never output headers giving file names'
		db 0Ah
		db '      --retry              keep trying to open a file even when i'
		db 't is or',0Ah
		db '                             becomes inaccessible; useful when fo'
		db 'llowing by',0Ah
		db '                             name, i.e., with --follow=name',0Ah,0
		align 4
; char aSSleepInterval[]
aSSleepInterval	db '  -s, --sleep-interval=N   with -f, sleep for approximately N sec'
					; DATA XREF: usage+133o
		db 'onds',0Ah
		db '                             (default 1.0) between iterations',0Ah
		db '  -v, --verbose            always output headers giving file name'
		db 's',0Ah,0
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+156o
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+179o
		align 4
; char aIfTheFirstChar[]
aIfTheFirstChar	db 0Ah			; DATA XREF: usage+19Co
		db 'If the first character of K (the number of bytes or lines) is a `'
		db '+',27h,',',0Ah
		db 'print beginning with the Kth item from the start of each file, ot'
		db 'herwise,',0Ah
		db 'print the last K items in the file.  K may have a multiplier suff'
		db 'ix:',0Ah
		db 'b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,',0Ah
		db 'GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.'
		db 0Ah
		db 0Ah,0
; char aWithFollowFTai[]
aWithFollowFTai	db 'With --follow (-f), tail defaults to following the file descripto'
					; DATA XREF: usage+1BFo
		db 'r, which',0Ah
		db 'means that even if a tail',27h,'ed file is renamed, tail will contin'
		db 'ue to track',0Ah
		db 'its end.  This default behavior is not desirable when you really '
		db 'want to',0Ah
		db 'track the actual name of the file, not the file descriptor (e.g.,'
		db ' log',0Ah
		db 'rotation).  Use --follow=name in that case.  That causes tail to '
		db 'track the',0Ah
		db 'named file in a way that accommodates renaming, removal and creat'
		db 'ion.',0Ah,0
; char asc_80057D9[]
asc_80057D9	db '-',0                ; DATA XREF: pretty_name+Eo
					; recheck+2Bo ...
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: pretty_name+23o
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: xwrite_stdout+2Ao
					; tail_forever+6D3o ...
; char aClosingSFdD[]
aClosingSFdD	db 'closing %s (fd=%d)',0 ; DATA XREF: close_fd+28o
; char locale
locale		db 0			; DATA XREF: write_header+11o
					; parse_options+23Bo ...
asc_800580A	db 0Ah,0		; DATA XREF: write_header:loc_8000555o
; char format[]
format		db '%s==> %s <==',0Ah,0 ; DATA XREF: write_header+24o
; char aErrorReadingS[]
aErrorReadingS	db 'error reading %s',0 ; DATA XREF: dump_remainder+DAo
					; file_lines+1B2o ...
; char aSCannotSeekToO[]
aSCannotSeekToO	db '%s: cannot seek to offset %s',0 ; DATA XREF: xlseek+8Fo
; char aSCannotSeekToR[]
aSCannotSeekToR	db '%s: cannot seek to relative offset %s',0 ; DATA XREF: xlseek+BFo
		align 10h
; char aSCannotSeekToE[]
aSCannotSeekToE	db '%s: cannot seek to end-relative offset %s',0 ; DATA XREF: xlseek+EFo
; char file[]
file		db 'tail.c',0           ; DATA XREF: pipe_lines+38Do
					; recheck+A4o ...
; char assertion[]
assertion	db 'beg',0              ; DATA XREF: pipe_lines+392o
		align 4
; char aCannotDetermin[]
aCannotDetermin	db 'cannot determine location of %s. reverting to polling',0
					; DATA XREF: fremote+4Bo
; char aValid_file_spe[]
aValid_file_spe	db 'valid_file_spec (f)',0 ; DATA XREF: recheck+A9o
; char aSHasBecomeInac[]
aSHasBecomeInac	db '%s has become inaccessible',0 ; DATA XREF: recheck+144o
; char aS[]
aS		db '%s',0               ; DATA XREF: recheck+193o
					; tail_forever+2D5o
; char aSHasBeenReplac[]
aSHasBeenReplac	db '%s has been replaced with an untailable file; giving up on this n'
					; DATA XREF: recheck+215o
		db 'ame',0
		align 4
; char aSHasBeenRepl_0[]
aSHasBeenRepl_0	db '%s has been replaced with a remote file. giving up on this name',0
					; DATA XREF: recheck+298o
; char aFFd1[]
aFFd1		db 'f->fd == -1',0      ; DATA XREF: recheck+358o
; char aSHasBecomeAcce[]
aSHasBecomeAcce	db '%s has become accessible',0 ; DATA XREF: recheck+381o
		align 10h
; char aSHasAppearedFo[]
aSHasAppearedFo	db '%s has appeared;  following end of new file',0 ; DATA XREF: recheck+409o
; char aSHasBeenRepl_1[]
aSHasBeenRepl_1	db '%s has been replaced;  following end of new file',0
					; DATA XREF: recheck+46Bo
		align 10h
; char aSCannotChangeN[]
aSCannotChangeN	db '%s: cannot change nonblocking mode',0 ; DATA XREF: tail_forever+218o
; char aSFileTruncated[]
aSFileTruncated	db '%s: file truncated',0 ; DATA XREF: tail_forever+4EBo
					; check_fspec+D3o
; char aNoFilesRemaini[]
aNoFilesRemaini	db 'no files remaining',0 ; DATA XREF: tail_forever+682o
; char aCannotReadReal[]
aCannotReadReal	db 'cannot read realtime clock',0 ; DATA XREF: tail_forever+790o
a_		db '.',0                ; DATA XREF: tail_forever_inotify:loc_8002B7Fo
		align 4
; char aCannotWatchPar[]
aCannotWatchPar	db 'cannot watch parent directory of %s',0
					; DATA XREF: tail_forever_inotify+28Co
; char aCannotWatchS[]
aCannotWatchS	db 'cannot watch %s',0  ; DATA XREF: tail_forever_inotify+34Co
					; tail_forever_inotify+84Fo
; char aErrorMonitorin[]
aErrorMonitorin	db 'error monitoring inotify event',0 ; DATA XREF: tail_forever_inotify+624o
; char aErrorReadingIn[]
aErrorReadingIn	db 'error reading inotify event',0 ; DATA XREF: tail_forever_inotify+6FDo
; char aCannotFstatS[]
aCannotFstatS	db 'cannot fstat %s',0  ; DATA XREF: tail_bytes+66o
					; tail_lines+66o
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: tail_file+133o
		align 4
; char aSCannotFollowE[]
aSCannotFollowE	db '%s: cannot follow end of this type of file; giving up on this nam'
					; DATA XREF: tail_file+2A1o
		db 'e',0
; char asc_8005B67[]
asc_8005B67	db '--',0               ; DATA XREF: parse_obsolete_option+5Ao
aB		db 'b',0                ; DATA XREF: parse_obsolete_option+188o
; char aNumberInSIsToo[]
aNumberInSIsToo	db 'number in %s is too large',0 ; DATA XREF: parse_obsolete_option+1BFo
aBkkmmgtpezy0	db 'bkKmMGTPEZY0',0     ; DATA XREF: parse_options+160o
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of lines',0 ; DATA XREF: parse_options+18Bo
; char aInvalidNumbe_0[]
aInvalidNumbe_0	db 'invalid number of bytes',0 ; DATA XREF: parse_options+19Fo
; char aSS_0[]
aSS_0		db '%s: %s',0           ; DATA XREF: parse_options+1B8o
aFollow		db '--follow',0         ; DATA XREF: parse_options+209o
		align 4
; char aSInvalidMaximu[]
aSInvalidMaximu	db '%s: invalid maximum number of unchanged stats between opens',0
					; DATA XREF: parse_options+263o
; char aSInvalidPid[]
aSInvalidPid	db '%s: invalid PID',0  ; DATA XREF: parse_options+2C6o
; char aSInvalidNumber[]
aSInvalidNumber	db '%s: invalid number of seconds',0 ; DATA XREF: parse_options+346o
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: parse_options+393o
aIanLanceTaylor	db 'Ian Lance Taylor',0 ; DATA XREF: parse_options+398o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: parse_options+39Do
aPaulRubin	db 'Paul Rubin',0       ; DATA XREF: parse_options+3A2o
aTail		db 'tail',0             ; DATA XREF: parse_options+3ADo
; char aOptionUsedInIn[]
aOptionUsedInIn	db 'option used in invalid context -- %c',0 ; DATA XREF: parse_options+3C8o
; char shortopts[]
shortopts	db 'c:n:fFqs:v0123456789',0 ; DATA XREF: parse_options+3F9o
		align 4
; char aWarningRetryIs[]
aWarningRetryIs	db 'warning: --retry is useful mainly when following by name',0
					; DATA XREF: parse_options+431o
		align 4
; char aWarningPidIgno[]
aWarningPidIgno	db 'warning: PID ignored; --pid=PID is useful only when following',0
					; DATA XREF: parse_options+468o
		align 4
; char aWarningPidPidI[]
aWarningPidPidI	db 'warning: --pid=PID is not supported on this system',0
					; DATA XREF: parse_options+4B6o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+69o
; char aCannotFollowSB[]
aCannotFollowSB	db 'cannot follow %s by name',0 ; DATA XREF: main+1D7o
; char aWarningFollowi[]
aWarningFollowi	db 'warning: following standard input indefinitely is ineffective',0
					; DATA XREF: main+217o
		align 4
; char aInotifyCannotB[]
aInotifyCannotB	db 'inotify cannot be used, reverting to polling',0 ; DATA XREF: main+357o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5508[11]
__PRETTY_FUNCTION___5508 db 'pipe_lines',0 ; DATA XREF: pipe_lines+383o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5607[8]
__PRETTY_FUNCTION___5607 db 'recheck',0 ; DATA XREF: recheck+9Ao recheck+349o
		align 10h
dbl_8005E20	dq 1000000.0		; DATA XREF: tail_forever_inotify+555r
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8005E28h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8004A40-800A888h
		dd 46h,	80E4100h, 0D420285h, 0C5420205h, 4040Ch, 20h, 3Ch
		dd offset loc_8004A40-800A862h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8004A40-800A76Ah
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 18h, 80h
		dd offset loc_8004A40-800A76Fh
		dd 1E9h, 80E4100h, 0D420285h, 3834405h,	1Ch, 9Ch
		dd offset loc_8004A40-800A5A2h
		dd 29h,	80E4100h, 0D420285h, 0CC56505h,	404h, 1Ch, 0BCh
		dd offset loc_8004A40-800A599h
		dd 39h,	80E4100h, 0D420285h, 0CC57505h,	404h, 20h, 0DCh
		dd offset loc_8004A40-800A580h
		dd 55h,	80E4100h, 0D420285h, 3834405h, 0C3C54D02h, 4040Ch
		dd 20h,	100h
		dd offset loc_8004A40-800A54Fh
		dd 0C7h, 80E4100h, 0D420285h, 3834405h,	0C3C5BF02h, 4040Ch
		dd 20h,	124h
		dd offset loc_8004A40-800A4ACh
		dd 59h,	80E4100h, 0D420285h, 3834405h, 0C3C55102h, 4040Ch
		dd 1Ch,	148h
		dd offset loc_8004A40-800A477h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 28h, 168h
		dd offset loc_8004A40-800A45Ch
		dd 1CAh, 80E4100h, 0D420285h, 3864805h,	0BC030483h, 0C641C301h
		dd 40CC541h, 4,	20h, 194h
		dd offset loc_8004A40-800A2BEh
		dd 135h, 80E4100h, 0D420285h, 3834405h,	0C5012D03h, 4040CC3h
		dd 2Ch,	1B8h
		dd offset loc_8004A40-800A1ADh
		dd 4D4h, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C304C403h
		dd 0C741C641h, 40CC541h, 4, 28h, 1E8h
		dd offset loc_8004A40-8009D09h
		dd 435h, 80E4100h, 0D420285h, 3864505h,	2A030483h, 0C641C304h
		dd 40CC541h, 4,	28h, 214h
		dd offset loc_8004A40-8009900h
		dd 301h, 80E4100h, 0D420285h, 3864505h,	0F6030483h, 0C641C302h
		dd 40CC541h, 4,	28h, 240h
		dd offset loc_8004A40-800962Bh
		dd 17Eh, 80E4100h, 0D420285h, 3864805h,	70030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 26Ch
		dd offset loc_8004A40-80094D9h
		dd 1CAh, 80E4100h, 0D420285h, 3864805h,	0BC030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 298h
		dd offset loc_8004A40-800933Bh
		dd 10Fh, 80E4100h, 0D420285h, 3864505h,	4030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 2C4h
		dd offset loc_8004A40-8009258h
		dd 523h, 80E4100h, 0D420285h, 3864505h,	18030483h, 0C641C305h
		dd 40CC541h, 4,	1Ch, 2F0h
		dd offset loc_8004A40-8008D61h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 28h, 310h
		dd offset loc_8004A40-8008D46h
		dd 7D4h, 80E4100h, 0D420285h, 3864805h,	0C6030483h, 0C641C307h
		dd 40CC541h, 4,	1Ch, 33Ch
		dd offset loc_8004A40-800859Eh
		dd 4Eh,	80E4100h, 0D420285h, 0C54A0205h, 4040Ch, 1Ch, 35Ch
		dd offset loc_8004A40-8008570h
		dd 61h,	80E4100h, 0D420285h, 0C55D0205h, 4040Ch, 1Ch, 37Ch
		dd offset loc_8004A40-800852Fh
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 39Ch
		dd offset loc_8004A40-8008531h
		dd 25h,	80E4100h, 0D420285h, 0CC56105h,	404h, 28h, 3BCh
		dd offset loc_8004A40-800852Ch
		dd 273h, 80E4100h, 0D420285h, 3864805h,	65030483h, 0C641C302h
		dd 40CC541h, 4,	2Ch, 3E8h
		dd offset loc_8004A40-80082E5h
		dd 0A99h, 80E4100h, 0D420285h, 3874905h, 5830486h, 0C30A8903h
		dd 0C741C641h, 40CC541h, 4, 28h, 418h
		dd offset loc_8004A40-800787Ch
		dd 367h, 80E4100h, 0D420285h, 3864805h,	59030483h, 0C641C303h
		dd 40CC541h, 4,	28h, 444h
		dd offset loc_8004A40-8007541h
		dd 27Ch, 80E4100h, 0D420285h, 3864805h,	6E030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 470h
		dd offset loc_8004A40-80072F1h
		dd 65h,	80E4100h, 0D420285h, 0C5610205h, 4040Ch, 28h, 490h
		dd offset loc_8004A40-80072ACh
		dd 3F6h, 80E4100h, 0D420285h, 3864805h,	0E8030483h, 0C641C303h
		dd 40CC541h, 4,	20h, 4BCh
		dd offset loc_8004A40-8006EE2h
		dd 1FFh, 80E4100h, 0D420285h, 3834405h,	0C501F703h, 4040CC3h
		dd 20h,	4E0h
		dd offset loc_8004A40-8006D07h
		dd 4F4h, 80E4100h, 0D420285h, 3834405h,	0C504EC03h, 4040CC3h
		dd 1Ch,	504h
		dd offset loc_8004A40-8006837h
		dd 0C0h, 80E4100h, 0D420285h, 0C5BC0205h, 4040Ch, 24h
		dd 524h
		dd offset loc_8004A40-8006797h
		dd 44Ch, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+7Er ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+99p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+5Ep
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1E4p xlseek+126p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: pretty_name+14p
					; recheck+31p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	xwrite_stdout+1Bp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: xwrite_stdout+39p
					; close_fd+37p	...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: xwrite_stdout+47p
					; close_fd+4Bp	...
		extrn __stack_chk_fail:near ; CODE XREF: record_open_fd+BDp
					; dump_remainder+1BEp ...
; int close(int	fd)
		extrn close:near	; CODE XREF: close_fd+19p
					; tail_file+385p ...
		extrn safe_read:near	; CODE XREF: dump_remainder+9Dp
					; file_lines+185p ...
		extrn quote:near	; CODE XREF: dump_remainder+CDp
					; file_lines+1A5p ...
		extrn lseek64:near	; CODE XREF: xlseek+30p
					; tail_lines+155p ...
		extrn offtostr:near	; CODE XREF: xlseek+6Cp
; void abort(void)
		extrn abort:near	; CODE XREF: xlseek:loc_800085Ep
		extrn memrchr:near	; CODE XREF: file_lines+254p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: pipe_lines+27p
					; pipe_lines+6Cp ...
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: pipe_lines+126p
					; pipe_lines+372p ...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: pipe_lines+17Ep
					; pipe_bytes+10Fp
; void free(void *ptr)
		extrn free:near		; CODE XREF: pipe_lines+242p
					; pipe_lines+416p ...
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: pipe_lines+397p
					; recheck+AEp ...
		extrn fstatfs64:near	; CODE XREF: fremote+27p
		extrn open_safer:near	; CODE XREF: recheck+7Dp tail_file+76p
		extrn fstat64:near	; CODE XREF: recheck+ECp
					; tail_forever+288p ...
		extrn rpl_fcntl:near	; CODE XREF: tail_forever+185p
					; tail_forever+1DCp
; int fflush_unlocked(FILE *stream)
		extrn fflush_unlocked:near ; CODE XREF:	tail_forever+6C4p
					; check_fspec+224p ...
; int kill(__pid_t pid,	int sig)
		extrn kill:near		; CODE XREF: tail_forever+72Bp
					; tail_forever_inotify+4AFp ...
		extrn xnanosleep:near	; CODE XREF: tail_forever+77Dp
		extrn hash_initialize:near ; CODE XREF:	tail_forever_inotify+7Cp
		extrn xalloc_die:near	; CODE XREF: tail_forever_inotify+93p
					; tail_forever_inotify+398p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: tail_forever_inotify+DEp
		extrn dir_len:near	; CODE XREF: tail_forever_inotify+143p
; int inotify_add_watch(int fd,	const char *name, uint32_t mask)
		extrn inotify_add_watch:near ; CODE XREF: tail_forever_inotify+221p
					; tail_forever_inotify+2E6p ...
		extrn hash_insert:near	; CODE XREF: tail_forever_inotify+38Cp
					; tail_forever_inotify+94Ap
; int select(int nfds, fd_set *readfds,	fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)
		extrn select:near	; CODE XREF: tail_forever_inotify+5FDp
; void *xrealloc(void *, size_t)
		extrn xrealloc:near	; CODE XREF: tail_forever_inotify+6D5p
		extrn hash_delete:near	; CODE XREF: tail_forever_inotify+89Dp
					; tail_forever_inotify+8C3p ...
		extrn hash_lookup:near	; CODE XREF: tail_forever_inotify+998p
; int inotify_rm_watch(int fd, uint32_t	wd)
		extrn inotify_rm_watch:near ; CODE XREF: tail_forever_inotify+A03p
		extrn posix2_version:near ; CODE XREF: parse_obsolete_option:loc_8003EBCp
		extrn xstrtoumax:near	; CODE XREF: parse_obsolete_option+197p
					; parse_options+16Dp ...
; char *optarg
		extrn optarg:dword	; DATA XREF: parse_options+12Ar
					; parse_options:loc_8004184r ...
		extrn argmatch_die:dword ; DATA	XREF: parse_options:loc_8004232r
		extrn __xargmatch_internal:near	; CODE XREF: parse_options+20Ep
		extrn xstrtoul:near	; CODE XREF: parse_options+2A5p
		extrn c_strtod		; DATA XREF: parse_options+30Do
		extrn xstrtod:near	; CODE XREF: parse_options+319p
		extrn Version:dword	; DATA XREF: parse_options:loc_80043C8r
		extrn version_etc:near	; CODE XREF: parse_options+3B3p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: parse_options+404p
		extrn set_program_name:near ; CODE XREF: main+4Cp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+73p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+83p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+8Eo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+93p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_800472Dr
					; main+13Dr ...
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: main+208p
		extrn xnmalloc:near	; CODE XREF: main+23Cp
; int inotify_init(void)
		extrn inotify_init:near	; CODE XREF: main+346p


		end
