;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	29EE41357E980A680AC3165F00589438
; Input	CRC32 :	BF7F3132

; File Name   :	D:\coreutils-o\sum.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'sum.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+ECp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+D0p main+112p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000159
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800020D
; ---------------------------------------------------------------------------

loc_8000159:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintChecksumA ; "Print	checksum and block counts for eac"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithNoFileOrWh ; "\nWith no FILE, or when FILE is -, read"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800020D:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	bsd_sum_file(const char	*file, int print_name)
bsd_sum_file	proc near		; DATA XREF: main+14o
					; main:loc_80007B3o

file		= dword	ptr -2BCh
is_stdin	= byte ptr -2ADh
fp		= dword	ptr -2ACh
checksum	= dword	ptr -2A8h
ch_0		= dword	ptr -2A4h
total_bytes	= qword	ptr -2A0h
hbuf		= byte ptr -298h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
print_name	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 2C8h
		mov	eax, [ebp+arg_0]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+checksum],	0
		mov	dword ptr [ebp+total_bytes], 0
		mov	dword ptr [ebp+total_bytes+4], 0
		sub	esp, 8
		push	offset asc_8000C58 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_8000294
		mov	eax, ds:stdin
		mov	[ebp+fp], eax
		mov	ds:have_read_stdin, 1
		jmp	loc_8000322
; ---------------------------------------------------------------------------

loc_8000294:				; CODE XREF: bsd_sum_file+63j
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+file]
		call	fopen64
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jnz	short loc_8000322
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000451
; ---------------------------------------------------------------------------

loc_80002E0:				; CODE XREF: bsd_sum_file+128j
		add	dword ptr [ebp+total_bytes], 1
		adc	dword ptr [ebp+total_bytes+4], 0
		mov	eax, [ebp+checksum]
		sar	eax, 1
		mov	edx, eax
		mov	eax, [ebp+checksum]
		shl	eax, 0Fh
		movzx	eax, ax
		add	eax, edx
		mov	[ebp+checksum],	eax
		mov	eax, [ebp+ch_0]
		add	[ebp+checksum],	eax
		and	[ebp+checksum],	0FFFFh

loc_8000322:				; CODE XREF: bsd_sum_file+77j
					; bsd_sum_file+9Fj
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+ch_0], eax
		cmp	[ebp+ch_0], 0FFFFFFFFh
		jnz	short loc_80002E0
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_800039D
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8000393
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h

loc_8000393:				; CODE XREF: bsd_sum_file+168j
		mov	eax, 0
		jmp	loc_8000451
; ---------------------------------------------------------------------------

loc_800039D:				; CODE XREF: bsd_sum_file+13Dj
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_80003E4
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_80003E4
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8000451
; ---------------------------------------------------------------------------

loc_80003E4:				; CODE XREF: bsd_sum_file+191j
					; bsd_sum_file+1A6j
		push	0
		push	400h
		push	0
		push	1
		push	0
		lea	eax, [ebp+hbuf]
		push	eax
		push	dword ptr [ebp+total_bytes+4]
		push	dword ptr [ebp+total_bytes]
		call	human_readable
		add	esp, 20h
		sub	esp, 4
		push	eax
		push	[ebp+checksum]
		push	offset a05d5s	; "%05d	%5s"
		call	printf
		add	esp, 10h
		cmp	[ebp+print_name], 1
		jle	short loc_800043F
		sub	esp, 8
		push	[ebp+file]
		push	offset aS_0	; " %s"
		call	printf
		add	esp, 10h

loc_800043F:				; CODE XREF: bsd_sum_file+20Fj
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, 1

loc_8000451:				; CODE XREF: bsd_sum_file+C3j
					; bsd_sum_file+180j ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8000462
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000462:				; CODE XREF: bsd_sum_file+243j
		leave
		retn
bsd_sum_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	sysv_sum_file(const char *file,	int print_name)
sysv_sum_file	proc near		; DATA XREF: main:loc_80007BCo

file		= dword	ptr -22CCh
is_stdin	= byte ptr -22B9h
fd		= dword	ptr -22B8h
s		= dword	ptr -22B4h
i		= dword	ptr -22B0h
bytes_read	= dword	ptr -22ACh
r		= dword	ptr -22A8h
checksum	= dword	ptr -22A4h
total_bytes	= qword	ptr -22A0h
hbuf		= byte ptr -2298h
buf		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
print_name	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 22D8h
		mov	eax, [ebp+arg_0]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	dword ptr [ebp+total_bytes], 0
		mov	dword ptr [ebp+total_bytes+4], 0
		mov	[ebp+s], 0
		sub	esp, 8
		push	offset asc_8000C58 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_80004DC
		mov	[ebp+fd], 0
		mov	ds:have_read_stdin, 1
		jmp	short loc_8000525
; ---------------------------------------------------------------------------

loc_80004DC:				; CODE XREF: sysv_sum_file+63j
		sub	esp, 8
		push	0
		push	[ebp+file]
		call	open64
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0FFFFFFFFh
		jnz	short loc_8000525
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80006E7
; ---------------------------------------------------------------------------

loc_8000525:				; CODE XREF: sysv_sum_file+76j
					; sysv_sum_file+98j ...
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jz	loc_80005FB
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_80005A4
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_800059A
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h

loc_800059A:				; CODE XREF: sysv_sum_file+123j
		mov	eax, 0
		jmp	loc_80006E7
; ---------------------------------------------------------------------------

loc_80005A4:				; CODE XREF: sysv_sum_file+F8j
		mov	[ebp+i], 0
		jmp	short loc_80005D1
; ---------------------------------------------------------------------------

loc_80005B0:				; CODE XREF: sysv_sum_file+179j
		lea	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		add	[ebp+s], eax
		add	[ebp+i], 1

loc_80005D1:				; CODE XREF: sysv_sum_file+14Aj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+bytes_read]
		jb	short loc_80005B0
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+total_bytes], eax
		adc	dword ptr [ebp+total_bytes+4], edx
		jmp	loc_8000525
; ---------------------------------------------------------------------------

loc_80005FB:				; CODE XREF: sysv_sum_file+EBj
		nop
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8000646
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000646
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80006E7
; ---------------------------------------------------------------------------

loc_8000646:				; CODE XREF: sysv_sum_file+1A4j
					; sysv_sum_file+1B9j
		mov	eax, [ebp+s]
		movzx	eax, ax
		mov	edx, [ebp+s]
		shr	edx, 10h
		add	eax, edx
		mov	[ebp+r], eax
		mov	eax, [ebp+r]
		movzx	eax, ax
		mov	edx, [ebp+r]
		sar	edx, 10h
		add	eax, edx
		mov	[ebp+checksum],	eax
		push	0
		push	200h
		push	0
		push	1
		push	0
		lea	eax, [ebp+hbuf]
		push	eax
		push	dword ptr [ebp+total_bytes+4]
		push	dword ptr [ebp+total_bytes]
		call	human_readable
		add	esp, 20h
		sub	esp, 4
		push	eax
		push	[ebp+checksum]
		push	offset aDS	; "%d %s"
		call	printf
		add	esp, 10h
		cmp	[ebp+print_name], 0
		jz	short loc_80006D5
		sub	esp, 8
		push	[ebp+file]
		push	offset aS_0	; " %s"
		call	printf
		add	esp, 10h

loc_80006D5:				; CODE XREF: sysv_sum_file+259j
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, 1

loc_80006E7:				; CODE XREF: sysv_sum_file+BCj
					; sysv_sum_file+13Bj ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80006F8
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80006F8:				; CODE XREF: sysv_sum_file+28Dj
		leave
		retn
sysv_sum_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ok		= byte ptr -15h
sum_func	= dword	ptr -14h
optc		= dword	ptr -10h
files_given	= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	[ebp+sum_func],	offset bsd_sum_file
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, ds:stdout
		push	0		; n
		push	1		; modes
		push	0		; buf
		push	eax		; stream
		call	setvbuf
		add	esp, 10h
		mov	ds:have_read_stdin, 0
		jmp	loc_8000811
; ---------------------------------------------------------------------------

loc_800078D:				; CODE XREF: main+13Aj
		mov	eax, [ebp+optc]
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_80007C5
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_80007A7
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_80007CF
		jmp	short loc_8000807
; ---------------------------------------------------------------------------

loc_80007A7:				; CODE XREF: main+A2j
		cmp	eax, 72h
		jz	short loc_80007B3
		cmp	eax, 73h
		jz	short loc_80007BC
		jmp	short loc_8000807
; ---------------------------------------------------------------------------

loc_80007B3:				; CODE XREF: main+B0j
		mov	[ebp+sum_func],	offset bsd_sum_file
		jmp	short loc_8000811
; ---------------------------------------------------------------------------

loc_80007BC:				; CODE XREF: main+B5j
		mov	[ebp+sum_func],	offset sysv_sum_file
		jmp	short loc_8000811
; ---------------------------------------------------------------------------

loc_80007C5:				; CODE XREF: main+9Bj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80007CF:				; CODE XREF: main+A9j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aKayvanAghaiepo ; "Kayvan Aghaiepour"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aSum	; "sum"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000807:				; CODE XREF: main+ABj main+B7j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000811:				; CODE XREF: main+8Ej main+C0j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "rs"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_800078D
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+files_given], eax
		cmp	[ebp+files_given], 0
		jg	short loc_8000866
		sub	esp, 8
		push	[ebp+files_given]
		push	offset asc_8000C58 ; "-"
		mov	eax, [ebp+sum_func]
		call	eax
		add	esp, 10h
		mov	[ebp+ok], al
		jmp	short loc_80008B5
; ---------------------------------------------------------------------------

loc_8000866:				; CODE XREF: main+152j
		mov	[ebp+ok], 1
		jmp	short loc_80008AC
; ---------------------------------------------------------------------------

loc_800086C:				; CODE XREF: main+1B9j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+files_given]
		push	eax
		mov	eax, [ebp+sum_func]
		call	eax
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax

loc_80008AC:				; CODE XREF: main+170j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_800086C

loc_80008B5:				; CODE XREF: main+16Aj
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_80008F0
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80008F0
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_8000C58 ; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008F0:				; CODE XREF: main+1C4j	main+1DAj
		cmp	[ebp+ok], 0
		jz	short loc_80008FD
		mov	eax, 0
		jmp	short loc_8000902
; ---------------------------------------------------------------------------

loc_80008FD:				; CODE XREF: main+1FAj
		mov	eax, 1

loc_8000902:				; CODE XREF: main+201j
		sub	esp, 0Ch
		push	eax		; status

loc_8000906:				; DATA XREF: .eh_frame:08000CD4o
					; .eh_frame:08000CF8o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 800090Ch
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: bsd_sum_file+70w
					; sysv_sum_file+6Fw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000920h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+46o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+F0o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aSysv		db 'sysv',0             ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 10h
; const	option longopts[4]
longopts	option <offset aSysv, 0, 0, 73h> ; DATA	XREF: main+11Co
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>	; "sysv"
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aPrintChecksumA[]
aPrintChecksumA	db 'Print checksum and block counts for each FILE.',0Ah
					; DATA XREF: usage+69o
		db 0Ah
		db '  -r              use BSD sum algorithm, use 1K blocks',0Ah
		db '  -s, --sysv      use System V sum algorithm, use 512 bytes block'
		db 's',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+8Co
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+AFo
		align 10h
; char aWithNoFileOrWh[]
aWithNoFileOrWh	db 0Ah			; DATA XREF: usage+D2o
		db 'With no FILE, or when FILE is -, read standard input.',0Ah,0
; char asc_8000C58[]
asc_8000C58	db '-',0                ; DATA XREF: bsd_sum_file+3Eo
					; sysv_sum_file+3Eo ...
aR		db 'r',0                ; DATA XREF: bsd_sum_file+7Fo
; char format[]
format		db '%s',0               ; DATA XREF: bsd_sum_file+AEo
					; bsd_sum_file+14Co ...
; char a05d5s[]
a05d5s		db '%05d %5s',0         ; DATA XREF: bsd_sum_file+1FEo
; char aS_0[]
aS_0		db ' %s',0              ; DATA XREF: bsd_sum_file+21Ao
					; sysv_sum_file+264o
; char aDS[]
aDS		db '%d %s',0            ; DATA XREF: sysv_sum_file+248o
; char locale
locale		db 0			; DATA XREF: main+2Fo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+41o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+E5o
aKayvanAghaiepo	db 'Kayvan Aghaiepour',0 ; DATA XREF: main+EAo
aSum		db 'sum',0              ; DATA XREF: main+F5o
; char shortopts[]
shortopts	db 'rs',0               ; DATA XREF: main+121o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8000CB4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8000906-80015DAh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset loc_8000906-80014E2h
		dd 0FCh, 80E4100h, 0D420285h, 3834405h,	1Ch, 5Ch
		dd offset loc_8000906-8001402h
		dd 24Ch, 80E4100h, 0D420285h, 2480305h,	4040CC5h, 1Ch
		dd 7Ch
		dd offset loc_8000906-80011D6h
		dd 296h, 80E4100h, 0D420285h, 2920305h,	4040CC5h, 24h
		dd 9Ch
		dd offset loc_8000906-8000F60h
		dd 211h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+36p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+F7p	main+108p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: bsd_sum_file+49p
					; sysv_sum_file+49p
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: bsd_sum_file+65r
					; main+1C6r
		extrn fopen64:near	; CODE XREF: bsd_sum_file+8Ap
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: bsd_sum_file+A1p
					; bsd_sum_file+13Fp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: bsd_sum_file+B6p
					; bsd_sum_file+154p ...
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: bsd_sum_file+113p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	bsd_sum_file+133p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: bsd_sum_file+173p
					; bsd_sum_file+19Cp ...
		extrn human_readable:near ; CODE XREF: bsd_sum_file+1ECp
					; sysv_sum_file+236p
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: bsd_sum_file+22Cp
					; sysv_sum_file+276p
		extrn __stack_chk_fail:near ; CODE XREF: bsd_sum_file+245p
					; sysv_sum_file+28Fp
		extrn open64:near	; CODE XREF: sysv_sum_file+83p
		extrn safe_read:near	; CODE XREF: sysv_sum_file+D6p
; int close(int	fd)
		extrn close:near	; CODE XREF: sysv_sum_file+12Ep
					; sysv_sum_file+1AFp
		extrn set_program_name:near ; CODE XREF: main+24p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+4Bp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+5Bp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+66o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+6Bp
; int setvbuf(FILE *stream, char *buf, int modes, size_t n)
		extrn setvbuf:near	; CODE XREF: main+7Fp
		extrn Version:dword	; DATA XREF: main:loc_80007CFr
		extrn version_etc:near	; CODE XREF: main+FBp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+12Bp
; int optind
		extrn optind:dword	; DATA XREF: main+140r
					; main:loc_800086Cr ...


		end
