;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	69C3A3EB76E10E8098FCE76A97398997
; Input	CRC32 :	434AF2A6

; File Name   :	D:\coreutils-o\copy.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'copy.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl freecon(char *con)
freecon		proc near		; CODE XREF: copy_reg+376p
					; copy_reg+38Ep ...

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
freecon		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl getfscreatecon(char **con)
getfscreatecon	proc near		; CODE XREF: copy_reg+248p

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
getfscreatecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl setfscreatecon(char *con)
setfscreatecon	proc near		; CODE XREF: restore_default_fscreatecon_or_die+Cp
					; copy_internal+14DDp

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
setfscreatecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl lgetfilecon(const	char *file, char **con)
lgetfilecon	proc near		; CODE XREF: copy_internal+14C3p

file		= dword	ptr  8
con		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
lgetfilecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl fsetfilecon(int fd, char *con)
fsetfilecon	proc near		; CODE XREF: copy_reg+2D3p

fd		= dword	ptr  8
con		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
fsetfilecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	dot_or_dotdot(const char *file_name)
dot_or_dotdot	proc near		; CODE XREF: copy_internal+93Ap

sep		= byte ptr -1
file_name	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+file_name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_80000B7
		mov	eax, [ebp+file_name]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_800008A
		mov	edx, 2
		jmp	short loc_800008F
; ---------------------------------------------------------------------------

loc_800008A:				; CODE XREF: dot_or_dotdot+1Bj
		mov	edx, 1

loc_800008F:				; CODE XREF: dot_or_dotdot+22j
		mov	eax, [ebp+file_name]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sep], al
		cmp	[ebp+sep], 0
		jz	short loc_80000A6
		cmp	[ebp+sep], 2Fh
		jnz	short loc_80000AD

loc_80000A6:				; CODE XREF: dot_or_dotdot+38j
		mov	eax, 1
		jmp	short loc_80000B2
; ---------------------------------------------------------------------------

loc_80000AD:				; CODE XREF: dot_or_dotdot+3Ej
		mov	eax, 0

loc_80000B2:				; CODE XREF: dot_or_dotdot+45j
		and	eax, 1
		jmp	short locret_80000BC
; ---------------------------------------------------------------------------

loc_80000B7:				; CODE XREF: dot_or_dotdot+Ej
		mov	eax, 0

locret_80000BC:				; CODE XREF: dot_or_dotdot+4Fj
		leave
		retn
dot_or_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl gcd(size_t u, size_t v)
gcd		proc near		; CODE XREF: lcm+9p

t		= dword	ptr -4
u		= dword	ptr  8
v		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h

loc_80000C4:				; CODE XREF: gcd+24j
		mov	eax, [ebp+u]
		mov	edx, 0
		div	[ebp+v]
		mov	[ebp+t], edx
		mov	eax, [ebp+v]
		mov	[ebp+u], eax
		mov	eax, [ebp+t]
		mov	[ebp+v], eax
		cmp	[ebp+v], 0
		jnz	short loc_80000C4
		mov	eax, [ebp+u]
		leave
		retn
gcd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl lcm(size_t u, size_t v)
lcm		proc near		; CODE XREF: copy_reg+70Cp

u		= dword	ptr  8
v		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	[ebp+v]		; v
		push	[ebp+u]		; u
		call	gcd
		add	esp, 8
		mov	ecx, eax
		mov	eax, [ebp+v]
		mov	edx, 0
		div	ecx
		imul	eax, [ebp+u]
		leave
		retn
lcm		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void *__cdecl	ptr_align(const	void *ptr, size_t alignment)
ptr_align	proc near		; CODE XREF: copy_reg+94Fp

p0		= dword	ptr -8
p1		= dword	ptr -4
ptr		= dword	ptr  8
alignment	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+ptr]
		mov	[ebp+p0], eax
		mov	eax, [ebp+alignment]
		lea	edx, [eax-1]
		mov	eax, [ebp+p0]
		add	eax, edx
		mov	[ebp+p1], eax
		mov	eax, [ebp+p1]
		mov	edx, 0
		div	[ebp+alignment]
		mov	eax, edx
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+p1]
		add	eax, edx
		leave
		retn
ptr_align	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl io_blksize(stat sb)
io_blksize	proc near		; CODE XREF: copy_reg+743p
					; copy_reg+85Dp

sb		= stat ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+sb.st_blksize]
		test	eax, eax
		jle	short loc_8000179
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_8000179
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 7FFFh
		jle	short loc_8000179
		mov	eax, [ebp+sb.st_blksize]
		test	eax, eax
		jle	short loc_8000172
		mov	eax, [ebp+sb.st_blksize]
		cmp	eax, 20000000h
		ja	short loc_8000172
		mov	eax, [ebp+sb.st_blksize]
		jmp	short loc_800017E
; ---------------------------------------------------------------------------

loc_8000172:				; CODE XREF: io_blksize+23j
					; io_blksize+2Dj
		mov	eax, 200h
		jmp	short loc_800017E
; ---------------------------------------------------------------------------

loc_8000179:				; CODE XREF: io_blksize+8j
					; io_blksize+12j ...
		mov	eax, 8000h

loc_800017E:				; CODE XREF: io_blksize+32j
					; io_blksize+39j
		pop	ebp
		retn
io_blksize	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl ignore_value(int	i)
ignore_value	proc near		; CODE XREF: set_owner+17Fp
					; set_owner+1F0p

i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
ignore_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_atime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_atime	proc near		; CODE XREF: copy_reg+C24p
					; copy_internal+20DDp

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+44h]
		mov	eax, [eax+40h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: copy_reg+C4Ep
					; copy_internal+2108p

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl utimens_symlink(const char *file,	const timespec *timespec)
utimens_symlink	proc near		; CODE XREF: copy_internal+2138p

err		= dword	ptr -0Ch
file		= dword	ptr  8
timespec	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	[ebp+timespec]
		push	[ebp+file]
		call	lutimens
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_80001EF
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 26h
		jnz	short loc_80001EF
		mov	[ebp+err], 0

loc_80001EF:				; CODE XREF: utimens_symlink+1Ej
					; utimens_symlink+2Aj
		mov	eax, [ebp+err]
		leave
		retn
utimens_symlink	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl clone_file(int dest_fd, int src_fd)
clone_file	proc near		; CODE XREF: copy_reg+65Cp

dest_fd		= dword	ptr  8
src_fd		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	[ebp+src_fd]
		push	40049409h	; request
		push	[ebp+dest_fd]	; fd
		call	ioctl
		add	esp, 10h
		leave
		retn
clone_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_ancestor(const stat *sb, const dir_list *ancestors)
is_ancestor	proc near		; CODE XREF: copy_internal+1645p

sb		= dword	ptr  8
ancestors	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		jmp	short loc_8000263
; ---------------------------------------------------------------------------

loc_8000219:				; CODE XREF: is_ancestor+55j
		mov	eax, [ebp+ancestors]
		mov	ecx, [eax+4]
		mov	ebx, [eax+8]
		mov	eax, [ebp+sb]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_800025B
		mov	eax, [ebp+ancestors]
		mov	ecx, [eax+0Ch]
		mov	ebx, [eax+10h]
		mov	eax, [ebp+sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_800025B
		mov	eax, 1
		jmp	short loc_800026E
; ---------------------------------------------------------------------------

loc_800025B:				; CODE XREF: is_ancestor+23j
					; is_ancestor+40j
		mov	eax, [ebp+ancestors]
		mov	eax, [eax]
		mov	[ebp+ancestors], eax

loc_8000263:				; CODE XREF: is_ancestor+5j
		cmp	[ebp+ancestors], 0
		jnz	short loc_8000219
		mov	eax, 0

loc_800026E:				; CODE XREF: is_ancestor+47j
		pop	ebx
		pop	esi
		pop	ebp
		retn
is_ancestor	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	errno_unsupported(int err)
errno_unsupported proc near		; CODE XREF: copy_internal+1592p

err		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+err], 5Fh
		jz	short loc_8000281
		cmp	[ebp+err], 3Dh
		jnz	short loc_8000288

loc_8000281:				; CODE XREF: errno_unsupported+7j
		mov	eax, 1
		jmp	short loc_800028D
; ---------------------------------------------------------------------------

loc_8000288:				; CODE XREF: errno_unsupported+Dj
		mov	eax, 0

loc_800028D:				; CODE XREF: errno_unsupported+14j
		and	eax, 1
		pop	ebp
		retn
errno_unsupported endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_attr_by_fd(const char *src_path, int src_fd, const	char *dst_path,	int dst_fd, const cp_options *x)
copy_attr_by_fd	proc near		; CODE XREF: copy_reg+D50p

src_path	= dword	ptr  8
src_fd		= dword	ptr  0Ch
dst_path	= dword	ptr  10h
dst_fd		= dword	ptr  14h
x		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		mov	eax, 1
		pop	ebp
		retn
copy_attr_by_fd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_attr_by_name(const	char *src_path,	const char *dst_path, const cp_options *x)
copy_attr_by_name proc near		; CODE XREF: copy_internal+2293p

src_path	= dword	ptr  8
dst_path	= dword	ptr  0Ch
x		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		mov	eax, 1
		pop	ebp
		retn
copy_attr_by_name endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_dir(const char *src_name_in, const	char *dst_name_in, _Bool new_dst, const	stat *src_sb, dir_list *ancestors, const cp_options *x,	_Bool *first_dir_created_per_command_line_arg, _Bool *copy_into_self)
copy_dir	proc near		; CODE XREF: copy_internal+1938p

copy_into_self	= dword	ptr -88h
first_dir_created_per_command_line_arg=	dword ptr -84h
x		= dword	ptr -80h
ancestors	= dword	ptr -7Ch
src_sb		= dword	ptr -78h
new_dst		= byte ptr -74h
dst_name_in	= dword	ptr -70h
src_name_in	= dword	ptr -6Ch
local_copy_into_self= byte ptr -5Ah
ok		= byte ptr -59h
namep		= dword	ptr -58h
name_space	= dword	ptr -54h
src_name	= dword	ptr -50h
dst_name	= dword	ptr -4Ch
non_command_line_options= cp_options ptr -48h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+src_name_in], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+dst_name_in], edx
		mov	[ebp+new_dst], al
		mov	eax, [ebp+arg_C]
		mov	[ebp+src_sb], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+ancestors], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+x], eax
		mov	eax, [ebp+arg_18]
		mov	[ebp+first_dir_created_per_command_line_arg], eax
		mov	eax, [ebp+arg_1C]
		mov	[ebp+copy_into_self], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+x]
		mov	edx, [eax]
		mov	[ebp+non_command_line_options.backup_type], edx
		mov	edx, [eax+4]
		mov	[ebp+non_command_line_options.dereference], edx
		mov	edx, [eax+8]
		mov	[ebp+non_command_line_options.interactive], edx
		mov	edx, [eax+0Ch]
		mov	[ebp+non_command_line_options.sparse_mode], edx
		mov	edx, [eax+10h]
		mov	[ebp+non_command_line_options.mode], edx
		mov	edx, [eax+14h]
		mov	dword ptr [ebp+non_command_line_options.copy_as_regular], edx
		mov	edx, [eax+18h]
		mov	dword ptr [ebp+non_command_line_options.move_mode], edx
		mov	edx, [eax+1Ch]
		mov	dword ptr [ebp+non_command_line_options.preserve_ownership], edx
		mov	edx, [eax+20h]
		mov	dword ptr [ebp+non_command_line_options.require_preserve], edx
		mov	edx, [eax+24h]
		mov	dword ptr [ebp+non_command_line_options.require_preserve_xattr], edx
		mov	edx, [eax+28h]
		mov	dword ptr [ebp+non_command_line_options.symbolic_link],	edx
		mov	edx, [eax+2Ch]
		mov	dword ptr [ebp+non_command_line_options.open_dangling_dest_symlink], edx
		mov	edx, [eax+30h]
		mov	[ebp+non_command_line_options.reflink_mode], edx
		mov	edx, [eax+34h]
		mov	[ebp+non_command_line_options.dest_info], edx
		mov	eax, [eax+38h]
		mov	[ebp+non_command_line_options.src_info], eax
		mov	[ebp+ok], 1
		sub	esp, 0Ch
		push	[ebp+src_name_in]
		call	savedir
		add	esp, 10h
		mov	[ebp+name_space], eax
		cmp	[ebp+name_space], 0
		jnz	short loc_80003A6
		sub	esp, 0Ch
		push	[ebp+src_name_in]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset msgid	; "cannot access %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80004AF
; ---------------------------------------------------------------------------

loc_80003A6:				; CODE XREF: copy_dir+BEj
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 3
		jnz	short loc_80003B8
		mov	[ebp+non_command_line_options.dereference], 2

loc_80003B8:				; CODE XREF: copy_dir+109j
		mov	eax, [ebp+name_space]
		mov	[ebp+namep], eax
		jmp	loc_800048C
; ---------------------------------------------------------------------------

loc_80003C3:				; CODE XREF: copy_dir+1EEj
		sub	esp, 4
		push	0
		push	[ebp+namep]
		push	[ebp+src_name_in]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+src_name],	eax
		sub	esp, 4
		push	0
		push	[ebp+namep]
		push	[ebp+dst_name_in]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+dst_name],	eax
		mov	eax, [ebp+src_sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		movzx	ecx, [ebp+new_dst]
		sub	esp, 4
		push	0		; rename_succeeded
		lea	ebx, [ebp+local_copy_into_self]
		push	ebx		; copy_into_self
		push	[ebp+first_dir_created_per_command_line_arg] ; first_dir_created_per_command_line_arg
		push	0		; command_line_arg
		lea	ebx, [ebp+non_command_line_options]
		push	ebx		; x
		push	[ebp+ancestors]	; ancestors
		push	edx
		push	eax		; device
		push	ecx		; new_dst
		push	[ebp+dst_name]	; dst_name
		push	[ebp+src_name]	; src_name
		call	copy_internal
		add	esp, 30h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	eax, [ebp+copy_into_self]
		movzx	edx, byte ptr [eax]
		movzx	eax, [ebp+local_copy_into_self]
		or	eax, edx
		movzx	eax, al
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+copy_into_self]
		mov	[eax], dl
		sub	esp, 0Ch
		push	[ebp+dst_name]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+src_name]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+local_copy_into_self]
		test	al, al
		jnz	short loc_800049C
		sub	esp, 0Ch
		push	[ebp+namep]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		add	[ebp+namep], eax

loc_800048C:				; CODE XREF: copy_dir+118j
		mov	eax, [ebp+namep]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_80003C3
		jmp	short loc_800049D
; ---------------------------------------------------------------------------

loc_800049C:				; CODE XREF: copy_dir+1D0j
		nop

loc_800049D:				; CODE XREF: copy_dir+1F4j
		sub	esp, 0Ch
		push	[ebp+name_space] ; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]

loc_80004AF:				; CODE XREF: copy_dir+FBj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80004C0
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80004C0:				; CODE XREF: copy_dir+213j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
copy_dir	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl set_owner(const cp_options *x, const char	*dst_name, int dest_desc, const	stat *src_sb, _Bool new_dst, const stat	*dst_sb)
set_owner	proc near		; CODE XREF: copy_reg+DFAp
					; copy_internal+222Ep

new_dst		= byte ptr -2Ch
uid		= dword	ptr -24h
gid		= dword	ptr -20h
old_mode	= dword	ptr -1Ch
new_mode	= dword	ptr -18h
restrictive_temp_mode= dword ptr -14h
saved_errno	= dword	ptr -10h
saved_errno_0	= dword	ptr -0Ch
x		= dword	ptr  8
dst_name	= dword	ptr  0Ch
dest_desc	= dword	ptr  10h
src_sb		= dword	ptr  14h
arg_10		= dword	ptr  18h
dst_sb		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_10]
		mov	[ebp+new_dst], al
		mov	eax, [ebp+src_sb]
		mov	eax, [eax+18h]
		mov	[ebp+uid], eax
		mov	eax, [ebp+src_sb]
		mov	eax, [eax+1Ch]
		mov	[ebp+gid], eax
		movzx	eax, [ebp+new_dst]
		xor	eax, 1
		test	al, al
		jz	loc_80005E1
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jnz	short loc_800051B
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jnz	short loc_800051B
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+27h]
		test	al, al
		jz	loc_80005E1

loc_800051B:				; CODE XREF: set_owner+38j
					; set_owner+43j
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		mov	[ebp+old_mode],	eax
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jnz	short loc_800053A
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8000542

loc_800053A:				; CODE XREF: set_owner+66j
		mov	eax, [ebp+src_sb]
		mov	eax, [eax+10h]
		jmp	short loc_8000548
; ---------------------------------------------------------------------------

loc_8000542:				; CODE XREF: set_owner+71j
		mov	eax, [ebp+x]
		mov	eax, [eax+10h]

loc_8000548:				; CODE XREF: set_owner+79j
		mov	[ebp+new_mode],	eax
		mov	eax, [ebp+old_mode]
		and	eax, [ebp+new_mode]
		and	eax, 1C0h
		mov	[ebp+restrictive_temp_mode], eax
		mov	eax, [ebp+new_mode]
		not	eax
		or	ah, 0Eh
		and	eax, [ebp+old_mode]
		and	eax, 0FFFh
		test	eax, eax
		jz	short loc_80005E1
		sub	esp, 4
		push	[ebp+restrictive_temp_mode]
		push	[ebp+dest_desc]
		push	[ebp+dst_name]
		call	qset_acl
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005E1
		sub	esp, 0Ch
		push	[ebp+x]		; x
		call	owner_failure_ok
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80005D0
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClearingPermis ; "clearing permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80005D0:				; CODE XREF: set_owner+D1j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		movzx	eax, al
		neg	eax
		jmp	loc_800072D
; ---------------------------------------------------------------------------

loc_80005E1:				; CODE XREF: set_owner+29j
					; set_owner+4Ej ...
		cmp	[ebp+dest_desc], 0FFFFFFFFh
		jz	short loc_800065C
		sub	esp, 4
		push	[ebp+gid]	; group
		push	[ebp+uid]	; owner
		push	[ebp+dest_desc]	; fd
		call	fchown
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000609
		mov	eax, 1
		jmp	loc_800072D
; ---------------------------------------------------------------------------

loc_8000609:				; CODE XREF: set_owner+136j
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8000625
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	loc_80006CB

loc_8000625:				; CODE XREF: set_owner+14Cj
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		sub	esp, 4
		push	[ebp+gid]	; group
		push	0FFFFFFFFh	; owner
		push	[ebp+dest_desc]	; fd
		call	fchown
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; i
		call	ignore_value
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno]
		mov	[edx], eax
		jmp	short loc_80006CB
; ---------------------------------------------------------------------------

loc_800065C:				; CODE XREF: set_owner+11Ej
		sub	esp, 4
		push	[ebp+gid]	; group
		push	[ebp+uid]	; owner
		push	[ebp+dst_name]	; file
		call	lchown
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800067E
		mov	eax, 1
		jmp	loc_800072D
; ---------------------------------------------------------------------------

loc_800067E:				; CODE XREF: set_owner+1ABj
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8000696
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_80006CB

loc_8000696:				; CODE XREF: set_owner+1C1j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno_0], eax
		sub	esp, 4
		push	[ebp+gid]	; group
		push	0FFFFFFFFh	; owner
		push	[ebp+dst_name]	; file
		call	lchown
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; i
		call	ignore_value
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno_0]
		mov	[edx], eax

loc_80006CB:				; CODE XREF: set_owner+158j
					; set_owner+193j ...
		sub	esp, 0Ch
		push	[ebp+x]		; x
		call	chown_failure_ok
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000728
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToPreser ; "failed to preserve ownership for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short loc_8000728
		mov	eax, 0FFFFFFFFh
		jmp	short loc_800072D
; ---------------------------------------------------------------------------

loc_8000728:				; CODE XREF: set_owner+217j
					; set_owner+258j
		mov	eax, 0

loc_800072D:				; CODE XREF: set_owner+115j
					; set_owner+13Dj ...
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
set_owner	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_author(const	char *dst_name,	int dest_desc, const stat *src_sb)
set_author	proc near		; CODE XREF: copy_reg+E39p
					; copy_internal+2268p

dst_name	= dword	ptr  8
dest_desc	= dword	ptr  0Ch
src_sb		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
set_author	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl fchmod_or_lchmod(int desc, const char *name, mode_t mode)
fchmod_or_lchmod proc near		; CODE XREF: copy_reg+D1Cp
					; copy_reg+D95p ...

desc		= dword	ptr  8
name		= dword	ptr  0Ch
mode		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+desc], 0
		js	short loc_8000759
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	[ebp+desc]	; fd
		call	fchmod
		add	esp, 10h
		jmp	short locret_800076A
; ---------------------------------------------------------------------------

loc_8000759:				; CODE XREF: fchmod_or_lchmod+Aj
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	[ebp+name]	; file
		call	chmod
		add	esp, 10h

locret_800076A:				; CODE XREF: fchmod_or_lchmod+1Dj
		leave
		retn
fchmod_or_lchmod endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_reg(const char *src_name, const char *dst_name, const cp_options *x, mode_t dst_mode, mode_t omitted_permissions, _Bool *new_dst, const stat *src_sb)
copy_reg	proc near		; CODE XREF: copy_internal+1C0Ap

var_178		= dword	ptr -178h
var_174		= dword	ptr -174h
var_170		= dword	ptr -170h
var_16C		= dword	ptr -16Ch
var_168		= timespec ptr -168h
src_sb		= dword	ptr -15Ch
new_dst		= dword	ptr -158h
x		= dword	ptr -154h
dst_name	= dword	ptr -150h
src_name	= dword	ptr -14Ch
return_val	= byte ptr -142h
data_copy_required= byte ptr -141h
last_write_made_hole= byte ptr -140h
make_holes	= byte ptr -13Fh
access_changed	= byte ptr -13Eh
clone_ok	= byte ptr -13Dh
buf_alloc	= dword	ptr -13Ch
dest_desc	= dword	ptr -138h
dest_errno	= dword	ptr -134h
src_mode	= dword	ptr -130h
buf_size	= dword	ptr -12Ch
wp		= dword	ptr -128h
cp		= dword	ptr -124h
name_alloc	= dword	ptr -120h
source_desc	= dword	ptr -11Ch
open_flags	= dword	ptr -118h
buf_alignment	= dword	ptr -114h
buf_alignment_slop= dword ptr -110h
blcm_max	= dword	ptr -10Ch
blcm		= dword	ptr -108h
buf		= dword	ptr -104h
n_read		= dword	ptr -100h
n		= dword	ptr -0FCh
n_read_total	= qword	ptr -0F8h
src_open_sb	= stat ptr -0ECh
dangling_link_sb= stat ptr -8Ch
timespec	= timespec ptr -2Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
dst_mode	= dword	ptr  14h
omitted_permissions= dword ptr	18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 16Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+src_name],	eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+dst_name],	eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+x], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+new_dst], eax
		mov	eax, [ebp+arg_18]
		mov	[ebp+src_sb], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+buf_alloc], 0
		mov	[ebp+name_alloc], 0
		mov	eax, [ebp+src_sb]
		mov	eax, [eax+10h]
		mov	[ebp+src_mode],	eax
		mov	[ebp+return_val], 1
		mov	[ebp+data_copy_required], 1
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jnz	short loc_80007F6
		mov	eax, 20000h
		jmp	short loc_80007FB
; ---------------------------------------------------------------------------

loc_80007F6:				; CODE XREF: copy_reg+81j
		mov	eax, 0

loc_80007FB:				; CODE XREF: copy_reg+88j
		sub	esp, 8
		push	eax
		push	[ebp+src_name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+source_desc], eax
		cmp	[ebp+source_desc], 0
		jns	short loc_800085F
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80017B3
; ---------------------------------------------------------------------------

loc_800085F:				; CODE XREF: copy_reg+AEj
		sub	esp, 8
		lea	eax, [ebp+src_open_sb]
		push	eax
		push	[ebp+source_desc]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_80008C0
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_desc
; ---------------------------------------------------------------------------

loc_80008C0:				; CODE XREF: copy_reg+10Dj
		mov	eax, [ebp+src_sb]
		mov	ecx, [eax+58h]
		mov	ebx, [eax+5Ch]
		mov	eax, dword ptr [ebp+src_open_sb.st_ino]
		mov	edx, dword ptr [ebp+src_open_sb.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8000907
		mov	eax, [ebp+src_sb]
		mov	ecx, [eax]
		mov	ebx, [eax+4]
		mov	eax, dword ptr [ebp+src_open_sb.st_dev]
		mov	edx, dword ptr [ebp+src_open_sb.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8000944

loc_8000907:				; CODE XREF: copy_reg+176j
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSkippingFileSA ; "skipping file	%s, as it was replaced wh"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_desc
; ---------------------------------------------------------------------------

loc_8000944:				; CODE XREF: copy_reg+199j
		mov	eax, [ebp+new_dst]
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	loc_8000BC2
		sub	esp, 8
		push	201h
		push	[ebp+dst_name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+dest_desc], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+dest_errno], eax
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+21h]
		test	al, al
		jz	loc_8000B02
		cmp	[ebp+dest_desc], 0
		js	loc_8000B02
		mov	dword ptr [ebp+dangling_link_sb.st_dev], 0
		sub	esp, 0Ch
		lea	eax, [ebp+dangling_link_sb]
		push	eax		; con
		call	getfscreatecon
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000A21
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+25h]
		xor	eax, 1
		test	al, al
		jnz	short loc_80009DF
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8000A07

loc_80009DF:				; CODE XREF: copy_reg+263j
		sub	esp, 0Ch
		push	offset aFailedToGetFil ; "failed to get	file system create contex"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000A07:				; CODE XREF: copy_reg+271j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8000A21
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8000A21:				; CODE XREF: copy_reg+252j
					; copy_reg+2A7j
		mov	eax, dword ptr [ebp+dangling_link_sb.st_dev]
		test	eax, eax
		jz	loc_8000B02
		mov	eax, dword ptr [ebp+dangling_link_sb.st_dev]
		sub	esp, 8
		push	eax		; con
		push	[ebp+dest_desc]	; fd
		call	fsetfilecon
		add	esp, 10h
		test	eax, eax
		jns	loc_8000AF0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+25h]
		xor	eax, 1
		test	al, al
		jnz	short loc_8000A6E
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8000AC3

loc_8000A6E:				; CODE XREF: copy_reg+2F2j
		mov	eax, dword ptr [ebp+dangling_link_sb.st_dev]
		sub	esp, 8
		push	eax
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToSetThe ; "failed to set	the security context of	%"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8000AC3:				; CODE XREF: copy_reg+300j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8000AF0
		mov	[ebp+return_val], 0
		mov	eax, dword ptr [ebp+dangling_link_sb.st_dev]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h
		nop
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8000AF0:				; CODE XREF: copy_reg+2DDj
					; copy_reg+363j
		mov	eax, dword ptr [ebp+dangling_link_sb.st_dev]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h

loc_8000B02:				; CODE XREF: copy_reg+221j
					; copy_reg+22Ej ...
		cmp	[ebp+dest_desc], 0
		jns	loc_8000BC2
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+16h]
		test	al, al
		jz	loc_8000BC2
		sub	esp, 0Ch
		push	[ebp+dst_name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B7B
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotRemoveS ;	"cannot	remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_desc
; ---------------------------------------------------------------------------

loc_8000B7B:				; CODE XREF: copy_reg+3C8j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8000BB9
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aRemovedS ; "removed %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000BB9:				; CODE XREF: copy_reg+41Bj
		mov	eax, [ebp+new_dst]
		mov	byte ptr [eax],	1

loc_8000BC2:				; CODE XREF: copy_reg+1E6j
					; copy_reg+39Dj ...
		mov	eax, [ebp+new_dst]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	loc_8000CF6
		mov	[ebp+open_flags], 41h
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+dst_mode]
		mov	edx, [ebp+open_flags]
		or	dl, 80h
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+dst_name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+dest_desc], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+dest_errno], eax
		cmp	[ebp+dest_desc], 0
		jns	loc_8000CFD
		cmp	[ebp+dest_errno], 11h
		jnz	loc_8000CFD
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	loc_8000CFD
		sub	esp, 8
		lea	eax, [ebp+dangling_link_sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000CFD
		mov	eax, [ebp+dangling_link_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	loc_8000CFD
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ch]
		test	al, al
		jz	short loc_8000CB9
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+dst_mode]
		sub	esp, 4
		push	eax
		push	[ebp+open_flags]
		push	[ebp+dst_name]
		call	open_safer
		add	esp, 10h
		mov	[ebp+dest_desc], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+dest_errno], eax
		jmp	short loc_8000CFD
; ---------------------------------------------------------------------------

loc_8000CB9:				; CODE XREF: copy_reg+516j
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aNotWritingThro ; "not writing through dangling symlink %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_desc
; ---------------------------------------------------------------------------

loc_8000CF6:				; CODE XREF: copy_reg+461j
		mov	[ebp+omitted_permissions], 0

loc_8000CFD:				; CODE XREF: copy_reg+4AFj
					; copy_reg+4BCj ...
		cmp	[ebp+dest_desc], 0
		jns	short loc_8000D47
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotCreateRe ; "cannot create	regular	file %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+dest_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_desc
; ---------------------------------------------------------------------------

loc_8000D47:				; CODE XREF: copy_reg+598j
		sub	esp, 8
		lea	eax, [ebp+dangling_link_sb]
		push	eax
		push	[ebp+dest_desc]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000DA8
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8000DA8:				; CODE XREF: copy_reg+5F5j
		mov	eax, [ebp+x]
		mov	eax, [eax+30h]
		test	eax, eax
		jz	loc_8000E4C
		sub	esp, 8
		push	[ebp+source_desc] ; src_fd
		push	[ebp+dest_desc]	; dest_fd
		call	clone_file
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+clone_ok],	al
		cmp	[ebp+clone_ok],	0
		jnz	short loc_8000DF2
		mov	eax, [ebp+x]
		mov	eax, [eax+30h]
		cmp	eax, 2
		jnz	short loc_8000E4C

loc_8000DF2:				; CODE XREF: copy_reg+676j
		movzx	eax, [ebp+clone_ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8000E45
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToCloneS ; "failed to clone %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8000E45:				; CODE XREF: copy_reg+692j
		mov	[ebp+data_copy_required], 0

loc_8000E4C:				; CODE XREF: copy_reg+647j
					; copy_reg+684j
		cmp	[ebp+data_copy_required], 0
		jz	loc_800136E
		mov	dword ptr [ebp+n_read_total], 0
		mov	dword ptr [ebp+n_read_total+4],	0
		call	getpagesize
		sub	esp, 8
		push	4		; v
		push	eax		; u
		call	lcm
		add	esp, 10h
		mov	[ebp+buf_alignment], eax
		mov	eax, [ebp+buf_alignment]
		add	eax, 3
		mov	[ebp+buf_alignment_slop], eax
		sub	esp, 60h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+dangling_link_sb]
		mov	edx, 18h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	io_blksize
		add	esp, 60h
		mov	[ebp+buf_size],	eax
		mov	[ebp+last_write_made_hole], 0
		mov	[ebp+make_holes], 0
		mov	eax, [ebp+dangling_link_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8000F8C
		mov	eax, [ebp+x]
		mov	eax, [eax+0Ch]
		cmp	eax, 3
		jnz	short loc_8000EF3
		mov	[ebp+make_holes], 1

loc_8000EF3:				; CODE XREF: copy_reg+77Ej
		mov	eax, [ebp+x]
		mov	eax, [eax+0Ch]
		cmp	eax, 2
		jnz	loc_8000F8C
		mov	eax, [ebp+src_open_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8000F8C
		mov	ecx, dword ptr [ebp+src_open_sb.st_blocks]
		mov	ebx, dword ptr [ebp+src_open_sb.st_blocks+4]
		mov	esi, dword ptr [ebp+src_open_sb.st_size]
		mov	edi, dword ptr [ebp+src_open_sb.st_size+4]
		mov	[ebp+var_178], esi
		mov	[ebp+var_174], edi
		mov	eax, edi
		sar	eax, 1Fh
		cdq
		mov	edi, eax
		and	edi, 1FFh
		mov	[ebp+var_170], edi
		mov	eax, edx
		and	eax, 0
		mov	[ebp+var_16C], eax
		mov	eax, [ebp+var_170]
		mov	edx, [ebp+var_16C]
		add	eax, [ebp+var_178]
		adc	edx, [ebp+var_174]
		shrd	eax, edx, 9
		sar	edx, 9
		cmp	ebx, edx
		jg	short loc_8000F8C
		cmp	ebx, edx
		jl	short loc_8000F85
		cmp	ecx, eax
		jnb	short loc_8000F8C

loc_8000F85:				; CODE XREF: copy_reg+813j
		mov	[ebp+make_holes], 1

loc_8000F8C:				; CODE XREF: copy_reg+76Cj
					; copy_reg+793j ...
		movzx	eax, [ebp+make_holes]
		xor	eax, 1
		test	al, al
		jz	loc_800108C
		mov	eax, 7FFFFFFFh
		sub	eax, [ebp+buf_alignment_slop]
		mov	[ebp+blcm_max],	eax
		sub	esp, 60h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+src_open_sb]
		mov	edx, 18h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	io_blksize
		add	esp, 60h
		sub	esp, 4
		push	[ebp+blcm_max]
		push	[ebp+buf_size]
		push	eax
		call	buffer_lcm
		add	esp, 10h
		mov	[ebp+blcm], eax
		mov	eax, [ebp+src_open_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8001039
		mov	eax, dword ptr [ebp+src_open_sb.st_size]
		mov	edx, dword ptr [ebp+src_open_sb.st_size+4]
		mov	ecx, [ebp+buf_size]
		mov	ebx, 0
		cmp	edx, ebx
		jg	short loc_8001039
		cmp	edx, ebx
		jl	short loc_8001024
		cmp	eax, ecx
		jnb	short loc_8001039

loc_8001024:				; CODE XREF: copy_reg+8B2j
		mov	eax, dword ptr [ebp+src_open_sb.st_size]
		mov	edx, dword ptr [ebp+src_open_sb.st_size+4]
		add	eax, 1
		mov	[ebp+buf_size],	eax

loc_8001039:				; CODE XREF: copy_reg+893j
					; copy_reg+8AEj ...
		mov	edx, [ebp+blcm]
		mov	eax, [ebp+buf_size]
		add	eax, edx
		sub	eax, 1
		mov	[ebp+buf_size],	eax
		mov	eax, [ebp+buf_size]
		mov	edx, 0
		div	[ebp+blcm]
		mov	eax, edx
		sub	[ebp+buf_size],	eax
		cmp	[ebp+buf_size],	0
		jz	short loc_8001080
		mov	eax, [ebp+blcm_max]
		cmp	eax, [ebp+buf_size]
		jnb	short loc_800108C

loc_8001080:				; CODE XREF: copy_reg+904j
		mov	eax, [ebp+blcm]
		mov	[ebp+buf_size],	eax

loc_800108C:				; CODE XREF: copy_reg+82Cj
					; copy_reg+912j
		mov	edx, [ebp+buf_size]
		mov	eax, [ebp+buf_alignment_slop]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf_alloc], eax
		sub	esp, 8
		push	[ebp+buf_alignment] ; alignment
		push	[ebp+buf_alloc]	; ptr
		call	ptr_align
		add	esp, 10h
		mov	[ebp+buf], eax

loc_80010C9:				; CODE XREF: copy_reg+B04j
					; copy_reg+B87j ...
		mov	[ebp+wp], 0
		sub	esp, 4
		push	[ebp+buf_size]	; nbytes
		push	[ebp+buf]	; buf
		push	[ebp+source_desc] ; fd
		call	read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0
		jns	short loc_8001154
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 4
		jz	loc_80012F8
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aReadingS ; "reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8001154:				; CODE XREF: copy_reg+991j
		cmp	[ebp+n_read], 0
		jz	loc_80012FE
		mov	eax, [ebp+n_read]
		cdq
		add	dword ptr [ebp+n_read_total], eax
		adc	dword ptr [ebp+n_read_total+4],	edx
		cmp	[ebp+make_holes], 0
		jz	loc_8001269
		mov	edx, [ebp+n_read]
		mov	eax, [ebp+buf]
		add	eax, edx
		mov	byte ptr [eax],	1
		mov	eax, [ebp+buf]
		mov	[ebp+wp], eax
		jmp	short loc_80011A1
; ---------------------------------------------------------------------------

loc_80011A0:				; CODE XREF: copy_reg+A48j
		nop

loc_80011A1:				; CODE XREF: copy_reg+A32j
		mov	eax, [ebp+wp]
		lea	edx, [eax+4]
		mov	[ebp+wp], edx
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_80011A0
		mov	eax, [ebp+wp]
		sub	eax, 4
		mov	[ebp+cp], eax
		jmp	short loc_80011C8
; ---------------------------------------------------------------------------

loc_80011C7:				; CODE XREF: copy_reg+A70j
		nop

loc_80011C8:				; CODE XREF: copy_reg+A59j
		mov	eax, [ebp+cp]
		lea	edx, [eax+1]
		mov	[ebp+cp], edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80011C7
		mov	edx, [ebp+n_read]
		mov	eax, [ebp+buf]
		add	eax, edx
		cmp	eax, [ebp+cp]
		jb	short loc_8001200
		mov	[ebp+wp], 0
		jmp	short loc_8001269
; ---------------------------------------------------------------------------

loc_8001200:				; CODE XREF: copy_reg+A86j
		mov	eax, [ebp+n_read]
		cdq
		push	1
		push	edx
		push	eax
		push	[ebp+dest_desc]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_8001262
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotLseekS ; "cannot lseek %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8001262:				; CODE XREF: copy_reg+AAFj
		mov	[ebp+last_write_made_hole], 1

loc_8001269:				; CODE XREF: copy_reg+A0Fj
					; copy_reg+A92j
		cmp	[ebp+wp], 0
		jnz	loc_80010C9
		mov	eax, [ebp+n_read]
		mov	[ebp+n], eax
		sub	esp, 4
		push	[ebp+n]
		push	[ebp+buf]
		push	[ebp+dest_desc]
		call	full_write
		add	esp, 10h
		cmp	eax, [ebp+n]
		jz	short loc_80012EC
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingS ; "writing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_80012EC:				; CODE XREF: copy_reg+B39j
		mov	[ebp+last_write_made_hole], 0
		jmp	loc_80010C9
; ---------------------------------------------------------------------------

loc_80012F8:				; CODE XREF: copy_reg+99Dj
		nop
		jmp	loc_80010C9
; ---------------------------------------------------------------------------

loc_80012FE:				; CODE XREF: copy_reg+9EFj
		nop
		cmp	[ebp+last_write_made_hole], 0
		jz	short loc_800136E
		sub	esp, 4
		push	dword ptr [ebp+n_read_total+4]
		push	dword ptr [ebp+n_read_total]
		push	[ebp+dest_desc]
		call	ftruncate64
		add	esp, 10h
		test	eax, eax
		jns	short loc_800136E
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingS ; "writing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_800136E:				; CODE XREF: copy_reg+6E7j
					; copy_reg+B9Aj ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	loc_8001446
		lea	eax, [ebp+var_168]
		sub	esp, 8
		push	[ebp+src_sb]	; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 0Ch
		mov	eax, [ebp+var_168.tv_sec]
		mov	edx, [ebp+var_168.tv_nsec]
		mov	[ebp+timespec.tv_sec], eax
		mov	[ebp+timespec.tv_nsec],	edx
		lea	eax, [ebp+var_168]
		sub	esp, 8
		push	[ebp+src_sb]	; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_168.tv_sec]
		mov	edx, [ebp+var_168.tv_nsec]
		mov	[ebp+timespec.tv_sec+8], eax
		mov	[ebp+timespec.tv_nsec+8], edx
		sub	esp, 4
		lea	eax, [ebp+timespec]
		push	eax
		push	[ebp+dst_name]
		push	[ebp+dest_desc]
		call	gl_futimens
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001446
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aPreservingTime ; "preserving times for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short loc_8001446
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8001446:				; CODE XREF: copy_reg+C0Ej
					; copy_reg+C85j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+23h]
		test	al, al
		jz	loc_8001509
		mov	[ebp+access_changed], 0
		mov	eax, [ebp+dangling_link_sb.st_mode]
		and	eax, 80h
		test	eax, eax
		jnz	short loc_800149B
		call	geteuid
		test	eax, eax
		jz	short loc_800149B
		sub	esp, 4
		push	180h		; mode
		push	[ebp+dst_name]	; name
		push	[ebp+dest_desc]	; desc
		call	fchmod_or_lchmod
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+access_changed], al

loc_800149B:				; CODE XREF: copy_reg+CFDj
					; copy_reg+D06j
		sub	esp, 0Ch
		push	[ebp+x]		; x
		push	[ebp+dest_desc]	; dst_fd
		push	[ebp+dst_name]	; dst_path
		push	[ebp+source_desc] ; src_fd
		push	[ebp+src_name]	; src_path
		call	copy_attr_by_fd
		add	esp, 20h
		xor	eax, 1
		test	al, al
		jz	short loc_80014E0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_80014E0
		mov	[ebp+return_val], 0

loc_80014E0:				; CODE XREF: copy_reg+D5Dj
					; copy_reg+D6Bj
		cmp	[ebp+access_changed], 0
		jz	short loc_8001509
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+dst_mode]
		sub	esp, 4
		push	eax		; mode
		push	[ebp+dst_name]	; name
		push	[ebp+dest_desc]	; desc
		call	fchmod_or_lchmod
		add	esp, 10h

loc_8001509:				; CODE XREF: copy_reg+CE6j
					; copy_reg+D7Bj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_8001590
		mov	eax, [ebp+src_sb]
		mov	edx, [eax+18h]
		mov	eax, [ebp+dangling_link_sb.st_uid]
		cmp	edx, eax
		jnz	short loc_8001537
		mov	eax, [ebp+src_sb]
		mov	edx, [eax+1Ch]
		mov	eax, [ebp+dangling_link_sb.st_gid]
		cmp	edx, eax
		jz	short loc_8001590

loc_8001537:				; CODE XREF: copy_reg+DB9j
		mov	eax, [ebp+new_dst]
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 8
		lea	edx, [ebp+dangling_link_sb]
		push	edx		; dst_sb
		push	eax		; new_dst
		push	[ebp+src_sb]	; src_sb
		push	[ebp+dest_desc]	; dest_desc
		push	[ebp+dst_name]	; dst_name
		push	[ebp+x]		; x
		call	set_owner
		add	esp, 20h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8001579
		test	eax, eax
		jz	short loc_8001585
		jmp	short loc_8001590
; ---------------------------------------------------------------------------

loc_8001579:				; CODE XREF: copy_reg+E05j
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_8001585:				; CODE XREF: copy_reg+E09j
		and	[ebp+src_mode],	0FFFFF1FFh
		nop

loc_8001590:				; CODE XREF: copy_reg+DA9j
					; copy_reg+DC9j ...
		sub	esp, 4
		push	[ebp+src_sb]	; src_sb
		push	[ebp+dest_desc]	; dest_desc
		push	[ebp+dst_name]	; dst_name
		call	set_author
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jnz	short loc_80015C9
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8001618

loc_80015C9:				; CODE XREF: copy_reg+E4Dj
		sub	esp, 0Ch
		push	[ebp+src_mode]
		push	[ebp+dest_desc]
		push	[ebp+dst_name]
		push	[ebp+source_desc]
		push	[ebp+src_name]
		call	copy_acl
		add	esp, 20h
		test	eax, eax
		jz	loc_80016DF
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	loc_80016DF
		mov	[ebp+return_val], 0
		jmp	loc_80016DF
; ---------------------------------------------------------------------------

loc_8001618:				; CODE XREF: copy_reg+E5Bj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+27h]
		test	al, al
		jz	short loc_800165B
		mov	eax, [ebp+x]
		mov	eax, [eax+10h]
		sub	esp, 4
		push	eax
		push	[ebp+dest_desc]
		push	[ebp+dst_name]
		call	set_acl
		add	esp, 10h
		test	eax, eax
		jz	close_src_and_dst_desc
		mov	[ebp+return_val], 0
		jmp	close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_800165B:				; CODE XREF: copy_reg+EB8j
		cmp	[ebp+omitted_permissions], 0
		jz	short close_src_and_dst_desc
		call	cached_umask
		not	eax
		and	[ebp+omitted_permissions], eax
		cmp	[ebp+omitted_permissions], 0
		jz	short close_src_and_dst_desc
		sub	esp, 4
		push	[ebp+dst_mode]	; mode
		push	[ebp+dst_name]	; name
		push	[ebp+dest_desc]	; desc
		call	fchmod_or_lchmod
		add	esp, 10h
		test	eax, eax
		jz	short close_src_and_dst_desc
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aPreservingPerm ; "preserving permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short close_src_and_dst_desc
		mov	[ebp+return_val], 0
		jmp	short close_src_and_dst_desc
; ---------------------------------------------------------------------------

loc_80016DF:				; CODE XREF: copy_reg+E88j
					; copy_reg+E9Aj ...
		nop

close_src_and_dst_desc:			; CODE XREF: copy_reg+2B0j
					; copy_reg+37Fj ...
		sub	esp, 0Ch
		push	[ebp+dest_desc]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short close_src_desc
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClosingS ; "closing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0

close_src_desc:				; CODE XREF: copy_reg+14Fj
					; copy_reg+1D3j ...
		sub	esp, 0Ch
		push	[ebp+source_desc] ; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_800178A
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClosingS ; "closing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+return_val], 0

loc_800178A:				; CODE XREF: copy_reg+FDCj
		sub	esp, 0Ch
		push	[ebp+buf_alloc]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+name_alloc] ; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+return_val]

loc_80017B3:				; CODE XREF: copy_reg+EEj
		mov	edi, [ebp+var_1C]
		xor	edi, large gs:14h
		jz	short loc_80017C4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80017C4:				; CODE XREF: copy_reg+1051j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
copy_reg	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	same_file_ok(const char	*src_name, const stat *src_sb, const char *dst_name, const stat	*dst_sb, const cp_options *x, _Bool *return_now, _Bool *unlink_src)
same_file_ok	proc near		; CODE XREF: copy_internal+436p

var_110		= dword	ptr -110h
var_10C		= dword	ptr -10Ch
unlink_src	= dword	ptr -104h
return_now	= dword	ptr -100h
x		= dword	ptr -0FCh
dst_sb		= dword	ptr -0F8h
dst_name	= dword	ptr -0F4h
src_sb		= dword	ptr -0F0h
src_name	= dword	ptr -0ECh
same_link	= byte ptr -0E6h
same		= byte ptr -0E5h
src_sb_link	= dword	ptr -0E4h
dst_sb_link	= dword	ptr -0E0h
tmp_dst_sb	= stat ptr -0DCh
tmp_src_sb	= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 10Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+src_name],	eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+src_sb], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+dst_name],	eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+dst_sb], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+x], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+return_now], eax
		mov	eax, [ebp+arg_18]
		mov	[ebp+unlink_src], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+src_sb]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001897
		mov	eax, [ebp+src_sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001897
		mov	eax, 1
		jmp	short loc_800189C
; ---------------------------------------------------------------------------

loc_8001897:				; CODE XREF: same_file_ok+8Cj
					; same_file_ok+C2j
		mov	eax, 0

loc_800189C:				; CODE XREF: same_file_ok+C9j
		mov	[ebp+same], al
		and	[ebp+same], 1
		mov	eax, [ebp+return_now]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+unlink_src]
		mov	byte ptr [eax],	0
		cmp	[ebp+same], 0
		jz	short loc_80018E5
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	short loc_80018E5
		mov	eax, [ebp+return_now]
		mov	byte ptr [eax],	1
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_80018E5:				; CODE XREF: same_file_ok+F6j
					; same_file_ok+104j
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jnz	loc_8001978
		movzx	eax, [ebp+same]
		mov	[ebp+same_link], al
		mov	eax, [ebp+src_sb]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_800195B
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_800195B
		sub	esp, 8
		push	[ebp+dst_name]
		push	[ebp+src_name]
		call	same_name
		add	esp, 10h
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		and	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_800195B:				; CODE XREF: same_file_ok+14Bj
					; same_file_ok+160j
		mov	eax, [ebp+src_sb]
		mov	[ebp+src_sb_link], eax
		mov	eax, [ebp+dst_sb]
		mov	[ebp+dst_sb_link], eax
		jmp	loc_8001AAD
; ---------------------------------------------------------------------------

loc_8001978:				; CODE XREF: same_file_ok+125j
		movzx	eax, [ebp+same]
		xor	eax, 1
		test	al, al
		jz	short loc_8001990
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001990:				; CODE XREF: same_file_ok+1B8j
		sub	esp, 8
		lea	eax, [ebp+tmp_dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80019C5
		sub	esp, 8
		lea	eax, [ebp+tmp_src_sb]
		push	eax
		push	[ebp+src_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_80019CF

loc_80019C5:				; CODE XREF: same_file_ok+1DEj
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_80019CF:				; CODE XREF: same_file_ok+1F7j
		lea	eax, [ebp+tmp_src_sb]
		mov	[ebp+src_sb_link], eax
		lea	eax, [ebp+tmp_dst_sb]
		mov	[ebp+dst_sb_link], eax
		mov	eax, [ebp+src_sb_link]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb_link]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001A59
		mov	eax, [ebp+src_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001A59
		mov	eax, 1
		jmp	short loc_8001A5E
; ---------------------------------------------------------------------------

loc_8001A59:				; CODE XREF: same_file_ok+24Ej
					; same_file_ok+284j
		mov	eax, 0

loc_8001A5E:				; CODE XREF: same_file_ok+28Bj
		mov	[ebp+same_link], al
		and	[ebp+same_link], 1
		mov	eax, [ebp+src_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8001AAD
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8001AAD
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jz	short loc_8001AAD
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001AAD:				; CODE XREF: same_file_ok+1A7j
					; same_file_ok+2B2j ...
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8001B55
		movzx	eax, [ebp+same_link]
		xor	eax, 1
		test	al, al
		jz	short loc_8001B28
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	short loc_8001B1E
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jz	short loc_8001B1E
		mov	eax, [ebp+src_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8001B1E
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_8001B1E
		mov	eax, 0
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001B1E:				; CODE XREF: same_file_ok+30Ej
					; same_file_ok+31Cj ...
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001B28:				; CODE XREF: same_file_ok+2FDj
		sub	esp, 8
		push	[ebp+dst_name]
		push	[ebp+src_name]
		call	same_name
		add	esp, 10h
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		and	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001B55:				; CODE XREF: same_file_ok+2EBj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jnz	short loc_8001B71
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jz	short loc_8001BEF

loc_8001B71:				; CODE XREF: same_file_ok+395j
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8001B90
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001B90:				; CODE XREF: same_file_ok+3B8j
		cmp	[ebp+same_link], 0
		jz	short loc_8001BEF
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+14h]
		cmp	eax, 1
		jbe	short loc_8001BEF
		sub	esp, 8
		push	[ebp+dst_name]
		push	[ebp+src_name]
		call	same_name
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001BEF
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8001BE5
		mov	eax, [ebp+unlink_src]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+return_now]
		mov	byte ptr [eax],	1

loc_8001BE5:				; CODE XREF: same_file_ok+405j
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001BEF:				; CODE XREF: same_file_ok+3A3j
					; same_file_ok+3CBj ...
		mov	eax, [ebp+src_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	loc_8001CBA
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	loc_8001CBA
		mov	eax, [ebp+src_sb_link]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb_link]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001C8F
		mov	eax, [ebp+src_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+dst_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+var_10C]
		xor	ecx, edx
		xor	eax, [ebp+var_110]
		or	eax, ecx
		test	eax, eax
		jz	short loc_8001C99

loc_8001C8F:				; CODE XREF: same_file_ok+48Bj
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001C99:				; CODE XREF: same_file_ok+4C1j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	short loc_8001CBA
		mov	eax, [ebp+return_now]
		mov	byte ptr [eax],	1
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001CBA:				; CODE XREF: same_file_ok+436j
					; same_file_ok+44Fj ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jz	short loc_8001D21
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8001D21
		mov	eax, [ebp+dst_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ebp+var_110], eax
		mov	[ebp+var_10C], edx
		mov	eax, [ebp+src_sb_link]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	edi, [ebp+var_110]
		xor	edi, eax
		mov	ebx, edi
		mov	edi, [ebp+var_10C]
		xor	edi, edx
		mov	esi, edi
		mov	eax, ebx
		or	eax, esi
		test	eax, eax
		setz	al
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001D21:				; CODE XREF: same_file_ok+4FAj
					; same_file_ok+50Fj
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jnz	loc_8001E38
		mov	eax, [ebp+src_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_8001D62
		mov	edx, [ebp+src_sb_link]
		lea	eax, [ebp+tmp_src_sb]
		mov	ebx, edx
		mov	edx, 18h
		mov	edi, eax
		mov	esi, ebx
		mov	ecx, edx
		rep movsd
		jmp	short loc_8001D85
; ---------------------------------------------------------------------------

loc_8001D62:				; CODE XREF: same_file_ok+57Aj
		sub	esp, 8
		lea	eax, [ebp+tmp_src_sb]
		push	eax
		push	[ebp+src_name]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001D85
		mov	eax, 1
		jmp	loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001D85:				; CODE XREF: same_file_ok+594j
					; same_file_ok+5ADj
		mov	eax, [ebp+dst_sb_link]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_8001DB7
		mov	edx, [ebp+dst_sb_link]
		lea	eax, [ebp+tmp_dst_sb]
		mov	ebx, edx
		mov	edx, 18h
		mov	edi, eax
		mov	esi, ebx
		mov	ecx, edx
		rep movsd
		jmp	short loc_8001DDA
; ---------------------------------------------------------------------------

loc_8001DB7:				; CODE XREF: same_file_ok+5CCj
		sub	esp, 8
		lea	eax, [ebp+tmp_dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001DDA
		mov	eax, 1
		jmp	short loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001DDA:				; CODE XREF: same_file_ok+5E9j
					; same_file_ok+605j
		mov	ecx, dword ptr [ebp+tmp_src_sb.st_ino]
		mov	ebx, dword ptr [ebp+tmp_src_sb.st_ino+4]
		mov	eax, dword ptr [ebp+tmp_dst_sb.st_ino]
		mov	edx, dword ptr [ebp+tmp_dst_sb.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8001E13
		mov	ecx, dword ptr [ebp+tmp_src_sb.st_dev]
		mov	ebx, dword ptr [ebp+tmp_src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+tmp_dst_sb.st_dev]
		mov	edx, dword ptr [ebp+tmp_dst_sb.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8001E1A

loc_8001E13:				; CODE XREF: same_file_ok+627j
		mov	eax, 1
		jmp	short loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001E1A:				; CODE XREF: same_file_ok+645j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	short loc_8001E38
		mov	eax, [ebp+return_now]
		mov	byte ptr [eax],	1
		mov	eax, 1
		jmp	short loc_8001E3D
; ---------------------------------------------------------------------------

loc_8001E38:				; CODE XREF: same_file_ok+561j
					; same_file_ok+65Aj
		mov	eax, 0

loc_8001E3D:				; CODE XREF: same_file_ok+114j
					; same_file_ok+18Aj ...
		mov	ebx, [ebp+var_1C]
		xor	ebx, large gs:14h
		jz	short loc_8001E4E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001E4E:				; CODE XREF: same_file_ok+67Bj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
same_file_ok	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	writable_destination(const char	*file, mode_t mode)
writable_destination proc near		; CODE XREF: overwrite_prompt+2Dp
					; abandon_move+63p

file		= dword	ptr  8
mode		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_8001E88
		call	can_write_any_file
		test	al, al
		jnz	short loc_8001E88
		sub	esp, 8
		push	2
		push	[ebp+file]
		call	euidaccess
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001E8F

loc_8001E88:				; CODE XREF: writable_destination+13j
					; writable_destination+1Cj
		mov	eax, 1
		jmp	short loc_8001E94
; ---------------------------------------------------------------------------

loc_8001E8F:				; CODE XREF: writable_destination+30j
		mov	eax, 0

loc_8001E94:				; CODE XREF: writable_destination+37j
		and	eax, 1
		leave
		retn
writable_destination endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl overwrite_prompt(const char *dst_name, const stat *dst_sb)
overwrite_prompt proc near		; CODE XREF: abandon_move+7Bp
					; copy_internal+6A3p

dst_sb		= dword	ptr -30h
dst_name	= dword	ptr -2Ch
perms		= byte ptr -28h
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+dst_name],	eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+dst_sb], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; file
		call	writable_destination
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001F42
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		sub	esp, 8
		lea	edx, [ebp+perms]
		push	edx
		push	eax
		call	strmode
		add	esp, 10h
		mov	[ebp+perms+0Ah], 0
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		and	eax, 0FFFh
		mov	esi, eax
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	edi, eax
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSTryToOverwrit ; "%s: try to overwrite %s, overriding mod"...
		call	gettext
		add	esp, 10h
		mov	ecx, eax
		mov	eax, ds:stderr
		sub	esp, 8
		lea	edx, [ebp+perms]
		add	edx, 1
		push	edx
		push	esi
		push	edi
		push	ebx
		push	ecx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 20h
		jmp	short loc_8001F7B
; ---------------------------------------------------------------------------

loc_8001F42:				; CODE XREF: overwrite_prompt+3Aj
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSOverwriteS? ; "%s: overwrite %s? "
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h

loc_8001F7B:				; CODE XREF: overwrite_prompt+A7j
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8001F8D
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001F8D:				; CODE XREF: overwrite_prompt+EDj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
overwrite_prompt endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl dest_info_init(cp_options *x)
		public dest_info_init
dest_info_init	proc near

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset triple_free
		push	offset triple_compare
		push	offset triple_hash
		push	0
		push	3Dh
		call	hash_initialize
		add	esp, 20h
		mov	edx, eax
		mov	eax, [ebp+x]
		mov	[eax+34h], edx
		nop
		leave
		retn
dest_info_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl src_info_init(cp_options	*x)
		public src_info_init
src_info_init	proc near

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset triple_free
		push	offset triple_compare
		push	offset triple_hash_no_name
		push	0
		push	3Dh
		call	hash_initialize
		add	esp, 20h
		mov	edx, eax
		mov	eax, [ebp+x]
		mov	[eax+38h], edx
		nop
		leave
		retn
src_info_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	abandon_move(const cp_options *x, const	char *dst_name,	const stat *dst_sb)
abandon_move	proc near		; CODE XREF: copy_internal+582p

x		= dword	ptr  8
dst_name	= dword	ptr  0Ch
dst_sb		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jnz	short loc_800201D
		push	offset __PRETTY_FUNCTION___5661	; "abandon_move"
		push	4A7h		; line
		push	offset file	; "copy.c"
		push	offset assertion ; "x->move_mode"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800201D:				; CODE XREF: abandon_move+Fj
		mov	eax, [ebp+x]
		mov	eax, [eax+8]
		cmp	eax, 2
		jz	short loc_8002082
		mov	eax, [ebp+x]
		mov	eax, [eax+8]
		cmp	eax, 3
		jz	short loc_8002065
		mov	eax, [ebp+x]
		mov	eax, [eax+8]
		cmp	eax, 4
		jnz	short loc_8002089
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Bh]
		test	al, al
		jz	short loc_8002089
		mov	eax, [ebp+dst_sb]
		mov	eax, [eax+10h]
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; file
		call	writable_destination
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8002089

loc_8002065:				; CODE XREF: abandon_move+3Ej
		sub	esp, 8
		push	[ebp+dst_sb]	; dst_sb
		push	[ebp+dst_name]	; dst_name
		call	overwrite_prompt
		add	esp, 10h
		call	yesno
		xor	eax, 1
		test	al, al
		jz	short loc_8002089

loc_8002082:				; CODE XREF: abandon_move+33j
		mov	eax, 1
		jmp	short loc_800208E
; ---------------------------------------------------------------------------

loc_8002089:				; CODE XREF: abandon_move+49j
					; abandon_move+54j ...
		mov	eax, 0

loc_800208E:				; CODE XREF: abandon_move+94j
		and	eax, 1
		leave
		retn
abandon_move	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl emit_verbose(const char *src, const char	*dst, const char *backup_dst_name)
emit_verbose	proc near		; CODE XREF: copy_internal+DF0p
					; copy_internal+122Bp ...

var_4		= dword	ptr -4
src		= dword	ptr  8
dst		= dword	ptr  0Ch
backup_dst_name	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		sub	esp, 8
		push	[ebp+dst]
		push	1
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 8
		push	[ebp+src]
		push	0
		call	quote_n
		add	esp, 10h
		sub	esp, 4
		push	ebx
		push	eax
		push	offset format	; "%s -> %s"
		call	printf
		add	esp, 10h
		cmp	[ebp+backup_dst_name], 0
		jz	short loc_8002101
		sub	esp, 0Ch
		push	[ebp+backup_dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aBackupS	; " (backup: %s)"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8002101:				; CODE XREF: emit_verbose+3Fj
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_verbose	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void restore_default_fscreatecon_or_die()
restore_default_fscreatecon_or_die proc	near ; CODE XREF: copy_internal+1F6Dp
					; copy_internal+24B7p

var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		sub	esp, 0Ch
		push	0		; con
		call	setfscreatecon
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002154
		sub	esp, 0Ch
		push	offset aFailedToRestor ; "failed to restore the	default	file crea"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002154:				; CODE XREF: restore_default_fscreatecon_or_die+16j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
restore_default_fscreatecon_or_die endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_internal(const char *src_name, const char *dst_name, _Bool	new_dst, dev_t device, dir_list	*ancestors, const cp_options *x, _Bool command_line_arg, _Bool *first_dir_created_per_command_line_arg,	_Bool *copy_into_self, _Bool *rename_succeeded)
copy_internal	proc near		; CODE XREF: copy_dir+176p copy+97p

var_240		= timespec ptr -240h
rename_succeeded= dword	ptr -234h
copy_into_self	= dword	ptr -230h
first_dir_created_per_command_line_arg=	dword ptr -22Ch
command_line_arg= byte ptr -228h
x		= dword	ptr -224h
device		= qword	ptr -220h
ancestors	= dword	ptr -218h
new_dst		= byte ptr -214h
dst_name	= dword	ptr -210h
src_name	= dword	ptr -20Ch
restore_dst_mode= byte ptr -1FFh
backup_succeeded= byte ptr -1FEh
delayed_ok	= byte ptr -1FDh
copied_as_regular= byte	ptr -1FCh
dest_is_symlink	= byte ptr -1FBh
have_dst_lstat	= byte ptr -1FAh
lstat_ok	= byte ptr -1F9h
link_failed	= byte ptr -1F8h
same_link	= byte ptr -1F7h
use_stat	= byte ptr -1F6h
in_current_dir	= byte ptr -1F5h
src_mode	= dword	ptr -1F4h
dst_mode	= dword	ptr -1F0h
omitted_permissions= dword ptr -1ECh
earlier_file	= dword	ptr -1E8h
dst_backup	= dword	ptr -1E4h
dst_lstat_sb	= dword	ptr -1E0h
options		= dword	ptr -1DCh
tmp_backup	= dword	ptr -1D8h
fmt		= dword	ptr -1D4h
__old		= dword	ptr -1D0h
__len		= dword	ptr -1CCh
__new		= dword	ptr -1C8h
dst_mode_bits	= dword	ptr -1C4h
dir		= dword	ptr -1C0h
dst_parent	= dword	ptr -1BCh
src_link_val	= dword	ptr -1B8h
saved_errno	= dword	ptr -1B4h
dest_link_val	= dword	ptr -1B0h
src_sb		= stat ptr -1ACh
dst_sb		= stat ptr -14Ch
dot_sb		= stat ptr -0ECh
sb		= stat ptr -8Ch
timespec	= timespec ptr -2Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h
arg_24		= dword	ptr  2Ch
arg_28		= dword	ptr  30h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 23Ch
		mov	edx, [ebp+arg_8]
		mov	eax, [ebp+arg_1C]
		mov	ecx, [ebp+arg_0]
		mov	[ebp+src_name],	ecx
		mov	ecx, [ebp+arg_4]
		mov	[ebp+dst_name],	ecx
		mov	[ebp+new_dst], dl
		mov	edx, [ebp+arg_C]
		mov	dword ptr [ebp+device],	edx
		mov	edx, [ebp+arg_10]
		mov	dword ptr [ebp+device+4], edx
		mov	edx, [ebp+arg_14]
		mov	[ebp+ancestors], edx
		mov	edx, [ebp+arg_18]
		mov	[ebp+x], edx
		mov	[ebp+command_line_arg],	al
		mov	eax, [ebp+arg_20]
		mov	[ebp+first_dir_created_per_command_line_arg], eax
		mov	eax, [ebp+arg_24]
		mov	[ebp+copy_into_self], eax
		mov	eax, [ebp+arg_28]
		mov	[ebp+rename_succeeded],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+restore_dst_mode],	0
		mov	[ebp+earlier_file], 0
		mov	[ebp+dst_backup], 0
		mov	[ebp+backup_succeeded],	0
		mov	[ebp+copied_as_regular], 0
		mov	[ebp+dest_is_symlink], 0
		mov	[ebp+have_dst_lstat], 0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_800222B
		cmp	[ebp+rename_succeeded],	0
		jz	short loc_800222B
		mov	eax, [ebp+rename_succeeded]
		mov	byte ptr [eax],	0

loc_800222B:				; CODE XREF: copy_internal+BDj
					; copy_internal+C6j
		mov	eax, [ebp+copy_into_self]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jnz	short loc_8002261
		sub	esp, 8
		lea	eax, [ebp+src_sb]
		push	eax
		push	[ebp+src_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_800227E
; ---------------------------------------------------------------------------

loc_8002261:				; CODE XREF: copy_internal+E6j
		sub	esp, 8
		lea	eax, [ebp+src_sb]
		push	eax
		push	[ebp+src_name]
		call	stat64
		add	esp, 10h
		test	eax, eax
		setnz	al

loc_800227E:				; CODE XREF: copy_internal+105j
		test	al, al
		jz	short loc_80022C5
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotStatS ; "cannot stat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80022C5:				; CODE XREF: copy_internal+126j
		mov	eax, [ebp+src_sb.st_mode]
		mov	[ebp+src_mode],	eax
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_800232F
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+26h]
		xor	eax, 1
		test	al, al
		jz	short loc_800232F
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aOmittingDirect ; "omitting directory %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800232F:				; CODE XREF: copy_internal+187j
					; copy_internal+198j
		cmp	[ebp+command_line_arg],	0
		jz	loc_80023DD
		mov	eax, [ebp+src_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_80023BB
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80023BB
		mov	eax, [ebp+x]
		mov	eax, [eax+38h]
		sub	esp, 4
		lea	edx, [ebp+src_sb]
		push	edx
		push	[ebp+src_name]
		push	eax
		call	seen_file
		add	esp, 10h
		test	al, al
		jz	short loc_80023BB
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWarningSourceF ; "warning: source file %s specified more "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80023BB:				; CODE XREF: copy_internal+1F2j
					; copy_internal+1FEj ...
		mov	eax, [ebp+x]
		mov	eax, [eax+38h]
		sub	esp, 4
		lea	edx, [ebp+src_sb]
		push	edx
		push	[ebp+src_name]
		push	eax
		call	record_file
		add	esp, 10h

loc_80023DD:				; CODE XREF: copy_internal+1DCj
		movzx	eax, [ebp+new_dst]
		xor	eax, 1
		test	al, al
		jz	loc_8002DD5
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8002433
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+14h]
		test	al, al
		jz	short loc_800248A
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_800248A
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_800248A

loc_8002433:				; CODE XREF: copy_internal+2A5j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	short loc_800248A
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+28h]
		xor	eax, 1
		test	al, al
		jz	short loc_800248A
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		xor	eax, 1
		test	al, al
		jz	short loc_800248A
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_800248A
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+15h]
		xor	eax, 1
		test	al, al
		jz	short loc_800248A
		mov	eax, 1
		jmp	short loc_800248F
; ---------------------------------------------------------------------------

loc_800248A:				; CODE XREF: copy_internal+2B3j
					; copy_internal+2C5j ...
		mov	eax, 0

loc_800248F:				; CODE XREF: copy_internal+32Ej
		mov	[ebp+use_stat],	al
		and	[ebp+use_stat],	1
		cmp	[ebp+use_stat],	0
		jz	short loc_80024C4
		sub	esp, 8
		lea	eax, [ebp+dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	stat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_80024E1
; ---------------------------------------------------------------------------

loc_80024C4:				; CODE XREF: copy_internal+349j
		sub	esp, 8
		lea	eax, [ebp+dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		setnz	al

loc_80024E1:				; CODE XREF: copy_internal+368j
		test	al, al
		jz	short loc_8002540
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jz	short loc_8002534
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotStatS ; "cannot stat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002534:				; CODE XREF: copy_internal+395j
		mov	[ebp+new_dst], 1
		jmp	loc_8002DD5
; ---------------------------------------------------------------------------

loc_8002540:				; CODE XREF: copy_internal+389j
		movzx	eax, [ebp+use_stat]
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+have_dst_lstat], al
		and	[ebp+have_dst_lstat], 1
		sub	esp, 4
		lea	eax, [ebp+sb]
		push	eax		; unlink_src
		lea	eax, [ebp+dot_sb]
		push	eax		; return_now
		push	[ebp+x]		; x
		lea	eax, [ebp+dst_sb]
		push	eax		; dst_sb
		push	[ebp+dst_name]	; dst_name
		lea	eax, [ebp+src_sb]
		push	eax		; src_sb
		push	[ebp+src_name]	; src_name
		call	same_file_ok
		add	esp, 20h
		xor	eax, 1
		test	al, al
		jz	short loc_80025F5
		sub	esp, 8
		push	[ebp+dst_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+src_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSAndSAreTheSam ; "%s and %s are	the same file"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80025F5:				; CODE XREF: copy_internal+443j
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	loc_80026B4
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+29h]
		test	al, al
		jz	loc_80026B4
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	short loc_8002667
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jnz	short loc_8002660
		mov	ecx, dword ptr [ebp+dst_sb.st_dev]
		mov	ebx, dword ptr [ebp+dst_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_dev]
		mov	edx, dword ptr [ebp+src_sb.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8002667

loc_8002660:				; CODE XREF: copy_internal+4E0j
		mov	eax, 1
		jmp	short loc_800266C
; ---------------------------------------------------------------------------

loc_8002667:				; CODE XREF: copy_internal+4CFj
					; copy_internal+504j
		mov	eax, 0

loc_800266C:				; CODE XREF: copy_internal+50Bj
		mov	[ebp+options], eax
		push	[ebp+options]
		lea	eax, [ebp+src_sb]
		push	eax
		lea	eax, [ebp+dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	utimecmp
		add	esp, 10h
		test	eax, eax
		js	short loc_80026B4
		cmp	[ebp+rename_succeeded],	0
		jz	short loc_80026AA
		mov	eax, [ebp+rename_succeeded]
		mov	byte ptr [eax],	1

loc_80026AA:				; CODE XREF: copy_internal+545j
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80026B4:				; CODE XREF: copy_internal+4ABj
					; copy_internal+4BDj ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	loc_80027BF
		sub	esp, 4
		lea	eax, [ebp+dst_sb]
		push	eax		; dst_sb
		push	[ebp+dst_name]	; dst_name
		push	[ebp+x]		; x
		call	abandon_move
		add	esp, 10h
		test	al, al
		jnz	short loc_8002708
		movzx	eax, byte ptr [ebp+sb.st_dev]
		test	al, al
		jz	short loc_800276D
		sub	esp, 0Ch
		push	[ebp+src_name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800276D

loc_8002708:				; CODE XREF: copy_internal+58Cj
		cmp	[ebp+rename_succeeded],	0
		jz	short loc_800271A
		mov	eax, [ebp+rename_succeeded]
		mov	byte ptr [eax],	1

loc_800271A:				; CODE XREF: copy_internal+5B5j
		movzx	eax, byte ptr [ebp+sb.st_dev]
		test	al, al
		jz	short loc_8002763
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8002763
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aRemovedS ; "removed %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8002763:				; CODE XREF: copy_internal+5C9j
					; copy_internal+5D7j
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800276D:				; CODE XREF: copy_internal+597j
					; copy_internal+5ACj
		movzx	eax, byte ptr [ebp+sb.st_dev]
		test	al, al
		jz	loc_800281B
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotRemoveS ;	"cannot	remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80027BF:				; CODE XREF: copy_internal+566j
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_800281B
		mov	eax, [ebp+x]
		mov	eax, [eax+8]
		cmp	eax, 2
		jz	short loc_8002811
		mov	eax, [ebp+x]
		mov	eax, [eax+8]
		cmp	eax, 3
		jnz	short loc_800281B
		sub	esp, 8
		lea	eax, [ebp+dst_sb]
		push	eax		; dst_sb
		push	[ebp+dst_name]	; dst_name
		call	overwrite_prompt
		add	esp, 10h
		call	yesno
		xor	eax, 1
		test	al, al
		jz	short loc_800281B

loc_8002811:				; CODE XREF: copy_internal+683j
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800281B:				; CODE XREF: copy_internal+61Cj
					; copy_internal+675j ...
		movzx	eax, byte ptr [ebp+dot_sb.st_dev]
		test	al, al
		jz	short loc_8002830
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002830:				; CODE XREF: copy_internal+6CAj
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	loc_800295E
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80028C8
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8002872
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80028C8

loc_8002872:				; CODE XREF: copy_internal+70Aj
		sub	esp, 8
		push	[ebp+src_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotOverwrit ; "cannot overwrite non-directory %s with "...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80028C8:				; CODE XREF: copy_internal+6FCj
					; copy_internal+716j
		cmp	[ebp+command_line_arg],	0
		jz	loc_800295E
		mov	eax, [ebp+x]
		mov	eax, [eax]
		cmp	eax, 3
		jz	short loc_800295E
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		sub	esp, 4
		lea	edx, [ebp+dst_sb]
		push	edx
		push	[ebp+dst_name]
		push	eax
		call	seen_file
		add	esp, 10h
		test	al, al
		jz	short loc_800295E
		sub	esp, 8
		push	[ebp+src_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWillNotOverwri ; "will not overwrite just-created %s with"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800295E:				; CODE XREF: copy_internal+6E6j
					; copy_internal+775j ...
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_80029D7
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80029D7
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_800299C
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80029D7

loc_800299C:				; CODE XREF: copy_internal+834j
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotOverwr_0 ; "cannot overwrite directory %s	with non-"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80029D7:				; CODE XREF: copy_internal+814j
					; copy_internal+826j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	loc_8002A6F
		mov	eax, [ebp+src_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_8002A6F
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8002A6F
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8002A6F
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+src_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotMoveDire ; "cannot move directory	onto non-director"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002A6F:				; CODE XREF: copy_internal+889j
					; copy_internal+89Fj ...
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8002CB2
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	last_component
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; file_name
		call	dot_or_dotdot
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	loc_8002CB2
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jnz	short loc_8002ACB
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	loc_8002CB2

loc_8002ACB:				; CODE XREF: copy_internal+959j
		mov	eax, [ebp+x]
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	[ebp+dst_name]
		call	find_backup_file_name
		add	esp, 10h
		mov	[ebp+tmp_backup], eax
		sub	esp, 8
		push	[ebp+src_name]	; s2
		push	[ebp+tmp_backup] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8002B9A
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8002B2A
		sub	esp, 0Ch
		push	offset aBackingUpSWoul ; "backing up %s	would destroy source;  %s"...
		call	gettext
		add	esp, 10h
		jmp	short loc_8002B3A
; ---------------------------------------------------------------------------

loc_8002B2A:				; CODE XREF: copy_internal+9BCj
		sub	esp, 0Ch
		push	offset aBackingUpSWo_0 ; "backing up %s	would destroy source;  %s"...
		call	gettext
		add	esp, 10h

loc_8002B3A:				; CODE XREF: copy_internal+9CEj
		mov	[ebp+fmt], eax
		sub	esp, 8
		push	[ebp+src_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	eax
		push	[ebp+fmt]	; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	[ebp+tmp_backup] ; ptr
		call	free
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002B9A:				; CODE XREF: copy_internal+9AAj
		mov	eax, [ebp+tmp_backup]
		mov	[ebp+__old], eax
		sub	esp, 0Ch
		push	[ebp+__old]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		mov	[ebp+__len], eax
		mov	eax, [ebp+__len]
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	edi, 10h
		mov	edx, 0
		div	edi
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+__new], eax
		sub	esp, 4
		push	[ebp+__len]	; n
		push	[ebp+__old]	; src
		push	[ebp+__new]	; dest
		call	memcpy
		add	esp, 10h
		mov	[ebp+dst_backup], eax
		sub	esp, 0Ch
		push	[ebp+tmp_backup] ; ptr
		call	free
		add	esp, 10h
		sub	esp, 8
		push	[ebp+dst_backup] ; new
		push	[ebp+dst_name]	; old
		call	rename
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002C9F
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jz	short loc_8002C93
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotBackupS ;	"cannot	backup %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002C93:				; CODE XREF: copy_internal+AF4j
		mov	[ebp+dst_backup], 0
		jmp	short loc_8002CA6
; ---------------------------------------------------------------------------

loc_8002C9F:				; CODE XREF: copy_internal+AE8j
		mov	[ebp+backup_succeeded],	1

loc_8002CA6:				; CODE XREF: copy_internal+B43j
		mov	[ebp+new_dst], 1
		jmp	loc_8002DD5
; ---------------------------------------------------------------------------

loc_8002CB2:				; CODE XREF: copy_internal+91Fj
					; copy_internal+947j ...
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	loc_8002DD5
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	loc_8002DD5
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+15h]
		test	al, al
		jnz	short loc_8002D2C
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Fh]
		test	al, al
		jz	short loc_8002D04
		mov	eax, [ebp+dst_sb.st_nlink]
		cmp	eax, 1
		ja	short loc_8002D2C

loc_8002D04:				; CODE XREF: copy_internal+B9Dj
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jnz	loc_8002DD5
		mov	eax, [ebp+src_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	loc_8002DD5

loc_8002D2C:				; CODE XREF: copy_internal+B8Fj
					; copy_internal+BA8j
		sub	esp, 0Ch
		push	[ebp+dst_name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002D90
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jz	short loc_8002D90
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotRemoveS ;	"cannot	remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002D90:				; CODE XREF: copy_internal+BE5j
					; copy_internal+BF1j
		mov	[ebp+new_dst], 1
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8002DD5
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aRemovedS ; "removed %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8002DD5:				; CODE XREF: copy_internal+28Fj
					; copy_internal+3E1j ...
		cmp	[ebp+command_line_arg],	0
		jz	loc_8002F04
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		test	eax, eax
		jz	loc_8002F04
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	loc_8002F04
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_8002F04
		mov	[ebp+lstat_ok],	1
		cmp	[ebp+have_dst_lstat], 0
		jz	short loc_8002E36
		lea	eax, [ebp+dst_sb]
		mov	[ebp+dst_lstat_sb], eax
		jmp	short loc_8002E67
; ---------------------------------------------------------------------------

loc_8002E36:				; CODE XREF: copy_internal+CCCj
		sub	esp, 8
		lea	eax, [ebp+sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002E60
		lea	eax, [ebp+sb]
		mov	[ebp+dst_lstat_sb], eax
		jmp	short loc_8002E67
; ---------------------------------------------------------------------------

loc_8002E60:				; CODE XREF: copy_internal+CF6j
		mov	[ebp+lstat_ok],	0

loc_8002E67:				; CODE XREF: copy_internal+CDAj
					; copy_internal+D04j
		cmp	[ebp+lstat_ok],	0
		jz	loc_8002F04
		mov	eax, [ebp+dst_lstat_sb]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8002F04
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		sub	esp, 4
		push	[ebp+dst_lstat_sb]
		push	[ebp+dst_name]
		push	eax
		call	seen_file
		add	esp, 10h
		test	al, al
		jz	short loc_8002F04
		sub	esp, 8
		push	[ebp+dst_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+src_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWillNotCopySTh ; "will not copy	%s through just-created	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8002F04:				; CODE XREF: copy_internal+C82j
					; copy_internal+C93j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8002F52
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8002F52
		cmp	[ebp+backup_succeeded],	0
		jz	short loc_8002F35
		mov	eax, [ebp+dst_backup]
		jmp	short loc_8002F3A
; ---------------------------------------------------------------------------

loc_8002F35:				; CODE XREF: copy_internal+DD1j
		mov	eax, 0

loc_8002F3A:				; CODE XREF: copy_internal+DD9j
		sub	esp, 4
		push	eax		; backup_dst_name
		push	[ebp+dst_name]	; dst
		push	[ebp+src_name]	; src
		call	emit_verbose
		add	esp, 10h

loc_8002F52:				; CODE XREF: copy_internal+DB6j
					; copy_internal+DC8j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8002F9A
		mov	eax, [ebp+src_sb.st_nlink]
		cmp	eax, 1
		jnz	short loc_8002F9A
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	src_to_dest_lookup
		add	esp, 10h
		mov	[ebp+earlier_file], eax
		jmp	loc_80030A9
; ---------------------------------------------------------------------------

loc_8002F9A:				; CODE XREF: copy_internal+E04j
					; copy_internal+E0Fj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Fh]
		test	al, al
		jz	short loc_8003021
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		xor	eax, 1
		test	al, al
		jz	short loc_8003021
		mov	eax, [ebp+src_sb.st_nlink]
		cmp	eax, 1
		ja	short loc_8002FE9
		cmp	[ebp+command_line_arg],	0
		jz	short loc_8002FDB
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 3
		jz	short loc_8002FE9

loc_8002FDB:				; CODE XREF: copy_internal+E71j
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 4
		jnz	short loc_8003021

loc_8002FE9:				; CODE XREF: copy_internal+E68j
					; copy_internal+E7Fj
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		sub	esp, 0Ch
		push	ebx
		push	ecx
		push	edx
		push	eax
		push	[ebp+dst_name]
		call	remember_copied
		add	esp, 20h
		mov	[ebp+earlier_file], eax
		jmp	loc_80030A9
; ---------------------------------------------------------------------------

loc_8003021:				; CODE XREF: copy_internal+E4Cj
					; copy_internal+E5Dj ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+26h]
		test	al, al
		jz	short loc_80030A9
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80030A9
		cmp	[ebp+command_line_arg],	0
		jz	short loc_800307F
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		sub	esp, 0Ch
		push	ebx
		push	ecx
		push	edx
		push	eax
		push	[ebp+dst_name]
		call	remember_copied
		add	esp, 20h
		mov	[ebp+earlier_file], eax
		jmp	short loc_80030A9
; ---------------------------------------------------------------------------

loc_800307F:				; CODE XREF: copy_internal+EEEj
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	src_to_dest_lookup
		add	esp, 10h
		mov	[ebp+earlier_file], eax

loc_80030A9:				; CODE XREF: copy_internal+E3Bj
					; copy_internal+EC2j ...
		cmp	[ebp+earlier_file], 0
		jz	loc_800330E
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	loc_80031A4
		sub	esp, 8
		push	[ebp+earlier_file]
		push	[ebp+src_name]
		call	same_name
		add	esp, 10h
		test	al, al
		jz	short loc_8003141
		mov	eax, ds:top_level_dst_name
		sub	esp, 8
		push	eax
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		mov	eax, ds:top_level_src_name
		sub	esp, 8
		push	eax
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotCopyADir ; "cannot copy a	directory, %s, into itsel"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, [ebp+copy_into_self]
		mov	byte ptr [eax],	1
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003141:				; CODE XREF: copy_internal+F8Bj
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 4
		jz	loc_800330E
		sub	esp, 8
		push	[ebp+earlier_file]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWillNotCreateH ; "will not create hard link %s to directo"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_80031A4:				; CODE XREF: copy_internal+F6Cj
		sub	esp, 0Ch
		push	0
		push	[ebp+dst_name]
		push	0FFFFFF9Ch
		push	[ebp+earlier_file]
		push	0FFFFFF9Ch
		call	rpl_linkat
		add	esp, 20h
		test	eax, eax
		setnz	al
		mov	[ebp+link_failed], al
		cmp	[ebp+link_failed], 0
		jz	loc_80032A2
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 11h
		jnz	loc_80032A2
		sub	esp, 0Ch
		push	[ebp+dst_name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	short loc_800323C
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotRemoveS ;	"cannot	remove %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_800323C:				; CODE XREF: copy_internal+10A2j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_800327A
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aRemovedS ; "removed %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_800327A:				; CODE XREF: copy_internal+10EEj
		sub	esp, 0Ch
		push	0
		push	[ebp+dst_name]
		push	0FFFFFF9Ch
		push	[ebp+earlier_file]
		push	0FFFFFF9Ch
		call	rpl_linkat
		add	esp, 20h
		test	eax, eax
		setnz	al
		mov	[ebp+link_failed], al

loc_80032A2:				; CODE XREF: copy_internal+1079j
					; copy_internal+1089j
		cmp	[ebp+link_failed], 0
		jz	short loc_8003304
		sub	esp, 8
		push	[ebp+earlier_file]
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateHa ; "cannot create	hard link %s to	%s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003304:				; CODE XREF: copy_internal+114Fj
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800330E:				; CODE XREF: copy_internal+F56j
					; copy_internal+FF3j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	loc_8003583
		sub	esp, 8
		push	[ebp+dst_name]	; new
		push	[ebp+src_name]	; old
		call	rename
		add	esp, 10h
		test	eax, eax
		jnz	loc_80033D4
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_800338D
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_800338D
		cmp	[ebp+backup_succeeded],	0
		jz	short loc_8003370
		mov	eax, [ebp+dst_backup]
		jmp	short loc_8003375
; ---------------------------------------------------------------------------

loc_8003370:				; CODE XREF: copy_internal+120Cj
		mov	eax, 0

loc_8003375:				; CODE XREF: copy_internal+1214j
		sub	esp, 4
		push	eax		; backup_dst_name
		push	[ebp+dst_name]	; dst
		push	[ebp+src_name]	; src
		call	emit_verbose
		add	esp, 10h

loc_800338D:				; CODE XREF: copy_internal+11F1j
					; copy_internal+1203j
		cmp	[ebp+rename_succeeded],	0
		jz	short loc_800339F
		mov	eax, [ebp+rename_succeeded]
		mov	byte ptr [eax],	1

loc_800339F:				; CODE XREF: copy_internal+123Aj
		cmp	[ebp+command_line_arg],	0
		jz	short loc_80033CA
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		sub	esp, 4
		lea	edx, [ebp+src_sb]
		push	edx
		push	[ebp+dst_name]
		push	eax
		call	record_file
		add	esp, 10h

loc_80033CA:				; CODE XREF: copy_internal+124Cj
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80033D4:				; CODE XREF: copy_internal+11DFj
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_800343F
		mov	eax, ds:top_level_dst_name
		sub	esp, 8
		push	eax
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		mov	eax, ds:top_level_src_name
		sub	esp, 8
		push	eax
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotMoveSToA ; "cannot move %s to a subdirectory of its"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, [ebp+copy_into_self]
		mov	byte ptr [eax],	1
		mov	eax, 1
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800343F:				; CODE XREF: copy_internal+1284j
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 12h
		jz	loc_80034D1
		sub	esp, 8
		push	[ebp+dst_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+src_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotMoveSToS ; "cannot move %s to %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	forget_created
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80034D1:				; CODE XREF: copy_internal+12EFj
		sub	esp, 0Ch
		push	[ebp+dst_name]	; name
		call	unlink
		add	esp, 10h
		test	eax, eax
		jz	loc_800357C
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jz	loc_800357C
		sub	esp, 8
		push	[ebp+dst_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+src_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInterDeviceMov ; "inter-device move failed: %s to %s; una"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	forget_created
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_800357C:				; CODE XREF: copy_internal+138Aj
					; copy_internal+139Aj
		mov	[ebp+new_dst], 1

loc_8003583:				; CODE XREF: copy_internal+11C0j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+27h]
		test	al, al
		jz	short loc_80035A1
		mov	eax, [ebp+x]
		mov	eax, [eax+10h]
		and	eax, 0FFFh
		jmp	short loc_80035AC
; ---------------------------------------------------------------------------

loc_80035A1:				; CODE XREF: copy_internal+1435j
		mov	eax, [ebp+src_mode]
		and	eax, 0FFFh

loc_80035AC:				; CODE XREF: copy_internal+1445j
		mov	[ebp+dst_mode_bits], eax
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		xor	eax, 1
		test	al, al
		jz	short loc_80035E3
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80035DC
		mov	eax, 12h
		jmp	short loc_80035E8
; ---------------------------------------------------------------------------

loc_80035DC:				; CODE XREF: copy_internal+1479j
		mov	eax, 0
		jmp	short loc_80035E8
; ---------------------------------------------------------------------------

loc_80035E3:				; CODE XREF: copy_internal+1467j
		mov	eax, 3Fh

loc_80035E8:				; CODE XREF: copy_internal+1480j
					; copy_internal+1487j
		and	eax, [ebp+dst_mode_bits]
		mov	[ebp+omitted_permissions], eax
		mov	[ebp+delayed_ok], 1
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+21h]
		test	al, al
		jz	loc_8003779
		sub	esp, 8
		lea	eax, [ebp+sb]
		push	eax		; con
		push	[ebp+src_name]	; file
		call	lgetfilecon
		add	esp, 10h
		test	eax, eax
		js	loc_80036E1
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax		; con
		call	setfscreatecon
		add	esp, 10h
		test	eax, eax
		jns	loc_80036CA
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+25h]
		xor	eax, 1
		test	al, al
		jnz	short loc_8003666
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_80036A0

loc_8003666:				; CODE XREF: copy_internal+14FCj
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToSetDef ; "failed to set	default	file creation con"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80036A0:				; CODE XREF: copy_internal+150Aj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_80036CA
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80036CA:				; CODE XREF: copy_internal+14E7j
					; copy_internal+1552j
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h
		jmp	loc_8003779
; ---------------------------------------------------------------------------

loc_80036E1:				; CODE XREF: copy_internal+14CDj
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; err
		call	errno_unsupported
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_8003709
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8003779

loc_8003709:				; CODE XREF: copy_internal+159Fj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+25h]
		xor	eax, 1
		test	al, al
		jnz	short loc_8003728
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8003761

loc_8003728:				; CODE XREF: copy_internal+15BEj
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToGetSec ; "failed to get	security context of %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8003761:				; CODE XREF: copy_internal+15CCj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8003779
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8003779:				; CODE XREF: copy_internal+14ADj
					; copy_internal+1582j ...
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	loc_8003AA5
		sub	esp, 8
		push	[ebp+ancestors]	; ancestors
		lea	eax, [ebp+src_sb]
		push	eax		; sb
		call	is_ancestor
		add	esp, 10h
		test	al, al
		jz	short loc_80037E1
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotCopyCycl ; "cannot copy cyclic symbolic link %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_80037E1:				; CODE XREF: copy_internal+164Fj
		mov	eax, 10h
		sub	eax, 1
		add	eax, 23h
		mov	edi, 10h
		mov	edx, 0
		div	edi
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+dir], eax
		mov	eax, [ebp+dir]
		mov	edx, [ebp+ancestors]
		mov	[eax], edx
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		mov	ecx, [ebp+dir]
		mov	[ecx+4], eax
		mov	[ecx+8], edx
		mov	eax, dword ptr [ebp+src_sb.st_dev]
		mov	edx, dword ptr [ebp+src_sb.st_dev+4]
		mov	ecx, [ebp+dir]
		mov	[ecx+0Ch], eax
		mov	[ecx+10h], edx
		movzx	eax, [ebp+new_dst]
		test	al, al
		jnz	short loc_800386D
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	loc_8003A1A

loc_800386D:				; CODE XREF: copy_internal+16FBj
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+dst_mode_bits]
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; path
		call	mkdir
		add	esp, 10h
		test	eax, eax
		jz	short loc_80038CF
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateDi ; "cannot create	directory %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_80038CF:				; CODE XREF: copy_internal+1735j
		sub	esp, 8
		lea	eax, [ebp+dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003929
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotStatS ; "cannot stat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003929:				; CODE XREF: copy_internal+178Fj
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 1C0h
		cmp	eax, 1C0h
		jz	short loc_80039AD
		mov	eax, [ebp+dst_sb.st_mode]
		mov	[ebp+dst_mode],	eax
		mov	[ebp+restore_dst_mode],	1
		mov	eax, [ebp+dst_mode]
		or	eax, 1C0h
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; file
		call	chmod
		add	esp, 10h
		test	eax, eax
		jz	short loc_80039AD
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSettingPermiss ; "setting permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_80039AD:				; CODE XREF: copy_internal+17DFj
					; copy_internal+1813j
		mov	eax, [ebp+first_dir_created_per_command_line_arg]
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_80039F3
		mov	ecx, dword ptr [ebp+dst_sb.st_dev]
		mov	ebx, dword ptr [ebp+dst_sb.st_dev+4]
		mov	eax, dword ptr [ebp+dst_sb.st_ino]
		mov	edx, dword ptr [ebp+dst_sb.st_ino+4]
		sub	esp, 0Ch
		push	ebx
		push	ecx
		push	edx
		push	eax
		push	[ebp+dst_name]
		call	remember_copied
		add	esp, 20h
		mov	eax, [ebp+first_dir_created_per_command_line_arg]
		mov	byte ptr [eax],	1

loc_80039F3:				; CODE XREF: copy_internal+1861j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8003A1A
		sub	esp, 4
		push	0		; backup_dst_name
		push	[ebp+dst_name]	; dst
		push	[ebp+src_name]	; src
		call	emit_verbose
		add	esp, 10h

loc_8003A1A:				; CODE XREF: copy_internal+170Dj
					; copy_internal+18A5j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Bh]
		test	al, al
		jz	short loc_8003A5C
		mov	eax, dword ptr [ebp+device+4]
		or	eax, dword ptr [ebp+device]
		test	eax, eax
		jz	short loc_8003A5C
		mov	eax, dword ptr [ebp+src_sb.st_dev]
		mov	edx, dword ptr [ebp+src_sb.st_dev+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+device+4]
		xor	eax, dword ptr [ebp+device]
		or	eax, ecx
		test	eax, eax
		jnz	loc_800417F

loc_8003A5C:				; CODE XREF: copy_internal+18CCj
					; copy_internal+18DCj
		movzx	eax, [ebp+new_dst]
		movzx	eax, al
		push	[ebp+copy_into_self] ; copy_into_self
		push	[ebp+first_dir_created_per_command_line_arg] ; first_dir_created_per_command_line_arg
		push	[ebp+x]		; x
		push	[ebp+dir]	; ancestors
		lea	edx, [ebp+src_sb]
		push	edx		; src_sb
		push	eax		; new_dst
		push	[ebp+dst_name]	; dst_name_in
		push	[ebp+src_name]	; src_name_in
		call	copy_dir
		add	esp, 20h
		mov	[ebp+delayed_ok], al
		jmp	loc_800417F
; ---------------------------------------------------------------------------

loc_8003AA5:				; CODE XREF: copy_internal+162Fj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+28h]
		test	al, al
		jz	loc_8003C5F
		mov	[ebp+dest_is_symlink], 1
		mov	eax, [ebp+src_name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	loc_8003BE7
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	dir_name
		add	esp, 10h
		mov	[ebp+dst_parent], eax
		sub	esp, 8
		push	[ebp+dst_parent] ; s2
		push	offset s1	; "."
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003B79
		sub	esp, 8
		lea	eax, [ebp+dot_sb]
		push	eax
		push	offset s1	; "."
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8003B79
		sub	esp, 8
		lea	eax, [ebp+sb]
		push	eax
		push	[ebp+dst_parent]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8003B79
		mov	ecx, dword ptr [ebp+dot_sb.st_ino]
		mov	ebx, dword ptr [ebp+dot_sb.st_ino+4]
		mov	eax, dword ptr [ebp+sb.st_ino]
		mov	edx, dword ptr [ebp+sb.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8003B80
		mov	ecx, dword ptr [ebp+dot_sb.st_dev]
		mov	ebx, dword ptr [ebp+dot_sb.st_dev+4]
		mov	eax, dword ptr [ebp+sb.st_dev]
		mov	edx, dword ptr [ebp+sb.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8003B80

loc_8003B79:				; CODE XREF: copy_internal+19A4j
					; copy_internal+19BFj ...
		mov	eax, 1
		jmp	short loc_8003B85
; ---------------------------------------------------------------------------

loc_8003B80:				; CODE XREF: copy_internal+19F9j
					; copy_internal+1A1Dj
		mov	eax, 0

loc_8003B85:				; CODE XREF: copy_internal+1A24j
		mov	[ebp+in_current_dir], al
		and	[ebp+in_current_dir], 1
		sub	esp, 0Ch
		push	[ebp+dst_parent] ; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+in_current_dir]
		xor	eax, 1
		test	al, al
		jz	short loc_8003BE7
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCanMakeRelati ; "%s: can make relative	symbolic links on"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003BE7:				; CODE XREF: copy_internal+196Fj
					; copy_internal+1A55j
		sub	esp, 8
		push	[ebp+dst_name]	; to
		push	[ebp+src_name]	; from
		call	symlink
		add	esp, 10h
		test	eax, eax
		jz	loc_800417F
		sub	esp, 8
		push	[ebp+src_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	edi, eax
		sub	esp, 8
		push	[ebp+dst_name]
		push	0
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateSy ; "cannot create	symbolic link %s to %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003C5F:				; CODE XREF: copy_internal+1957j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	loc_8003CF4
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_8003C91
		mov	eax, [ebp+x]
		mov	eax, [eax+4]
		cmp	eax, 2
		jz	short loc_8003CF4

loc_8003C91:				; CODE XREF: copy_internal+1B27j
		sub	esp, 0Ch
		push	0
		push	[ebp+dst_name]
		push	0FFFFFF9Ch
		push	[ebp+src_name]
		push	0FFFFFF9Ch
		call	rpl_linkat
		add	esp, 20h
		test	eax, eax
		jz	loc_800417F
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateLi ; "cannot create	link %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003CF4:				; CODE XREF: copy_internal+1B11j
					; copy_internal+1B35j
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8003D26
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+14h]
		test	al, al
		jz	short loc_8003D7C
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jz	short loc_8003D7C

loc_8003D26:				; CODE XREF: copy_internal+1BAAj
		mov	[ebp+copied_as_regular], 1
		mov	eax, [ebp+src_mode]
		and	eax, 1FFh
		mov	edx, eax
		sub	esp, 4
		lea	eax, [ebp+src_sb]
		push	eax		; src_sb
		lea	eax, [ebp+new_dst]
		push	eax		; new_dst
		push	[ebp+omitted_permissions] ; omitted_permissions
		push	edx		; dst_mode
		push	[ebp+x]		; x
		push	[ebp+dst_name]	; dst_name
		push	[ebp+src_name]	; src_name
		call	copy_reg
		add	esp, 20h
		xor	eax, 1
		test	al, al
		jz	loc_800417F
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003D7C:				; CODE XREF: copy_internal+1BB8j
					; copy_internal+1BCAj
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jnz	loc_8003E24
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+src_mode]
		push	0
		push	0		; dev
		push	eax		; mode
		push	[ebp+dst_name]	; path
		call	mknod
		add	esp, 10h
		test	eax, eax
		jz	loc_800417F
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+src_mode]
		and	ah, 0EFh
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; path
		call	mkfifo
		add	esp, 10h
		test	eax, eax
		jz	loc_800417F
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateFi ; "cannot create	fifo %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003E24:				; CODE XREF: copy_internal+1C32j
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 6000h
		jz	short loc_8003E5A
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jz	short loc_8003E5A
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jnz	short loc_8003ECB

loc_8003E5A:				; CODE XREF: copy_internal+1CDAj
					; copy_internal+1CECj
		mov	eax, dword ptr [ebp+src_sb.st_rdev]
		mov	edx, dword ptr [ebp+src_sb.st_rdev+4]
		mov	ecx, [ebp+omitted_permissions]
		not	ecx
		and	ecx, [ebp+src_mode]
		push	edx
		push	eax		; dev
		push	ecx		; mode
		push	[ebp+dst_name]	; path
		call	mknod
		add	esp, 10h
		test	eax, eax
		jz	loc_800417F
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateSp ; "cannot create	special	file %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003ECB:				; CODE XREF: copy_internal+1CFEj
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	loc_8004149
		mov	eax, dword ptr [ebp+src_sb.st_size]
		mov	edx, dword ptr [ebp+src_sb.st_size+4]
		sub	esp, 8
		push	eax
		push	[ebp+src_name]
		call	areadlink_with_size
		add	esp, 10h
		mov	[ebp+src_link_val], eax
		mov	[ebp+dest_is_symlink], 1
		cmp	[ebp+src_link_val], 0
		jnz	short loc_8003F53
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotReadSymb ; "cannot read symbolic link %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8003F53:				; CODE XREF: copy_internal+1DB9j
		sub	esp, 8
		push	[ebp+dst_name]	; to
		push	[ebp+src_link_val] ; from
		call	symlink
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8003F84
		sub	esp, 0Ch
		push	[ebp+src_link_val] ; ptr
		call	free
		add	esp, 10h
		jmp	loc_80040B9
; ---------------------------------------------------------------------------

loc_8003F84:				; CODE XREF: copy_internal+1E12j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		mov	[ebp+same_link], 0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+29h]
		test	al, al
		jz	loc_8004060
		movzx	eax, [ebp+new_dst]
		xor	eax, 1
		test	al, al
		jz	loc_8004060
		mov	eax, [ebp+dst_sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	loc_8004060
		mov	ebx, dword ptr [ebp+dst_sb.st_size]
		mov	esi, dword ptr [ebp+dst_sb.st_size+4]
		sub	esp, 0Ch
		push	[ebp+src_link_val] ; s
		call	strlen
		add	esp, 10h
		mov	edx, 0
		mov	ecx, esi
		xor	ecx, edx
		xor	eax, ebx
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8004060
		mov	eax, dword ptr [ebp+dst_sb.st_size]
		mov	edx, dword ptr [ebp+dst_sb.st_size+4]
		sub	esp, 8
		push	eax
		push	[ebp+dst_name]
		call	areadlink_with_size
		add	esp, 10h
		mov	[ebp+dest_link_val], eax
		cmp	[ebp+dest_link_val], 0
		jz	short loc_800404F
		sub	esp, 8
		push	[ebp+src_link_val] ; s2
		push	[ebp+dest_link_val] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800404F
		mov	[ebp+same_link], 1

loc_800404F:				; CODE XREF: copy_internal+1ED1j
					; copy_internal+1EECj
		sub	esp, 0Ch
		push	[ebp+dest_link_val] ; ptr
		call	free
		add	esp, 10h

loc_8004060:				; CODE XREF: copy_internal+1E4Aj
					; copy_internal+1E5Cj ...
		sub	esp, 0Ch
		push	[ebp+src_link_val] ; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+same_link]
		xor	eax, 1
		test	al, al
		jz	short loc_80040B9
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotCreate_0 ; "cannot create	symbolic link %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+saved_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_80040B9:				; CODE XREF: copy_internal+1E25j
					; copy_internal+1F23j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+21h]
		test	al, al
		jz	short loc_80040CC
		call	restore_default_fscreatecon_or_die

loc_80040CC:				; CODE XREF: copy_internal+1F6Bj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	loc_800417F
		mov	edx, [ebp+src_sb.st_gid]
		mov	eax, [ebp+src_sb.st_uid]
		sub	esp, 4
		push	edx		; group
		push	eax		; owner
		push	[ebp+dst_name]	; file
		call	lchown
		add	esp, 10h
		test	eax, eax
		jz	short loc_800417F
		sub	esp, 0Ch
		push	[ebp+x]		; x
		call	chown_failure_ok
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_800417F
		sub	esp, 0Ch
		push	offset aFailedToPreser ; "failed to preserve ownership for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+dst_name]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_8004149:				; CODE XREF: copy_internal+1D81j
		sub	esp, 0Ch
		push	[ebp+src_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSHasUnknownFil ; "%s has unknown file type"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	un_backup
; ---------------------------------------------------------------------------

loc_800417F:				; CODE XREF: copy_internal+18FCj
					; copy_internal+1946j ...
		cmp	[ebp+command_line_arg],	0
		jz	short loc_80041D3
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		test	eax, eax
		jz	short loc_80041D3
		sub	esp, 8
		lea	eax, [ebp+sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80041D3
		mov	eax, [ebp+x]
		mov	eax, [eax+34h]
		sub	esp, 4
		lea	edx, [ebp+sb]
		push	edx
		push	[ebp+dst_name]
		push	eax
		call	record_file
		add	esp, 10h

loc_80041D3:				; CODE XREF: copy_internal+202Cj
					; copy_internal+2039j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	short loc_80041FF
		mov	eax, [ebp+src_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_80041FF
		movzx	eax, [ebp+delayed_ok]
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80041FF:				; CODE XREF: copy_internal+2085j
					; copy_internal+2097j
		cmp	[ebp+copied_as_regular], 0
		jz	short loc_8004214
		movzx	eax, [ebp+delayed_ok]
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004214:				; CODE XREF: copy_internal+20ACj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	loc_8004310
		lea	eax, [ebp+var_240]
		sub	esp, 8
		lea	edx, [ebp+src_sb]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 0Ch
		mov	eax, [ebp+var_240.tv_sec]
		mov	edx, [ebp+var_240.tv_nsec]
		mov	[ebp+timespec.tv_sec], eax
		mov	[ebp+timespec.tv_nsec],	edx
		lea	eax, [ebp+var_240]
		sub	esp, 8
		lea	edx, [ebp+src_sb]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_240.tv_sec]
		mov	edx, [ebp+var_240.tv_nsec]
		mov	[ebp+timespec.tv_sec+8], eax
		mov	[ebp+timespec.tv_nsec+8], edx
		cmp	[ebp+dest_is_symlink], 0
		jz	short loc_80042A1
		sub	esp, 8
		lea	eax, [ebp+timespec]
		push	eax		; timespec
		push	[ebp+dst_name]	; file
		call	utimens_symlink
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_80042BB
; ---------------------------------------------------------------------------

loc_80042A1:				; CODE XREF: copy_internal+2129j
		sub	esp, 8
		lea	eax, [ebp+timespec]
		push	eax
		push	[ebp+dst_name]
		call	utimens
		add	esp, 10h
		test	eax, eax
		setnz	al

loc_80042BB:				; CODE XREF: copy_internal+2145j
		test	al, al
		jz	short loc_8004310
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aPreservingTime ; "preserving times for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short loc_8004310
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004310:				; CODE XREF: copy_internal+20C6j
					; copy_internal+2163j ...
		cmp	[ebp+dest_is_symlink], 0
		jz	short loc_8004325
		movzx	eax, [ebp+delayed_ok]
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004325:				; CODE XREF: copy_internal+21BDj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_80043B0
		movzx	eax, [ebp+new_dst]
		test	al, al
		jnz	short loc_800435E
		mov	edx, [ebp+src_sb.st_uid]
		mov	eax, [ebp+dst_sb.st_uid]
		cmp	edx, eax
		jnz	short loc_800435E
		mov	edx, [ebp+src_sb.st_gid]
		mov	eax, [ebp+dst_sb.st_gid]
		cmp	edx, eax
		jz	short loc_80043B0

loc_800435E:				; CODE XREF: copy_internal+21E2j
					; copy_internal+21F2j
		movzx	eax, [ebp+new_dst]
		movzx	eax, al
		sub	esp, 8
		lea	edx, [ebp+dst_sb]
		push	edx		; dst_sb
		push	eax		; new_dst
		lea	eax, [ebp+src_sb]
		push	eax		; src_sb
		push	0FFFFFFFFh	; dest_desc
		push	[ebp+dst_name]	; dst_name
		push	[ebp+x]		; x
		call	set_owner
		add	esp, 20h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_800439B
		test	eax, eax
		jz	short loc_80043A5
		jmp	short loc_80043B0
; ---------------------------------------------------------------------------

loc_800439B:				; CODE XREF: copy_internal+2239j
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80043A5:				; CODE XREF: copy_internal+223Dj
		and	[ebp+src_mode],	0FFFFF1FFh
		nop

loc_80043B0:				; CODE XREF: copy_internal+21D7j
					; copy_internal+2202j ...
		sub	esp, 4
		lea	eax, [ebp+src_sb]
		push	eax		; src_sb
		push	0FFFFFFFFh	; dest_desc
		push	[ebp+dst_name]	; dst_name
		call	set_author
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+23h]
		test	al, al
		jz	short loc_8004414
		sub	esp, 4
		push	[ebp+x]		; x
		push	[ebp+dst_name]	; dst_path
		push	[ebp+src_name]	; src_path
		call	copy_attr_by_name
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8004414
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_8004414
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004414:				; CODE XREF: copy_internal+227Cj
					; copy_internal+22A0j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jnz	short loc_8004430
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8004475

loc_8004430:				; CODE XREF: copy_internal+22C6j
		sub	esp, 0Ch
		push	[ebp+src_mode]
		push	0FFFFFFFFh
		push	[ebp+dst_name]
		push	0FFFFFFFFh
		push	[ebp+src_name]
		call	copy_acl
		add	esp, 20h
		test	eax, eax
		jz	loc_80045F6
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	loc_80045F6
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004475:				; CODE XREF: copy_internal+22D4j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+27h]
		test	al, al
		jz	short loc_80044B2
		mov	eax, [ebp+x]
		mov	eax, [eax+10h]
		sub	esp, 4
		push	eax
		push	0FFFFFFFFh
		push	[ebp+dst_name]
		call	set_acl
		add	esp, 10h
		test	eax, eax
		jz	loc_80045F7
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80044B2:				; CODE XREF: copy_internal+2327j
		cmp	[ebp+omitted_permissions], 0
		jz	loc_800457A
		call	cached_umask
		not	eax
		and	[ebp+omitted_permissions], eax
		cmp	[ebp+omitted_permissions], 0
		jz	loc_800457A
		movzx	eax, [ebp+restore_dst_mode]
		xor	eax, 1
		test	al, al
		jz	loc_800457A
		movzx	eax, [ebp+new_dst]
		test	al, al
		jz	short loc_8004555
		sub	esp, 8
		lea	eax, [ebp+dst_sb]
		push	eax
		push	[ebp+dst_name]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8004555
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotStatS ; "cannot stat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_8004555:				; CODE XREF: copy_internal+239Aj
					; copy_internal+23B6j
		mov	eax, [ebp+dst_sb.st_mode]
		mov	[ebp+dst_mode],	eax
		mov	eax, [ebp+dst_mode]
		not	eax
		and	eax, [ebp+omitted_permissions]
		test	eax, eax
		jz	short loc_800457A
		mov	[ebp+restore_dst_mode],	1

loc_800457A:				; CODE XREF: copy_internal+235Fj
					; copy_internal+2379j ...
		cmp	[ebp+restore_dst_mode],	0
		jz	short loc_80045F7
		mov	eax, [ebp+dst_mode]
		or	eax, [ebp+omitted_permissions]
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; file
		call	chmod
		add	esp, 10h
		test	eax, eax
		jz	short loc_80045F7
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aPreservingPerm ; "preserving permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short loc_80045F7
		mov	eax, 0
		jmp	loc_8004701
; ---------------------------------------------------------------------------

loc_80045F6:				; CODE XREF: copy_internal+22F9j
					; copy_internal+230Bj
		nop

loc_80045F7:				; CODE XREF: copy_internal+2348j
					; copy_internal+2427j ...
		movzx	eax, [ebp+delayed_ok]
		jmp	loc_8004701
; ---------------------------------------------------------------------------

un_backup:				; CODE XREF: copy_internal+FE2j
					; copy_internal+1045j ...
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+21h]
		test	al, al
		jz	short loc_8004616
		call	restore_default_fscreatecon_or_die

loc_8004616:				; CODE XREF: copy_internal+24B5j
		cmp	[ebp+earlier_file], 0
		jnz	short loc_8004643
		mov	ecx, dword ptr [ebp+src_sb.st_dev]
		mov	ebx, dword ptr [ebp+src_sb.st_dev+4]
		mov	eax, dword ptr [ebp+src_sb.st_ino]
		mov	edx, dword ptr [ebp+src_sb.st_ino+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	forget_created
		add	esp, 10h

loc_8004643:				; CODE XREF: copy_internal+24C3j
		cmp	[ebp+dst_backup], 0
		jz	loc_80046FC
		sub	esp, 8
		push	[ebp+dst_name]	; new
		push	[ebp+dst_backup] ; old
		call	rename
		add	esp, 10h
		test	eax, eax
		jz	short loc_80046A6
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotUnBackup ; "cannot un-backup %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_80046FC
; ---------------------------------------------------------------------------

loc_80046A6:				; CODE XREF: copy_internal+250Fj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_80046FC
		sub	esp, 8
		push	[ebp+dst_name]
		push	1
		call	quote_n
		add	esp, 10h
		mov	esi, eax
		sub	esp, 8
		push	[ebp+dst_backup]
		push	0
		call	quote_n
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSSUnbackup ; "%s -> %s (unbackup)\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80046FC:				; CODE XREF: copy_internal+24F0j
					; copy_internal+254Aj ...
		mov	eax, 0

loc_8004701:				; CODE XREF: copy_internal+166j
					; copy_internal+1D0j ...
		mov	edi, [ebp+var_1C]
		xor	edi, large gs:14h
		jz	short loc_8004712
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8004712:				; CODE XREF: copy_internal+25B1j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
copy_internal	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	valid_options(const cp_options *co)
valid_options	proc near		; CODE XREF: copy+3Bp

co		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+co], 0
		jnz	short loc_800473F
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D2h		; line
		push	offset file	; "copy.c"
		push	offset aCoNull	; "co != NULL"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800473F:				; CODE XREF: valid_options+Aj
		mov	eax, [ebp+co]
		mov	eax, [eax]
		cmp	eax, 3
		jbe	short loc_8004762
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D3h		; line
		push	offset file	; "copy.c"
		push	offset aValid_backup_t ; "VALID_BACKUP_TYPE (co->backup_type)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8004762:				; CODE XREF: valid_options+2Dj
		mov	eax, [ebp+co]
		mov	eax, [eax+0Ch]
		cmp	eax, 1
		jz	short loc_800479C
		mov	eax, [ebp+co]
		mov	eax, [eax+0Ch]
		cmp	eax, 2
		jz	short loc_800479C
		mov	eax, [ebp+co]
		mov	eax, [eax+0Ch]
		cmp	eax, 3
		jz	short loc_800479C
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D4h		; line
		push	offset file	; "copy.c"
		push	offset aValid_sparse_m ; "VALID_SPARSE_MODE (co->sparse_mode)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800479C:				; CODE XREF: valid_options+51j
					; valid_options+5Cj ...
		mov	eax, [ebp+co]
		mov	eax, [eax+30h]
		test	eax, eax
		jz	short loc_80047D5
		mov	eax, [ebp+co]
		mov	eax, [eax+30h]
		cmp	eax, 1
		jz	short loc_80047D5
		mov	eax, [ebp+co]
		mov	eax, [eax+30h]
		cmp	eax, 2
		jz	short loc_80047D5
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D5h		; line
		push	offset file	; "copy.c"
		push	offset aValid_reflink_ ; "VALID_REFLINK_MODE (co->reflink_mode)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80047D5:				; CODE XREF: valid_options+8Aj
					; valid_options+95j ...
		mov	eax, [ebp+co]
		movzx	eax, byte ptr [eax+17h]
		test	al, al
		jz	short loc_8004804
		mov	eax, [ebp+co]
		movzx	eax, byte ptr [eax+28h]
		test	al, al
		jz	short loc_8004804
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D6h		; line
		push	offset file	; "copy.c"
		push	offset aCoHard_linkCoS ; "!(co->hard_link && co->symbolic_link)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8004804:				; CODE XREF: valid_options+C4j
					; valid_options+CFj
		mov	eax, [ebp+co]
		mov	eax, [eax+30h]
		cmp	eax, 2
		jnz	short loc_8004833
		mov	eax, [ebp+co]
		mov	eax, [eax+0Ch]
		cmp	eax, 2
		jz	short loc_8004833
		push	offset __PRETTY_FUNCTION___5729	; "valid_options"
		push	8D9h		; line
		push	offset file	; "copy.c"
		push	offset aCoReflink_mode ; "! (co->reflink_mode == REFLINK_ALWAYS	&"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8004833:				; CODE XREF: valid_options+F3j
					; valid_options+FEj
		mov	eax, 1
		leave
		retn
valid_options	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _Bool	__cdecl	copy(const char	*src_name, const char *dst_name, _Bool nonexistent_dst,	const cp_options *options, _Bool *copy_into_self, _Bool	*rename_succeeded)
		public copy
copy		proc near

rename_succeeded= dword	ptr -30h
copy_into_self	= dword	ptr -2Ch
options		= dword	ptr -28h
nonexistent_dst	= byte ptr -24h
dst_name	= dword	ptr -20h
src_name	= dword	ptr -1Ch
first_dir_created_per_command_line_arg=	byte ptr -0Dh
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+src_name],	edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+dst_name],	edx
		mov	[ebp+nonexistent_dst], al
		mov	eax, [ebp+arg_C]
		mov	[ebp+options], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+copy_into_self], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+rename_succeeded],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+options]	; co
		call	valid_options
		add	esp, 10h
		test	al, al
		jnz	short loc_800489A
		push	offset __PRETTY_FUNCTION___5738	; "copy"
		push	8EBh		; line
		push	offset file	; "copy.c"
		push	offset aValid_optionsO ; "valid_options	(options)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800489A:				; CODE XREF: copy+45j
		mov	eax, [ebp+src_name]
		mov	ds:top_level_src_name, eax
		mov	eax, [ebp+dst_name]
		mov	ds:top_level_dst_name, eax
		mov	[ebp+first_dir_created_per_command_line_arg], 0
		movzx	eax, [ebp+nonexistent_dst]
		sub	esp, 4
		push	[ebp+rename_succeeded] ; rename_succeeded
		push	[ebp+copy_into_self] ; copy_into_self
		lea	edx, [ebp+first_dir_created_per_command_line_arg]
		push	edx		; first_dir_created_per_command_line_arg
		push	1		; command_line_arg
		push	[ebp+options]	; x
		push	0		; ancestors
		push	0
		push	0		; device
		push	eax		; new_dst
		push	[ebp+dst_name]	; dst_name
		push	[ebp+src_name]	; src_name
		call	copy_internal
		add	esp, 30h
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80048EA
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80048EA:				; CODE XREF: copy+A9j
		leave
		retn
copy		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; void __cdecl cp_options_default(cp_options *x)
		public cp_options_default
cp_options_default proc	near

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	3Ch		; n
		push	0		; c
		push	[ebp+x]		; s
		call	memset
		add	esp, 10h
		call	geteuid
		test	eax, eax
		setz	dl
		mov	eax, [ebp+x]
		mov	[eax+1Ah], dl
		mov	eax, [ebp+x]
		movzx	edx, byte ptr [eax+1Ah]
		mov	eax, [ebp+x]
		mov	[eax+19h], dl
		nop
		leave
		retn
cp_options_default endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; _Bool	__cdecl	chown_failure_ok(const cp_options *x)
		public chown_failure_ok
chown_failure_ok proc near		; CODE XREF: set_owner+20Ap
					; copy_internal+1FB0p

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_8004942
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_8004957

loc_8004942:				; CODE XREF: chown_failure_ok+10j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+19h]
		xor	eax, 1
		test	al, al
		jz	short loc_8004957
		mov	eax, 1
		jmp	short loc_800495C
; ---------------------------------------------------------------------------

loc_8004957:				; CODE XREF: chown_failure_ok+1Cj
					; chown_failure_ok+2Aj
		mov	eax, 0

loc_800495C:				; CODE XREF: chown_failure_ok+31j
		and	eax, 1
		leave
		retn
chown_failure_ok endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	owner_failure_ok(const cp_options *x)
owner_failure_ok proc near		; CODE XREF: set_owner+C4p

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 1
		jz	short loc_800497F
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jnz	short loc_8004994

loc_800497F:				; CODE XREF: owner_failure_ok+10j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ah]
		xor	eax, 1
		test	al, al
		jz	short loc_8004994
		mov	eax, 1
		jmp	short loc_8004999
; ---------------------------------------------------------------------------

loc_8004994:				; CODE XREF: owner_failure_ok+1Cj
					; owner_failure_ok+2Aj
		mov	eax, 0

loc_8004999:				; CODE XREF: owner_failure_ok+31j
		and	eax, 1
		leave
		retn
owner_failure_ok endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; mode_t cached_umask()
		public cached_umask
cached_umask	proc near		; CODE XREF: copy_reg+EF5p
					; copy_internal+2365p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, mask_5752
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80049D1
		sub	esp, 0Ch
		push	0		; mask
		call	umask
		add	esp, 10h
		mov	mask_5752, eax
		mov	eax, mask_5752
		sub	esp, 0Ch
		push	eax		; mask
		call	umask
		add	esp, 10h

loc_80049D1:				; CODE XREF: cached_umask+Ej
		mov	eax, mask_5752
		leave

locret_80049D7:				; DATA XREF: .eh_frame:080052A0o
					; .eh_frame:080052C0o ...
		retn
cached_umask	endp

_text		ends

; Function-local static	variable
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 80049D8h
; mode_t mask_5752
mask_5752	dd 0FFFFFFFFh		; DATA XREF: cached_umask+6r
					; cached_umask+1Dw ...
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 80049DCh
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; const	char *top_level_src_name
top_level_src_name dd ?			; DATA XREF: copy_internal+FA2r
					; copy_internal+129Br ...
; const	char *top_level_dst_name
top_level_dst_name dd ?			; DATA XREF: copy_internal+F8Dr
					; copy_internal+1286r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 80049E4h
; char msgid[]
msgid		db 'cannot access %s',0 ; DATA XREF: copy_dir+D3o
; char aClearingPermis[]
aClearingPermis	db 'clearing permissions for %s',0 ; DATA XREF: set_owner+E6o
		align 4
; char aFailedToPreser[]
aFailedToPreser	db 'failed to preserve ownership for %s',0 ; DATA XREF: set_owner+22Co
					; copy_internal+1FC2o
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: copy_reg+C6o
; char aCannotFstatS[]
aCannotFstatS	db 'cannot fstat %s',0  ; DATA XREF: copy_reg+125o
					; copy_reg+60Do
		align 4
; char aSkippingFileSA[]
aSkippingFileSA	db 'skipping file %s, as it was replaced while being copied',0
					; DATA XREF: copy_reg+1B1o
; char aFailedToGetFil[]
aFailedToGetFil	db 'failed to get file system create context',0 ; DATA XREF: copy_reg+276o
		align 4
; char aFailedToSetThe[]
aFailedToSetThe	db 'failed to set the security context of %s to %s',0
					; DATA XREF: copy_reg+330o
; char aCannotRemoveS[]
aCannotRemoveS	db 'cannot remove %s',0 ; DATA XREF: copy_reg+3E0o
					; copy_internal+638o ...
; char aRemovedS[]
aRemovedS	db 'removed %s',0Ah,0   ; DATA XREF: copy_reg+433o
					; copy_internal+5EFo ...
; char aNotWritingThro[]
aNotWritingThro	db 'not writing through dangling symlink %s',0 ; DATA XREF: copy_reg+563o
; char aCannotCreateRe[]
aCannotCreateRe	db 'cannot create regular file %s',0 ; DATA XREF: copy_reg+5B0o
; char aFailedToCloneS[]
aFailedToCloneS	db 'failed to clone %s',0 ; DATA XREF: copy_reg+6AAo
; char aReadingS[]
aReadingS	db 'reading %s',0       ; DATA XREF: copy_reg+9B9o
; char aCannotLseekS[]
aCannotLseekS	db 'cannot lseek %s',0  ; DATA XREF: copy_reg+AC7o
; char aWritingS[]
aWritingS	db 'writing %s',0       ; DATA XREF: copy_reg+B51o
					; copy_reg+BD3o
; char aPreservingTime[]
aPreservingTime	db 'preserving times for %s',0 ; DATA XREF: copy_reg+C9Do
					; copy_internal+217Bo
; char aPreservingPerm[]
aPreservingPerm	db 'preserving permissions for %s',0 ; DATA XREF: copy_reg+F39o
					; copy_internal+2461o
; char aClosingS[]
aClosingS	db 'closing %s',0       ; DATA XREF: copy_reg+F9Fo
					; copy_reg+FF4o
; char aSTryToOverwrit[]
aSTryToOverwrit	db '%s: try to overwrite %s, overriding mode %04lo (%s)? ',0
					; DATA XREF: overwrite_prompt+7Co
; char aSOverwriteS_[]
aSOverwriteS?	db '%s: overwrite %s? ',0 ; DATA XREF: overwrite_prompt+C2o
; char file[]
file		db 'copy.c',0           ; DATA XREF: abandon_move+1Bo
					; valid_options+16o ...
; char assertion[]
assertion	db 'x->move_mode',0     ; DATA XREF: abandon_move+20o
; char format[]
format		db '%s -> %s',0         ; DATA XREF: emit_verbose+2Eo
; char aBackupS[]
aBackupS	db ' (backup: %s)',0    ; DATA XREF: emit_verbose+54o
; char aFailedToRestor[]
aFailedToRestor	db 'failed to restore the default file creation context',0
					; DATA XREF: restore_default_fscreatecon_or_die+1Bo
; char aCannotStatS[]
aCannotStatS	db 'cannot stat %s',0   ; DATA XREF: copy_internal+13Eo
					; copy_internal+3ADo ...
; char aOmittingDirect[]
aOmittingDirect	db 'omitting directory %s',0 ; DATA XREF: copy_internal+1B0o
		align 4
; char aWarningSourceF[]
aWarningSourceF	db 'warning: source file %s specified more than once',0
					; DATA XREF: copy_internal+23Co
; char aSAndSAreTheSam[]
aSAndSAreTheSam	db '%s and %s are the same file',0 ; DATA XREF: copy_internal+472o
		align 4
; char aCannotOverwrit[]
aCannotOverwrit	db 'cannot overwrite non-directory %s with directory %s',0
					; DATA XREF: copy_internal+745o
; char aWillNotOverwri[]
aWillNotOverwri	db 'will not overwrite just-created %s with %s',0
					; DATA XREF: copy_internal+7DBo
		align 4
; char aCannotOverwr_0[]
aCannotOverwr_0	db 'cannot overwrite directory %s with non-directory',0
					; DATA XREF: copy_internal+858o
		align 4
; char aCannotMoveDire[]
aCannotMoveDire	db 'cannot move directory onto non-directory: %s -> %s',0
					; DATA XREF: copy_internal+8ECo
		align 4
; char aBackingUpSWoul[]
aBackingUpSWoul	db 'backing up %s would destroy source;  %s not moved',0
					; DATA XREF: copy_internal+9C1o
		align 10h
; char aBackingUpSWo_0[]
aBackingUpSWo_0	db 'backing up %s would destroy source;  %s not copied',0
					; DATA XREF: copy_internal+9D3o
; char aCannotBackupS[]
aCannotBackupS	db 'cannot backup %s',0 ; DATA XREF: copy_internal+B0Co
; char aWillNotCopySTh[]
aWillNotCopySTh	db 'will not copy %s through just-created symlink %s',0
					; DATA XREF: copy_internal+D81o
		align 4
; char aCannotCopyADir[]
aCannotCopyADir	db 'cannot copy a directory, %s, into itself, %s',0
					; DATA XREF: copy_internal+FBAo
		align 4
; char aWillNotCreateH[]
aWillNotCreateH	db 'will not create hard link %s to directory %s',0
					; DATA XREF: copy_internal+1026o
		align 4
; char aCannotCreateHa[]
aCannotCreateHa	db 'cannot create hard link %s to %s',0 ; DATA XREF: copy_internal+117Eo
		align 4
; char aCannotMoveSToA[]
aCannotMoveSToA	db 'cannot move %s to a subdirectory of itself, %s',0
					; DATA XREF: copy_internal+12B3o
; char aCannotMoveSToS[]
aCannotMoveSToS	db 'cannot move %s to %s',0 ; DATA XREF: copy_internal+1322o
; char aInterDeviceMov[]
aInterDeviceMov	db 'inter-device move failed: %s to %s; unable to remove target',0
					; DATA XREF: copy_internal+13CDo
; char aFailedToSetDef[]
aFailedToSetDef	db 'failed to set default file creation context to %s',0
					; DATA XREF: copy_internal+1523o
		align 10h
; char aFailedToGetSec[]
aFailedToGetSec	db 'failed to get security context of %s',0 ; DATA XREF: copy_internal+15E4o
		align 4
; char aCannotCopyCycl[]
aCannotCopyCycl	db 'cannot copy cyclic symbolic link %s',0 ; DATA XREF: copy_internal+1667o
; char aCannotCreateDi[]
aCannotCreateDi	db 'cannot create directory %s',0 ; DATA XREF: copy_internal+174Do
; char aSettingPermiss[]
aSettingPermiss	db 'setting permissions for %s',0 ; DATA XREF: copy_internal+182Bo
; char s1[]
s1		db '.',0                ; DATA XREF: copy_internal+1995o
					; copy_internal+19B0o
; char aSCanMakeRelati[]
aSCanMakeRelati	db '%s: can make relative symbolic links only in current directory',0
					; DATA XREF: copy_internal+1A6Do
		align 4
; char aCannotCreateSy[]
aCannotCreateSy	db 'cannot create symbolic link %s to %s',0 ; DATA XREF: copy_internal+1AD9o
; char aCannotCreateLi[]
aCannotCreateLi	db 'cannot create link %s',0 ; DATA XREF: copy_internal+1B72o
; char aCannotCreateFi[]
aCannotCreateFi	db 'cannot create fifo %s',0 ; DATA XREF: copy_internal+1CA2o
; char aCannotCreateSp[]
aCannotCreateSp	db 'cannot create special file %s',0 ; DATA XREF: copy_internal+1D49o
; char aCannotReadSymb[]
aCannotReadSymb	db 'cannot read symbolic link %s',0 ; DATA XREF: copy_internal+1DD1o
; char aCannotCreate_0[]
aCannotCreate_0	db 'cannot create symbolic link %s',0 ; DATA XREF: copy_internal+1F3Bo
; char aSHasUnknownFil[]
aSHasUnknownFil	db '%s has unknown file type',0 ; DATA XREF: copy_internal+2005o
; char aCannotUnBackup[]
aCannotUnBackup	db 'cannot un-backup %s',0 ; DATA XREF: copy_internal+2527o
; char aSSUnbackup[]
aSSUnbackup	db '%s -> %s (unbackup)',0Ah,0 ; DATA XREF: copy_internal+2587o
; char aCoNull[]
aCoNull		db 'co != NULL',0       ; DATA XREF: valid_options+1Bo
; char aValid_backup_t[]
aValid_backup_t	db 'VALID_BACKUP_TYPE (co->backup_type)',0 ; DATA XREF: valid_options+3Eo
; char aValid_sparse_m[]
aValid_sparse_m	db 'VALID_SPARSE_MODE (co->sparse_mode)',0 ; DATA XREF: valid_options+78o
; char aValid_reflink_[]
aValid_reflink_	db 'VALID_REFLINK_MODE (co->reflink_mode)',0 ; DATA XREF: valid_options+B1o
		align 4
; char aCoHard_linkCoS[]
aCoHard_linkCoS	db '!(co->hard_link && co->symbolic_link)',0 ; DATA XREF: valid_options+E0o
		align 4
; char aCoReflink_mode[]
aCoReflink_mode	db '! (co->reflink_mode == REFLINK_ALWAYS && co->sparse_mode != SPARS'
					; DATA XREF: valid_options+10Fo
		db 'E_AUTO)',0
; char aValid_optionsO[]
aValid_optionsO	db 'valid_options (options)',0 ; DATA XREF: copy+56o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5661[13]
__PRETTY_FUNCTION___5661 db 'abandon_move',0 ; DATA XREF: abandon_move+11o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5729[14]
__PRETTY_FUNCTION___5729 db 'valid_options',0 ; DATA XREF: valid_options+Co
					; valid_options+2Fo ...
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5738[5]
__PRETTY_FUNCTION___5738 db 'copy',0    ; DATA XREF: copy+47o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8005280h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_80049D7-8009C77h
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 3Ch
		dd offset locret_80049D7-8009C91h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 5Ch
		dd offset locret_80049D7-8009C99h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 7Ch
		dd offset locret_80049D7-8009CA1h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 9Ch
		dd offset locret_80049D7-8009CA9h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 0BCh
		dd offset locret_80049D7-8009CB1h
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 1Ch, 0DCh
		dd offset locret_80049D7-8009C79h
		dd 2Bh,	80E4100h, 0D420285h, 0CC56705h,	404h, 1Ch, 0FCh
		dd offset locret_80049D7-8009C6Eh
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 1Ch, 11Ch
		dd offset locret_80049D7-8009C6Bh
		dd 32h,	80E4100h, 0D420285h, 0CC56E05h,	404h, 1Ch, 13Ch
		dd offset locret_80049D7-8009C59h
		dd 42h,	80E4100h, 0D420285h, 0CC57E05h,	404h, 1Ch, 15Ch
		dd offset locret_80049D7-8009C37h
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 17Ch
		dd offset locret_80049D7-8009C51h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 19Ch
		dd offset locret_80049D7-8009C56h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 1BCh
		dd offset locret_80049D7-8009C5Bh
		dd 38h,	80E4100h, 0D420285h, 0CC57405h,	404h, 1Ch, 1DCh
		dd offset locret_80049D7-8009C43h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 24h, 1FCh
		dd offset locret_80049D7-8009C45h
		dd 60h,	80E4100h, 0D420285h, 3864205h, 58020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 224h
		dd offset locret_80049D7-8009C0Dh
		dd 20h,	80E4100h, 0D420285h, 0CC55C05h,	404h, 1Ch, 244h
		dd offset locret_80049D7-8009C0Dh
		dd 0Ah,	80E4100h, 0D420285h, 0CC54605h,	404h, 1Ch, 264h
		dd offset locret_80049D7-8009C23h
		dd 0Ah,	80E4100h, 0D420285h, 0CC54605h,	404h, 28h, 284h
		dd offset locret_80049D7-8009C39h
		dd 221h, 80E4100h, 0D420285h, 3864505h,	16030483h, 0C641C302h
		dd 40CC541h, 4,	28h, 2B0h
		dd offset locret_80049D7-8009A44h
		dd 26Dh, 80E4100h, 0D420285h, 3864505h,	62030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 2DCh
		dd offset locret_80049D7-8009803h
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 2FCh
		dd offset locret_80049D7-800981Dh
		dd 32h,	80E4100h, 0D420285h, 0CC56E05h,	404h, 2Ch, 31Ch
		dd offset locret_80049D7-800980Bh
		dd 1060h, 80E4100h, 0D420285h, 3874905h, 5830486h, 0C3105003h
		dd 0C741C641h, 40CC541h, 4, 2Ch, 34Ch
		dd offset locret_80049D7-80087DBh
		dd 68Ah, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3067A03h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 37Ch
		dd offset locret_80049D7-8008181h
		dd 43h,	80E4100h, 0D420285h, 0CC57F05h,	404h, 28h, 39Ch
		dd offset locret_80049D7-800815Eh
		dd 0FCh, 80E4100h, 0D420285h, 3874605h,	5830486h, 41C3EF02h
		dd 41C741C6h, 4040CC5h,	1Ch, 3C8h
		dd offset locret_80049D7-800808Eh
		dd 2Fh,	80E4100h, 0D420285h, 0CC56B05h,	404h, 1Ch, 3E8h
		dd offset locret_80049D7-800807Fh
		dd 2Fh,	80E4100h, 0D420285h, 0CC56B05h,	404h, 1Ch, 408h
		dd offset locret_80049D7-8008070h
		dd 0A0h, 80E4100h, 0D420285h, 0C59C0205h, 4040Ch, 20h
		dd 428h
		dd offset locret_80049D7-8007FF0h
		dd 81h,	80E4100h, 0D420285h, 3834405h, 0C3C57902h, 4040Ch
		dd 20h,	44Ch
		dd offset locret_80049D7-8007F93h
		dd 46h,	80E4100h, 0D420285h, 3834405h, 0CC3C57Eh, 404h
		dd 2Ch,	470h
		dd offset locret_80049D7-8007F71h
		dd 25C0h, 80E4100h, 0D420285h, 3874905h, 5830486h, 0C325B003h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 4A0h
		dd offset locret_80049D7-80059E1h
		dd 120h, 80E4100h, 0D420285h, 11C0305h,	4040CC5h, 1Ch
		dd 4C0h
		dd offset locret_80049D7-80058E1h
		dd 0B2h, 80E4100h, 0D420285h, 0C5AE0205h, 4040Ch, 1Ch
		dd 4E0h
		dd offset locret_80049D7-800584Fh
		dd 38h,	80E4100h, 0D420285h, 0CC57405h,	404h, 1Ch, 500h
		dd offset locret_80049D7-8005837h
		dd 3Dh,	80E4100h, 0D420285h, 0CC57905h,	404h, 1Ch, 520h
		dd offset locret_80049D7-800581Ah
		dd 3Dh,	80E4100h, 0D420285h, 0CC57905h,	404h, 1Ch, 540h
		dd offset locret_80049D7-80057FDh
		dd 3Ah,	80E4100h, 0D420285h, 0CC57605h,	404h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: getfscreatecon+6p
					; setfscreatecon+6p ...
		extrn lutimens:near	; CODE XREF: utimens_symlink+Fp
; int ioctl(int	fd, unsigned __int32 request, ...)
		extrn ioctl:near	; CODE XREF: clone_file+14p
		extrn savedir:near	; CODE XREF: copy_dir+AFp
		extrn quote:near	; CODE XREF: copy_dir+C6p
					; set_owner+D9p ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: copy_dir+D8p
					; set_owner+EBp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: copy_dir+EEp
					; set_owner+101p ...
		extrn file_name_concat:near ; CODE XREF: copy_dir+128p
					; copy_dir+13Ep
; void free(void *ptr)
		extrn free:near		; CODE XREF: copy_dir+1B4p
					; copy_dir+1C2p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: copy_dir+1D8p
					; copy_internal+A55p ...
		extrn __stack_chk_fail:near ; CODE XREF: copy_dir+215p
					; copy_reg+1053p ...
		extrn qset_acl:near	; CODE XREF: set_owner+B2p
; int fchown(int fd, __uid_t owner, __gid_t group)
		extrn fchown:near	; CODE XREF: set_owner+12Cp
					; set_owner+173p
; int lchown(const char	*file, __uid_t owner, __gid_t group)
		extrn lchown:near	; CODE XREF: set_owner+1A1p
					; set_owner+1E4p ...
; int fchmod(int fd, __mode_t mode)
		extrn fchmod:near	; CODE XREF: fchmod_or_lchmod+15p
; int chmod(const char *file, __mode_t mode)
		extrn chmod:near	; CODE XREF: fchmod_or_lchmod+28p
					; copy_internal+1809p ...
		extrn open_safer:near	; CODE XREF: copy_reg+99p
					; copy_reg+1FAp ...
		extrn fstat64:near	; CODE XREF: copy_reg+103p
					; copy_reg+5EBp
		extrn quote_n:near	; CODE XREF: copy_reg+30Ep
					; copy_reg+323p ...
; int unlink(const char	*name)
		extrn unlink:near	; CODE XREF: copy_reg+3BEp
					; copy_internal+5A2p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: copy_reg+445p
					; emit_verbose+33p ...
		extrn lstat64:near	; CODE XREF: copy_reg+4E7p
					; same_file_ok+1D4p ...
; int getpagesize(void)
		extrn getpagesize:near	; CODE XREF: copy_reg+701p
		extrn buffer_lcm:near	; CODE XREF: copy_reg+875p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: copy_reg+932p
; ssize_t read(int fd, void *buf, size_t nbytes)
		extrn read:near		; CODE XREF: copy_reg+97Cp
		extrn lseek64:near	; CODE XREF: copy_reg+AA5p
		extrn full_write:near	; CODE XREF: copy_reg+B2Bp
		extrn ftruncate64:near	; CODE XREF: copy_reg+BB1p
		extrn gl_futimens:near	; CODE XREF: copy_reg+C7Bp
; __uid_t geteuid(void)
		extrn geteuid:near	; CODE XREF: copy_reg+CFFp
					; cp_options_default+18p
		extrn copy_acl:near	; CODE XREF: copy_reg+E7Ep
					; copy_internal+22EFp
		extrn set_acl:near	; CODE XREF: copy_reg+ED3p
					; copy_internal+233Ep
; int close(int	fd)
		extrn close:near	; CODE XREF: copy_reg+F7Dp
					; copy_reg+FD2p
		extrn same_name:near	; CODE XREF: same_file_ok+171p
					; same_file_ok+36Bp ...
		extrn stat64:near	; CODE XREF: same_file_ok+5A3p
					; same_file_ok+5FBp ...
		extrn can_write_any_file:near ;	CODE XREF: writable_destination+15p
		extrn euidaccess:near	; CODE XREF: writable_destination+26p
		extrn strmode:near	; CODE XREF: overwrite_prompt+4Ap
		extrn program_name:dword ; DATA	XREF: overwrite_prompt+73r
					; overwrite_prompt+B9r
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: overwrite_prompt+8Br
					; overwrite_prompt+D1r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: overwrite_prompt+9Fp
					; overwrite_prompt+DAp
		extrn triple_free	; DATA XREF: dest_info_init+9o
					; src_info_init+9o
		extrn triple_compare	; DATA XREF: dest_info_init+Eo
					; src_info_init+Eo
		extrn triple_hash	; DATA XREF: dest_info_init+13o
		extrn hash_initialize:near ; CODE XREF:	dest_info_init+1Cp
					; src_info_init+1Cp
		extrn triple_hash_no_name ; DATA XREF: src_info_init+13o
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: abandon_move+25p
					; valid_options+20p ...
		extrn yesno:near	; CODE XREF: abandon_move+83p
					; copy_internal+6ABp
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: emit_verbose+73p
		extrn seen_file:near	; CODE XREF: copy_internal+21Ap
					; copy_internal+7A2p ...
		extrn record_file:near	; CODE XREF: copy_internal+27Bp
					; copy_internal+1268p ...
		extrn utimecmp:near	; CODE XREF: copy_internal+532p
		extrn last_component:near ; CODE XREF: copy_internal+92Ep
		extrn find_backup_file_name:near ; CODE	XREF: copy_internal+983p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: copy_internal+9A0p
					; copy_internal+199Ap ...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: copy_internal+AB0p
; int rename(const char	*old, const char *new)
		extrn rename:near	; CODE XREF: copy_internal+ADEp
					; copy_internal+11D5p ...
		extrn src_to_dest_lookup:near ;	CODE XREF: copy_internal+E2Dp
					; copy_internal+F41p
		extrn remember_copied:near ; CODE XREF:	copy_internal+EB4p
					; copy_internal+F15p ...
		extrn rpl_linkat:near	; CODE XREF: copy_internal+105Fp
					; copy_internal+1135p ...
		extrn forget_created:near ; CODE XREF: copy_internal+1365p
					; copy_internal+1410p ...
; int mkdir(const char *path, __mode_t mode)
		extrn mkdir:near	; CODE XREF: copy_internal+172Bp
		extrn dir_name:near	; CODE XREF: copy_internal+197Ep
; int symlink(const char *from,	const char *to)
		extrn symlink:near	; CODE XREF: copy_internal+1A9Cp
					; copy_internal+1E08p
; int mknod(const char *path, __mode_t mode, __dev_t dev)
		extrn mknod:near	; CODE XREF: copy_internal+1C51p
					; copy_internal+1D23p
; int mkfifo(const char	*path, __mode_t	mode)
		extrn mkfifo:near	; CODE XREF: copy_internal+1C7Cp
		extrn areadlink_with_size:near ; CODE XREF: copy_internal+1D9Dp
					; copy_internal+1EBCp
		extrn utimens:near	; CODE XREF: copy_internal+2154p
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: cp_options_default+10p
; __mode_t umask(__mode_t mask)
		extrn umask:near	; CODE XREF: cached_umask+15p
					; cached_umask+2Bp


		end
