;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	975DDB4848E93562267438FF4BC2DD72
; Input	CRC32 :	F2E33D9B

; File Name   :	D:\coreutils-o\tac.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'tac.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+10Fp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+113p	main+155p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000159
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000230
; ---------------------------------------------------------------------------

loc_8000159:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWriteEachFileT ; "Write	each FILE to standard output, las"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBBeforeAttachT ; "  -b,	--before	     attach the	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000230:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl output(const char *start, const char *past_end)
output		proc near		; CODE XREF: tac_seekable+2AFp
					; tac_seekable+517p ...

bytes_to_add	= dword	ptr -10h
bytes_available	= dword	ptr -0Ch
start		= dword	ptr  8
past_end	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+past_end]
		mov	eax, [ebp+start]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+bytes_to_add], eax
		mov	eax, ds:bytes_in_buffer_5337
		mov	edx, 2000h
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+bytes_available], eax
		cmp	[ebp+start], 0
		jnz	short loc_80002E3
		mov	edx, ds:stdout
		mov	eax, ds:bytes_in_buffer_5337
		push	edx		; stream
		push	eax		; n
		push	1		; size
		push	offset buffer_5336 ; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	ds:bytes_in_buffer_5337, 0
		jmp	locret_8000317
; ---------------------------------------------------------------------------

loc_8000290:				; CODE XREF: output+AEj
		mov	eax, ds:bytes_in_buffer_5337
		add	eax, offset buffer_5336
		sub	esp, 4
		push	[ebp+bytes_available] ;	n
		push	[ebp+start]	; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+bytes_available]
		sub	[ebp+bytes_to_add], eax
		mov	eax, [ebp+bytes_available]
		add	[ebp+start], eax
		mov	eax, ds:stdout
		push	eax		; stream
		push	2000h		; n
		push	1		; size
		push	offset buffer_5336 ; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	ds:bytes_in_buffer_5337, 0
		mov	[ebp+bytes_available], 2000h

loc_80002E3:				; CODE XREF: output+28j
		mov	eax, [ebp+bytes_to_add]
		cmp	eax, [ebp+bytes_available]
		jnb	short loc_8000290
		mov	eax, ds:bytes_in_buffer_5337
		add	eax, offset buffer_5336
		sub	esp, 4
		push	[ebp+bytes_to_add] ; n
		push	[ebp+start]	; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	edx, ds:bytes_in_buffer_5337
		mov	eax, [ebp+bytes_to_add]
		add	eax, edx
		mov	ds:bytes_in_buffer_5337, eax

locret_8000317:				; CODE XREF: output+50j
		leave
		retn
output		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tac_seekable(int input_fd, const char *file)
tac_seekable	proc near		; CODE XREF: tac_nonseekable+49p
					; tac_file+F8p

first_time	= byte ptr -4Eh
first_char	= byte ptr -4Dh
match_start	= dword	ptr -4Ch
past_end	= dword	ptr -48h
saved_record_size= dword ptr -44h
separator1	= dword	ptr -40h
match_length1	= dword	ptr -3Ch
i		= dword	ptr -38h
ri		= dword	ptr -34h
range		= dword	ptr -30h
ret		= dword	ptr -2Ch
match_end	= dword	ptr -28h
offset		= dword	ptr -24h
match_start_offset= dword ptr -20h
past_end_offset	= dword	ptr -1Ch
old_G_buffer_size= dword ptr -18h
newbuffer	= dword	ptr -14h
file_pos	= qword	ptr -10h
input_fd	= dword	ptr  8
file		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 50h
		mov	[ebp+first_time], 1
		mov	eax, ds:separator
		movzx	eax, byte ptr [eax]
		mov	[ebp+first_char], al
		mov	eax, ds:separator
		add	eax, 1
		mov	[ebp+separator1], eax
		mov	eax, ds:match_length
		sub	eax, 1
		mov	[ebp+match_length1], eax
		push	2
		push	0
		push	0
		push	[ebp+input_fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+file_pos], eax
		mov	dword ptr [ebp+file_pos+4], edx
		cmp	dword ptr [ebp+file_pos+4], 0
		jg	short loc_8000379
		cmp	dword ptr [ebp+file_pos+4], 0
		js	short loc_800036F
		cmp	dword ptr [ebp+file_pos], 0
		ja	short loc_8000379

loc_800036F:				; CODE XREF: tac_seekable+4Ej
		mov	eax, 1
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_8000379:				; CODE XREF: tac_seekable+48j
					; tac_seekable+54j
		mov	eax, ds:read_size
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+file_pos]
		mov	edx, dword ptr [ebp+file_pos+4]
		push	ebx
		push	ecx
		push	edx
		push	eax
		call	__moddi3
		add	esp, 10h
		mov	[ebp+saved_record_size], eax
		cmp	[ebp+saved_record_size], 0
		jnz	short loc_80003A8
		mov	eax, ds:read_size
		mov	[ebp+saved_record_size], eax

loc_80003A8:				; CODE XREF: tac_seekable+85j
		mov	eax, [ebp+saved_record_size]
		mov	edx, 0
		sub	dword ptr [ebp+file_pos], eax
		sbb	dword ptr [ebp+file_pos+4], edx
		push	0
		push	dword ptr [ebp+file_pos+4]
		push	dword ptr [ebp+file_pos]
		push	[ebp+input_fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_8000403
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSSeekFailed ; "%s: seek	failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000403:				; CODE XREF: tac_seekable+B2j
		mov	eax, ds:G_buffer
		sub	esp, 4
		push	[ebp+saved_record_size]
		push	eax
		push	[ebp+input_fd]
		call	safe_read
		add	esp, 10h
		cmp	eax, [ebp+saved_record_size]
		jz	short loc_800045F
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_800045F:				; CODE XREF: tac_seekable+104j
		mov	edx, ds:G_buffer
		mov	eax, [ebp+saved_record_size]
		add	eax, edx
		mov	[ebp+past_end],	eax
		mov	eax, [ebp+past_end]
		mov	[ebp+match_start], eax
		mov	eax, ds:sentinel_length
		test	eax, eax
		jz	short loc_8000484
		mov	eax, [ebp+match_length1]
		neg	eax
		add	[ebp+match_start], eax

loc_8000484:				; CODE XREF: tac_seekable+161j
					; tac_seekable+49Cj ...
		mov	eax, ds:sentinel_length
		test	eax, eax
		jnz	loc_8000573
		mov	eax, [ebp+match_start]
		mov	edx, ds:G_buffer
		sub	eax, edx
		mov	[ebp+i], eax
		mov	eax, [ebp+i]
		mov	[ebp+ri], eax
		mov	eax, 1
		sub	eax, [ebp+ri]
		mov	[ebp+range], eax
		cmp	[ebp+range], 1
		jle	short loc_80004D6
		sub	esp, 0Ch
		push	offset aRecordTooLarge ; "record too large"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80004D6:				; CODE XREF: tac_seekable+19Bj
		cmp	[ebp+range], 1
		jz	short loc_8000510
		mov	eax, [ebp+i]
		sub	eax, 1
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, ds:G_buffer
		sub	esp, 8
		push	offset regs	; regs
		push	[ebp+range]	; range
		push	ecx		; start
		push	edx		; length
		push	eax		; string
		push	offset compiled_separator ; buffer
		call	re_search
		add	esp, 20h
		mov	[ebp+ret], eax
		cmp	[ebp+ret], 0FFFFFFFFh
		jnz	short loc_8000520

loc_8000510:				; CODE XREF: tac_seekable+1C1j
		mov	eax, ds:G_buffer
		sub	eax, 1
		mov	[ebp+match_start], eax
		jmp	loc_80005A4
; ---------------------------------------------------------------------------

loc_8000520:				; CODE XREF: tac_seekable+1F5j
		cmp	[ebp+ret], 0FFFFFFFEh
		jnz	short loc_8000548
		sub	esp, 0Ch
		push	offset aErrorInRegular ; "error	in regular expression search"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_80005A4
; ---------------------------------------------------------------------------

loc_8000548:				; CODE XREF: tac_seekable+20Bj
		mov	edx, ds:G_buffer
		mov	eax, ds:regs.start
		mov	eax, [eax]
		add	eax, edx
		mov	[ebp+match_start], eax
		mov	eax, ds:regs.end
		mov	edx, [eax]
		mov	eax, ds:regs.start
		mov	eax, [eax]
		sub	edx, eax
		mov	eax, edx
		mov	ds:match_length, eax
		jmp	short loc_80005A4
; ---------------------------------------------------------------------------

loc_8000573:				; CODE XREF: tac_seekable+172j
					; tac_seekable+267j ...
		sub	[ebp+match_start], 1
		mov	eax, [ebp+match_start]
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+first_char]
		jnz	short loc_8000573
		cmp	[ebp+match_length1], 0
		jz	short loc_80005A4
		mov	eax, [ebp+match_start]
		add	eax, 1
		sub	esp, 4
		push	[ebp+match_length1] ; n
		push	[ebp+separator1] ; s2
		push	eax		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000573

loc_80005A4:				; CODE XREF: tac_seekable+202j
					; tac_seekable+22Dj ...
		mov	eax, ds:G_buffer
		cmp	[ebp+match_start], eax
		jnb	loc_80007FB
		mov	eax, dword ptr [ebp+file_pos+4]
		or	eax, dword ptr [ebp+file_pos]
		test	eax, eax
		jnz	short loc_80005DA
		mov	eax, ds:G_buffer
		sub	esp, 8
		push	[ebp+past_end]	; past_end
		push	eax		; start
		call	output
		add	esp, 10h
		mov	eax, 1
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_80005DA:				; CODE XREF: tac_seekable+2A1j
		mov	eax, [ebp+past_end]
		mov	edx, ds:G_buffer
		sub	eax, edx
		mov	[ebp+saved_record_size], eax
		mov	eax, ds:read_size
		cmp	[ebp+saved_record_size], eax
		jbe	loc_80006AA
		mov	eax, ds:sentinel_length
		test	eax, eax
		jz	short loc_8000606
		mov	eax, ds:sentinel_length
		jmp	short loc_800060B
; ---------------------------------------------------------------------------

loc_8000606:				; CODE XREF: tac_seekable+2E4j
		mov	eax, 1

loc_800060B:				; CODE XREF: tac_seekable+2EBj
		mov	[ebp+offset], eax
		mov	eax, [ebp+match_start]
		mov	edx, ds:G_buffer
		sub	eax, edx
		mov	[ebp+match_start_offset], eax
		mov	eax, [ebp+past_end]
		mov	edx, ds:G_buffer
		sub	eax, edx
		mov	[ebp+past_end_offset], eax
		mov	eax, ds:G_buffer_size
		mov	[ebp+old_G_buffer_size], eax
		mov	eax, ds:read_size
		add	eax, eax
		mov	ds:read_size, eax
		mov	eax, ds:read_size
		lea	edx, [eax+eax]
		mov	eax, ds:sentinel_length
		add	eax, edx
		add	eax, 2
		mov	ds:G_buffer_size, eax
		mov	eax, ds:G_buffer_size
		cmp	eax, [ebp+old_G_buffer_size]
		jnb	short loc_8000664
		call	xalloc_die

loc_8000664:				; CODE XREF: tac_seekable+344j
		mov	eax, ds:G_buffer_size
		mov	edx, ds:G_buffer
		mov	ecx, [ebp+offset]
		neg	ecx
		add	edx, ecx
		sub	esp, 8
		push	eax		; size_t
		push	edx		; void *
		call	xrealloc
		add	esp, 10h
		mov	[ebp+newbuffer], eax
		mov	eax, [ebp+offset]
		add	[ebp+newbuffer], eax
		mov	edx, [ebp+match_start_offset]
		mov	eax, [ebp+newbuffer]
		add	eax, edx
		mov	[ebp+match_start], eax
		mov	edx, [ebp+past_end_offset]
		mov	eax, [ebp+newbuffer]
		add	eax, edx
		mov	[ebp+past_end],	eax
		mov	eax, [ebp+newbuffer]
		mov	ds:G_buffer, eax

loc_80006AA:				; CODE XREF: tac_seekable+2D7j
		mov	eax, ds:read_size
		mov	edx, 0
		cmp	edx, dword ptr [ebp+file_pos+4]
		jg	short loc_80006D5
		cmp	edx, dword ptr [ebp+file_pos+4]
		jl	short loc_80006C3
		cmp	eax, dword ptr [ebp+file_pos]
		ja	short loc_80006D5

loc_80006C3:				; CODE XREF: tac_seekable+3A3j
		mov	eax, ds:read_size
		mov	edx, 0
		sub	dword ptr [ebp+file_pos], eax
		sbb	dword ptr [ebp+file_pos+4], edx
		jmp	short loc_80006EB
; ---------------------------------------------------------------------------

loc_80006D5:				; CODE XREF: tac_seekable+39Ej
					; tac_seekable+3A8j
		mov	eax, dword ptr [ebp+file_pos]
		mov	ds:read_size, eax
		mov	dword ptr [ebp+file_pos], 0
		mov	dword ptr [ebp+file_pos+4], 0

loc_80006EB:				; CODE XREF: tac_seekable+3BAj
		push	0
		push	dword ptr [ebp+file_pos+4]
		push	dword ptr [ebp+file_pos]
		push	[ebp+input_fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_8000738
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSSeekFailed ; "%s: seek	failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000738:				; CODE XREF: tac_seekable+3E7j
		mov	eax, ds:G_buffer
		mov	ecx, ds:G_buffer
		mov	edx, ds:read_size
		add	edx, ecx
		sub	esp, 4
		push	[ebp+saved_record_size]	; n
		push	eax		; src
		push	edx		; dest
		call	memmove
		add	esp, 10h
		mov	eax, ds:G_buffer
		mov	ecx, ds:read_size
		mov	edx, [ebp+saved_record_size]
		add	edx, ecx
		add	eax, edx
		mov	[ebp+past_end],	eax
		mov	eax, ds:sentinel_length
		test	eax, eax
		jz	short loc_800078B
		mov	edx, ds:G_buffer
		mov	eax, ds:read_size
		add	eax, edx
		mov	[ebp+match_start], eax
		jmp	short loc_8000791
; ---------------------------------------------------------------------------

loc_800078B:				; CODE XREF: tac_seekable+45Ej
		mov	eax, [ebp+past_end]
		mov	[ebp+match_start], eax

loc_8000791:				; CODE XREF: tac_seekable+470j
		mov	edx, ds:read_size
		mov	eax, ds:G_buffer
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+input_fd]
		call	safe_read
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:read_size
		cmp	edx, eax
		jz	loc_8000484
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_80007FB:				; CODE XREF: tac_seekable+293j
		movzx	eax, ds:separator_ends_record
		test	al, al
		jz	short loc_8000844
		mov	edx, ds:match_length
		mov	eax, [ebp+match_start]
		add	eax, edx
		mov	[ebp+match_end], eax
		movzx	eax, [ebp+first_time]
		xor	eax, 1
		test	al, al
		jnz	short loc_8000827
		mov	eax, [ebp+match_end]
		cmp	eax, [ebp+past_end]
		jz	short loc_8000838

loc_8000827:				; CODE XREF: tac_seekable+504j
		sub	esp, 8
		push	[ebp+past_end]	; past_end
		push	[ebp+match_end]	; start
		call	output
		add	esp, 10h

loc_8000838:				; CODE XREF: tac_seekable+50Cj
		mov	eax, [ebp+match_end]
		mov	[ebp+past_end],	eax
		mov	[ebp+first_time], 0
		jmp	short loc_800085B
; ---------------------------------------------------------------------------

loc_8000844:				; CODE XREF: tac_seekable+4EBj
		sub	esp, 8
		push	[ebp+past_end]	; past_end
		push	[ebp+match_start] ; start
		call	output
		add	esp, 10h
		mov	eax, [ebp+match_start]
		mov	[ebp+past_end],	eax

loc_800085B:				; CODE XREF: tac_seekable+529j
		mov	eax, ds:sentinel_length
		test	eax, eax
		jz	loc_8000484
		mov	eax, ds:match_length
		mov	edx, 1
		sub	edx, eax
		mov	eax, edx
		add	[ebp+match_start], eax
		jmp	loc_8000484
; ---------------------------------------------------------------------------

loc_800087E:				; CODE XREF: tac_seekable+5Bj
					; tac_seekable+141j ...
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tac_seekable	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl record_or_unlink_tempfile(const char *fn, FILE *fp)
record_or_unlink_tempfile proc near	; CODE XREF: copy_to_temp+17Cp

fn		= dword	ptr  8
fp		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+fn]	; name
		call	unlink
		add	esp, 10h
		nop
		leave
		retn
record_or_unlink_tempfile endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	copy_to_temp(FILE **g_tmp, char	**g_tempfile, int input_fd, const char *file)
copy_to_temp	proc near		; CODE XREF: tac_nonseekable+26p

Template	= dword	ptr -1Ch
tempfile	= dword	ptr -18h
fd		= dword	ptr -14h
tmp		= dword	ptr -10h
bytes_read	= dword	ptr -0Ch
g_tmp		= dword	ptr  8
g_tempfile	= dword	ptr  0Ch
input_fd	= dword	ptr  10h
file		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	eax, ds:template_5379
		test	eax, eax
		jnz	loc_8000932
		mov	[ebp+Template],	offset aSTacxxxxxx ; "%s/tacXXXXXX"
		sub	esp, 0Ch
		push	offset name	; "TMPDIR"
		call	getenv
		add	esp, 10h
		mov	ds:tempdir_5380, eax
		mov	eax, ds:tempdir_5380
		test	eax, eax
		jnz	short loc_80008E0
		mov	ds:tempdir_5380, offset	aTmp ; "/tmp"

loc_80008E0:				; CODE XREF: copy_to_temp+38j
		mov	eax, ds:tempdir_5380
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+Template]	; s
		call	strlen
		add	esp, 10h
		add	eax, ebx
		sub	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:template_5379, eax
		mov	edx, ds:tempdir_5380
		mov	eax, ds:template_5379
		sub	esp, 4
		push	edx
		push	[ebp+Template]	; format
		push	eax		; s
		call	sprintf
		add	esp, 10h

loc_8000932:				; CODE XREF: copy_to_temp+Fj
		mov	eax, ds:template_5379
		mov	[ebp+tempfile],	eax
		mov	eax, ds:template_5379
		sub	esp, 0Ch
		push	eax
		call	mkstemp_safer
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		jns	short loc_8000997
		mov	eax, ds:tempdir_5380
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateTe ; "cannot create	temporary file in %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000B55
; ---------------------------------------------------------------------------

loc_8000997:				; CODE XREF: copy_to_temp+B6j
		sub	esp, 8
		push	offset modes	; "w+"
		push	[ebp+fd]	; fd
		call	fdopen
		add	esp, 10h
		mov	[ebp+tmp], eax
		cmp	[ebp+tmp], 0
		jnz	short loc_8000A0F
		sub	esp, 0Ch
		push	[ebp+tempfile]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for writing"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tempfile]	; name
		call	unlink
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000B55
; ---------------------------------------------------------------------------

loc_8000A0F:				; CODE XREF: copy_to_temp+115j
		sub	esp, 8
		push	[ebp+tmp]	; fp
		push	[ebp+tempfile]	; fn
		call	record_or_unlink_tempfile
		add	esp, 10h

loc_8000A20:				; CODE XREF: copy_to_temp+206j
		mov	edx, ds:read_size
		mov	eax, ds:G_buffer
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+input_fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jz	loc_8000AE0
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8000A89
		sub	esp, 0Ch
		push	[ebp+file]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	Fail
; ---------------------------------------------------------------------------

loc_8000A89:				; CODE XREF: copy_to_temp+1B0j
		mov	eax, ds:G_buffer
		push	[ebp+tmp]	; stream
		push	[ebp+bytes_read] ; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+bytes_read]
		jz	loc_8000A20
		sub	esp, 0Ch
		push	[ebp+tempfile]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSWriteError ; "%s: write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short Fail
; ---------------------------------------------------------------------------

loc_8000AE0:				; CODE XREF: copy_to_temp+1A6j
		nop
		sub	esp, 0Ch
		push	[ebp+tmp]	; stream
		call	fflush_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B2B
		sub	esp, 0Ch
		push	[ebp+tempfile]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSWriteError ; "%s: write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short Fail
; ---------------------------------------------------------------------------

loc_8000B2B:				; CODE XREF: copy_to_temp+255j
		mov	eax, [ebp+g_tmp]
		mov	edx, [ebp+tmp]
		mov	[eax], edx
		mov	eax, [ebp+g_tempfile]
		mov	edx, [ebp+tempfile]
		mov	[eax], edx
		mov	eax, 1
		jmp	short loc_8000B55
; ---------------------------------------------------------------------------

Fail:					; CODE XREF: copy_to_temp+1E8j
					; copy_to_temp+242j ...
		sub	esp, 0Ch
		push	[ebp+tmp]	; stream
		call	fclose
		add	esp, 10h
		mov	eax, 0

loc_8000B55:				; CODE XREF: copy_to_temp+F6j
					; copy_to_temp+16Ej ...
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
copy_to_temp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tac_nonseekable(int input_fd, const char *file)
tac_nonseekable	proc near		; CODE XREF: tac_file+DDp

file		= dword	ptr -1Ch
tmp_stream	= dword	ptr -14h
tmp_file	= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
input_fd	= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_4]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		push	[ebp+file]	; file
		push	[ebp+input_fd]	; input_fd
		lea	eax, [ebp+tmp_file]
		push	eax		; g_tempfile
		lea	eax, [ebp+tmp_stream]
		push	eax		; g_tmp
		call	copy_to_temp
		add	esp, 10h
		test	al, al
		jz	short loc_8000BB8
		mov	ebx, [ebp+tmp_file]
		mov	eax, [ebp+tmp_stream]
		sub	esp, 0Ch
		push	eax		; stream
		call	fileno
		add	esp, 10h
		sub	esp, 8
		push	ebx		; file
		push	eax		; input_fd
		call	tac_seekable
		add	esp, 10h
		test	al, al
		jz	short loc_8000BB8
		mov	eax, 1
		jmp	short loc_8000BBD
; ---------------------------------------------------------------------------

loc_8000BB8:				; CODE XREF: tac_nonseekable+30j
					; tac_nonseekable+53j
		mov	eax, 0

loc_8000BBD:				; CODE XREF: tac_nonseekable+5Aj
		and	eax, 1
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000BD1
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000BD1:				; CODE XREF: tac_nonseekable+6Ej
		mov	ebx, [ebp+var_4]
		leave
		retn
tac_nonseekable	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tac_file(const char *filename)
tac_file	proc near		; CODE XREF: main+331p

ok		= byte ptr -16h
is_stdin	= byte ptr -15h
fd		= dword	ptr -14h
file_size	= qword	ptr -10h
filename	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		sub	esp, 8
		push	offset asc_800378D ; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_8000C22
		mov	ds:have_read_stdin, 1
		mov	[ebp+fd], 0
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	[ebp+filename],	eax
		jmp	short loc_8000C7B
; ---------------------------------------------------------------------------

loc_8000C22:				; CODE XREF: tac_file+27j
		sub	esp, 8
		push	0
		push	[ebp+filename]
		call	open64
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		jns	short loc_8000C7B
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSF_0 ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D3C
; ---------------------------------------------------------------------------

loc_8000C7B:				; CODE XREF: tac_file+4Aj tac_file+63j
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+file_size], eax
		mov	dword ptr [ebp+file_size+4], edx
		cmp	dword ptr [ebp+file_size+4], 0
		js	short loc_8000CAA
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000CC5

loc_8000CAA:				; CODE XREF: tac_file+C0j
		sub	esp, 8
		push	[ebp+filename]	; file
		push	[ebp+fd]	; input_fd
		call	tac_nonseekable
		add	esp, 10h
		movzx	eax, al
		test	eax, eax
		setnz	al
		jmp	short loc_8000CDE
; ---------------------------------------------------------------------------

loc_8000CC5:				; CODE XREF: tac_file+D2j
		sub	esp, 8
		push	[ebp+filename]	; file
		push	[ebp+fd]	; input_fd
		call	tac_seekable
		add	esp, 10h
		movzx	eax, al
		test	eax, eax
		setnz	al

loc_8000CDE:				; CODE XREF: tac_file+EDj
		mov	[ebp+ok], al
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8000D38
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000D38
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8000D38:				; CODE XREF: tac_file+114j
					; tac_file+126j
		movzx	eax, [ebp+ok]

loc_8000D3C:				; CODE XREF: tac_file+A0j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
tac_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ok		= byte ptr -21h
i		= dword	ptr -20h
optc		= dword	ptr -1Ch
error_message	= dword	ptr -18h
half_buffer_size= dword	ptr -14h
buf		= dword	ptr -10h
file		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 20h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:separator, offset asc_80037D2 ; "\n"
		mov	ds:sentinel_length, 1
		mov	ds:separator_ends_record, 1
		jmp	loc_8000E9D
; ---------------------------------------------------------------------------

loc_8000DCF:				; CODE XREF: main+17Dj
		mov	eax, [ebp+optc]
		cmp	eax, 62h
		jz	short loc_8000DFE
		cmp	eax, 62h
		jg	short loc_8000DEF
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_8000E5B
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8000E51
		jmp	loc_8000E93
; ---------------------------------------------------------------------------

loc_8000DEF:				; CODE XREF: main+97j
		cmp	eax, 72h
		jz	short loc_8000E0A
		cmp	eax, 73h
		jz	short loc_8000E19
		jmp	loc_8000E93
; ---------------------------------------------------------------------------

loc_8000DFE:				; CODE XREF: main+92j
		mov	ds:separator_ends_record, 0
		jmp	loc_8000E9D
; ---------------------------------------------------------------------------

loc_8000E0A:				; CODE XREF: main+AFj
		mov	ds:sentinel_length, 0
		jmp	loc_8000E9D
; ---------------------------------------------------------------------------

loc_8000E19:				; CODE XREF: main+B4j
		mov	eax, ds:optarg
		mov	ds:separator, eax
		mov	eax, ds:separator
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000E9D
		sub	esp, 0Ch
		push	offset aSeparatorCanno ; "separator cannot be empty"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000E9D
; ---------------------------------------------------------------------------

loc_8000E51:				; CODE XREF: main+A5j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E5B:				; CODE XREF: main+9Ej
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aJayLepreau ; "Jay Lepreau"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aTac	; "tac"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000E93:				; CODE XREF: main+A7j main+B6j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E9D:				; CODE XREF: main+87j main+C2j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "brs:"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_8000DCF
		mov	eax, ds:sentinel_length
		test	eax, eax
		jnz	short loc_8000F40
		mov	ds:compiled_separator.buffer, 0
		mov	ds:compiled_separator.allocated, 0
		mov	ds:compiled_separator.fastmap, offset compiled_separator_fastmap
		mov	ds:compiled_separator.translate, 0
		mov	eax, ds:separator
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:separator
		sub	esp, 4
		push	offset compiled_separator ; buffer
		push	edx		; length
		push	eax		; pattern
		call	re_compile_pattern
		add	esp, 10h
		mov	[ebp+error_message], eax
		cmp	[ebp+error_message], 0
		jz	short loc_8000F60
		push	[ebp+error_message]
		push	offset format	; "%s"
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000F60
; ---------------------------------------------------------------------------

loc_8000F40:				; CODE XREF: main+18Aj
		mov	eax, ds:separator
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	ds:sentinel_length, eax
		mov	eax, ds:sentinel_length
		mov	ds:match_length, eax

loc_8000F60:				; CODE XREF: main+1E5j	main+1FBj
		mov	ds:read_size, 2000h
		jmp	short loc_8000F86
; ---------------------------------------------------------------------------

loc_8000F6C:				; CODE XREF: main+253j
		mov	eax, ds:read_size
		test	eax, eax
		jns	short loc_8000F7A
		call	xalloc_die

loc_8000F7A:				; CODE XREF: main+230j
		mov	eax, ds:read_size
		add	eax, eax
		mov	ds:read_size, eax

loc_8000F86:				; CODE XREF: main+227j
		mov	eax, ds:read_size
		shr	eax, 1
		mov	edx, eax
		mov	eax, ds:sentinel_length
		cmp	edx, eax
		jbe	short loc_8000F6C
		mov	edx, ds:read_size
		mov	eax, ds:sentinel_length
		add	eax, edx
		add	eax, 1
		mov	[ebp+half_buffer_size],	eax
		mov	eax, [ebp+half_buffer_size]
		add	eax, eax
		mov	ds:G_buffer_size, eax
		mov	eax, ds:read_size
		cmp	eax, [ebp+half_buffer_size]
		jnb	short loc_8000FC9
		mov	eax, ds:G_buffer_size
		cmp	[ebp+half_buffer_size],	eax
		jb	short loc_8000FCE

loc_8000FC9:				; CODE XREF: main+27Aj
		call	xalloc_die

loc_8000FCE:				; CODE XREF: main+284j
		mov	eax, ds:G_buffer_size
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:G_buffer, eax
		mov	eax, ds:G_buffer
		mov	[ebp+buf], eax
		mov	eax, ds:sentinel_length
		test	eax, eax
		jz	short loc_8001021
		mov	edx, ds:separator
		mov	eax, ds:G_buffer
		sub	esp, 8
		push	edx		; src
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		mov	edx, ds:G_buffer
		mov	eax, ds:sentinel_length
		add	eax, edx
		mov	ds:G_buffer, eax
		jmp	short loc_800102E
; ---------------------------------------------------------------------------

loc_8001021:				; CODE XREF: main+2B0j
		mov	eax, ds:G_buffer
		add	eax, 1
		mov	ds:G_buffer, eax

loc_800102E:				; CODE XREF: main+2DCj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_800104A
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		jmp	short loc_800104F
; ---------------------------------------------------------------------------

loc_800104A:				; CODE XREF: main+2F2j
		mov	eax, offset default_file_list_5410

loc_800104F:				; CODE XREF: main+305j
		mov	[ebp+file], eax
		mov	[ebp+ok], 1
		mov	[ebp+i], 0
		jmp	short loc_8001091
; ---------------------------------------------------------------------------

loc_800105F:				; CODE XREF: main+361j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; filename
		call	tac_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	[ebp+i], 1

loc_8001091:				; CODE XREF: main+31Aj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_800105F
		sub	esp, 8
		push	0		; past_end
		push	0		; start
		call	output
		add	esp, 10h
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_80010EF
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_80010EF
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_800378D ; "-"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_80010EF:				; CODE XREF: main+37Bj	main+38Cj
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h
		cmp	[ebp+ok], 0
		jz	short loc_800110A
		mov	eax, 0
		jmp	short loc_800110F
; ---------------------------------------------------------------------------

loc_800110A:				; CODE XREF: main+3BEj
		mov	eax, 1

loc_800110F:				; CODE XREF: main+3C5j
		sub	esp, 0Ch
		push	eax		; status

loc_8001113:				; DATA XREF: .eh_frame:08003840o
					; .eh_frame:08003864o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8001120h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; const	char *separator
separator	dd ?			; DATA XREF: tac_seekable+Cr
					; tac_seekable+17r ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: tac_file+29w main+372r
; _Bool	separator_ends_record
separator_ends_record db ?		; DATA XREF: tac_seekable:loc_80007FBr
					; main+80w ...
		align 4
; size_t sentinel_length
sentinel_length	dd ?			; DATA XREF: tac_seekable+15Ar
					; tac_seekable:loc_8000484r ...
; size_t match_length
match_length	dd ?			; DATA XREF: tac_seekable+22r
					; tac_seekable+253w ...
; char *G_buffer
G_buffer	dd ?			; DATA XREF: tac_seekable:loc_8000403r
					; tac_seekable:loc_800045Fr ...
; size_t read_size
read_size	dd ?			; DATA XREF: tac_seekable:loc_8000379r
					; tac_seekable+87r ...
; size_t G_buffer_size
G_buffer_size	dd ?			; DATA XREF: tac_seekable+311r
					; tac_seekable+337w ...
		align 10h
; re_pattern_buffer compiled_separator
compiled_separator re_pattern_buffer <?> ; DATA	XREF: tac_seekable+1E1o
					; main+18Cw ...
; char compiled_separator_fastmap[256]
compiled_separator_fastmap db 100h dup(?) ; DATA XREF: main+1A0o
; re_registers regs
regs		re_registers <?>	; DATA XREF: tac_seekable+1D6o
					; tac_seekable+235r ...
; Function-local static	variable
; size_t bytes_in_buffer_5337
bytes_in_buffer_5337 dd	?		; DATA XREF: output+13r output+30r ...
		align 20h
; Function-local static	variable
; char buffer_5336[8192]
buffer_5336	db 2000h dup(?)		; DATA XREF: output+39o output+5Ao ...
; Function-local static	variable
; char *template_5379
template_5379	dd ?			; DATA XREF: copy_to_temp+8r
					; copy_to_temp+76w ...
; Function-local static	variable
; const	char *tempdir_5380
tempdir_5380	dd ?			; DATA XREF: copy_to_temp+2Cw
					; copy_to_temp+31r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80032A0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+133o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aBefore		db 'before',0           ; DATA XREF: .rodata:longoptso
aRegex		db 'regex',0            ; DATA XREF: .rodata:longoptso
aSeparator	db 'separator',0        ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[6]
longopts	option <offset aBefore,	0, 0, 62h> ; DATA XREF:	main+15Fo
		option <offset aRegex, 0, 0, 72h> ; "before"
		option <offset aSeparator, 1, 0, 73h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aWriteEachFileT[]
aWriteEachFileT	db 'Write each FILE to standard output, last line first.',0Ah
					; DATA XREF: usage+69o
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aBBeforeAttachT[]
aBBeforeAttachT	db '  -b, --before             attach the separator before instead of'
					; DATA XREF: usage+AFo
		db ' after',0Ah
		db '  -r, --regex              interpret the separator as a regular e'
		db 'xpression',0Ah
		db '  -s, --separator=STRING   use STRING as the separator instead of'
		db ' newline',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+F5o
; char aSSeekFailed[]
aSSeekFailed	db '%s: seek failed',0  ; DATA XREF: tac_seekable+C7o
					; tac_seekable+3FCo
; char aSReadError[]
aSReadError	db '%s: read error',0   ; DATA XREF: tac_seekable+119o
					; tac_seekable+4B5o ...
; char aRecordTooLarge[]
aRecordTooLarge	db 'record too large',0 ; DATA XREF: tac_seekable+1A0o
		align 10h
; char aErrorInRegular[]
aErrorInRegular	db 'error in regular expression search',0 ; DATA XREF: tac_seekable+210o
aSTacxxxxxx	db '%s/tacXXXXXX',0     ; DATA XREF: copy_to_temp+15o
; char name[]
name		db 'TMPDIR',0           ; DATA XREF: copy_to_temp+1Fo
aTmp		db '/tmp',0             ; DATA XREF: copy_to_temp+3Ao
; char aCannotCreateTe[]
aCannotCreateTe	db 'cannot create temporary file in %s',0 ; DATA XREF: copy_to_temp+CEo
; char modes[]
modes		db 'w+',0               ; DATA XREF: copy_to_temp+FEo
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for writing',0 ; DATA XREF: copy_to_temp+12Ao
; char aSWriteError[]
aSWriteError	db '%s: write error',0  ; DATA XREF: copy_to_temp+21Fo
					; copy_to_temp+26Ao
; char asc_800378D[]
asc_800378D	db '-',0                ; DATA XREF: tac_file+Bo main+398o ...
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: tac_file+3Ao
; char aCannotOpenSF_0[]
aCannotOpenSF_0	db 'cannot open %s for reading',0 ; DATA XREF: tac_file+78o
; char locale
locale		db 0			; DATA XREF: main+28o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
asc_80037D2	db 0Ah,0		; DATA XREF: main+6Co
; char aSeparatorCanno[]
aSeparatorCanno	db 'separator cannot be empty',0 ; DATA XREF: main+EFo
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+128o
aJayLepreau	db 'Jay Lepreau',0      ; DATA XREF: main+12Do
aTac		db 'tac',0              ; DATA XREF: main+138o
; char shortopts[]
shortopts	db 'brs:',0             ; DATA XREF: main+164o
; char format[]
format		db '%s',0               ; DATA XREF: main+1EAo
		align 4
; Function-local static	variable
; const	char *const default_file_list_5410[2]
default_file_list_5410 dd offset asc_800378D ; DATA XREF: main:loc_800104Ao
					; "-"
		align 10h
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8003820h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8001113-8004953h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset loc_8001113-800485Bh
		dd 11Fh, 80E4100h, 0D420285h, 3834405h,	1Ch, 5Ch
		dd offset loc_8001113-8004758h
		dd 0DEh, 80E4100h, 0D420285h, 0C5DA0205h, 4040Ch, 28h
		dd 7Ch
		dd offset loc_8001113-800469Ah
		dd 56Ch, 80E4100h, 0D420285h, 3864505h,	61030483h, 0C641C305h
		dd 40CC541h, 4,	1Ch, 0A8h
		dd offset loc_8001113-800415Ah
		dd 17h,	80E4100h, 0D420285h, 0CC55305h,	404h, 28h, 0C8h
		dd offset loc_8001113-8004163h
		dd 2C0h, 80E4100h, 0D420285h, 3864505h,	0B5030483h, 0C641C302h
		dd 40CC541h, 4,	20h, 0F4h
		dd offset loc_8001113-8003ECFh
		dd 7Ah,	80E4100h, 0D420285h, 3834405h, 0C3C57202h, 4040Ch
		dd 28h,	118h
		dd offset loc_8001113-8003E79h
		dd 16Dh, 80E4100h, 0D420285h, 3864505h,	62030483h, 0C641C301h
		dd 40CC541h, 4,	24h, 144h
		dd offset loc_8001113-8003D38h
		dd 3D5h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
					; tac_seekable+27Fp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+11Ap main+14Bp ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	output+3Ep output+8Fp	...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: output+69p output+C4p
		extrn __moddi3:near	; CODE XREF: tac_seekable+76p
		extrn lseek64:near	; CODE XREF: tac_seekable+36p
					; tac_seekable+A8p ...
		extrn quotearg_colon:near ; CODE XREF: tac_seekable+BAp
					; tac_seekable+10Cp ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: tac_seekable+D6p
					; tac_seekable+128p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: tac_seekable+E2p
					; tac_seekable+134p ...
		extrn safe_read:near	; CODE XREF: tac_seekable+F9p
					; tac_seekable+48Bp ...
; int re_search(struct re_pattern_buffer *buffer, const	char *string, int length, int start, int range,	struct re_registers *regs)
		extrn re_search:near	; CODE XREF: tac_seekable+1E6p
		extrn xalloc_die:near	; CODE XREF: tac_seekable+346p
					; main+232p ...
; void *xrealloc(void *, size_t)
		extrn xrealloc:near	; CODE XREF: tac_seekable+362p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: tac_seekable+43Ap
; int unlink(const char	*name)
		extrn unlink:near	; CODE XREF: record_or_unlink_tempfile+Cp
					; copy_to_temp+161p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: copy_to_temp+24p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: copy_to_temp+4Dp
					; copy_to_temp+5Dp ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: copy_to_temp+6Ep
					; main+294p
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: copy_to_temp+8Ep
		extrn mkstemp_safer:near ; CODE	XREF: copy_to_temp+A7p
		extrn quote:near	; CODE XREF: copy_to_temp+C1p
					; copy_to_temp+11Dp ...
; FILE *fdopen(int fd, const char *modes)
		extrn fdopen:near	; CODE XREF: copy_to_temp+106p
; int close(int	fd)
		extrn close:near	; CODE XREF: copy_to_temp+153p
					; tac_file+11Cp ...
; int fflush_unlocked(FILE *stream)
		extrn fflush_unlocked:near ; CODE XREF:	copy_to_temp+24Bp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: copy_to_temp+2ACp
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: tac_nonseekable+3Cp
		extrn __stack_chk_fail:near ; CODE XREF: tac_nonseekable+70p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: tac_file+13p
		extrn open64:near	; CODE XREF: tac_file+54p
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: tac_file+C8p
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+5Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+64p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000E19r
		extrn Version:dword	; DATA XREF: main:loc_8000E5Br
		extrn version_etc:near	; CODE XREF: main+13Ep
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+16Ep
; const	char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer)
		extrn re_compile_pattern:near ;	CODE XREF: main+1D6p
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: main+2C2p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_800102Er
					; main+2F4r
; void free(void *ptr)
		extrn free:near		; CODE XREF: main+3B2p


		end
