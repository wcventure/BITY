;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	0FEDCA0D6BFED09BBDEAD59485CCEAFD
; Input	CRC32 :	7D36E803

; File Name   :	D:\coreutils-o\base64.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'base64.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+10Fp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+136p	main+173p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000159
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000230
; ---------------------------------------------------------------------------

loc_8000159:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]\nBase64 en"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWWrapColsWrapE ; "  -w,	--wrap=COLS	  Wrap encoded li"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithNoFileOrWh ; "\nWith no FILE, or when FILE is -, read"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTheDataAreEnco ; "\nThe	data are encoded as described for"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000230:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl wrap_write(const	char *buffer, size_t len, uintmax_t wrap_column, size_t	*current_column, FILE *out)
wrap_write	proc near		; CODE XREF: do_encode+13Cp

wrap_column	= qword	ptr -20h
written		= dword	ptr -18h
to_write	= dword	ptr -14h
cols_remaining	= qword	ptr -10h
var_4		= dword	ptr -4
buffer		= dword	ptr  8
len		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
current_column	= dword	ptr  18h
out		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+wrap_column], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+wrap_column+4], eax
		mov	eax, dword ptr [ebp+wrap_column+4]
		or	eax, dword ptr [ebp+wrap_column]
		test	eax, eax
		jnz	short loc_80002A4
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+len]	; n
		push	1		; size
		push	[ebp+buffer]	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+len]
		jnb	loc_80003B1
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_80003B1
; ---------------------------------------------------------------------------

loc_80002A4:				; CODE XREF: wrap_write+1Bj
		mov	[ebp+written], 0
		jmp	loc_80003A5
; ---------------------------------------------------------------------------

loc_80002B0:				; CODE XREF: wrap_write+170j
		mov	eax, [ebp+current_column]
		mov	eax, [eax]
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+wrap_column]
		mov	edx, dword ptr [ebp+wrap_column+4]
		sub	eax, ecx
		sbb	edx, ebx
		mov	dword ptr [ebp+cols_remaining],	eax
		mov	dword ptr [ebp+cols_remaining+4], edx
		mov	eax, dword ptr [ebp+cols_remaining]
		mov	edx, dword ptr [ebp+cols_remaining+4]
		cmp	edx, 0
		jbe	short loc_80002E1
		mov	eax, 0FFFFFFFFh
		mov	edx, 0

loc_80002E1:				; CODE XREF: wrap_write+9Aj
		mov	[ebp+to_write],	eax
		mov	eax, [ebp+len]
		sub	eax, [ebp+written]
		mov	edx, eax
		mov	eax, [ebp+to_write]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+to_write],	eax
		cmp	[ebp+to_write],	0
		jnz	short loc_8000347
		sub	esp, 8
		push	[ebp+out]
		push	offset asc_8001164 ; "\n"
		call	fputs_unlocked
		add	esp, 10h
		test	eax, eax
		jns	short loc_800033C
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800033C:				; CODE XREF: wrap_write+D7j
		mov	eax, [ebp+current_column]
		mov	dword ptr [eax], 0
		jmp	short loc_80003A5
; ---------------------------------------------------------------------------

loc_8000347:				; CODE XREF: wrap_write+C0j
		mov	eax, ds:stdout
		mov	ecx, [ebp+buffer]
		mov	edx, [ebp+written]
		add	edx, ecx
		push	eax		; stream
		push	[ebp+to_write]	; n
		push	1		; size
		push	edx		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+to_write]
		jnb	short loc_8000390
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000390:				; CODE XREF: wrap_write+12Bj
		mov	eax, [ebp+current_column]
		mov	edx, [eax]
		mov	eax, [ebp+to_write]
		add	edx, eax
		mov	eax, [ebp+current_column]
		mov	[eax], edx
		mov	eax, [ebp+to_write]
		add	[ebp+written], eax

loc_80003A5:				; CODE XREF: wrap_write+70j
					; wrap_write+10Aj
		mov	eax, [ebp+written]
		cmp	eax, [ebp+len]
		jb	loc_80002B0

loc_80003B1:				; CODE XREF: wrap_write+36j
					; wrap_write+64j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
wrap_write	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl do_encode(FILE *in, FILE	*out, uintmax_t	wrap_column)
do_encode	proc near		; CODE XREF: main+2ACp

wrap_column	= qword	ptr -1C28h
out		= dword	ptr -1C20h
in		= dword	ptr -1C1Ch
current_column	= dword	ptr -1C18h
sum		= dword	ptr -1C14h
n		= dword	ptr -1C10h
inbuf		= byte ptr -1C0Ch
outbuf		= byte ptr -100Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 1C24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+in], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+out], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+wrap_column], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+wrap_column+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+current_column], 0

loc_80003FA:				; CODE XREF: do_encode+178j
		mov	[ebp+sum], 0

loc_8000404:				; CODE XREF: do_encode+BEj
		mov	eax, 0C00h
		sub	eax, [ebp+sum]
		lea	ecx, [ebp+inbuf]
		mov	edx, [ebp+sum]
		add	edx, ecx
		push	[ebp+in]	; stream
		push	eax		; n
		push	1		; size
		push	edx		; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+n], eax
		mov	eax, [ebp+n]
		add	[ebp+sum], eax
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000477
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000477
		cmp	[ebp+sum], 0BFFh
		jbe	short loc_8000404

loc_8000477:				; CODE XREF: do_encode+9Dj
					; do_encode+B2j
		cmp	[ebp+sum], 0
		jz	short loc_80004FB
		mov	eax, [ebp+sum]
		add	eax, 2
		mov	edx, 0AAAAAAABh
		mul	edx
		mov	eax, edx
		shr	eax, 1
		shl	eax, 2
		push	eax
		lea	eax, [ebp+outbuf]
		push	eax
		push	[ebp+sum]
		lea	eax, [ebp+inbuf]
		push	eax
		call	base64_encode
		add	esp, 10h
		mov	eax, [ebp+sum]
		add	eax, 2
		mov	edx, 0AAAAAAABh
		mul	edx
		mov	eax, edx
		shr	eax, 1
		lea	edx, ds:0[eax*4]
		sub	esp, 8
		push	[ebp+out]	; out
		lea	eax, [ebp+current_column]
		push	eax		; current_column
		push	dword ptr [ebp+wrap_column+4]
		push	dword ptr [ebp+wrap_column] ; wrap_column
		push	edx		; len
		lea	eax, [ebp+outbuf]
		push	eax		; buffer
		call	wrap_write
		add	esp, 20h

loc_80004FB:				; CODE XREF: do_encode+C7j
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000535
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000535
		cmp	[ebp+sum], 0C00h
		jz	loc_80003FA

loc_8000535:				; CODE XREF: do_encode+157j
					; do_encode+16Cj
		mov	eax, dword ptr [ebp+wrap_column+4]
		or	eax, dword ptr [ebp+wrap_column]
		test	eax, eax
		jz	short loc_8000591
		mov	eax, [ebp+current_column]
		test	eax, eax
		jz	short loc_8000591
		sub	esp, 8
		push	[ebp+out]
		push	offset asc_8001164 ; "\n"
		call	fputs_unlocked
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000591
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000591:				; CODE XREF: do_encode+18Cj
					; do_encode+196j ...
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005CE
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80005CE:				; CODE XREF: do_encode+1EDj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_80005E0
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80005E0:				; CODE XREF: do_encode+222j
		mov	ebx, [ebp+var_4]
		leave
		retn
do_encode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl do_decode(FILE *in, FILE	*out, _Bool ignore_garbage)
do_decode	proc near		; CODE XREF: main+290p

ignore_garbage	= byte ptr -1C34h
out		= dword	ptr -1C30h
in		= dword	ptr -1C2Ch
ok		= byte ptr -1C25h
n		= dword	ptr -1C24h
sum		= dword	ptr -1C20h
k		= dword	ptr -1C1Ch
i		= dword	ptr -1C18h
ctx		= base64_decode_context	ptr -1C14h
outbuf		= byte ptr -1C0Ch
inbuf		= byte ptr -100Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 1C34h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+in], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+out], edx
		mov	[ebp+ignore_garbage], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		lea	eax, [ebp+ctx]
		push	eax
		call	base64_decode_ctx_init
		add	esp, 10h

loc_8000627:				; CODE XREF: do_decode+305j
		mov	[ebp+sum], 0

loc_8000631:				; CODE XREF: do_decode+1C1j
		mov	eax, 1000h
		sub	eax, [ebp+sum]
		lea	ecx, [ebp+inbuf]
		mov	edx, [ebp+sum]
		add	edx, ecx
		push	[ebp+in]	; stream
		push	eax		; n
		push	1		; size
		push	edx		; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+n], eax
		cmp	[ebp+ignore_garbage], 0
		jz	loc_800073E
		mov	[ebp+i], 0
		jmp	loc_8000722
; ---------------------------------------------------------------------------

loc_800067E:				; CODE XREF: do_decode+153j
		mov	edx, [ebp+sum]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, [ebp+eax+inbuf]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax
		call	isbase64
		add	esp, 10h
		test	al, al
		jnz	short loc_80006C1
		mov	edx, [ebp+sum]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, [ebp+eax+inbuf]
		cmp	al, 3Dh
		jnz	short loc_80006CA

loc_80006C1:				; CODE XREF: do_decode+C0j
		add	[ebp+i], 1
		jmp	short loc_8000722
; ---------------------------------------------------------------------------

loc_80006CA:				; CODE XREF: do_decode+DAj
		mov	eax, [ebp+n]
		sub	eax, 1
		mov	[ebp+n], eax
		mov	eax, [ebp+n]
		sub	eax, [ebp+i]
		mov	ecx, [ebp+sum]
		mov	edx, [ebp+i]
		add	edx, ecx
		lea	ecx, [edx+1]
		lea	edx, [ebp+inbuf]
		add	ecx, edx
		mov	ebx, [ebp+sum]
		mov	edx, [ebp+i]
		add	ebx, edx
		lea	edx, [ebp+inbuf]
		add	edx, ebx
		sub	esp, 4
		push	eax		; n
		push	ecx		; src
		push	edx		; dest
		call	memmove
		add	esp, 10h

loc_8000722:				; CODE XREF: do_decode+94j
					; do_decode+E3j
		mov	eax, [ebp+n]
		test	eax, eax
		jz	short loc_800073E
		mov	eax, [ebp+n]
		cmp	[ebp+i], eax
		jb	loc_800067E

loc_800073E:				; CODE XREF: do_decode+84j
					; do_decode+145j
		mov	eax, [ebp+n]
		add	[ebp+sum], eax
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000787
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000787:				; CODE XREF: do_decode+178j
		cmp	[ebp+sum], 0FFFh
		ja	short loc_80007AC
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_8000631

loc_80007AC:				; CODE XREF: do_decode+1ACj
		mov	[ebp+k], 0
		jmp	loc_80008A7
; ---------------------------------------------------------------------------

loc_80007BB:				; CODE XREF: do_decode+2E9j
		cmp	[ebp+k], 1
		jnz	short loc_80007D2
		mov	eax, [ebp+ctx.i]
		test	eax, eax
		jz	loc_80008D6

loc_80007D2:				; CODE XREF: do_decode+1DDj
		mov	[ebp+n], 0C00h
		cmp	[ebp+k], 0
		jnz	short loc_80007ED
		mov	eax, [ebp+sum]
		jmp	short loc_80007F2
; ---------------------------------------------------------------------------

loc_80007ED:				; CODE XREF: do_decode+1FEj
		mov	eax, 0

loc_80007F2:				; CODE XREF: do_decode+206j
		sub	esp, 0Ch
		lea	edx, [ebp+n]
		push	edx
		lea	edx, [ebp+outbuf]
		push	edx
		push	eax
		lea	eax, [ebp+inbuf]
		push	eax
		lea	eax, [ebp+ctx]
		push	eax
		call	base64_decode_ctx
		add	esp, 20h
		mov	[ebp+ok], al
		mov	eax, [ebp+n]
		push	[ebp+out]	; stream
		push	eax		; n
		push	1		; size
		lea	eax, [ebp+outbuf]
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+n]
		cmp	edx, eax
		jnb	short loc_8000872
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000872:				; CODE XREF: do_decode+263j
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_80008A0
		sub	esp, 0Ch
		push	offset aInvalidInput ; "invalid	input"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008A0:				; CODE XREF: do_decode+299j
		add	[ebp+k], 1

loc_80008A7:				; CODE XREF: do_decode+1D1j
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80008C3
		mov	eax, 2
		jmp	short loc_80008C8
; ---------------------------------------------------------------------------

loc_80008C3:				; CODE XREF: do_decode+2D5j
		mov	eax, 1

loc_80008C8:				; CODE XREF: do_decode+2DCj
		cmp	eax, [ebp+k]
		ja	loc_80007BB
		jmp	short loc_80008D7
; ---------------------------------------------------------------------------

loc_80008D6:				; CODE XREF: do_decode+1E7j
		nop

loc_80008D7:				; CODE XREF: do_decode+2EFj
		sub	esp, 0Ch
		push	[ebp+in]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_8000627
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8000902
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000902:				; CODE XREF: do_decode+316j
		mov	ebx, [ebp+var_4]
		leave
		retn
do_decode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -3Ch
decode		= byte ptr -36h
ignore_garbage	= byte ptr -35h
input_fh	= dword	ptr -34h
infile		= dword	ptr -30h
opt		= dword	ptr -2Ch
wrap_column	= qword	ptr -28h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 3Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+decode], 0
		mov	[ebp+ignore_garbage], 0
		mov	dword ptr [ebp+wrap_column], 4Ch
		mov	dword ptr [ebp+wrap_column+4], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	loc_8000A7F
; ---------------------------------------------------------------------------

loc_80009A0:				; CODE XREF: main+19Bj
		mov	eax, [ebp+opt]
		cmp	eax, 64h
		jz	short loc_80009D3
		cmp	eax, 64h
		jg	short loc_80009C4
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000A42
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8000A38
		jmp	loc_8000A75
; ---------------------------------------------------------------------------

loc_80009C4:				; CODE XREF: main+A4j
		cmp	eax, 69h
		jz	short loc_8000A32
		cmp	eax, 77h
		jz	short loc_80009DC
		jmp	loc_8000A75
; ---------------------------------------------------------------------------

loc_80009D3:				; CODE XREF: main+9Fj
		mov	[ebp+decode], 1
		jmp	loc_8000A7F
; ---------------------------------------------------------------------------

loc_80009DC:				; CODE XREF: main+C5j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+wrap_column]
		push	edx
		push	0
		push	0
		push	eax
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jz	loc_8000A7F
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quotearg
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidWrapSiz ; "invalid wrap size: %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000A7F
; ---------------------------------------------------------------------------

loc_8000A32:				; CODE XREF: main+C0j
		mov	[ebp+ignore_garbage], 1
		jmp	short loc_8000A7F
; ---------------------------------------------------------------------------

loc_8000A38:				; CODE XREF: main+B6j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000A42:				; CODE XREF: main+ABj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aSimonJosefsson ; "Simon	Josefsson"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aBase64	; "base64"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000A75:				; CODE XREF: main+B8j main+C7j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000A7F:				; CODE XREF: main+94j main+D0j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "diw:"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+opt], eax
		cmp	[ebp+opt], 0FFFFFFFFh
		jnz	loc_80009A0
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 1
		jle	short loc_8000B01
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000B01:				; CODE XREF: main+1AFj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_8000B22
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+infile], eax
		jmp	short loc_8000B29
; ---------------------------------------------------------------------------

loc_8000B22:				; CODE XREF: main+201j
		mov	[ebp+infile], offset asc_80011DB ; "-"

loc_8000B29:				; CODE XREF: main+219j
		sub	esp, 8
		push	offset asc_80011DB ; "-"
		push	[ebp+infile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000B4A
		mov	eax, ds:stdin
		mov	[ebp+input_fh],	eax
		jmp	short loc_8000B80
; ---------------------------------------------------------------------------

loc_8000B4A:				; CODE XREF: main+237j
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+infile]
		call	fopen64
		add	esp, 10h
		mov	[ebp+input_fh],	eax
		cmp	[ebp+input_fh],	0
		jnz	short loc_8000B80
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+infile]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B80:				; CODE XREF: main+241j	main+25Dj
		cmp	[ebp+decode], 0
		jz	short loc_8000BA1
		movzx	edx, [ebp+ignore_garbage]
		mov	eax, ds:stdout
		sub	esp, 4
		push	edx		; ignore_garbage
		push	eax		; out
		push	[ebp+input_fh]	; in
		call	do_decode
		add	esp, 10h
		jmp	short loc_8000BBB
; ---------------------------------------------------------------------------

loc_8000BA1:				; CODE XREF: main+27Dj
		mov	eax, dword ptr [ebp+wrap_column]
		mov	edx, dword ptr [ebp+wrap_column+4]
		mov	ecx, ds:stdout
		push	edx
		push	eax		; wrap_column
		push	ecx		; out
		push	[ebp+input_fh]	; in
		call	do_encode
		add	esp, 10h

loc_8000BBB:				; CODE XREF: main+298j
		sub	esp, 0Ch
		push	[ebp+input_fh]	; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000C29
		sub	esp, 8
		push	offset asc_80011DB ; "-"
		push	[ebp+infile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000C0F
		sub	esp, 0Ch
		push	offset aClosingStandar ; "closing standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000C29
; ---------------------------------------------------------------------------

loc_8000C0F:				; CODE XREF: main+2DCj
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+infile]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000C29:				; CODE XREF: main+2C5j	main+306j
		sub	esp, 0Ch
		push	0		; status

loc_8000C2E:				; DATA XREF: .eh_frame:0800121Co
					; .eh_frame:08001240o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000C40h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+67o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+151o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aDecode		db 'decode',0           ; DATA XREF: .rodata:long_optionso
aWrap		db 'wrap',0             ; DATA XREF: .rodata:long_optionso
aIgnoreGarbage	db 'ignore-garbage',0   ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[6]
long_options	option <offset aDecode,	0, 0, 64h> ; DATA XREF:	main+17Do
		option <offset aWrap, 1, 0, 77h> ; "decode"
		option <offset aIgnoreGarbage, 0, 0, 69h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]',0Ah ; DATA XREF: usage+46o
		db 'Base64 encode or decode FILE, or standard input, to standard outp'
		db 'ut.',0Ah
		db 0Ah,0
; char aWWrapColsWrapE[]
aWWrapColsWrapE	db '  -w, --wrap=COLS       Wrap encoded lines after COLS character ('
					; DATA XREF: usage+69o
		db 'default 76).',0Ah
		db '                        Use 0 to disable line wrapping.',0Ah
		db 0Ah
		db '  -d, --decode          Decode data.',0Ah
		db '  -i, --ignore-garbage  When decoding, ignore non-alphabet charac'
		db 'ters.',0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+8Co
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+AFo
		align 4
; char aWithNoFileOrWh[]
aWithNoFileOrWh	db 0Ah			; DATA XREF: usage+D2o
		db 'With no FILE, or when FILE is -, read standard input.',0Ah,0
; char aTheDataAreEnco[]
aTheDataAreEnco	db 0Ah			; DATA XREF: usage+F5o
		db 'The data are encoded as described for the base64 alphabet in RFC '
		db '3548.',0Ah
		db 'When decoding, the input may contain newlines in addition to the '
		db 'bytes of',0Ah
		db 'the formal base64 alphabet.  Use --ignore-garbage to attempt to r'
		db 'ecover',0Ah
		db 'from any other non-alphabet bytes in the encoded stream.',0Ah,0
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: wrap_write+3Fo
					; wrap_write+DCo ...
asc_8001164	db 0Ah,0		; DATA XREF: wrap_write+C8o
					; do_encode+1A1o
; char aReadError[]
aReadError	db 'read error',0       ; DATA XREF: do_encode+1F2o
					; do_decode+17Do
; char aInvalidInput[]
aInvalidInput	db 'invalid input',0    ; DATA XREF: do_decode+29Eo
; char locale
locale		db 0			; DATA XREF: main+50o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+62o
; char aInvalidWrapSiz[]
aInvalidWrapSiz	db 'invalid wrap size: %s',0 ; DATA XREF: main+10Eo
aSimonJosefsson	db 'Simon Josefsson',0  ; DATA XREF: main+14Bo
aBase64		db 'base64',0           ; DATA XREF: main+156o
; char shortopts[]
shortopts	db 'diw:',0             ; DATA XREF: main+182o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+1D5o
; char asc_80011DB[]
asc_80011DB	db '-',0                ; DATA XREF: main:loc_8000B22o
					; main+225o ...
aR		db 'r',0                ; DATA XREF: main+246o
; char format[]
format		db '%s',0               ; DATA XREF: main+269o main+312o
; char aClosingStandar[]
aClosingStandar	db 'closing standard input',0 ; DATA XREF: main+2E1o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80011FCh
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8000C2E-8001E4Ah
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset loc_8000C2E-8001D52h
		dd 11Fh, 80E4100h, 0D420285h, 3834405h,	20h, 5Ch
		dd offset loc_8000C2E-8001C4Fh
		dd 17Ch, 80E4100h, 0D420285h, 3834405h,	0C5017403h, 4040CC3h
		dd 20h,	80h
		dd offset loc_8000C2E-8001AF7h
		dd 22Eh, 80E4100h, 0D420285h, 3834705h,	0C5022303h, 4040CC3h
		dd 20h,	0A4h
		dd offset loc_8000C2E-80018EDh
		dd 322h, 80E4100h, 0D420285h, 3834705h,	0C5031703h, 4040CC3h
		dd 28h,	0C8h
		dd offset loc_8000C2E-80015EFh
		dd 32Ch, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+57p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+11Ap main+169p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	wrap_write+2Bp
					; wrap_write+120p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: wrap_write+4Ep
					; wrap_write+EBp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: wrap_write+5Cp
					; wrap_write+F9p ...
; size_t fread_unlocked(void *ptr, size_t size,	size_t n, FILE *stream)
		extrn fread_unlocked:near ; CODE XREF: do_encode+70p
					; do_decode+6Fp
; int feof_unlocked(FILE *stream)
		extrn feof_unlocked:near ; CODE	XREF: do_encode+93p
					; do_encode+14Dp ...
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	do_encode+A8p
					; do_encode+162p ...
		extrn base64_encode:near ; CODE	XREF: do_encode+F5p
		extrn __stack_chk_fail:near ; CODE XREF: do_encode+224p
					; do_decode+318p
		extrn base64_decode_ctx_init:near ; CODE XREF: do_decode+3Ap
		extrn isbase64:near	; CODE XREF: do_decode+B6p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: do_decode+135p
		extrn base64_decode_ctx:near ; CODE XREF: do_decode+22Dp
		extrn set_program_name:near ; CODE XREF: main+45p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+6Cp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+7Cp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+87o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+8Cp
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_80009DCr
					; main+F8r
		extrn xstrtoumax:near	; CODE XREF: main+E8p
		extrn quotearg:near	; CODE XREF: main+101p
		extrn Version:dword	; DATA XREF: main:loc_8000A42r
		extrn version_etc:near	; CODE XREF: main+15Cp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+18Cp
; int optind
		extrn optind:dword	; DATA XREF: main+1A1r	main+1B1r ...
		extrn quote:near	; CODE XREF: main+1C8p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+22Dp	main+2D2p
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main+239r
		extrn fopen64:near	; CODE XREF: main+24Ep
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+2BAp


		end
