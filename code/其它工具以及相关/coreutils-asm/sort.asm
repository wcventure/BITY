;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	5737E42D390ADC403BFD9D6722F4822B
; Input	CRC32 :	7728AEE6

; File Name   :	D:\coreutils-o\sort.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'sort.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+F2p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: inittables+178p
					; begfield+9Dp	...

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+2FCp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_800010C
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800010C
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_800010C:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl die(const char *message,	const char *file)
die		proc near		; CODE XREF: xfopen+37p xfclose+6Ap ...

message		= dword	ptr  8
file		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+file], 0
		jnz	short loc_8000163
		sub	esp, 0Ch
		push	offset aStandardOutput ; "standard output"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		jmp	short loc_8000166
; ---------------------------------------------------------------------------

loc_8000163:				; CODE XREF: die+Bj
		mov	ebx, [ebp+file]

loc_8000166:				; CODE XREF: die+1Fj
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	ebx
		push	[ebp+message]
		push	offset format	; "%s: %s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	2		; status
		call	exit
die		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+DA2p	main+DE4p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_80001C9
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800048F
; ---------------------------------------------------------------------------

loc_80001C9:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n  or: "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWriteSortedCon ; "Write	sorted concatenation of	all FILE("...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOrderingOption ; "Ordering options:\n\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBIgnoreLeading ; "  -b,	--ignore-leading-blanks	 ignore	l"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGGeneralNumeri ; "  -g,	--general-numeric-sort	compare	a"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHHumanNumericS ; "  -h,	--human-numeric-sort	compare	h"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNNumericSortCo ; "  -n,	--numeric-sort		compare	a"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSortWordSortAc ; "	--sort=WORD		sort acco"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOtherOptions ; "Other options:\n\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBatchSizeNmerg ; "	--batch-size=NMERGE   merge at mo"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCCheckCheckDia ; "  -c,	--check, --check=diagnose-first	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aKKeyPos1Pos2St ; "  -k,	--key=POS1[,POS2]     start a key"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOOutputFileWri ; "  -o,	--output=FILE	      write resul"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aTFieldSeparato ; "  -t,	--field-separator=SEP  use SEP in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aTmp	; "/tmp"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aZZeroTerminate ; "  -z,	--zero-terminated     end lines	w"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPosIsF_cOptsWh ; "\nPOS	is F[.C][OPTS],	where F	is the fi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset a1OfMemoryB1K10 ; "% 1% of memory, b 1, K 1024 (default), "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800048F:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; cs_status *cs_enter(cs_status	*__return_ptr __struct_ptr retstr)
cs_enter	proc near		; CODE XREF: exit_cleanup+2Ap
					; create_temp_file+110p ...

var_AC		= dword	ptr -0ACh
status		= cs_status ptr	-0A0h
var_1C		= dword	ptr -1Ch
retstr		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0ACh
		mov	eax, [ebp+retstr]
		mov	[ebp+var_AC], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		sub	esp, 4
		lea	eax, [ebp+status]
		add	eax, 4
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+status.valid], al
		mov	eax, [ebp+var_AC]
		mov	ebx, eax
		lea	eax, [ebp+status]
		mov	edx, 21h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		mov	eax, [ebp+var_AC]
		mov	edx, [ebp+var_1C]
		xor	edx, large gs:14h
		jz	short loc_8000513
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000513:				; CODE XREF: cs_enter+72j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn	4
cs_enter	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cs_leave(cs_status status)
cs_leave	proc near		; CODE XREF: exit_cleanup+57p
					; create_temp_file+17Dp ...

status		= cs_status ptr	 8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, [ebp+status.valid]
		test	al, al
		jz	short loc_800053E
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+status.sigs]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h

loc_800053E:				; CODE XREF: cs_leave+Cj
		nop
		leave
		retn
cs_leave	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl proctab_hasher(const void *entry, size_t tabsize)
proctab_hasher	proc near		; DATA XREF: register_proc+27o

node		= dword	ptr -4
entry		= dword	ptr  8
tabsize		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+entry]
		mov	[ebp+node], eax
		mov	eax, [ebp+node]
		mov	eax, [eax]
		mov	edx, 0
		div	[ebp+tabsize]
		mov	eax, edx
		leave
		retn
proctab_hasher	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	proctab_comparator(const void *e1, const void *e2)
proctab_comparator proc	near		; DATA XREF: register_proc+22o

n1		= dword	ptr -8
n2		= dword	ptr -4
e1		= dword	ptr  8
e2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+e1]
		mov	[ebp+n1], eax
		mov	eax, [ebp+e2]
		mov	[ebp+n2], eax
		mov	eax, [ebp+n1]
		mov	edx, [eax]
		mov	eax, [ebp+n2]
		mov	eax, [eax]
		cmp	edx, eax
		setz	al
		leave
		retn
proctab_comparator endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; pid_t	__cdecl	reap(pid_t pid)
reap		proc near		; CODE XREF: wait_proc+3Fp
					; reap_some+24p

status		= dword	ptr -1Ch
var_18		= dword	ptr -18h
var_14		= dword	ptr -14h
cpid		= dword	ptr -10h
var_C		= dword	ptr -0Ch
pid		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+pid]
		shr	eax, 1Fh
		movzx	eax, al
		sub	esp, 4
		push	eax		; options
		lea	eax, [ebp+status]
		push	eax		; stat_loc
		push	[ebp+pid]	; pid
		call	waitpid
		add	esp, 10h
		mov	[ebp+cpid], eax
		cmp	[ebp+cpid], 0
		jns	short loc_80005E7
		mov	ebx, ds:compress_program
		sub	esp, 0Ch
		push	(offset	sort_types+6) ;	msgid
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	esi		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000643
; ---------------------------------------------------------------------------

loc_80005E7:				; CODE XREF: reap+36j
		cmp	[ebp+cpid], 0
		jle	short loc_8000643
		mov	eax, [ebp+status]
		mov	[ebp+var_18], eax
		mov	eax, [ebp+var_18]
		and	eax, 7Fh
		test	eax, eax
		jnz	short loc_8000612
		mov	eax, [ebp+status]
		mov	[ebp+var_14], eax
		mov	eax, [ebp+var_14]
		and	eax, 0FF00h
		sar	eax, 8
		test	eax, eax
		jz	short loc_8000636

loc_8000612:				; CODE XREF: reap+7Aj
		mov	ebx, ds:compress_program
		sub	esp, 0Ch
		push	offset aSDTerminatedAb ; "%s [-d] terminated abnormally"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8000636:				; CODE XREF: reap+8Fj
		mov	eax, ds:nprocs
		sub	eax, 1
		mov	ds:nprocs, eax

loc_8000643:				; CODE XREF: reap+64j reap+6Aj
		mov	eax, [ebp+cpid]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000657
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000657:				; CODE XREF: reap+CFj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
reap		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl register_proc(pid_t pid)
register_proc	proc near		; CODE XREF: maybe_create_temp+B3p

node		= dword	ptr -1Ch
test		= procnode ptr -18h
var_C		= dword	ptr -0Ch
pid		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:proctab
		test	eax, eax
		jnz	short loc_80006A9
		sub	esp, 0Ch
		push	offset free
		push	offset proctab_comparator
		push	offset proctab_hasher
		push	0
		push	2Fh
		call	hash_initialize
		add	esp, 20h
		mov	ds:proctab, eax
		mov	eax, ds:proctab
		test	eax, eax
		jnz	short loc_80006A9
		call	xalloc_die

loc_80006A9:				; CODE XREF: register_proc+18j
					; register_proc+44j
		mov	eax, [ebp+pid]
		mov	[ebp+test.pid],	eax
		mov	eax, ds:proctab
		sub	esp, 8
		lea	edx, [ebp+test]
		push	edx
		push	eax
		call	hash_lookup
		add	esp, 10h
		mov	[ebp+node], eax
		cmp	[ebp+node], 0
		jz	short loc_80006E8
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+node]
		mov	eax, [eax+8]
		lea	edx, [eax+1]
		mov	eax, [ebp+node]
		mov	[eax+8], edx
		jmp	short loc_8000731
; ---------------------------------------------------------------------------

loc_80006E8:				; CODE XREF: register_proc+6Dj
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+node], eax
		mov	eax, [ebp+node]
		mov	edx, [ebp+pid]
		mov	[eax], edx
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+node]
		mov	dword ptr [eax+8], 1
		mov	eax, ds:proctab
		sub	esp, 8
		push	[ebp+node]
		push	eax
		call	hash_insert
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000731
		call	xalloc_die

loc_8000731:				; CODE XREF: register_proc+88j
					; register_proc+CCj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000743
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000743:				; CODE XREF: register_proc+DEj
		leave
		retn
register_proc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl update_proc(pid_t pid)
update_proc	proc near		; CODE XREF: reap_some+Ep

node		= dword	ptr -1Ch
test		= procnode ptr -18h
var_C		= dword	ptr -0Ch
pid		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+pid]
		mov	[ebp+test.pid],	eax
		mov	eax, ds:proctab
		sub	esp, 8
		lea	edx, [ebp+test]
		push	edx
		push	eax
		call	hash_lookup
		add	esp, 10h
		mov	[ebp+node], eax
		cmp	[ebp+node], 0
		jz	short loc_8000784
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 1

loc_8000784:				; CODE XREF: update_proc+33j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000796
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000796:				; CODE XREF: update_proc+4Aj
		leave
		retn
update_proc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl wait_proc(pid_t pid)
wait_proc	proc near		; CODE XREF: open_temp+26p

node		= dword	ptr -1Ch
test		= procnode ptr -18h
var_C		= dword	ptr -0Ch
pid		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+pid]
		mov	[ebp+test.pid],	eax
		mov	eax, ds:proctab
		sub	esp, 8
		lea	edx, [ebp+test]
		push	edx
		push	eax
		call	hash_lookup
		add	esp, 10h
		mov	[ebp+node], eax
		mov	eax, [ebp+node]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_80007DF
		sub	esp, 0Ch
		push	[ebp+pid]	; pid
		call	reap
		add	esp, 10h

loc_80007DF:				; CODE XREF: wait_proc+37j
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 1
		mov	eax, [ebp+node]
		mov	eax, [eax+8]
		lea	edx, [eax-1]
		mov	eax, [ebp+node]
		mov	[eax+8], edx
		mov	eax, [ebp+node]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_8000824
		mov	eax, ds:proctab
		sub	esp, 8
		push	[ebp+node]
		push	eax
		call	hash_delete
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+node]	; ptr
		call	free
		add	esp, 10h

loc_8000824:				; CODE XREF: wait_proc+68j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000836
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000836:				; CODE XREF: wait_proc+97j
		leave
		retn
wait_proc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void reap_some()
reap_some	proc near		; CODE XREF: pipe_fork+116p
					; mergefps+8C8p ...

pid		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		jmp	short loc_800084E
; ---------------------------------------------------------------------------

loc_8000840:				; CODE XREF: reap_some+33j
		sub	esp, 0Ch
		push	[ebp+pid]	; pid
		call	update_proc
		add	esp, 10h

loc_800084E:				; CODE XREF: reap_some+6j
		mov	eax, ds:nprocs
		test	eax, eax
		jz	short loc_800086D
		sub	esp, 0Ch
		push	0FFFFFFFFh	; pid
		call	reap
		add	esp, 10h
		mov	[ebp+pid], eax
		cmp	[ebp+pid], 0
		jnz	short loc_8000840

loc_800086D:				; CODE XREF: reap_some+1Dj
		nop
		leave
		retn
reap_some	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void cleanup()
cleanup		proc near		; CODE XREF: exit_cleanup+32p
					; sighandler+6p

node		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:temphead
		mov	[ebp+node], eax
		jmp	short loc_800089A
; ---------------------------------------------------------------------------

loc_8000880:				; CODE XREF: cleanup+2Ej
		mov	eax, [ebp+node]
		add	eax, 8
		sub	esp, 0Ch
		push	eax		; name
		call	unlink
		add	esp, 10h
		mov	eax, [ebp+node]
		mov	eax, [eax]
		mov	[ebp+node], eax

loc_800089A:				; CODE XREF: cleanup+Ej
		cmp	[ebp+node], 0
		jnz	short loc_8000880
		mov	ds:temphead, 0
		nop
		leave
		retn
cleanup		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void exit_cleanup()
exit_cleanup	proc near		; DATA XREF: main+2D5o

cs_0		= cs_status ptr	-0A0h
var_1C		= dword	ptr -1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 9Ch
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, ds:temphead
		test	eax, eax
		jz	short loc_800090F
		lea	eax, [ebp+cs_0]
		sub	esp, 0Ch
		push	eax		; retstr
		call	cs_enter
		add	esp, 0Ch
		call	cleanup
		sub	esp, 0Ch
		sub	esp, 84h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+cs_0]
		mov	edx, 21h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	cs_leave
		add	esp, 90h

loc_800090F:				; CODE XREF: exit_cleanup+1Ej
		call	close_stdout
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8000926
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000926:				; CODE XREF: exit_cleanup+72j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
exit_cleanup	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; tempnode *__cdecl create_temp_file(int *pfd, _Bool survive_fd_exhaustion)
create_temp_file proc near		; CODE XREF: maybe_create_temp+31p

survive_fd_exhaustion= byte ptr	-0C0h
pfd		= dword	ptr -0BCh
node		= dword	ptr -0B8h
temp_dir	= dword	ptr -0B4h
len		= dword	ptr -0B0h
file		= dword	ptr -0ACh
fd		= dword	ptr -0A8h
saved_errno	= dword	ptr -0A4h
cs_0		= cs_status ptr	-0A0h
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0BCh
		mov	eax, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+pfd], edx
		mov	[ebp+survive_fd_exhaustion], al
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, ds:temp_dirs
		mov	edx, ds:temp_dir_index_6180
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+temp_dir],	eax
		sub	esp, 0Ch
		push	[ebp+temp_dir]	; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, [ebp+len]
		add	eax, 14h
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+node], eax
		mov	eax, [ebp+node]
		add	eax, 8
		mov	[ebp+file], eax
		sub	esp, 4
		push	[ebp+len]	; n
		push	[ebp+temp_dir]	; src
		push	[ebp+file]	; dest
		call	memcpy
		add	esp, 10h
		mov	edx, [ebp+file]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	edx, ds:slashbase_6179
		mov	[eax], edx
		mov	edx, ds:dword_80094AC
		mov	[eax+4], edx
		mov	edx, ds:dword_80094B0
		mov	[eax+8], edx
		mov	eax, [ebp+node]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 0
		mov	eax, ds:temp_dir_index_6180
		add	eax, 1
		mov	ds:temp_dir_index_6180,	eax
		mov	edx, ds:temp_dir_index_6180
		mov	eax, ds:temp_dir_count
		cmp	edx, eax
		jnz	short loc_8000A34
		mov	ds:temp_dir_index_6180,	0

loc_8000A34:				; CODE XREF: create_temp_file+FAj
		lea	eax, [ebp+cs_0]
		sub	esp, 0Ch
		push	eax		; retstr
		call	cs_enter
		add	esp, 0Ch
		sub	esp, 0Ch
		push	[ebp+file]
		call	mkstemp_safer
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		js	short loc_8000A7E
		mov	eax, temptail
		mov	edx, [ebp+node]
		mov	[eax], edx
		mov	eax, [ebp+node]
		mov	temptail, eax

loc_8000A7E:				; CODE XREF: create_temp_file+136j
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		sub	esp, 0Ch
		sub	esp, 84h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+cs_0]
		mov	edx, 21h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	cs_leave
		add	esp, 90h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno]
		mov	[edx], eax
		cmp	[ebp+fd], 0
		jns	short loc_8000B3C
		movzx	eax, [ebp+survive_fd_exhaustion]
		xor	eax, 1
		test	al, al
		jnz	short loc_8000AE8
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 18h
		jz	short loc_8000B21

loc_8000AE8:				; CODE XREF: create_temp_file+1ACj
		sub	esp, 0Ch
		push	[ebp+temp_dir]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotCreateTe ; "cannot create	temporary file in %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8000B21:				; CODE XREF: create_temp_file+1B8j
		sub	esp, 0Ch
		push	[ebp+node]	; ptr
		call	free
		add	esp, 10h
		mov	[ebp+node], 0

loc_8000B3C:				; CODE XREF: create_temp_file+19Ej
		mov	eax, [ebp+pfd]
		mov	edx, [ebp+fd]
		mov	[eax], edx
		mov	eax, [ebp+node]
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8000B61
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000B61:				; CODE XREF: create_temp_file+22Cj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
create_temp_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; FILE *__cdecl	stream_open(const char *file, const char *how)
stream_open	proc near		; CODE XREF: xfopen+Fp
					; open_input_files+A4p	...

file		= dword	ptr  8
how		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+file], 0
		jnz	short loc_8000B7C
		mov	eax, ds:stdout
		jmp	short locret_8000BBC
; ---------------------------------------------------------------------------

loc_8000B7C:				; CODE XREF: stream_open+Aj
		sub	esp, 8
		push	offset file	; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000BAB
		mov	eax, [ebp+how]
		movzx	eax, byte ptr [eax]
		cmp	al, 72h
		jnz	short loc_8000BAB
		mov	ds:have_read_stdin, 1
		mov	eax, ds:stdin
		jmp	short locret_8000BBC
; ---------------------------------------------------------------------------

loc_8000BAB:				; CODE XREF: stream_open+28j
					; stream_open+32j
		sub	esp, 8
		push	[ebp+how]
		push	[ebp+file]
		call	fopen_safer
		add	esp, 10h

locret_8000BBC:				; CODE XREF: stream_open+11j
					; stream_open+40j
		leave
		retn
stream_open	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; FILE *__cdecl	xfopen(const char *file, const char *how)
xfopen		proc near		; CODE XREF: check+36p	sort+47p ...

fp		= dword	ptr -0Ch
file		= dword	ptr  8
how		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	[ebp+how]	; how
		push	[ebp+file]	; file
		call	stream_open
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jnz	short loc_8000BFA
		sub	esp, 0Ch
		push	offset aOpenFailed ; "open failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8000BFA:				; CODE XREF: xfopen+1Ej
		mov	eax, [ebp+fp]
		leave
		retn
xfopen		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl xfclose(FILE *fp, const char *file)
xfclose		proc near		; CODE XREF: check+2CBp mergefps+1C1p	...

fp		= dword	ptr  8
file		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fileno
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000C1E
		cmp	eax, 1
		jz	short loc_8000C40
		jmp	short loc_8000C6E
; ---------------------------------------------------------------------------

loc_8000C1E:				; CODE XREF: xfclose+16j
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000C9C
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	clearerr_unlocked
		add	esp, 10h
		jmp	short loc_8000C9C
; ---------------------------------------------------------------------------

loc_8000C40:				; CODE XREF: xfclose+1Bj
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fflush_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000C9F
		sub	esp, 0Ch
		push	offset aFflushFailed ; "fflush failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8000C6E:				; CODE XREF: xfclose+1Dj
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000CA2
		sub	esp, 0Ch
		push	offset aCloseFailed ; "close failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8000C9C:				; CODE XREF: xfclose+2Fj xfclose+3Fj
		nop
		jmp	short loc_8000CA3
; ---------------------------------------------------------------------------

loc_8000C9F:				; CODE XREF: xfclose+51j
		nop
		jmp	short loc_8000CA3
; ---------------------------------------------------------------------------

loc_8000CA2:				; CODE XREF: xfclose+7Fj
		nop

loc_8000CA3:				; CODE XREF: xfclose+9Ej xfclose+A1j
		nop
		leave
		retn
xfclose		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl dup2_or_die(int oldfd, int newfd)
dup2_or_die	proc near		; CODE XREF: maybe_create_temp+E6p
					; maybe_create_temp+106p ...

var_4		= dword	ptr -4
oldfd		= dword	ptr  8
newfd		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		sub	esp, 8
		push	[ebp+newfd]	; fd2
		push	[ebp+oldfd]	; fd
		call	dup2
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000CEA
		sub	esp, 0Ch
		push	offset aDup2Failed ; "dup2 failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8000CEA:				; CODE XREF: dup2_or_die+1Aj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
dup2_or_die	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; pid_t	__cdecl	pipe_fork(int *pipefds,	size_t tries)
pipe_fork	proc near		; CODE XREF: maybe_create_temp+6Bp
					; open_temp+5Ap

pipefds		= dword	ptr -0BCh
pid		= dword	ptr -0B4h
saved_temphead	= dword	ptr -0B0h
saved_errno	= dword	ptr -0ACh
wait_retry	= qword	ptr -0A8h
cs_0		= cs_status ptr	-0A0h
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
tries		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0BCh
		mov	eax, [ebp+arg_0]
		mov	[ebp+pipefds], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		fld	ds:dbl_80095F0
		fstp	[ebp+wait_retry]
		sub	esp, 0Ch
		push	[ebp+pipefds]	; pipedes
		call	pipe
		add	esp, 10h
		test	eax, eax
		jns	loc_8000E0B
		mov	eax, 0FFFFFFFFh
		jmp	loc_8000EA6
; ---------------------------------------------------------------------------

loc_8000D3F:				; CODE XREF: pipe_fork+126j
		lea	eax, [ebp+cs_0]
		sub	esp, 0Ch
		push	eax		; retstr
		call	cs_enter
		add	esp, 0Ch
		mov	eax, ds:temphead
		mov	[ebp+saved_temphead], eax
		mov	ds:temphead, 0
		call	fork
		mov	[ebp+pid], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		cmp	[ebp+pid], 0
		jz	short loc_8000D92
		mov	eax, [ebp+saved_temphead]
		mov	ds:temphead, eax

loc_8000D92:				; CODE XREF: pipe_fork+95j
		sub	esp, 0Ch
		sub	esp, 84h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+cs_0]
		mov	edx, 21h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	cs_leave
		add	esp, 90h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno]
		mov	[edx], eax
		cmp	[ebp+pid], 0
		jns	short loc_8000E1C
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 0Bh
		jnz	short loc_8000E1C
		sub	esp, 8
		push	dword ptr [ebp+wait_retry+4]
		push	dword ptr [ebp+wait_retry]
		call	xnanosleep
		add	esp, 10h
		fld	[ebp+wait_retry]
		fadd	st, st
		fstp	[ebp+wait_retry]
		call	reap_some

loc_8000E0B:				; CODE XREF: pipe_fork+3Fj
		mov	eax, [ebp+tries]
		lea	edx, [eax-1]
		mov	[ebp+tries], edx
		test	eax, eax
		jnz	loc_8000D3F

loc_8000E1C:				; CODE XREF: pipe_fork+E3j
					; pipe_fork+EFj
		cmp	[ebp+pid], 0
		jns	short loc_8000E6E
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		mov	eax, [ebp+pipefds]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno]
		mov	[edx], eax
		jmp	short loc_8000EA0
; ---------------------------------------------------------------------------

loc_8000E6E:				; CODE XREF: pipe_fork+133j
		cmp	[ebp+pid], 0
		jnz	short loc_8000E93
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; fd
		call	close
		add	esp, 10h
		jmp	short loc_8000EA0
; ---------------------------------------------------------------------------

loc_8000E93:				; CODE XREF: pipe_fork+185j
		mov	eax, ds:nprocs
		add	eax, 1
		mov	ds:nprocs, eax

loc_8000EA0:				; CODE XREF: pipe_fork+17Cj
					; pipe_fork+1A1j
		mov	eax, [ebp+pid]

loc_8000EA6:				; CODE XREF: pipe_fork+4Aj
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8000EB7
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000EB7:				; CODE XREF: pipe_fork+1C0j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
pipe_fork	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	maybe_create_temp(FILE **pfp, pid_t *ppid, _Bool survive_fd_exhaustion)
maybe_create_temp proc near		; CODE XREF: create_temp+11p
					; merge+329p

survive_fd_exhaustion= byte ptr	-34h
ppid		= dword	ptr -30h
pfp		= dword	ptr -2Ch
tempfd		= dword	ptr -20h
node		= dword	ptr -1Ch
name		= dword	ptr -18h
pipefds		= dword	ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_8]
		mov	edx, [ebp+arg_0]
		mov	[ebp+pfp], edx
		mov	edx, [ebp+arg_4]
		mov	[ebp+ppid], edx
		mov	[ebp+survive_fd_exhaustion], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		movzx	eax, [ebp+survive_fd_exhaustion]
		sub	esp, 8
		push	eax		; survive_fd_exhaustion
		lea	eax, [ebp+tempfd]
		push	eax		; pfd
		call	create_temp_file
		add	esp, 10h
		mov	[ebp+node], eax
		cmp	[ebp+node], 0
		jnz	short loc_8000F0B
		mov	eax, 0
		jmp	loc_8001086
; ---------------------------------------------------------------------------

loc_8000F0B:				; CODE XREF: maybe_create_temp+40j
		mov	eax, [ebp+node]
		add	eax, 8
		mov	[ebp+name], eax
		mov	eax, ds:compress_program
		test	eax, eax
		jz	loc_8001032
		sub	esp, 8
		push	4		; tries
		lea	eax, [ebp+pipefds]
		push	eax		; pipefds
		call	pipe_fork
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+node]
		mov	[eax+4], edx
		mov	eax, [ebp+node]
		mov	eax, [eax+4]
		test	eax, eax
		jle	short loc_8000F7F
		mov	eax, [ebp+tempfd]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds+4]
		mov	[ebp+tempfd], eax
		mov	eax, [ebp+node]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; pid
		call	register_proc
		add	esp, 10h
		jmp	loc_8001032
; ---------------------------------------------------------------------------

loc_8000F7F:				; CODE XREF: maybe_create_temp+83j
		mov	eax, [ebp+node]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	loc_8001028
		mov	eax, [ebp+pipefds+4]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+tempfd]
		sub	esp, 8
		push	1		; newfd
		push	eax		; oldfd
		call	dup2_or_die
		add	esp, 10h
		mov	eax, [ebp+tempfd]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds]
		sub	esp, 8
		push	0		; newfd
		push	eax		; oldfd
		call	dup2_or_die
		add	esp, 10h
		mov	eax, [ebp+pipefds]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	edx, ds:compress_program
		mov	eax, ds:compress_program
		sub	esp, 4
		push	0
		push	edx		; arg
		push	eax		; file
		call	execlp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8001032
		mov	ebx, ds:compress_program
		sub	esp, 0Ch
		push	offset aCouldnTExecute ; "couldn't execute %s"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	esi		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001032
; ---------------------------------------------------------------------------

loc_8001028:				; CODE XREF: maybe_create_temp+C8j
		mov	eax, [ebp+node]
		mov	dword ptr [eax+4], 0

loc_8001032:				; CODE XREF: maybe_create_temp+5Cj
					; maybe_create_temp+BBj ...
		mov	eax, [ebp+tempfd]
		sub	esp, 8
		push	offset modes	; "w"
		push	eax		; fd
		call	fdopen
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+pfp]
		mov	[eax], edx
		mov	eax, [ebp+pfp]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8001072
		sub	esp, 0Ch
		push	offset aCouldnTCreateT ; "couldn't create temporary file"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+name]	; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8001072:				; CODE XREF: maybe_create_temp+195j
		cmp	[ebp+ppid], 0
		jz	short loc_8001083
		mov	eax, [ebp+node]
		mov	edx, [eax+4]
		mov	eax, [ebp+ppid]
		mov	[eax], edx

loc_8001083:				; CODE XREF: maybe_create_temp+1B7j
		mov	eax, [ebp+name]

loc_8001086:				; CODE XREF: maybe_create_temp+47j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8001097
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001097:				; CODE XREF: maybe_create_temp+1D1j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
maybe_create_temp endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	create_temp(FILE **pfp,	pid_t *ppid)
create_temp	proc near		; CODE XREF: avoid_trashing_input+1D6p
					; merge+41p ...

pfp		= dword	ptr  8
ppid		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	0		; survive_fd_exhaustion
		push	[ebp+ppid]	; ppid
		push	[ebp+pfp]	; pfp
		call	maybe_create_temp
		add	esp, 10h
		leave
		retn
create_temp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; FILE *__cdecl	open_temp(const	char *name, pid_t pid)
open_temp	proc near		; CODE XREF: open_input_files+80p

name		= dword	ptr -2Ch
fp		= dword	ptr -20h
tempfd		= dword	ptr -1Ch
saved_errno	= dword	ptr -18h
pipefds		= dword	ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
pid		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+fp], 0
		sub	esp, 0Ch
		push	[ebp+pid]	; pid
		call	wait_proc
		add	esp, 10h
		sub	esp, 8
		push	0
		push	[ebp+name]
		call	open64
		add	esp, 10h
		mov	[ebp+tempfd], eax
		cmp	[ebp+tempfd], 0
		jns	short loc_800110A
		mov	eax, 0
		jmp	loc_8001277
; ---------------------------------------------------------------------------

loc_800110A:				; CODE XREF: open_temp+45j
		sub	esp, 8
		push	9		; tries
		lea	eax, [ebp+pipefds]
		push	eax		; pipefds
		call	pipe_fork
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8001129
		test	eax, eax
		jz	short loc_800117F
		jmp	loc_8001214
; ---------------------------------------------------------------------------

loc_8001129:				; CODE XREF: open_temp+65j
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 18h
		jz	short loc_8001161
		mov	ebx, ds:compress_program
		sub	esp, 0Ch
		push	offset aCouldnTCreateP ; "couldn't create process for %s -d"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	esi		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8001161:				; CODE XREF: open_temp+7Aj
		sub	esp, 0Ch
		push	[ebp+tempfd]	; fd
		call	close
		add	esp, 10h
		call	__errno_location
		mov	dword ptr [eax], 18h
		jmp	loc_8001274
; ---------------------------------------------------------------------------

loc_800117F:				; CODE XREF: open_temp+69j
		mov	eax, [ebp+pipefds]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		sub	esp, 8
		push	0		; newfd
		push	[ebp+tempfd]	; oldfd
		call	dup2_or_die
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tempfd]	; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds+4]
		sub	esp, 8
		push	1		; newfd
		push	eax		; oldfd
		call	dup2_or_die
		add	esp, 10h
		mov	eax, [ebp+pipefds+4]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	edx, ds:compress_program
		mov	eax, ds:compress_program
		push	0
		push	offset aD	; "-d"
		push	edx		; arg
		push	eax		; file
		call	execlp
		add	esp, 10h
		mov	ebx, ds:compress_program
		sub	esp, 0Ch
		push	offset aCouldnTExecu_0 ; "couldn't execute %s -d"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	esi		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8001214:				; CODE XREF: open_temp+6Bj
		sub	esp, 0Ch
		push	[ebp+tempfd]	; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds+4]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		mov	eax, [ebp+pipefds]
		sub	esp, 8
		push	offset how	; "r"
		push	eax		; fd
		call	fdopen
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jnz	short loc_8001273
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		mov	eax, [ebp+pipefds]
		sub	esp, 0Ch
		push	eax		; fd
		call	close
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+saved_errno]
		mov	[edx], eax

loc_8001273:				; CODE XREF: open_temp+193j
		nop

loc_8001274:				; CODE XREF: open_temp+C1j
		mov	eax, [ebp+fp]

loc_8001277:				; CODE XREF: open_temp+4Cj
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8001288
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001288:				; CODE XREF: open_temp+1C8j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
open_temp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_bytes(const char *buf, size_t n_bytes, FILE *fp, const char *output_file)
write_bytes	proc near		; CODE XREF: check+1B7p mergefps+3D7p	...

buf		= dword	ptr  8
n_bytes		= dword	ptr  0Ch
fp		= dword	ptr  10h
output_file	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	[ebp+fp]	; stream
		push	[ebp+n_bytes]	; n
		push	1		; size
		push	[ebp+buf]	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+n_bytes]
		jz	short loc_80012C9
		sub	esp, 0Ch
		push	offset aWriteFailed ; "write failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+output_file] ; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_80012C9:				; CODE XREF: write_bytes+1Cj
		nop
		leave
		retn
write_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl add_temp_dir(const char *dir)
add_temp_dir	proc near		; CODE XREF: main+D09p	main+13DBp

dir		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, ds:temp_dir_count
		mov	eax, ds:temp_dir_alloc
		cmp	edx, eax
		jnz	short loc_80012FE
		mov	eax, ds:temp_dirs
		sub	esp, 4
		push	4
		push	offset temp_dir_alloc
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	ds:temp_dirs, eax

loc_80012FE:				; CODE XREF: add_temp_dir+13j
		mov	ecx, ds:temp_dirs
		mov	eax, ds:temp_dir_count
		lea	edx, [eax+1]
		mov	ds:temp_dir_count, edx
		shl	eax, 2
		lea	edx, [ecx+eax]
		mov	eax, [ebp+dir]
		mov	[edx], eax
		nop
		leave
		retn
add_temp_dir	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl zaptemp(const char *name)
zaptemp		proc near		; CODE XREF: mergefps+1EAp
					; mergefps+645p

name		= dword	ptr -0BCh
pnode		= dword	ptr -0B4h
unlink_errno	= dword	ptr -0B0h
node		= dword	ptr -0ACh
next		= dword	ptr -0A8h
unlink_status	= dword	ptr -0A4h
cs_0		= cs_status ptr	-0A0h
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0BCh
		mov	eax, [ebp+arg_0]
		mov	[ebp+name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+unlink_errno], 0
		mov	[ebp+pnode], offset temphead
		jmp	short loc_8001362
; ---------------------------------------------------------------------------

loc_8001356:				; CODE XREF: zaptemp+5Fj
		mov	eax, [ebp+node]
		mov	[ebp+pnode], eax

loc_8001362:				; CODE XREF: zaptemp+34j
		mov	eax, [ebp+pnode]
		mov	eax, [eax]
		mov	[ebp+node], eax
		mov	eax, [ebp+node]
		add	eax, 8
		cmp	eax, [ebp+name]
		jnz	short loc_8001356
		mov	eax, [ebp+node]
		mov	eax, [eax]
		mov	[ebp+next], eax
		lea	eax, [ebp+cs_0]
		sub	esp, 0Ch
		push	eax		; retstr
		call	cs_enter
		add	esp, 0Ch
		sub	esp, 0Ch
		push	[ebp+name]	; name
		call	unlink
		add	esp, 10h
		mov	[ebp+unlink_status], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+unlink_errno], eax
		mov	eax, [ebp+pnode]
		mov	edx, [ebp+next]
		mov	[eax], edx
		sub	esp, 0Ch
		sub	esp, 84h
		mov	eax, esp
		mov	ebx, eax
		lea	eax, [ebp+cs_0]
		mov	edx, 21h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		call	cs_leave
		add	esp, 90h
		cmp	[ebp+unlink_status], 0
		jz	short loc_800142E
		sub	esp, 0Ch
		push	offset aWarningCannotR ; "warning: cannot remove: %s"
		call	gettext
		add	esp, 10h
		push	[ebp+name]
		push	eax		; format
		push	[ebp+unlink_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800142E:				; CODE XREF: zaptemp+E5j
		cmp	[ebp+next], 0
		jnz	short loc_8001442
		mov	eax, [ebp+pnode]
		mov	temptail, eax

loc_8001442:				; CODE XREF: zaptemp+115j
		sub	esp, 0Ch
		push	[ebp+node]	; ptr
		call	free
		add	esp, 10h
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8001465
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001465:				; CODE XREF: zaptemp+13Ej
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
zaptemp		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl struct_month_cmp(const void *m1, const void *m2)
struct_month_cmp proc near		; DATA XREF: inittables+1B1o

month1		= dword	ptr -10h
month2		= dword	ptr -0Ch
m1		= dword	ptr  8
m2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+m1]
		mov	[ebp+month1], eax
		mov	eax, [ebp+m2]
		mov	[ebp+month2], eax
		mov	eax, [ebp+month2]
		mov	edx, [eax]
		mov	eax, [ebp+month1]
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		leave
		retn
struct_month_cmp endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void inittables()
inittables	proc near		; CODE XREF: main+1C0p

i		= dword	ptr -1Ch
j		= dword	ptr -18h
s		= dword	ptr -14h
s_len		= dword	ptr -10h
name		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+i], 0
		jmp	loc_8001568
; ---------------------------------------------------------------------------

loc_80014AB:				; CODE XREF: inittables+D7j
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+i]
		add	eax, offset blanks
		mov	[eax], dl
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		setz	dl
		mov	eax, [ebp+i]
		add	eax, offset nonprinting
		mov	[eax], dl
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 8
		test	eax, eax
		jnz	short loc_8001536
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_8001536
		mov	eax, 1
		jmp	short loc_800153B
; ---------------------------------------------------------------------------

loc_8001536:				; CODE XREF: inittables+7Aj
					; inittables+95j
		mov	eax, 0

loc_800153B:				; CODE XREF: inittables+9Cj
		and	eax, 1
		mov	edx, [ebp+i]
		add	edx, offset nondictionary
		mov	[edx], al
		mov	eax, [ebp+i]
		sub	esp, 0Ch
		push	eax		; c
		call	toupper
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset fold_toupper
		mov	[eax], dl
		add	[ebp+i], 1

loc_8001568:				; CODE XREF: inittables+Ej
		cmp	[ebp+i], 0FFh
		jbe	loc_80014AB
		movzx	eax, ds:hard_LC_TIME
		test	al, al
		jz	loc_800165F
		mov	[ebp+i], 0
		jmp	loc_800163F
; ---------------------------------------------------------------------------

loc_8001590:				; CODE XREF: inittables+1ABj
		mov	eax, [ebp+i]
		add	eax, 2000Eh
		sub	esp, 0Ch
		push	eax		; item
		call	nl_langinfo
		add	esp, 10h
		mov	[ebp+s], eax
		sub	esp, 0Ch
		push	[ebp+s]		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+s_len], eax
		mov	eax, [ebp+s_len]
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+name], eax
		mov	eax, [ebp+i]
		mov	edx, [ebp+name]
		mov	dword ptr monthtab.name[eax*8],	edx
		mov	eax, [ebp+i]
		add	eax, 1
		mov	edx, eax
		mov	eax, [ebp+i]
		mov	monthtab.val[eax*8], edx
		mov	[ebp+j], 0
		jmp	short loc_8001628
; ---------------------------------------------------------------------------

loc_80015F5:				; CODE XREF: inittables+196j
		mov	edx, [ebp+name]
		mov	eax, [ebp+j]
		lea	ebx, [edx+eax]
		mov	edx, [ebp+s]
		mov	eax, [ebp+j]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:fold_toupper[eax]
		mov	[ebx], al
		add	[ebp+j], 1

loc_8001628:				; CODE XREF: inittables+15Bj
		mov	eax, [ebp+j]
		cmp	eax, [ebp+s_len]
		jb	short loc_80015F5
		mov	edx, [ebp+name]
		mov	eax, [ebp+j]
		add	eax, edx
		mov	byte ptr [eax],	0
		add	[ebp+i], 1

loc_800163F:				; CODE XREF: inittables+F3j
		cmp	[ebp+i], 0Bh
		jbe	loc_8001590
		push	offset struct_month_cmp	; compar
		push	8		; size
		push	0Ch		; nmemb
		push	offset monthtab	; base
		call	qsort
		add	esp, 10h

loc_800165F:				; CODE XREF: inittables+E6j
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
inittables	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl specify_nmerge(int oi, char c, const char *s)
specify_nmerge	proc near		; CODE XREF: main+B30p

s		= dword	ptr -40h
c		= byte ptr -3Ch
e		= dword	ptr -38h
max_nmerge	= dword	ptr -34h
n		= qword	ptr -30h
rlimit		= rlimit ptr -28h
max_nmerge_buf	= byte ptr -17h
var_C		= dword	ptr -0Ch
oi		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 40h
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		mov	eax, [ebp+arg_8]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	0
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		push	0
		push	[ebp+s]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+e], eax
		sub	esp, 8
		lea	eax, [ebp+rlimit]
		push	eax
		push	7
		call	getrlimit64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80016BF
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		sub	eax, 3
		jmp	short loc_80016C4
; ---------------------------------------------------------------------------

loc_80016BF:				; CODE XREF: specify_nmerge+4Dj
		mov	eax, 11h

loc_80016C4:				; CODE XREF: specify_nmerge+58j
		mov	[ebp+max_nmerge], eax
		cmp	[ebp+e], 0
		jnz	loc_80017AB
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	nmerge,	eax
		mov	eax, nmerge
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8001706
		mov	[ebp+e], 1
		jmp	loc_80017AB
; ---------------------------------------------------------------------------

loc_8001706:				; CODE XREF: specify_nmerge+93j
		mov	eax, nmerge
		cmp	eax, 1
		ja	loc_8001796
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+oi]
		shl	eax, 4
		add	eax, offset long_options
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aInvalidSArgume ; "invalid --%s argument	%s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	offset a2	; "2"
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+oi]
		shl	eax, 4
		add	eax, offset long_options
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aMinimumSArgume ; "minimum --%s argument	is %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h
		jmp	short loc_80017AB
; ---------------------------------------------------------------------------

loc_8001796:				; CODE XREF: specify_nmerge+A9j
		mov	eax, nmerge
		cmp	[ebp+max_nmerge], eax
		jnb	loc_8001854
		mov	[ebp+e], 1

loc_80017AB:				; CODE XREF: specify_nmerge+66j
					; specify_nmerge+9Cj ...
		cmp	[ebp+e], 1
		jnz	loc_8001839
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+oi]
		shl	eax, 4
		add	eax, offset long_options
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSArgumentSTooL ; "--%s argument	%s too large"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 8
		lea	eax, [ebp+max_nmerge_buf]
		push	eax
		push	[ebp+max_nmerge]
		call	uinttostr
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+oi]
		shl	eax, 4
		add	eax, offset long_options
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aMaximumSArgume ; "maximum --%s argument	with current rlim"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h
		jmp	short loc_8001855
; ---------------------------------------------------------------------------

loc_8001839:				; CODE XREF: specify_nmerge+14Aj
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	[ebp+s]
		push	offset long_options
		push	eax
		push	[ebp+oi]
		push	[ebp+e]
		call	xstrtol_fatal

loc_8001854:				; CODE XREF: specify_nmerge+139j
		nop

loc_8001855:				; CODE XREF: specify_nmerge+1D2j
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001866
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001866:				; CODE XREF: specify_nmerge+1FAj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
specify_nmerge	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl specify_sort_size(int oi, char c, const char *s)
specify_sort_size proc near		; CODE XREF: main+C0Cp

var_50		= qword	ptr -50h
var_48		= qword	ptr -48h
var_3A		= word ptr -3Ah
var_38		= qword	ptr -38h
s		= dword	ptr -30h
c		= byte ptr -2Ch
var_2A		= word ptr -2Ah
suffix		= dword	ptr -28h
e		= dword	ptr -24h
n		= qword	ptr -20h
mem		= qword	ptr -18h
var_C		= dword	ptr -0Ch
oi		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 50h
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		mov	eax, [ebp+arg_8]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aEggkkmmpttyz ; "EgGkKmMPtTYZ"
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		lea	eax, [ebp+suffix]
		push	eax
		push	[ebp+s]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+e], eax
		cmp	[ebp+e], 0
		jnz	short loc_80018F0
		mov	eax, [ebp+suffix]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_80018F0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		cmp	edx, 3FFFFFh
		ja	short loc_80018E9
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		shld	edx, eax, 0Ah
		shl	eax, 0Ah
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		jmp	short loc_80018F0
; ---------------------------------------------------------------------------

loc_80018E9:				; CODE XREF: specify_sort_size+65j
		mov	[ebp+e], 1

loc_80018F0:				; CODE XREF: specify_sort_size+43j
					; specify_sort_size+57j ...
		cmp	[ebp+e], 2
		jnz	loc_8001A0E
		mov	eax, [ebp+suffix]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_8001A0E
		mov	eax, [ebp+suffix]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001A0E
		mov	eax, [ebp+suffix]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 25h
		jz	short loc_8001946
		cmp	eax, 62h
		jnz	loc_8001A0E
		mov	[ebp+e], 0
		jmp	loc_8001A0E
; ---------------------------------------------------------------------------

loc_8001946:				; CODE XREF: specify_sort_size+C2j
		call	physmem_total
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	dword ptr [ebp+var_50],	eax
		mov	dword ptr [ebp+var_50+4], edx
		fild	[ebp+var_50]
		test	edx, edx
		jns	short loc_8001966
		fld	ds:tbyte_8009600
		faddp	st(1), st

loc_8001966:				; CODE XREF: specify_sort_size+EFj
		fstp	[ebp+var_38]
		fld	[ebp+var_38]
		fmulp	st(1), st
		fld	ds:dbl_8009610
		fdivp	st(1), st
		fstp	[ebp+mem]
		fld	ds:dbl_8009618
		fld	[ebp+mem]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_8001A06
		fld	[ebp+mem]
		fld	ds:dbl_8009620
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jnb	short loc_80019BC
		fld	[ebp+mem]
		fnstcw	[ebp+var_2A]
		movzx	eax, [ebp+var_2A]
		mov	ah, 0Ch
		mov	[ebp+var_3A], ax
		fldcw	[ebp+var_3A]
		fistp	[ebp+var_48]
		fldcw	[ebp+var_2A]
		mov	eax, dword ptr [ebp+var_48]
		mov	edx, dword ptr [ebp+var_48+4]
		jmp	short loc_80019F7
; ---------------------------------------------------------------------------

loc_80019BC:				; CODE XREF: specify_sort_size+12Cj
		fld	[ebp+mem]
		fld	ds:dbl_8009620
		fsubp	st(1), st
		fnstcw	[ebp+var_2A]
		movzx	eax, [ebp+var_2A]
		mov	ah, 0Ch
		mov	[ebp+var_3A], ax
		fldcw	[ebp+var_3A]
		fistp	[ebp+var_48]
		fldcw	[ebp+var_2A]
		mov	eax, dword ptr [ebp+var_48]
		mov	edx, dword ptr [ebp+var_48+4]
		mov	ecx, eax
		xor	ch, 0
		mov	ebx, ecx
		mov	eax, edx
		xor	eax, 80000000h
		mov	esi, eax
		mov	eax, ebx
		mov	edx, esi

loc_80019F7:				; CODE XREF: specify_sort_size+14Dj
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		mov	[ebp+e], 0
		jmp	short loc_8001A0D
; ---------------------------------------------------------------------------

loc_8001A06:				; CODE XREF: specify_sort_size+11Bj
		mov	[ebp+e], 1

loc_8001A0D:				; CODE XREF: specify_sort_size+197j
		nop

loc_8001A0E:				; CODE XREF: specify_sort_size+87j
					; specify_sort_size+9Fj ...
		cmp	[ebp+e], 0
		jnz	short loc_8001A84
		mov	eax, ds:sort_size
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		cmp	ebx, edx
		jb	short loc_8001A32
		cmp	ebx, edx
		ja	short loc_8001A9F
		cmp	ecx, eax
		ja	short loc_8001A9F

loc_8001A32:				; CODE XREF: specify_sort_size+1BBj
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	ds:sort_size, eax
		mov	eax, ds:sort_size
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8001A7D
		mov	edx, nmerge
		mov	eax, edx
		shl	eax, 3
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, ds:sort_size
		cmp	edx, eax
		cmovnb	eax, edx
		mov	ds:sort_size, eax
		jmp	short loc_8001AA0
; ---------------------------------------------------------------------------

loc_8001A7D:				; CODE XREF: specify_sort_size+1ECj
		mov	[ebp+e], 1

loc_8001A84:				; CODE XREF: specify_sort_size+1A5j
		movsx	eax, [ebp+c]
		sub	esp, 0Ch
		push	[ebp+s]
		push	offset long_options
		push	eax
		push	[ebp+oi]
		push	[ebp+e]
		call	xstrtol_fatal

loc_8001A9F:				; CODE XREF: specify_sort_size+1BFj
					; specify_sort_size+1C3j
		nop

loc_8001AA0:				; CODE XREF: specify_sort_size+20Ej
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001AB1
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001AB1:				; CODE XREF: specify_sort_size+23Dj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
specify_sort_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t default_sort_size()
default_sort_size proc near		; CODE XREF: sort_buffer_size+191p

var_68		= qword	ptr -68h
var_60		= qword	ptr -60h
var_54		= word ptr -54h
var_52		= word ptr -52h
var_50		= qword	ptr -50h
size		= dword	ptr -3Ch
avail		= qword	ptr -38h
total		= qword	ptr -30h
mem		= qword	ptr -28h
rlimit		= rlimit ptr -1Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 64h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		call	physmem_available
		fstp	[ebp+avail]
		call	physmem_total
		fstp	[ebp+total]
		fld	[ebp+total]
		fld	ds:dbl_8009628
		fdivp	st(1), st
		fld	[ebp+avail]
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_8001AF3
		fld	[ebp+avail]
		jmp	short loc_8001AFE
; ---------------------------------------------------------------------------

loc_8001AF3:				; CODE XREF: default_sort_size+34j
		fld	[ebp+total]
		fld	ds:dbl_8009628
		fdivp	st(1), st

loc_8001AFE:				; CODE XREF: default_sort_size+39j
		fstp	[ebp+mem]
		mov	[ebp+size], 0FFFFFFFFh
		mov	eax, [ebp+size]
		mov	edx, 0
		mov	dword ptr [ebp+var_68],	eax
		mov	dword ptr [ebp+var_68+4], edx
		fild	[ebp+var_68]
		fstp	[ebp+var_50]
		fld	[ebp+var_50]
		fld	[ebp+mem]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_8001B4C
		fld	[ebp+mem]
		fnstcw	[ebp+var_52]
		movzx	eax, [ebp+var_52]
		mov	ah, 0Ch
		mov	[ebp+var_54], ax
		fldcw	[ebp+var_54]
		fistp	[ebp+var_60]
		fldcw	[ebp+var_52]
		mov	eax, dword ptr [ebp+var_60]
		mov	edx, dword ptr [ebp+var_60+4]
		mov	[ebp+size], eax

loc_8001B4C:				; CODE XREF: default_sort_size+70j
		sub	esp, 8
		lea	eax, [ebp+rlimit]
		push	eax
		push	2
		call	getrlimit64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001B84
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		mov	ecx, [ebp+size]
		mov	ebx, 0
		cmp	edx, ebx
		ja	short loc_8001B84
		cmp	edx, ebx
		jb	short loc_8001B7B
		cmp	eax, ecx
		jnb	short loc_8001B84

loc_8001B7B:				; CODE XREF: default_sort_size+BDj
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		mov	[ebp+size], eax

loc_8001B84:				; CODE XREF: default_sort_size+A7j
					; default_sort_size+B9j ...
		sub	esp, 8
		lea	eax, [ebp+rlimit]
		push	eax
		push	9
		call	getrlimit64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001BBC
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		mov	ecx, [ebp+size]
		mov	ebx, 0
		cmp	edx, ebx
		ja	short loc_8001BBC
		cmp	edx, ebx
		jb	short loc_8001BB3
		cmp	eax, ecx
		jnb	short loc_8001BBC

loc_8001BB3:				; CODE XREF: default_sort_size+F5j
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		mov	[ebp+size], eax

loc_8001BBC:				; CODE XREF: default_sort_size+DFj
					; default_sort_size+F1j ...
		mov	eax, [ebp+size]
		shr	eax, 1
		mov	[ebp+size], eax
		sub	esp, 8
		lea	eax, [ebp+rlimit]
		push	eax
		push	5
		call	getrlimit64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001C26
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		shrd	eax, edx, 4
		shr	edx, 4
		imul	ebx, edx, 0Fh
		imul	ecx, eax, 0
		add	ecx, ebx
		mov	ebx, 0Fh
		mul	ebx
		add	ecx, edx
		mov	edx, ecx
		mov	ecx, [ebp+size]
		mov	ebx, 0
		cmp	edx, ebx
		ja	short loc_8001C26
		cmp	edx, ebx
		jb	short loc_8001C0D
		cmp	eax, ecx
		jnb	short loc_8001C26

loc_8001C0D:				; CODE XREF: default_sort_size+14Fj
		mov	eax, dword ptr [ebp+rlimit.rlim_cur]
		mov	edx, dword ptr [ebp+rlimit.rlim_cur+4]
		shrd	eax, edx, 4
		shr	edx, 4
		mov	edx, eax
		mov	eax, edx
		shl	eax, 4
		sub	eax, edx
		mov	[ebp+size], eax

loc_8001C26:				; CODE XREF: default_sort_size+11Fj
					; default_sort_size+14Bj ...
		mov	edx, nmerge
		mov	eax, edx
		shl	eax, 3
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+size]
		cmp	edx, eax
		cmovnb	eax, edx
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8001C50
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001C50:				; CODE XREF: default_sort_size+191j
		mov	ebx, [ebp+var_4]
		leave
		retn
default_sort_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl sort_buffer_size(FILE *const *fps, size_t nfps, char *const *files, size_t nfiles, size_t line_bytes)
sort_buffer_size proc near		; CODE XREF: sort+72p

files		= dword	ptr -90h
fps		= dword	ptr -8Ch
size		= dword	ptr -88h
i		= dword	ptr -84h
worst_case_per_input_byte= dword ptr -80h
worst_case	= dword	ptr -7Ch
file_size	= qword	ptr -78h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
nfps		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
nfiles		= dword	ptr  14h
line_bytes	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 94h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fps], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+files], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+line_bytes]
		add	eax, 1
		mov	[ebp+worst_case_per_input_byte], eax
		mov	eax, [ebp+worst_case_per_input_byte]
		add	eax, 1
		mov	[ebp+size], eax
		mov	[ebp+i], 0
		jmp	loc_8001E42
; ---------------------------------------------------------------------------

loc_8001CA0:				; CODE XREF: sort_buffer_size+1F6j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfps]
		jnb	short loc_8001CE7
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; stream
		call	fileno
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	edx
		call	fstat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_8001D57
; ---------------------------------------------------------------------------

loc_8001CE7:				; CODE XREF: sort_buffer_size+54j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset file	; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001D2B
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	0
		call	fstat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_8001D57
; ---------------------------------------------------------------------------

loc_8001D2B:				; CODE XREF: sort_buffer_size+BCj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+st]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		setnz	al

loc_8001D57:				; CODE XREF: sort_buffer_size+90j
					; sort_buffer_size+D4j
		test	al, al
		jz	short loc_8001D8C
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aStatFailed ; "stat failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8001D8C:				; CODE XREF: sort_buffer_size+104j
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8001DA9
		mov	eax, dword ptr [ebp+st.st_size]
		mov	edx, dword ptr [ebp+st.st_size+4]
		mov	dword ptr [ebp+file_size], eax
		mov	dword ptr [ebp+file_size+4], edx
		jmp	short loc_8001DCA
; ---------------------------------------------------------------------------

loc_8001DA9:				; CODE XREF: sort_buffer_size+144j
		mov	eax, ds:sort_size
		test	eax, eax
		jz	short loc_8001DBC
		mov	eax, ds:sort_size
		jmp	loc_8001E57
; ---------------------------------------------------------------------------

loc_8001DBC:				; CODE XREF: sort_buffer_size+15Bj
		mov	dword ptr [ebp+file_size], 100000h
		mov	dword ptr [ebp+file_size+4], 0

loc_8001DCA:				; CODE XREF: sort_buffer_size+152j
		mov	eax, ds:size_bound_6331
		test	eax, eax
		jnz	short loc_8001DF0
		mov	eax, ds:sort_size
		mov	ds:size_bound_6331, eax
		mov	eax, ds:size_bound_6331
		test	eax, eax
		jnz	short loc_8001DF0
		call	default_sort_size
		mov	ds:size_bound_6331, eax

loc_8001DF0:				; CODE XREF: sort_buffer_size+17Cj
					; sort_buffer_size+18Fj
		mov	eax, dword ptr [ebp+file_size]
		imul	eax, [ebp+worst_case_per_input_byte]
		add	eax, 1
		mov	[ebp+worst_case], eax
		mov	eax, [ebp+worst_case]
		mov	edx, 0
		div	[ebp+worst_case_per_input_byte]
		mov	edx, 0
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+file_size+4]
		xor	eax, dword ptr [ebp+file_size]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001E2B
		mov	eax, ds:size_bound_6331
		sub	eax, [ebp+size]
		cmp	eax, [ebp+worst_case]
		ja	short loc_8001E32

loc_8001E2B:				; CODE XREF: sort_buffer_size+1C4j
		mov	eax, ds:size_bound_6331
		jmp	short loc_8001E57
; ---------------------------------------------------------------------------

loc_8001E32:				; CODE XREF: sort_buffer_size+1D4j
		mov	eax, [ebp+worst_case]
		add	[ebp+size], eax
		add	[ebp+i], 1

loc_8001E42:				; CODE XREF: sort_buffer_size+46j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8001CA0
		mov	eax, [ebp+size]

loc_8001E57:				; CODE XREF: sort_buffer_size+162j
					; sort_buffer_size+1DBj
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8001E68
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001E68:				; CODE XREF: sort_buffer_size+20Cj
		mov	ebx, [ebp+var_4]
		leave
		retn
sort_buffer_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initbuf(buffer *buf, size_t line_bytes, size_t alloc)
initbuf		proc near		; CODE XREF: check+98p	mergefps+D3p ...

buf		= dword	ptr  8
line_bytes	= dword	ptr  0Ch
alloc		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8

loc_8001E73:				; CODE XREF: initbuf+41j
		mov	eax, [ebp+alloc]
		and	eax, 0FFFFFFF0h
		add	eax, 10h
		mov	[ebp+alloc], eax
		sub	esp, 0Ch
		push	[ebp+alloc]	; size
		call	malloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax], edx
		mov	eax, [ebp+buf]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8001EB5
		mov	eax, [ebp+alloc]
		shr	eax, 1
		mov	[ebp+alloc], eax
		mov	eax, [ebp+line_bytes]
		add	eax, 1
		cmp	eax, [ebp+alloc]
		jb	short loc_8001E73
		call	xalloc_die

loc_8001EB5:				; CODE XREF: initbuf+2Ej
		nop
		mov	eax, [ebp+buf]
		mov	edx, [ebp+line_bytes]
		mov	[eax+14h], edx
		mov	eax, [ebp+buf]
		mov	edx, [ebp+alloc]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+buf]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+buf]
		mov	edx, [eax+8]
		mov	eax, [ebp+buf]
		mov	[eax+10h], edx
		mov	eax, [ebp+buf]
		mov	edx, [eax+10h]
		mov	eax, [ebp+buf]
		mov	[eax+4], edx
		mov	eax, [ebp+buf]
		mov	byte ptr [eax+18h], 0
		nop
		leave
		retn
initbuf		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; line *__cdecl	buffer_linelim(const buffer *buf)
buffer_linelim	proc near		; CODE XREF: fillbuf+CBp fillbuf+33Fp	...

buf		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+buf]
		mov	edx, [eax]
		mov	eax, [ebp+buf]
		mov	eax, [eax+0Ch]
		add	eax, edx
		pop	ebp
		retn
buffer_linelim	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	begfield(const line *line, const keyfield *key)
begfield	proc near		; CODE XREF: fillbuf+280p
					; keycompare+A69p ...

ptr		= dword	ptr -10h
sword		= dword	ptr -0Ch
lim		= dword	ptr -8
schar		= dword	ptr -4
line		= dword	ptr  8
key		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+line]
		mov	eax, [eax]
		mov	[ebp+ptr], eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		lea	edx, [eax-1]
		mov	eax, [ebp+ptr]
		add	eax, edx
		mov	[ebp+lim], eax
		mov	eax, [ebp+key]
		mov	eax, [eax]
		mov	[ebp+sword], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+4]
		mov	[ebp+schar], eax
		mov	eax, tab
		cmp	eax, 80h
		jz	loc_8001FEA
		jmp	short loc_8001F72
; ---------------------------------------------------------------------------

loc_8001F48:				; CODE XREF: begfield+5Ej
		add	[ebp+ptr], 1

loc_8001F4C:				; CODE XREF: begfield+83j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8001F66
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	edx, al
		mov	eax, tab
		cmp	edx, eax
		jnz	short loc_8001F48

loc_8001F66:				; CODE XREF: begfield+4Cj
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8001F72
		add	[ebp+ptr], 1

loc_8001F72:				; CODE XREF: begfield+40j begfield+66j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	loc_8001FFF
		mov	eax, [ebp+sword]
		lea	edx, [eax-1]
		mov	[ebp+sword], edx
		test	eax, eax
		jnz	short loc_8001F4C
		jmp	short loc_8001FFF
; ---------------------------------------------------------------------------

loc_8001F8D:				; CODE XREF: begfield+B1j
		add	[ebp+ptr], 1

loc_8001F91:				; CODE XREF: begfield+F7j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8001FBF
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_8001F8D
		jmp	short loc_8001FBF
; ---------------------------------------------------------------------------

loc_8001FBB:				; CODE XREF: begfield+E2j
		add	[ebp+ptr], 1

loc_8001FBF:				; CODE XREF: begfield+91j begfield+B3j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8001FEA
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		xor	eax, 1
		test	al, al
		jnz	short loc_8001FBB

loc_8001FEA:				; CODE XREF: begfield+3Aj begfield+BFj
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8001FFF
		mov	eax, [ebp+sword]
		lea	edx, [eax-1]
		mov	[ebp+sword], edx
		test	eax, eax
		jnz	short loc_8001F91

loc_8001FFF:				; CODE XREF: begfield+72j begfield+85j ...
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8002038
		jmp	short loc_8002010
; ---------------------------------------------------------------------------

loc_800200C:				; CODE XREF: begfield+130j
		add	[ebp+ptr], 1

loc_8002010:				; CODE XREF: begfield+104j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8002038
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_800200C

loc_8002038:				; CODE XREF: begfield+102j
					; begfield+110j
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+schar]
		add	edx, eax
		mov	eax, [ebp+lim]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+ptr], eax
		mov	eax, [ebp+ptr]
		leave
		retn
begfield	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	limfield(const line *line, const keyfield *key)
limfield	proc near		; CODE XREF: fillbuf+25Ap
					; keycompare+9E8p ...

ptr		= dword	ptr -10h
eword		= dword	ptr -0Ch
lim		= dword	ptr -8
echar		= dword	ptr -4
line		= dword	ptr  8
key		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+line]
		mov	eax, [eax]
		mov	[ebp+ptr], eax
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		lea	edx, [eax-1]
		mov	eax, [ebp+ptr]
		add	eax, edx
		mov	[ebp+lim], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+8]
		mov	[ebp+eword], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+0Ch]
		mov	[ebp+echar], eax
		cmp	[ebp+echar], 0
		jnz	short loc_800208B
		add	[ebp+eword], 1

loc_800208B:				; CODE XREF: limfield+35j
		mov	eax, tab
		cmp	eax, 80h
		jz	loc_800214B
		jmp	short loc_80020D3
; ---------------------------------------------------------------------------

loc_800209D:				; CODE XREF: limfield+69j
		add	[ebp+ptr], 1

loc_80020A1:				; CODE XREF: limfield+9Aj
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_80020BB
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	edx, al
		mov	eax, tab
		cmp	edx, eax
		jnz	short loc_800209D

loc_80020BB:				; CODE XREF: limfield+57j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_80020D3
		cmp	[ebp+eword], 0
		jnz	short loc_80020CF
		cmp	[ebp+echar], 0
		jz	short loc_80020D3

loc_80020CF:				; CODE XREF: limfield+77j
		add	[ebp+ptr], 1

loc_80020D3:				; CODE XREF: limfield+4Bj limfield+71j ...
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	loc_8002160
		mov	eax, [ebp+eword]
		lea	edx, [eax-1]
		mov	[ebp+eword], edx
		test	eax, eax
		jnz	short loc_80020A1
		jmp	short loc_8002160
; ---------------------------------------------------------------------------

loc_80020EE:				; CODE XREF: limfield+C8j
		add	[ebp+ptr], 1

loc_80020F2:				; CODE XREF: limfield+10Ej
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8002120
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_80020EE
		jmp	short loc_8002120
; ---------------------------------------------------------------------------

loc_800211C:				; CODE XREF: limfield+F9j
		add	[ebp+ptr], 1

loc_8002120:				; CODE XREF: limfield+A8j limfield+CAj
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_800214B
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		xor	eax, 1
		test	al, al
		jnz	short loc_800211C

loc_800214B:				; CODE XREF: limfield+45j limfield+D6j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_8002160
		mov	eax, [ebp+eword]
		lea	edx, [eax-1]
		mov	[ebp+eword], edx
		test	eax, eax
		jnz	short loc_80020F2

loc_8002160:				; CODE XREF: limfield+89j limfield+9Cj ...
		cmp	[ebp+echar], 0
		jz	short loc_80021B2
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+19h]
		test	al, al
		jz	short loc_800219F
		jmp	short loc_8002177
; ---------------------------------------------------------------------------

loc_8002173:				; CODE XREF: limfield+14Dj
		add	[ebp+ptr], 1

loc_8002177:				; CODE XREF: limfield+121j
		mov	eax, [ebp+ptr]
		cmp	eax, [ebp+lim]
		jnb	short loc_800219F
		mov	eax, [ebp+ptr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_8002173

loc_800219F:				; CODE XREF: limfield+11Fj
					; limfield+12Dj
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+echar]
		add	edx, eax
		mov	eax, [ebp+lim]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+ptr], eax

loc_80021B2:				; CODE XREF: limfield+114j
		mov	eax, [ebp+ptr]
		leave
		retn
limfield	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	fillbuf(buffer *buf, FILE *fp, const char *file)
fillbuf		proc near		; CODE XREF: check+2AFp mergefps+117p	...

file		= dword	ptr -54h
fp		= dword	ptr -50h
buf		= dword	ptr -4Ch
eol		= byte ptr -41h
line_alloc	= dword	ptr -40h
mergesize	= dword	ptr -3Ch
ptr		= dword	ptr -38h
line		= dword	ptr -34h
avail		= dword	ptr -30h
line_start	= dword	ptr -2Ch
ptrlim		= dword	ptr -28h
key		= dword	ptr -24h
line_bytes	= dword	ptr -20h
linelim		= dword	ptr -1Ch
readsize	= dword	ptr -18h
bytes_read	= dword	ptr -14h
p		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 54h
		mov	eax, [ebp+arg_0]
		mov	[ebp+buf], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+fp], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		movzx	eax, byte ptr eolchar ;	"\n"
		mov	[ebp+eol], al
		mov	eax, [ebp+buf]
		mov	eax, [eax+14h]
		mov	[ebp+line_bytes], eax
		mov	eax, merge_buffer_size
		sub	eax, 12h
		mov	[ebp+mergesize], eax
		mov	eax, [ebp+buf]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_8002216
		mov	eax, 0
		jmp	loc_800257D
; ---------------------------------------------------------------------------

loc_8002216:				; CODE XREF: fillbuf+53j
		mov	eax, [ebp+buf]
		mov	edx, [eax+4]
		mov	eax, [ebp+buf]
		mov	eax, [eax+10h]
		cmp	edx, eax
		jz	short loc_800226C
		mov	eax, [ebp+buf]
		mov	edx, [eax+10h]
		mov	eax, [ebp+buf]
		mov	ecx, [eax]
		mov	eax, [ebp+buf]
		mov	ebx, [eax+4]
		mov	eax, [ebp+buf]
		mov	eax, [eax+10h]
		sub	ebx, eax
		mov	eax, ebx
		add	ecx, eax
		mov	eax, [ebp+buf]
		mov	eax, [eax]
		sub	esp, 4
		push	edx		; n
		push	ecx		; src
		push	eax		; dest
		call	memmove
		add	esp, 10h
		mov	eax, [ebp+buf]
		mov	edx, [eax+10h]
		mov	eax, [ebp+buf]
		mov	[eax+4], edx
		mov	eax, [ebp+buf]
		mov	dword ptr [eax+8], 0

loc_800226C:				; CODE XREF: fillbuf+6Dj fillbuf+3C1j
		mov	eax, [ebp+buf]
		mov	edx, [eax]
		mov	eax, [ebp+buf]
		mov	eax, [eax+4]
		add	eax, edx
		mov	[ebp+ptr], eax
		sub	esp, 0Ch
		push	[ebp+buf]	; buf
		call	buffer_linelim
		add	esp, 10h
		mov	[ebp+linelim], eax
		mov	eax, [ebp+buf]
		mov	eax, [eax+8]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+linelim]
		add	eax, edx
		mov	[ebp+line], eax
		mov	eax, [ebp+buf]
		mov	eax, [eax+8]
		imul	eax, [ebp+line_bytes]
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+linelim]
		add	eax, edx
		mov	edx, eax
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+avail], eax
		mov	eax, [ebp+buf]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_80022DA
		mov	eax, [ebp+line]
		mov	edx, [eax]
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		add	eax, edx
		jmp	short loc_80022DF
; ---------------------------------------------------------------------------

loc_80022DA:				; CODE XREF: fillbuf+112j
		mov	eax, [ebp+buf]
		mov	eax, [eax]

loc_80022DF:				; CODE XREF: fillbuf+121j
		mov	[ebp+line_start], eax
		jmp	loc_80024CA
; ---------------------------------------------------------------------------

loc_80022E7:				; CODE XREF: fillbuf+31Cj
		mov	eax, [ebp+avail]
		sub	eax, 1
		mov	edx, [ebp+line_bytes]
		lea	ecx, [edx+1]
		mov	edx, 0
		div	ecx
		mov	[ebp+readsize],	eax
		push	[ebp+fp]	; stream
		push	[ebp+readsize]	; n
		push	1		; size
		push	[ebp+ptr]	; ptr
		call	fread_unlocked
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+bytes_read]
		add	eax, edx
		mov	[ebp+ptrlim], eax
		mov	eax, [ebp+bytes_read]
		sub	[ebp+avail], eax
		mov	eax, [ebp+bytes_read]
		cmp	eax, [ebp+readsize]
		jz	loc_800248C
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_800235E
		sub	esp, 0Ch
		push	offset aReadFailed ; "read failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_800235E:				; CODE XREF: fillbuf+189j
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_800248C
		mov	eax, [ebp+buf]
		mov	byte ptr [eax+18h], 1
		mov	eax, [ebp+buf]
		mov	eax, [eax]
		cmp	eax, [ebp+ptrlim]
		jnz	short loc_800238F
		mov	eax, 0
		jmp	loc_800257D
; ---------------------------------------------------------------------------

loc_800238F:				; CODE XREF: fillbuf+1CCj
		mov	eax, [ebp+ptrlim]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+eol]
		jz	loc_800248C
		mov	eax, [ebp+ptrlim]
		lea	edx, [eax+1]
		mov	[ebp+ptrlim], edx
		movzx	edx, [ebp+eol]
		mov	[eax], dl
		jmp	loc_800248C
; ---------------------------------------------------------------------------

loc_80023B5:				; CODE XREF: fillbuf+2FCj
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+ptr], eax
		sub	[ebp+line], 10h
		mov	eax, [ebp+line]
		mov	edx, [ebp+line_start]
		mov	[eax], edx
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+line_start]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+line]
		mov	[eax+4], edx
		mov	eax, [ebp+line]
		mov	edx, [eax+4]
		mov	eax, [ebp+mergesize]
		cmp	edx, eax
		cmovnb	eax, edx
		mov	[ebp+mergesize], eax
		mov	eax, [ebp+line_bytes]
		sub	[ebp+avail], eax
		cmp	[ebp+key], 0
		jz	loc_8002486
		mov	eax, [ebp+key]
		mov	eax, [eax+8]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_800241B
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+line]	; line
		call	limfield
		add	esp, 10h
		jmp	short loc_800241E
; ---------------------------------------------------------------------------

loc_800241B:				; CODE XREF: fillbuf+24Fj
		mov	eax, [ebp+p]

loc_800241E:				; CODE XREF: fillbuf+262j
		mov	edx, [ebp+line]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+key]
		mov	eax, [eax]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8002449
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+line]	; line
		call	begfield
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+line]
		mov	[eax+8], edx
		jmp	short loc_8002486
; ---------------------------------------------------------------------------

loc_8002449:				; CODE XREF: fillbuf+275j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	short loc_800247D
		jmp	short loc_800245A
; ---------------------------------------------------------------------------

loc_8002456:				; CODE XREF: fillbuf+2C4j
		add	[ebp+line_start], 1

loc_800245A:				; CODE XREF: fillbuf+29Dj
		mov	eax, [ebp+line_start]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_8002456

loc_800247D:				; CODE XREF: fillbuf+29Bj
		mov	eax, [ebp+line]
		mov	edx, [ebp+line_start]
		mov	[eax+8], edx

loc_8002486:				; CODE XREF: fillbuf+240j fillbuf+290j
		mov	eax, [ebp+ptr]
		mov	[ebp+line_start], eax

loc_800248C:				; CODE XREF: fillbuf+173j fillbuf+1B7j ...
		mov	edx, [ebp+ptrlim]
		mov	eax, [ebp+ptr]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		movsx	eax, [ebp+eol]
		sub	esp, 4
		push	edx		; n
		push	eax		; c
		push	[ebp+ptr]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	loc_80023B5
		mov	eax, [ebp+ptrlim]
		mov	[ebp+ptr], eax
		mov	eax, [ebp+buf]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jnz	short loc_80024DB

loc_80024CA:				; CODE XREF: fillbuf+12Bj
		mov	eax, [ebp+line_bytes]
		add	eax, 1
		cmp	eax, [ebp+avail]
		jb	loc_80022E7
		jmp	short loc_80024DC
; ---------------------------------------------------------------------------

loc_80024DB:				; CODE XREF: fillbuf+311j
		nop

loc_80024DC:				; CODE XREF: fillbuf+322j
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+buf]
		mov	eax, [eax]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax+4], edx
		sub	esp, 0Ch
		push	[ebp+buf]	; buf
		call	buffer_linelim
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+line]
		sub	edx, eax
		mov	eax, edx
		sar	eax, 4
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax+8], edx
		mov	eax, [ebp+buf]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_8002540
		mov	edx, [ebp+ptr]
		mov	eax, [ebp+line_start]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax+10h], edx
		mov	eax, [ebp+mergesize]
		add	eax, 12h
		mov	merge_buffer_size, eax
		mov	eax, 1
		jmp	short loc_800257D
; ---------------------------------------------------------------------------

loc_8002540:				; CODE XREF: fillbuf+363j
		mov	eax, [ebp+buf]
		mov	eax, [eax+0Ch]
		shr	eax, 4
		mov	[ebp+line_alloc], eax
		mov	eax, [ebp+buf]
		mov	eax, [eax]
		sub	esp, 4
		push	10h
		lea	edx, [ebp+line_alloc]
		push	edx
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax], edx
		mov	eax, [ebp+line_alloc]
		shl	eax, 4
		mov	edx, eax
		mov	eax, [ebp+buf]
		mov	[eax+0Ch], edx
		jmp	loc_800226C
; ---------------------------------------------------------------------------

loc_800257D:				; CODE XREF: fillbuf+5Aj fillbuf+1D3j	...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800258E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800258E:				; CODE XREF: fillbuf+3D0j
		mov	ebx, [ebp+var_4]
		leave
		retn
fillbuf		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl numcompare(const char *a,	const char *b)
numcompare	proc near		; CODE XREF: keycompare+1A6p

a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		jmp	short loc_800259F
; ---------------------------------------------------------------------------

loc_800259B:				; CODE XREF: numcompare+2Aj
		add	[ebp+a], 1

loc_800259F:				; CODE XREF: numcompare+6j
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_800259B
		jmp	short loc_80025C5
; ---------------------------------------------------------------------------

loc_80025C1:				; CODE XREF: numcompare+50j
		add	[ebp+b], 1

loc_80025C5:				; CODE XREF: numcompare+2Cj
		mov	eax, [ebp+b]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_80025C1
		mov	edx, ds:thousands_sep
		mov	eax, ds:decimal_point
		push	edx
		push	eax
		push	[ebp+b]
		push	[ebp+a]
		call	strnumcmp
		add	esp, 10h
		leave
		retn
numcompare	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_mixed_SI_IEC(char prefix, keyfield	*key)
check_mixed_SI_IEC proc	near		; CODE XREF: find_unit_order+C4p

prefix		= byte ptr -1Ch
si_present	= dword	ptr -0Ch
arg_0		= dword	ptr  8
key		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+prefix], al
		cmp	[ebp+prefix], 69h
		setz	al
		movzx	eax, al
		mov	[ebp+si_present], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+20h]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8002651
		mov	eax, [ebp+key]
		mov	eax, [eax+20h]
		cmp	eax, [ebp+si_present]
		jz	short loc_8002651
		sub	esp, 0Ch
		push	offset aBothSiAndIecPr ; "both SI and IEC prefixes present on uni"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8002651:				; CODE XREF: check_mixed_SI_IEC+22j
					; check_mixed_SI_IEC+2Dj
		mov	eax, [ebp+key]
		mov	edx, [ebp+si_present]
		mov	[eax+20h], edx
		nop
		leave
		retn
check_mixed_SI_IEC endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl find_unit_order(const char *number, keyfield *key)
find_unit_order	proc near		; CODE XREF: human_numcompare+5Bp
					; human_numcompare+6Fp

p		= dword	ptr -14h
sign		= dword	ptr -10h
order		= dword	ptr -0Ch
number		= dword	ptr  8
key		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+number]
		mov	[ebp+p], eax
		mov	[ebp+sign], 1
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_80026E1
		mov	[ebp+sign], 0FFFFFFFFh
		add	[ebp+p], 1
		jmp	short loc_80026E1
; ---------------------------------------------------------------------------

loc_8002687:				; CODE XREF: find_unit_order+93j
		add	[ebp+p], 1
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	eax, ds:decimal_point
		cmp	edx, eax
		jnz	short loc_80026B7
		mov	eax, [ebp+p]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_80026B7
		add	[ebp+p], 2
		jmp	short loc_80026E1
; ---------------------------------------------------------------------------

loc_80026B7:				; CODE XREF: find_unit_order+3Ej
					; find_unit_order+52j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	eax, ds:thousands_sep
		cmp	edx, eax
		jnz	short loc_80026E1
		mov	eax, [ebp+p]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_80026E1
		add	[ebp+p], 2

loc_80026E1:				; CODE XREF: find_unit_order+1Bj
					; find_unit_order+28j ...
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8002687
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		movzx	eax, ds:orders_6451[eax]
		movsx	eax, al
		mov	[ebp+order], eax
		cmp	[ebp+order], 0
		jz	short loc_8002729
		mov	eax, [ebp+p]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	[ebp+key]	; key
		push	eax		; prefix
		call	check_mixed_SI_IEC
		add	esp, 10h

loc_8002729:				; CODE XREF: find_unit_order+AFj
		mov	eax, [ebp+sign]
		imul	eax, [ebp+order]
		leave
		retn
find_unit_order	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl human_numcompare(const char *a, const char *b, keyfield *key)
human_numcompare proc near		; CODE XREF: keycompare+1ECp

order_a		= dword	ptr -10h
order_b		= dword	ptr -0Ch
a		= dword	ptr  8
b		= dword	ptr  0Ch
key		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		jmp	short loc_800273E
; ---------------------------------------------------------------------------

loc_800273A:				; CODE XREF: human_numcompare+2Aj
		add	[ebp+a], 1

loc_800273E:				; CODE XREF: human_numcompare+6j
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_800273A
		jmp	short loc_8002764
; ---------------------------------------------------------------------------

loc_8002760:				; CODE XREF: human_numcompare+50j
		add	[ebp+b], 1

loc_8002764:				; CODE XREF: human_numcompare+2Cj
		mov	eax, [ebp+b]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_8002760
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+a]		; number
		call	find_unit_order
		add	esp, 10h
		mov	[ebp+order_a], eax
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+b]		; number
		call	find_unit_order
		add	esp, 10h
		mov	[ebp+order_b], eax
		mov	eax, [ebp+order_a]
		cmp	eax, [ebp+order_b]
		jg	short loc_80027E0
		mov	eax, [ebp+order_a]
		cmp	eax, [ebp+order_b]
		jl	short loc_80027D9
		mov	edx, ds:thousands_sep
		mov	eax, ds:decimal_point
		push	edx
		push	eax
		push	[ebp+b]
		push	[ebp+a]
		call	strnumcmp
		add	esp, 10h
		jmp	short locret_80027E5
; ---------------------------------------------------------------------------

loc_80027D9:				; CODE XREF: human_numcompare+88j
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80027E5
; ---------------------------------------------------------------------------

loc_80027E0:				; CODE XREF: human_numcompare+80j
		mov	eax, 1

locret_80027E5:				; CODE XREF: human_numcompare+A5j
					; human_numcompare+ACj
		leave
		retn
human_numcompare endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl general_numcompare(const char *sa, const char *sb)
general_numcompare proc	near		; CODE XREF: keycompare+1CDp

sb		= dword	ptr -30h
sa		= dword	ptr -2Ch
ea		= dword	ptr -28h
eb		= dword	ptr -24h
a		= qword	ptr -20h
b		= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+sa], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+sb], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+ea]
		push	eax		; endptr
		push	[ebp+sa]	; nptr
		call	strtod
		add	esp, 10h
		fstp	[ebp+a]
		sub	esp, 8
		lea	eax, [ebp+eb]
		push	eax		; endptr
		push	[ebp+sb]	; nptr
		call	strtod
		add	esp, 10h
		fstp	[ebp+b]
		mov	eax, [ebp+ea]
		cmp	[ebp+sa], eax
		jnz	short loc_8002852
		mov	eax, [ebp+eb]
		cmp	[ebp+sb], eax
		jnz	short loc_8002848
		mov	eax, 0
		jmp	loc_80028FC
; ---------------------------------------------------------------------------

loc_8002848:				; CODE XREF: general_numcompare+55j
		mov	eax, 0FFFFFFFFh
		jmp	loc_80028FC
; ---------------------------------------------------------------------------

loc_8002852:				; CODE XREF: general_numcompare+4Dj
		mov	eax, [ebp+eb]
		cmp	[ebp+sb], eax
		jnz	short loc_8002864
		mov	eax, 1
		jmp	loc_80028FC
; ---------------------------------------------------------------------------

loc_8002864:				; CODE XREF: general_numcompare+71j
		fld	[ebp+a]
		fld	[ebp+b]
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_800287A
		mov	eax, 0FFFFFFFFh
		jmp	loc_80028FC
; ---------------------------------------------------------------------------

loc_800287A:				; CODE XREF: general_numcompare+87j
		fld	[ebp+a]
		fld	[ebp+b]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_800288F
		mov	eax, 1
		jmp	short loc_80028FC
; ---------------------------------------------------------------------------

loc_800288F:				; CODE XREF: general_numcompare+9Fj
		fld	[ebp+a]
		fld	[ebp+b]
		fucomi	st, st(1)
		jp	short loc_80028A1
		fucomip	st, st(1)
		fstp	st
		jz	short loc_80028F6
		jmp	short loc_80028A5
; ---------------------------------------------------------------------------

loc_80028A1:				; CODE XREF: general_numcompare+B0j
		fstp	st
		fstp	st

loc_80028A5:				; CODE XREF: general_numcompare+B8j
		fld	[ebp+b]
		fld	[ebp+b]
		fucomi	st, st(1)
		jp	short loc_80028B7
		fucomip	st, st(1)
		fstp	st
		jz	short loc_80028EF
		jmp	short loc_80028BB
; ---------------------------------------------------------------------------

loc_80028B7:				; CODE XREF: general_numcompare+C6j
		fstp	st
		fstp	st

loc_80028BB:				; CODE XREF: general_numcompare+CEj
		fld	[ebp+a]
		fld	[ebp+a]
		fucomi	st, st(1)
		jp	short loc_80028CD
		fucomip	st, st(1)
		fstp	st
		jz	short loc_80028E8
		jmp	short loc_80028D1
; ---------------------------------------------------------------------------

loc_80028CD:				; CODE XREF: general_numcompare+DCj
		fstp	st
		fstp	st

loc_80028D1:				; CODE XREF: general_numcompare+E4j
		sub	esp, 4
		push	8		; n
		lea	eax, [ebp+b]
		push	eax		; s2
		lea	eax, [ebp+a]
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		jmp	short loc_80028FC
; ---------------------------------------------------------------------------

loc_80028E8:				; CODE XREF: general_numcompare+E2j
		mov	eax, 1
		jmp	short loc_80028FC
; ---------------------------------------------------------------------------

loc_80028EF:				; CODE XREF: general_numcompare+CCj
		mov	eax, 0FFFFFFFFh
		jmp	short loc_80028FC
; ---------------------------------------------------------------------------

loc_80028F6:				; CODE XREF: general_numcompare+B6j
		mov	eax, 0
		nop

loc_80028FC:				; CODE XREF: general_numcompare+5Cj
					; general_numcompare+66j ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_800290D
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_800290D:				; CODE XREF: general_numcompare+11Fj
		leave
		retn
general_numcompare endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl getmonth(const char *month, size_t len)
getmonth	proc near		; CODE XREF: keycompare+273p
					; keycompare+28Cp

lo		= dword	ptr -1Ch
hi		= dword	ptr -18h
m		= dword	ptr -14h
n		= dword	ptr -10h
monthlim	= dword	ptr -0Ch
ix		= dword	ptr -8
var_4		= dword	ptr -4
month		= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 20h
		mov	[ebp+lo], 0
		mov	[ebp+hi], 0Ch
		mov	edx, [ebp+month]
		mov	eax, [ebp+len]
		add	eax, edx
		mov	[ebp+monthlim],	eax

loc_800292F:				; CODE XREF: getmonth+5Bj
		mov	eax, [ebp+month]
		cmp	eax, [ebp+monthlim]
		jnz	short loc_8002941
		mov	eax, 0
		jmp	loc_8002A4E
; ---------------------------------------------------------------------------

loc_8002941:				; CODE XREF: getmonth+26j
		mov	eax, [ebp+month]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8002966
		jmp	short loc_800296C
; ---------------------------------------------------------------------------

loc_8002966:				; CODE XREF: getmonth+53j
		add	[ebp+month], 1
		jmp	short loc_800292F
; ---------------------------------------------------------------------------

loc_800296C:				; CODE XREF: getmonth+55j
					; getmonth+134j
		mov	edx, [ebp+lo]
		mov	eax, [ebp+hi]
		add	eax, edx
		shr	eax, 1
		mov	[ebp+ix], eax
		mov	eax, [ebp+month]
		mov	[ebp+m], eax
		mov	eax, [ebp+ix]
		mov	eax, dword ptr monthtab.name[eax*8]
		mov	[ebp+n], eax

loc_800298C:				; CODE XREF: getmonth+129j
		mov	eax, [ebp+n]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80029A5
		mov	eax, [ebp+ix]
		mov	eax, monthtab.val[eax*8]
		jmp	loc_8002A4E
; ---------------------------------------------------------------------------

loc_80029A5:				; CODE XREF: getmonth+85j
		mov	eax, [ebp+m]
		cmp	eax, [ebp+monthlim]
		jz	short loc_80029E5
		mov	eax, [ebp+m]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:fold_toupper[eax]
		movsx	ebx, al
		mov	eax, [ebp+n]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		cmp	ebx, eax
		jge	short loc_80029ED

loc_80029E5:				; CODE XREF: getmonth+9Cj
		mov	eax, [ebp+ix]
		mov	[ebp+hi], eax
		jmp	short loc_8002A3D
; ---------------------------------------------------------------------------

loc_80029ED:				; CODE XREF: getmonth+D4j
		mov	eax, [ebp+m]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:fold_toupper[eax]
		movsx	ebx, al
		mov	eax, [ebp+n]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		cmp	ebx, eax
		jle	short loc_8002A30
		mov	eax, [ebp+ix]
		add	eax, 1
		mov	[ebp+lo], eax
		jmp	short loc_8002A3D
; ---------------------------------------------------------------------------

loc_8002A30:				; CODE XREF: getmonth+114j
		add	[ebp+m], 1
		add	[ebp+n], 1
		jmp	loc_800298C
; ---------------------------------------------------------------------------

loc_8002A3D:				; CODE XREF: getmonth+DCj
					; getmonth+11Fj
		mov	eax, [ebp+lo]
		cmp	eax, [ebp+hi]
		jb	loc_800296C
		mov	eax, 0

loc_8002A4E:				; CODE XREF: getmonth+2Dj getmonth+91j
		mov	ebx, [ebp+var_4]
		leave
		retn
getmonth	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; md5_ctx *random_state(md5_ctx	*__return_ptr __struct_ptr retstr, size_t i)
random_state	proc near		; CODE XREF: cmp_hashes+42p

var_3C		= dword	ptr -3Ch
s		= dword	ptr -30h
buf		= byte ptr -2Ch
var_1C		= dword	ptr -1Ch
retstr		= dword	ptr  8
i		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		mov	eax, [ebp+retstr]
		mov	[ebp+var_3C], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	edx, ds:state_6499
		mov	eax, [ebp+i]
		imul	eax, 9Ch
		add	eax, edx
		mov	[ebp+s], eax
		mov	eax, ds:used_6500
		cmp	eax, [ebp+i]
		ja	loc_8002B13
		mov	eax, ds:used_6500
		add	eax, 1
		mov	ds:used_6500, eax
		mov	eax, ds:allocated_6501
		cmp	eax, [ebp+i]
		ja	short loc_8002ADA
		mov	eax, ds:state_6499
		sub	esp, 4
		push	9Ch
		push	offset allocated_6501
		push	eax
		call	x2nrealloc
		add	esp, 10h
		mov	ds:state_6499, eax
		mov	edx, ds:state_6499
		mov	eax, [ebp+i]
		imul	eax, 9Ch
		add	eax, edx
		mov	[ebp+s], eax

loc_8002ADA:				; CODE XREF: random_state+51j
		mov	eax, ds:randread_source_0
		sub	esp, 4
		push	10h
		lea	edx, [ebp+buf]
		push	edx
		push	eax
		call	randread
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+s]
		call	md5_init_ctx
		add	esp, 10h
		sub	esp, 4
		push	[ebp+s]
		push	10h
		lea	eax, [ebp+buf]
		push	eax
		call	md5_process_bytes
		add	esp, 10h

loc_8002B13:				; CODE XREF: random_state+36j
		mov	edx, [ebp+var_3C]
		mov	eax, [ebp+s]
		mov	ebx, eax
		mov	eax, 27h
		mov	edi, edx
		mov	esi, ebx
		mov	ecx, eax
		rep movsd
		mov	eax, [ebp+var_3C]
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8002B3C
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002B3C:				; CODE XREF: random_state+E2j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn	4
random_state	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl cmp_hashes(const char *texta, size_t lena, const char *textb, size_t lenb)
cmp_hashes	proc near		; CODE XREF: compare_random+46p
					; compare_random+1A6p

var_228		= md5_ctx ptr -228h
textb		= dword	ptr -180h
texta		= dword	ptr -17Ch
i		= dword	ptr -16Ch
diff		= dword	ptr -168h
dig		= dword	ptr -164h
s		= md5_ctx ptr -144h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
lena		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
lenb		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		sub	esp, 220h
		mov	eax, [ebp+arg_0]
		mov	[ebp+texta], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+textb], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+i], 0

loc_8002B78:				; CODE XREF: cmp_hashes+150j
		lea	eax, [ebp+var_228]
		sub	esp, 8
		push	[ebp+i]		; i
		push	eax		; retstr
		call	random_state
		add	esp, 0Ch
		lea	eax, [ebp+s.A+9Ch]
		lea	edx, [ebp+var_228]
		mov	ecx, 27h
		mov	edi, eax
		mov	esi, edx
		rep movsd
		lea	eax, [ebp+s]
		lea	edx, [ebp+s.A+9Ch]
		mov	ecx, 27h
		mov	edi, eax
		mov	esi, edx
		rep movsd
		sub	esp, 4
		lea	eax, [ebp+s]
		push	eax
		push	[ebp+lena]
		push	[ebp+texta]
		call	md5_process_bytes
		add	esp, 10h
		sub	esp, 8
		lea	eax, [ebp+dig]
		push	eax
		lea	eax, [ebp+s]
		push	eax
		call	md5_finish_ctx
		add	esp, 10h
		sub	esp, 4
		lea	eax, [ebp+s]
		add	eax, 9Ch
		push	eax
		push	[ebp+lenb]
		push	[ebp+textb]
		call	md5_process_bytes
		add	esp, 10h
		sub	esp, 8
		lea	eax, [ebp+dig]
		add	eax, 10h
		push	eax
		lea	eax, [ebp+s]
		add	eax, 9Ch
		push	eax
		call	md5_finish_ctx
		add	esp, 10h
		sub	esp, 4
		push	10h		; n
		lea	eax, [ebp+dig]
		add	eax, 10h
		push	eax		; s2
		lea	eax, [ebp+dig]
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8002C9B
		cmp	[ebp+i], 0
		jnz	short loc_8002C8F
		mov	eax, [ebp+lena]
		cmp	eax, [ebp+lenb]
		jnz	short loc_8002C8F
		sub	esp, 4
		push	[ebp+lena]	; n
		push	[ebp+textb]	; s2
		push	[ebp+texta]	; s1
		call	memcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002C9E

loc_8002C8F:				; CODE XREF: cmp_hashes+121j
					; cmp_hashes+129j
		add	[ebp+i], 1
		jmp	loc_8002B78
; ---------------------------------------------------------------------------

loc_8002C9B:				; CODE XREF: cmp_hashes+118j
		nop
		jmp	short loc_8002C9F
; ---------------------------------------------------------------------------

loc_8002C9E:				; CODE XREF: cmp_hashes+147j
		nop

loc_8002C9F:				; CODE XREF: cmp_hashes+156j
		mov	eax, [ebp+diff]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8002CB6
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002CB6:				; CODE XREF: cmp_hashes+169j
		lea	esp, [ebp-8]
		pop	esi
		pop	edi
		pop	ebp
		retn
cmp_hashes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl compare_random(char *texta, size_t lena, char *textb, size_t lenb)
compare_random	proc near		; CODE XREF: keycompare+110p

textb		= dword	ptr -0FD0h
texta		= dword	ptr -0FCCh
a_fits		= byte ptr -0FBDh
diff		= dword	ptr -0FBCh
buf		= dword	ptr -0FB8h
tlena		= dword	ptr -0FB4h
tlenb		= dword	ptr -0FB0h
stackbuf	= byte ptr -0FACh
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
lena		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
lenb		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 0FD8h
		mov	eax, [ebp+arg_0]
		mov	[ebp+texta], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+textb], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		movzx	eax, ds:hard_LC_COLLATE
		xor	eax, 1
		test	al, al
		jz	short loc_8002D16
		push	[ebp+lenb]	; lenb
		push	[ebp+textb]	; textb
		push	[ebp+lena]	; lena
		push	[ebp+texta]	; texta
		call	cmp_hashes
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	loc_8002E90
; ---------------------------------------------------------------------------

loc_8002D16:				; CODE XREF: compare_random+32j
		mov	[ebp+buf], 0
		push	[ebp+lena]
		push	[ebp+texta]
		push	0FA0h
		lea	eax, [ebp+stackbuf]
		push	eax
		call	xmemxfrm
		add	esp, 10h
		mov	[ebp+tlena], eax
		cmp	[ebp+tlena], 0FA0h
		setbe	al
		mov	[ebp+a_fits], al
		cmp	[ebp+a_fits], 0
		jz	short loc_8002D6C
		mov	eax, 0FA0h
		sub	eax, [ebp+tlena]
		jmp	short loc_8002D71
; ---------------------------------------------------------------------------

loc_8002D6C:				; CODE XREF: compare_random+A0j
		mov	eax, 0

loc_8002D71:				; CODE XREF: compare_random+ADj
		cmp	[ebp+a_fits], 0
		jz	short loc_8002D8A
		lea	ecx, [ebp+stackbuf]
		mov	edx, [ebp+tlena]
		add	edx, ecx
		jmp	short loc_8002D8F
; ---------------------------------------------------------------------------

loc_8002D8A:				; CODE XREF: compare_random+BBj
		mov	edx, 0

loc_8002D8F:				; CODE XREF: compare_random+CBj
		push	[ebp+lenb]
		push	[ebp+textb]
		push	eax
		push	edx
		call	xmemxfrm
		add	esp, 10h
		mov	[ebp+tlenb], eax
		cmp	[ebp+a_fits], 0
		jz	short loc_8002DD4
		mov	edx, [ebp+tlena]
		mov	eax, [ebp+tlenb]
		add	eax, edx
		cmp	eax, 0FA0h
		ja	short loc_8002DD4
		lea	eax, [ebp+stackbuf]
		mov	[ebp+buf], eax
		jmp	short loc_8002E42
; ---------------------------------------------------------------------------

loc_8002DD4:				; CODE XREF: compare_random+F2j
					; compare_random+107j
		mov	edx, [ebp+tlena]
		mov	eax, [ebp+tlenb]
		add	eax, edx
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, [ebp+tlena]
		add	eax, 1
		push	[ebp+lena]
		push	[ebp+texta]
		push	eax
		push	[ebp+buf]
		call	xmemxfrm
		add	esp, 10h
		mov	eax, [ebp+tlenb]
		lea	edx, [eax+1]
		mov	ecx, [ebp+buf]
		mov	eax, [ebp+tlena]
		add	eax, ecx
		push	[ebp+lenb]
		push	[ebp+textb]
		push	edx
		push	eax
		call	xmemxfrm
		add	esp, 10h

loc_8002E42:				; CODE XREF: compare_random+115j
		mov	edx, [ebp+buf]
		mov	eax, [ebp+tlena]
		add	eax, edx
		push	[ebp+tlenb]	; lenb
		push	eax		; textb
		push	[ebp+tlena]	; lena
		push	[ebp+buf]	; texta
		call	cmp_hashes
		add	esp, 10h
		mov	[ebp+diff], eax
		lea	eax, [ebp+stackbuf]
		cmp	[ebp+buf], eax
		jz	short loc_8002E90
		sub	esp, 0Ch
		push	[ebp+buf]	; ptr
		call	free
		add	esp, 10h

loc_8002E90:				; CODE XREF: compare_random+54j
					; compare_random+1C0j
		mov	eax, [ebp+diff]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8002EA7
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8002EA7:				; CODE XREF: compare_random+1E3j
		leave
		retn
compare_random	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl compare_version(char *texta, size_t lena,	char *textb, size_t lenb)
compare_version	proc near		; CODE XREF: keycompare+243p

sv_a		= byte ptr -0Eh
sv_b		= byte ptr -0Dh
diff		= dword	ptr -0Ch
texta		= dword	ptr  8
lena		= dword	ptr  0Ch
textb		= dword	ptr  10h
lenb		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+texta]
		mov	eax, [ebp+lena]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sv_a], al
		mov	edx, [ebp+textb]
		mov	eax, [ebp+lenb]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sv_b], al
		mov	edx, [ebp+texta]
		mov	eax, [ebp+lena]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	edx, [ebp+textb]
		mov	eax, [ebp+lenb]
		add	eax, edx
		mov	byte ptr [eax],	0
		sub	esp, 8
		push	[ebp+textb]
		push	[ebp+texta]
		call	filevercmp
		add	esp, 10h
		mov	[ebp+diff], eax
		mov	edx, [ebp+texta]
		mov	eax, [ebp+lena]
		add	edx, eax
		movzx	eax, [ebp+sv_a]
		mov	[edx], al
		mov	edx, [ebp+textb]
		mov	eax, [ebp+lenb]
		add	edx, eax
		movzx	eax, [ebp+sv_b]
		mov	[edx], al
		mov	eax, [ebp+diff]
		leave
		retn
compare_version	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl keycompare(const line *a,	const line *b)
keycompare	proc near		; CODE XREF: compare+18p

b		= dword	ptr -1000h
a		= dword	ptr -0FFCh
savea		= byte ptr -0FEEh
saveb		= byte ptr -0FEDh
key		= dword	ptr -0FECh
texta		= dword	ptr -0FE8h
textb		= dword	ptr -0FE4h
lima		= dword	ptr -0FE0h
limb		= dword	ptr -0FDCh
diff		= dword	ptr -0FD8h
new_len_a	= dword	ptr -0FD4h
new_len_b	= dword	ptr -0FD0h
i		= dword	ptr -0FCCh
translate	= dword	ptr -0FC8h
ignore		= dword	ptr -0FC4h
lena		= dword	ptr -0FC0h
lenb		= dword	ptr -0FBCh
size		= dword	ptr -0FB8h
copy_a		= dword	ptr -0FB4h
copy_b		= dword	ptr -0FB0h
buf		= byte ptr -0FACh
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 1004h
		mov	eax, [ebp+arg_0]
		mov	[ebp+a], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+b], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		mov	eax, [ebp+a]
		mov	eax, [eax+8]
		mov	[ebp+texta], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+8]
		mov	[ebp+textb], eax
		mov	eax, [ebp+a]
		mov	eax, [eax+0Ch]
		mov	[ebp+lima], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+0Ch]
		mov	[ebp+limb], eax

loc_8002F84:				; CODE XREF: keycompare+A94j
					; keycompare+AC1j ...
		mov	eax, [ebp+key]
		mov	eax, [eax+14h]
		mov	[ebp+translate], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+10h]
		mov	[ebp+ignore], eax
		mov	eax, [ebp+texta]
		cmp	[ebp+lima], eax
		cmovnb	eax, [ebp+lima]
		mov	[ebp+lima], eax
		mov	eax, [ebp+textb]
		cmp	[ebp+limb], eax
		cmovnb	eax, [ebp+limb]
		mov	[ebp+limb], eax
		mov	edx, [ebp+lima]
		mov	eax, [ebp+texta]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+lena], eax
		mov	edx, [ebp+limb]
		mov	eax, [ebp+textb]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+lenb], eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		test	al, al
		jz	short loc_8003039
		push	[ebp+lenb]	; lenb
		push	[ebp+textb]	; textb
		push	[ebp+lena]	; lena
		push	[ebp+texta]	; texta
		call	compare_random
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_8003039:				; CODE XREF: keycompare+F6j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ah]
		test	al, al
		jnz	short loc_8003067
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jnz	short loc_8003067
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jz	loc_8003133

loc_8003067:				; CODE XREF: keycompare+12Fj
					; keycompare+13Dj
		mov	eax, [ebp+lima]
		movzx	eax, byte ptr [eax]
		mov	[ebp+savea], al
		mov	eax, [ebp+limb]
		movzx	eax, byte ptr [eax]
		mov	[ebp+saveb], al
		mov	eax, [ebp+limb]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+limb]
		movzx	edx, byte ptr [eax]
		mov	eax, [ebp+lima]
		mov	[eax], dl
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ah]
		test	al, al
		jz	short loc_80030C6
		sub	esp, 8
		push	[ebp+textb]	; b
		push	[ebp+texta]	; a
		call	numcompare
		add	esp, 10h
		jmp	short loc_800310A
; ---------------------------------------------------------------------------

loc_80030C6:				; CODE XREF: keycompare+195j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_80030ED
		sub	esp, 8
		push	[ebp+textb]	; sb
		push	[ebp+texta]	; sa
		call	general_numcompare
		add	esp, 10h
		jmp	short loc_800310A
; ---------------------------------------------------------------------------

loc_80030ED:				; CODE XREF: keycompare+1BCj
		sub	esp, 4
		push	[ebp+key]	; key
		push	[ebp+textb]	; b
		push	[ebp+texta]	; a
		call	human_numcompare
		add	esp, 10h

loc_800310A:				; CODE XREF: keycompare+1AEj
					; keycompare+1D5j
		mov	[ebp+diff], eax
		mov	eax, [ebp+lima]
		movzx	edx, [ebp+savea]
		mov	[eax], dl
		mov	eax, [ebp+limb]
		movzx	edx, [ebp+saveb]
		mov	[eax], dl
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_8003133:				; CODE XREF: keycompare+14Bj
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+26h]
		test	al, al
		jz	short loc_800316C
		push	[ebp+lenb]	; lenb
		push	[ebp+textb]	; textb
		push	[ebp+lena]	; lena
		push	[ebp+texta]	; texta
		call	compare_version
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_800316C:				; CODE XREF: keycompare+229j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_80031B9
		sub	esp, 8
		push	[ebp+lena]	; len
		push	[ebp+texta]	; month
		call	getmonth
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 8
		push	[ebp+lenb]	; len
		push	[ebp+textb]	; month
		call	getmonth
		add	esp, 10h
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_80031B9:				; CODE XREF: keycompare+262j
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	loc_800348F
		cmp	[ebp+ignore], 0
		jnz	short loc_80031DE
		cmp	[ebp+translate], 0
		jz	loc_8003434

loc_80031DE:				; CODE XREF: keycompare+2B9j
		mov	edx, [ebp+lena]
		mov	eax, [ebp+lenb]
		add	eax, edx
		add	eax, 2
		mov	[ebp+size], eax
		cmp	[ebp+size], 0FA0h
		ja	short loc_8003209
		lea	eax, [ebp+buf]
		jmp	short loc_800321A
; ---------------------------------------------------------------------------

loc_8003209:				; CODE XREF: keycompare+2E9j
		sub	esp, 0Ch
		push	[ebp+size]	; size_t
		call	xmalloc
		add	esp, 10h

loc_800321A:				; CODE XREF: keycompare+2F1j
		mov	[ebp+copy_a], eax
		mov	eax, [ebp+lena]
		lea	edx, [eax+1]
		mov	eax, [ebp+copy_a]
		add	eax, edx
		mov	[ebp+copy_b], eax
		mov	[ebp+i], 0
		mov	eax, [ebp+i]
		mov	[ebp+new_len_b], eax
		mov	eax, [ebp+new_len_b]
		mov	[ebp+new_len_a], eax
		jmp	loc_80033C9
; ---------------------------------------------------------------------------

loc_800325E:				; CODE XREF: keycompare+4CCj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+lena]
		jnb	loc_8003310
		mov	edx, [ebp+copy_a]
		mov	eax, [ebp+new_len_a]
		lea	ebx, [edx+eax]
		cmp	[ebp+translate], 0
		jz	short loc_80032B8
		mov	edx, [ebp+texta]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		jmp	short loc_80032C9
; ---------------------------------------------------------------------------

loc_80032B8:				; CODE XREF: keycompare+370j
		mov	edx, [ebp+texta]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]

loc_80032C9:				; CODE XREF: keycompare+3A0j
		mov	[ebx], al
		cmp	[ebp+ignore], 0
		jz	short loc_8003309
		mov	edx, [ebp+texta]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8003310

loc_8003309:				; CODE XREF: keycompare+3BCj
		add	[ebp+new_len_a], 1

loc_8003310:				; CODE XREF: keycompare+354j
					; keycompare+3F1j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+lenb]
		jnb	loc_80033C2
		mov	edx, [ebp+copy_b]
		mov	eax, [ebp+new_len_b]
		lea	ebx, [edx+eax]
		cmp	[ebp+translate], 0
		jz	short loc_800336A
		mov	edx, [ebp+textb]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		jmp	short loc_800337B
; ---------------------------------------------------------------------------

loc_800336A:				; CODE XREF: keycompare+422j
		mov	edx, [ebp+textb]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]

loc_800337B:				; CODE XREF: keycompare+452j
		mov	[ebx], al
		cmp	[ebp+ignore], 0
		jz	short loc_80033BB
		mov	edx, [ebp+textb]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_80033C2

loc_80033BB:				; CODE XREF: keycompare+46Ej
		add	[ebp+new_len_b], 1

loc_80033C2:				; CODE XREF: keycompare+406j
					; keycompare+4A3j
		add	[ebp+i], 1

loc_80033C9:				; CODE XREF: keycompare+343j
		mov	eax, [ebp+lena]
		cmp	[ebp+lenb], eax
		cmovnb	eax, [ebp+lenb]
		cmp	eax, [ebp+i]
		ja	loc_800325E
		push	[ebp+new_len_b]
		push	[ebp+copy_b]
		push	[ebp+new_len_a]
		push	[ebp+copy_a]
		call	xmemcoll
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+size], 0FA0h
		jbe	loc_80038B7
		sub	esp, 0Ch
		push	[ebp+copy_a]	; ptr
		call	free
		add	esp, 10h
		jmp	loc_80038B7
; ---------------------------------------------------------------------------

loc_8003434:				; CODE XREF: keycompare+2C2j
		cmp	[ebp+lena], 0
		jnz	short loc_8003457
		cmp	[ebp+lenb], 0
		setnz	al
		movzx	eax, al
		neg	eax
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_8003457:				; CODE XREF: keycompare+525j
		cmp	[ebp+lenb], 0
		jz	loc_8003A68
		push	[ebp+lenb]
		push	[ebp+textb]
		push	[ebp+lena]
		push	[ebp+texta]
		call	xmemcoll
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_800348F:				; CODE XREF: keycompare+2ACj
		cmp	[ebp+ignore], 0
		jz	loc_800374D
		cmp	[ebp+translate], 0
		jz	loc_8003625

loc_80034A9:				; CODE XREF: keycompare+6CEj
		jmp	short loc_80034B2
; ---------------------------------------------------------------------------

loc_80034AB:				; CODE XREF: keycompare+5D2j
		add	[ebp+texta], 1

loc_80034B2:				; CODE XREF: keycompare:loc_80034A9j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	short loc_80034F3
		mov	eax, [ebp+texta]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80034AB
		jmp	short loc_80034F3
; ---------------------------------------------------------------------------

loc_80034EC:				; CODE XREF: keycompare+613j
		add	[ebp+textb], 1

loc_80034F3:				; CODE XREF: keycompare+5A8j
					; keycompare+5D4j
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jnb	short loc_800352B
		mov	eax, [ebp+textb]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80034EC

loc_800352B:				; CODE XREF: keycompare+5E9j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	loc_80035E9
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jnb	loc_80035E9
		mov	eax, [ebp+texta]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	ebx, al
		mov	eax, [ebp+textb]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	loc_8003A78
		add	[ebp+texta], 1
		add	[ebp+textb], 1
		jmp	loc_80034A9
; ---------------------------------------------------------------------------

loc_80035E9:				; CODE XREF: keycompare+621j
					; keycompare+633j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		setb	al
		movzx	edx, al
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		setb	al
		movzx	eax, al
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_800361C:				; CODE XREF: keycompare+7FFj
		jmp	short loc_8003625
; ---------------------------------------------------------------------------

loc_800361E:				; CODE XREF: keycompare+745j
		add	[ebp+texta], 1

loc_8003625:				; CODE XREF: keycompare+58Dj
					; keycompare:loc_800361Cj
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	short loc_8003666
		mov	eax, [ebp+texta]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_800361E
		jmp	short loc_8003666
; ---------------------------------------------------------------------------

loc_800365F:				; CODE XREF: keycompare+786j
		add	[ebp+textb], 1

loc_8003666:				; CODE XREF: keycompare+71Bj
					; keycompare+747j
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jnb	short loc_800369E
		mov	eax, [ebp+textb]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+ignore]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_800365F

loc_800369E:				; CODE XREF: keycompare+75Cj
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	short loc_800371A
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jnb	short loc_800371A
		mov	eax, [ebp+texta]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	ebx, al
		mov	eax, [ebp+textb]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	loc_8003A7B
		add	[ebp+texta], 1
		add	[ebp+textb], 1
		jmp	loc_800361C
; ---------------------------------------------------------------------------

loc_800371A:				; CODE XREF: keycompare+794j
					; keycompare+7A2j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		setb	al
		movzx	edx, al
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		setb	al
		movzx	eax, al
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_800374D:				; CODE XREF: keycompare+580j
		cmp	[ebp+lena], 0
		jnz	short loc_8003770
		cmp	[ebp+lenb], 0
		setnz	al
		movzx	eax, al
		neg	eax
		mov	[ebp+diff], eax
		jmp	loc_80038B8
; ---------------------------------------------------------------------------

loc_8003770:				; CODE XREF: keycompare+83Ej
		cmp	[ebp+lenb], 0
		jz	loc_8003A6B
		cmp	[ebp+translate], 0
		jz	loc_800384A
		jmp	loc_8003828
; ---------------------------------------------------------------------------

loc_800378F:				; CODE XREF: keycompare+92Cj
		mov	eax, [ebp+texta]
		lea	edx, [eax+1]
		mov	[ebp+texta], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	ebx, al
		mov	eax, [ebp+textb]
		lea	edx, [eax+1]
		mov	[ebp+textb], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	edx, al
		mov	eax, [ebp+translate]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		sub	ebx, eax
		mov	eax, ebx
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	loc_8003A7E

loc_8003828:				; CODE XREF: keycompare+874j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	short loc_8003888
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jb	loc_800378F
		jmp	short loc_8003888
; ---------------------------------------------------------------------------

loc_800384A:				; CODE XREF: keycompare+86Ej
		mov	eax, [ebp+lena]
		cmp	[ebp+lenb], eax
		cmovbe	eax, [ebp+lenb]
		sub	esp, 4
		push	eax		; n
		push	[ebp+textb]	; s2
		push	[ebp+texta]	; s1
		call	memcmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	loc_8003A81

loc_8003888:				; CODE XREF: keycompare+91Ej
					; keycompare+932j
		mov	eax, [ebp+lena]
		cmp	eax, [ebp+lenb]
		jb	short loc_80038AA
		mov	eax, [ebp+lena]
		cmp	eax, [ebp+lenb]
		setnz	al
		movzx	eax, al
		jmp	short loc_80038AF
; ---------------------------------------------------------------------------

loc_80038AA:				; CODE XREF: keycompare+97Ej
		mov	eax, 0FFFFFFFFh

loc_80038AF:				; CODE XREF: keycompare+992j
		mov	[ebp+diff], eax
		jmp	short loc_80038B8
; ---------------------------------------------------------------------------

loc_80038B7:				; CODE XREF: keycompare+502j
					; keycompare+519j
		nop

loc_80038B8:				; CODE XREF: keycompare+11Ej
					; keycompare+218j ...
		cmp	[ebp+diff], 0
		jnz	loc_8003A84
		mov	eax, [ebp+key]
		mov	eax, [eax+28h]
		mov	[ebp+key], eax
		cmp	[ebp+key], 0
		jz	loc_8003A60
		mov	eax, [ebp+key]
		mov	eax, [eax+8]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_800392B
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+a]		; line
		call	limfield
		add	esp, 10h
		mov	[ebp+lima], eax
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+b]		; line
		call	limfield
		add	esp, 10h
		mov	[ebp+limb], eax
		jmp	short loc_8003963
; ---------------------------------------------------------------------------

loc_800392B:				; CODE XREF: keycompare+9D7j
		mov	eax, [ebp+a]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax+4]
		sub	eax, 1
		add	eax, edx
		mov	[ebp+lima], eax
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+b]
		mov	eax, [eax+4]
		sub	eax, 1
		add	eax, edx
		mov	[ebp+limb], eax

loc_8003963:				; CODE XREF: keycompare+A13j
		mov	eax, [ebp+key]
		mov	eax, [eax]
		cmp	eax, 0FFFFFFFFh
		jz	short loc_80039AF
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+a]		; line
		call	begfield
		add	esp, 10h
		mov	[ebp+texta], eax
		sub	esp, 8
		push	[ebp+key]	; key
		push	[ebp+b]		; line
		call	begfield
		add	esp, 10h
		mov	[ebp+textb], eax
		jmp	loc_8002F84
; ---------------------------------------------------------------------------

loc_80039AF:				; CODE XREF: keycompare+A58j
		mov	eax, [ebp+a]
		mov	eax, [eax]
		mov	[ebp+texta], eax
		mov	eax, [ebp+b]
		mov	eax, [eax]
		mov	[ebp+textb], eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+18h]
		test	al, al
		jz	loc_8002F84
		jmp	short loc_80039E6
; ---------------------------------------------------------------------------

loc_80039DF:				; CODE XREF: keycompare+B02j
		add	[ebp+texta], 1

loc_80039E6:				; CODE XREF: keycompare+AC7j
		mov	eax, [ebp+texta]
		cmp	eax, [ebp+lima]
		jnb	short loc_8003A23
		mov	eax, [ebp+texta]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_80039DF
		jmp	short loc_8003A23
; ---------------------------------------------------------------------------

loc_8003A1C:				; CODE XREF: keycompare+B43j
		add	[ebp+textb], 1

loc_8003A23:				; CODE XREF: keycompare+ADCj
					; keycompare+B04j
		mov	eax, [ebp+textb]
		cmp	eax, [ebp+limb]
		jnb	loc_8002F84
		mov	eax, [ebp+textb]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:blanks[eax]
		test	al, al
		jnz	short loc_8003A1C
		jmp	loc_8002F84
; ---------------------------------------------------------------------------

loc_8003A60:				; CODE XREF: keycompare+9C5j
		nop
		mov	eax, 0
		jmp	short loc_8003AA4
; ---------------------------------------------------------------------------

loc_8003A68:				; CODE XREF: keycompare+548j
		nop
		jmp	short greater
; ---------------------------------------------------------------------------

loc_8003A6B:				; CODE XREF: keycompare+861j
		nop

greater:				; CODE XREF: keycompare+B53j
		mov	[ebp+diff], 1
		jmp	short not_equal
; ---------------------------------------------------------------------------

loc_8003A78:				; CODE XREF: keycompare+6BAj
		nop
		jmp	short not_equal
; ---------------------------------------------------------------------------

loc_8003A7B:				; CODE XREF: keycompare+7EBj
		nop
		jmp	short not_equal
; ---------------------------------------------------------------------------

loc_8003A7E:				; CODE XREF: keycompare+90Cj
		nop
		jmp	short not_equal
; ---------------------------------------------------------------------------

loc_8003A81:				; CODE XREF: keycompare+96Cj
		nop
		jmp	short not_equal
; ---------------------------------------------------------------------------

loc_8003A84:				; CODE XREF: keycompare+9A9j
		nop

not_equal:				; CODE XREF: keycompare+B60j
					; keycompare+B63j ...
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+25h]
		test	al, al
		jz	short loc_8003A9D
		mov	eax, [ebp+diff]
		neg	eax
		jmp	short loc_8003AA3
; ---------------------------------------------------------------------------

loc_8003A9D:				; CODE XREF: keycompare+B7Bj
		mov	eax, [ebp+diff]

loc_8003AA3:				; CODE XREF: keycompare+B85j
		nop

loc_8003AA4:				; CODE XREF: keycompare+B50j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8003AB5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003AB5:				; CODE XREF: keycompare+B98j
		mov	ebx, [ebp+var_4]
		leave
		retn
keycompare	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl compare(const line *a, const line	*b)
compare		proc near		; CODE XREF: check+ECp	check+1D9p ...

diff		= dword	ptr -14h
alen		= dword	ptr -10h
blen		= dword	ptr -0Ch
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:keylist
		test	eax, eax
		jz	short loc_8003B01
		sub	esp, 8
		push	[ebp+b]		; b
		push	[ebp+a]		; a
		call	keycompare
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8003AF9
		movzx	eax, ds:unique
		test	al, al
		jnz	short loc_8003AF9
		movzx	eax, ds:stable
		test	al, al
		jz	short loc_8003B01

loc_8003AF9:				; CODE XREF: compare+27j compare+32j
		mov	eax, [ebp+diff]
		jmp	locret_8003BCD
; ---------------------------------------------------------------------------

loc_8003B01:				; CODE XREF: compare+Dj compare+3Dj
		mov	eax, [ebp+a]
		mov	eax, [eax+4]
		sub	eax, 1
		mov	[ebp+alen], eax
		mov	eax, [ebp+b]
		mov	eax, [eax+4]
		sub	eax, 1
		mov	[ebp+blen], eax
		cmp	[ebp+alen], 0
		jnz	short loc_8003B33
		cmp	[ebp+blen], 0
		setnz	al
		movzx	eax, al
		neg	eax
		mov	[ebp+diff], eax
		jmp	loc_8003BB7
; ---------------------------------------------------------------------------

loc_8003B33:				; CODE XREF: compare+63j
		cmp	[ebp+blen], 0
		jnz	short loc_8003B42
		mov	[ebp+diff], 1
		jmp	short loc_8003BB7
; ---------------------------------------------------------------------------

loc_8003B42:				; CODE XREF: compare+7Dj
		movzx	eax, ds:hard_LC_COLLATE
		test	al, al
		jz	short loc_8003B6C
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		push	[ebp+blen]
		push	edx
		push	[ebp+alen]
		push	eax
		call	xmemcoll
		add	esp, 10h
		mov	[ebp+diff], eax
		jmp	short loc_8003BB7
; ---------------------------------------------------------------------------

loc_8003B6C:				; CODE XREF: compare+91j
		mov	eax, [ebp+alen]
		cmp	[ebp+blen], eax
		cmovbe	eax, [ebp+blen]
		mov	ecx, eax
		mov	eax, [ebp+b]
		mov	edx, [eax]
		mov	eax, [ebp+a]
		mov	eax, [eax]
		sub	esp, 4
		push	ecx		; n
		push	edx		; s2
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		mov	[ebp+diff], eax
		cmp	[ebp+diff], 0
		jnz	short loc_8003BB7
		mov	eax, [ebp+alen]
		cmp	eax, [ebp+blen]
		jb	short loc_8003BAF
		mov	eax, [ebp+alen]
		cmp	eax, [ebp+blen]
		setnz	al
		movzx	eax, al
		jmp	short loc_8003BB4
; ---------------------------------------------------------------------------

loc_8003BAF:				; CODE XREF: compare+E5j
		mov	eax, 0FFFFFFFFh

loc_8003BB4:				; CODE XREF: compare+F3j
		mov	[ebp+diff], eax

loc_8003BB7:				; CODE XREF: compare+74j compare+86j ...
		movzx	eax, ds:reverse
		test	al, al
		jz	short loc_8003BC9
		mov	eax, [ebp+diff]
		neg	eax
		jmp	short loc_8003BCC
; ---------------------------------------------------------------------------

loc_8003BC9:				; CODE XREF: compare+106j
		mov	eax, [ebp+diff]

loc_8003BCC:				; CODE XREF: compare+10Dj
		nop

locret_8003BCD:				; CODE XREF: compare+42j
		leave
		retn
compare		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	check(const char *file_name, char checkonly)
check		proc near		; CODE XREF: main+14C8p

checkonly	= byte ptr -90h
file_name	= dword	ptr -8Ch
ordered		= byte ptr -7Ah
nonunique	= byte ptr -79h
alloc		= dword	ptr -78h
line		= dword	ptr -74h
fp		= dword	ptr -70h
key		= dword	ptr -6Ch
linebase	= dword	ptr -68h
disorder_line	= dword	ptr -64h
line_number	= qword	ptr -60h
disorder_line_number= qword ptr	-58h
temp		= line ptr -50h
buf		= buffer ptr -40h
hr_buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, [ebp+arg_4]
		mov	edx, [ebp+arg_0]
		mov	[ebp+file_name], edx
		mov	[ebp+checkonly], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		push	offset how	; "r"
		push	[ebp+file_name]	; file
		call	xfopen
		add	esp, 10h
		mov	[ebp+fp], eax
		mov	[ebp+alloc], 0
		mov	dword ptr [ebp+line_number], 0
		mov	dword ptr [ebp+line_number+4], 0
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		movzx	eax, ds:unique
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+nonunique], al
		and	[ebp+nonunique], 1
		mov	[ebp+ordered], 1
		mov	edx, ds:sort_size
		mov	eax, merge_buffer_size
		cmp	edx, eax
		cmovnb	eax, edx
		sub	esp, 4
		push	eax		; alloc
		push	10h		; line_bytes
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	initbuf
		add	esp, 10h
		mov	[ebp+temp.text], 0
		jmp	loc_8003E6E
; ---------------------------------------------------------------------------

loc_8003C7B:				; CODE XREF: check+2B9j
		sub	esp, 0Ch
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	buffer_linelim
		add	esp, 10h
		mov	[ebp+line], eax
		mov	eax, [ebp+buf.nlines]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+line]
		add	eax, edx
		mov	[ebp+linebase],	eax
		cmp	[ebp+alloc], 0
		jz	loc_8003DB8
		movzx	ebx, [ebp+nonunique]
		mov	eax, [ebp+line]
		sub	eax, 10h
		sub	esp, 8
		push	eax		; b
		lea	eax, [ebp+temp]
		push	eax		; a
		call	compare
		add	esp, 10h
		cmp	ebx, eax
		jg	loc_8003DB8
		jmp	short found_disorder
; ---------------------------------------------------------------------------

loc_8003CCD:				; CODE XREF: check+1E3j
		nop

found_disorder:				; CODE XREF: check+FCj
		cmp	[ebp+checkonly], 63h
		jnz	loc_8003D8E
		mov	eax, [ebp+line]
		sub	eax, 10h
		mov	[ebp+disorder_line], eax
		sub	esp, 0Ch
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	buffer_linelim
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+disorder_line]
		sub	edx, eax
		mov	eax, edx
		sar	eax, 4
		mov	ecx, eax
		mov	ebx, eax
		sar	ebx, 1Fh
		mov	eax, dword ptr [ebp+line_number]
		mov	edx, dword ptr [ebp+line_number+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+disorder_line_number], eax
		mov	dword ptr [ebp+disorder_line_number+4],	edx
		sub	esp, 4
		lea	eax, [ebp+hr_buf]
		push	eax
		push	dword ptr [ebp+disorder_line_number+4]
		push	dword ptr [ebp+disorder_line_number]
		call	umaxtostr
		add	esp, 10h
		mov	esi, eax
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSSSDisorder ; "%s: %s:%s: disorder: "
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	esi
		push	[ebp+file_name]
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 20h
		sub	esp, 0Ch
		push	offset aStandardError ;	"standard error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		mov	ecx, ds:stderr
		mov	eax, [ebp+disorder_line]
		mov	edx, [eax+4]
		mov	eax, [ebp+disorder_line]
		mov	eax, [eax]
		push	ebx		; output_file
		push	ecx		; fp
		push	edx		; n_bytes
		push	eax		; buf
		call	write_bytes
		add	esp, 10h

loc_8003D8E:				; CODE XREF: check+106j
		mov	[ebp+ordered], 0
		jmp	loc_8003E8E
; ---------------------------------------------------------------------------

loc_8003D97:				; CODE XREF: check+1F3j
		movzx	ebx, [ebp+nonunique]
		mov	eax, [ebp+line]
		sub	eax, 10h
		sub	esp, 8
		push	eax		; b
		push	[ebp+line]	; a
		call	compare
		add	esp, 10h
		cmp	ebx, eax
		jle	loc_8003CCD

loc_8003DB8:				; CODE XREF: check+D4j	check+F6j
		sub	[ebp+line], 10h
		mov	eax, [ebp+line]
		cmp	eax, [ebp+linebase]
		ja	short loc_8003D97
		mov	eax, [ebp+buf.nlines]
		mov	edx, 0
		add	dword ptr [ebp+line_number], eax
		adc	dword ptr [ebp+line_number+4], edx
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		cmp	eax, [ebp+alloc]
		jbe	short loc_8003E11

loc_8003DDD:				; CODE XREF: check+22Bj
		shl	[ebp+alloc], 1
		cmp	[ebp+alloc], 0
		jnz	short loc_8003DF1
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	[ebp+alloc], eax
		jmp	short loc_8003DFC
; ---------------------------------------------------------------------------

loc_8003DF1:				; CODE XREF: check+215j
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		cmp	eax, [ebp+alloc]
		ja	short loc_8003DDD

loc_8003DFC:				; CODE XREF: check+220j
		mov	eax, [ebp+temp.text]
		sub	esp, 8
		push	[ebp+alloc]	; size_t
		push	eax		; void *
		call	xrealloc
		add	esp, 10h
		mov	[ebp+temp.text], eax

loc_8003E11:				; CODE XREF: check+20Cj
		mov	eax, [ebp+line]
		mov	ecx, [eax+4]
		mov	eax, [ebp+line]
		mov	edx, [eax]
		mov	eax, [ebp+temp.text]
		sub	esp, 4
		push	ecx		; n
		push	edx		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+line]
		mov	eax, [eax+4]
		mov	[ebp+temp.length], eax
		cmp	[ebp+key], 0
		jz	short loc_8003E6E
		mov	edx, [ebp+temp.text]
		mov	eax, [ebp+line]
		mov	eax, [eax+8]
		mov	ecx, eax
		mov	eax, [ebp+line]
		mov	eax, [eax]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		mov	[ebp+temp.keybeg], eax
		mov	edx, [ebp+temp.text]
		mov	eax, [ebp+line]
		mov	eax, [eax+0Ch]
		mov	ecx, eax
		mov	eax, [ebp+line]
		mov	eax, [eax]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		mov	[ebp+temp.keylim], eax

loc_8003E6E:				; CODE XREF: check+A7j	check+26Bj
		sub	esp, 4
		push	[ebp+file_name]	; file
		push	[ebp+fp]	; fp
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	fillbuf
		add	esp, 10h
		test	al, al
		jnz	loc_8003C7B

loc_8003E8E:				; CODE XREF: check+1C3j
		sub	esp, 8
		push	[ebp+file_name]	; file
		push	[ebp+fp]	; fp
		call	xfclose
		add	esp, 10h
		mov	eax, [ebp+buf.buf]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+temp.text]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ordered]
		mov	esi, [ebp+var_C]
		xor	esi, large gs:14h
		jz	short loc_8003ED5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8003ED5:				; CODE XREF: check+2FFj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
check		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl open_input_files(sortfile *files, size_t nfiles, FILE ***pfps)
open_input_files proc near		; CODE XREF: mergefiles+31p merge+221p

i		= dword	ptr -10h
fps		= dword	ptr -0Ch
var_4		= dword	ptr -4
files		= dword	ptr  8
nfiles		= dword	ptr  0Ch
pfps		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 8
		push	4
		push	[ebp+nfiles]
		call	xnmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+pfps]
		mov	[eax], edx
		mov	eax, [ebp+pfps]
		mov	eax, [eax]
		mov	[ebp+fps], eax
		mov	[ebp+i], 0
		jmp	loc_8003FA3
; ---------------------------------------------------------------------------

loc_8003F0E:				; CODE XREF: open_input_files+CDj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		lea	ebx, [edx+eax]
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_8003F66
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; pid
		push	eax		; name
		call	open_temp
		add	esp, 10h
		jmp	short loc_8003F88
; ---------------------------------------------------------------------------

loc_8003F66:				; CODE XREF: open_input_files+56j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset how	; "r"
		push	eax		; file
		call	stream_open
		add	esp, 10h

loc_8003F88:				; CODE XREF: open_input_files+88j
		mov	[ebx], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8003FB1
		add	[ebp+i], 1

loc_8003FA3:				; CODE XREF: open_input_files+2Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8003F0E
		jmp	short loc_8003FB2
; ---------------------------------------------------------------------------

loc_8003FB1:				; CODE XREF: open_input_files+C1j
		nop

loc_8003FB2:				; CODE XREF: open_input_files+D3j
		mov	eax, [ebp+i]
		mov	ebx, [ebp+var_4]
		leave
		retn
open_input_files endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mergefps(sortfile *files, size_t	ntemps,	size_t nfiles, FILE *ofp, const	char *output_file, FILE	**fps)
mergefps	proc near		; CODE XREF: mergefiles+8Bp merge+266p ...

fps		= dword	ptr -78h
output_file	= dword	ptr -74h
ofp		= dword	ptr -70h
files		= dword	ptr -6Ch
savedline	= dword	ptr -68h
savealloc	= dword	ptr -64h
i		= dword	ptr -60h
j		= dword	ptr -5Ch
lo		= dword	ptr -58h
hi		= dword	ptr -54h
probe		= dword	ptr -50h
buffer		= dword	ptr -4Ch
cur		= dword	ptr -48h
base		= dword	ptr -44h
ord		= dword	ptr -40h
key		= dword	ptr -3Ch
linelim		= dword	ptr -38h
t		= dword	ptr -34h
smallest	= dword	ptr -30h
linelim_0	= dword	ptr -2Ch
ord0		= dword	ptr -28h
cmp		= dword	ptr -24h
count_of_smaller_lines=	dword ptr -20h
saved		= line ptr -1Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
ntemps		= dword	ptr  0Ch
nfiles		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 74h
		mov	eax, [ebp+arg_0]
		mov	[ebp+files], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+ofp], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+output_file], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+fps], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		push	1Ch
		push	[ebp+nfiles]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+buffer], eax
		mov	[ebp+savedline], 0
		mov	[ebp+savealloc], 0
		sub	esp, 8
		push	4
		push	[ebp+nfiles]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+cur], eax
		sub	esp, 8
		push	4
		push	[ebp+nfiles]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+base], eax
		sub	esp, 8
		push	4
		push	[ebp+nfiles]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+ord], eax
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		mov	[ebp+saved.text], 0
		mov	[ebp+i], 0
		jmp	loc_8004237
; ---------------------------------------------------------------------------

loc_8004059:				; CODE XREF: mergefps+283j
		mov	eax, ds:sort_size
		mov	edx, 0
		div	[ebp+nfiles]
		mov	edx, eax
		mov	eax, merge_buffer_size
		cmp	edx, eax
		cmovb	edx, eax
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	ecx, ds:0[eax*8]
		sub	ecx, eax
		mov	eax, [ebp+buffer]
		add	eax, ecx
		sub	esp, 4
		push	edx		; alloc
		push	10h		; line_bytes
		push	eax		; buf
		call	initbuf
		add	esp, 10h
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	ecx, [eax]
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	ebx, ds:0[eax*8]
		sub	ebx, eax
		mov	eax, [ebp+buffer]
		add	eax, ebx
		sub	esp, 4
		push	ecx		; file
		push	edx		; fp
		push	eax		; buf
		call	fillbuf
		add	esp, 10h
		test	al, al
		jz	short loc_8004154
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, [ebp+buffer]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; buf
		call	buffer_linelim
		add	esp, 10h
		mov	[ebp+linelim], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	edx, [ebp+linelim]
		sub	edx, 10h
		mov	[eax], edx
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+base]
		add	edx, eax
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	ecx, ds:0[eax*8]
		sub	ecx, eax
		mov	eax, [ebp+buffer]
		add	eax, ecx
		mov	eax, [eax+8]
		shl	eax, 4
		neg	eax
		mov	ecx, eax
		mov	eax, [ebp+linelim]
		add	eax, ecx
		mov	[edx], eax
		add	[ebp+i], 1
		jmp	loc_8004237
; ---------------------------------------------------------------------------

loc_8004154:				; CODE XREF: mergefps+121j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h
		mov	eax, [ebp+i]
		cmp	eax, [ebp+ntemps]
		jnb	short loc_80041AC
		sub	[ebp+ntemps], 1
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; name
		call	zaptemp
		add	esp, 10h

loc_80041AC:				; CODE XREF: mergefps+1CFj
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, [ebp+buffer]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		sub	[ebp+nfiles], 1
		mov	eax, [ebp+i]
		mov	[ebp+j], eax
		jmp	short loc_800422F
; ---------------------------------------------------------------------------

loc_80041DA:				; CODE XREF: mergefps+27Bj
		mov	eax, [ebp+j]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		lea	ecx, [edx+eax]
		mov	eax, [ebp+j]
		add	eax, 1
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+j]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	edx, eax
		mov	eax, [ebp+j]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+j], 1

loc_800422F:				; CODE XREF: mergefps+21Ej
		mov	eax, [ebp+j]
		cmp	eax, [ebp+nfiles]
		jb	short loc_80041DA

loc_8004237:				; CODE XREF: mergefps+9Aj
					; mergefps+195j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8004059
		mov	[ebp+i], 0
		jmp	short loc_8004264
; ---------------------------------------------------------------------------

loc_800424C:				; CODE XREF: mergefps+2B0j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+i]
		mov	[edx], eax
		add	[ebp+i], 1

loc_8004264:				; CODE XREF: mergefps+290j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	short loc_800424C
		mov	[ebp+i], 1
		jmp	loc_800432B
; ---------------------------------------------------------------------------

loc_8004278:				; CODE XREF: mergefps+377j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+i]
		add	eax, 3FFFFFFFh
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, ecx
		mov	eax, [eax]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; b
		push	eax		; a
		call	compare
		add	esp, 10h
		test	eax, eax
		jle	short loc_8004327
		mov	eax, [ebp+i]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+t], eax
		mov	eax, [ebp+i]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+t]
		mov	[edx], eax
		mov	[ebp+i], 0

loc_8004327:				; CODE XREF: mergefps+310j
		add	[ebp+i], 1

loc_800432B:				; CODE XREF: mergefps+2B9j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8004278
		jmp	loc_8004887
; ---------------------------------------------------------------------------

loc_800433C:				; CODE XREF: mergefps+8D1j
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+smallest],	eax
		movzx	eax, ds:unique
		test	al, al
		jz	loc_8004444
		cmp	[ebp+savedline], 0
		jz	short loc_8004399
		sub	esp, 8
		push	[ebp+smallest]	; b
		push	[ebp+savedline]	; a
		call	compare
		add	esp, 10h
		test	eax, eax
		jz	short loc_8004399
		mov	[ebp+savedline], 0
		mov	edx, [ebp+saved.length]
		mov	eax, [ebp+saved.text]
		push	[ebp+output_file] ; output_file
		push	[ebp+ofp]	; fp
		push	edx		; n_bytes
		push	eax		; buf
		call	write_bytes
		add	esp, 10h

loc_8004399:				; CODE XREF: mergefps+3ABj
					; mergefps+3C0j
		cmp	[ebp+savedline], 0
		jnz	loc_800445F
		lea	eax, [ebp+saved]
		mov	[ebp+savedline], eax
		mov	eax, [ebp+smallest]
		mov	eax, [eax+4]
		cmp	eax, [ebp+savealloc]
		jbe	short loc_80043E8

loc_80043B4:				; CODE XREF: mergefps+417j
		cmp	[ebp+savealloc], 0
		jnz	short loc_80043C5
		mov	eax, [ebp+smallest]
		mov	eax, [eax+4]
		mov	[ebp+savealloc], eax
		jmp	short loc_80043D3
; ---------------------------------------------------------------------------

loc_80043C5:				; CODE XREF: mergefps+3FEj
		shl	[ebp+savealloc], 1
		mov	eax, [ebp+smallest]
		mov	eax, [eax+4]
		cmp	[ebp+savealloc], eax
		jb	short loc_80043B4

loc_80043D3:				; CODE XREF: mergefps+409j
		mov	eax, [ebp+saved.text]
		sub	esp, 8
		push	[ebp+savealloc]	; size_t
		push	eax		; void *
		call	xrealloc
		add	esp, 10h
		mov	[ebp+saved.text], eax

loc_80043E8:				; CODE XREF: mergefps+3F8j
		mov	eax, [ebp+smallest]
		mov	eax, [eax+4]
		mov	[ebp+saved.length], eax
		mov	ecx, [ebp+saved.length]
		mov	eax, [ebp+smallest]
		mov	edx, [eax]
		mov	eax, [ebp+saved.text]
		sub	esp, 4
		push	ecx		; n
		push	edx		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		cmp	[ebp+key], 0
		jz	short loc_800445F
		mov	edx, [ebp+saved.text]
		mov	eax, [ebp+smallest]
		mov	eax, [eax+8]
		mov	ecx, eax
		mov	eax, [ebp+smallest]
		mov	eax, [eax]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		mov	[ebp+saved.keybeg], eax
		mov	edx, [ebp+saved.text]
		mov	eax, [ebp+smallest]
		mov	eax, [eax+0Ch]
		mov	ecx, eax
		mov	eax, [ebp+smallest]
		mov	eax, [eax]
		sub	ecx, eax
		mov	eax, ecx
		add	eax, edx
		mov	[ebp+saved.keylim], eax
		jmp	short loc_800445F
; ---------------------------------------------------------------------------

loc_8004444:				; CODE XREF: mergefps+3A1j
		mov	eax, [ebp+smallest]
		mov	edx, [eax+4]
		mov	eax, [ebp+smallest]
		mov	eax, [eax]
		push	[ebp+output_file] ; output_file
		push	[ebp+ofp]	; fp
		push	edx		; n_bytes
		push	eax		; buf
		call	write_bytes
		add	esp, 10h

loc_800445F:				; CODE XREF: mergefps+3E3j
					; mergefps+454j ...
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+base]
		add	eax, edx
		mov	eax, [eax]
		cmp	eax, [ebp+smallest]
		jnb	short loc_8004495
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	edx, [ebp+smallest]
		sub	edx, 10h
		mov	[eax], edx
		jmp	loc_8004775
; ---------------------------------------------------------------------------

loc_8004495:				; CODE XREF: mergefps+4BBj
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	ecx, [eax]
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		shl	eax, 2
		lea	ebx, ds:0[eax*8]
		sub	ebx, eax
		mov	eax, [ebp+buffer]
		add	eax, ebx
		sub	esp, 4
		push	ecx		; file
		push	edx		; fp
		push	eax		; buf
		call	fillbuf
		add	esp, 10h
		test	al, al
		jz	short loc_800455E
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, [ebp+buffer]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; buf
		call	buffer_linelim
		add	esp, 10h
		mov	[ebp+linelim_0], eax
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	edx, [ebp+linelim_0]
		sub	edx, 10h
		mov	[eax], edx
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+base]
		add	edx, eax
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		shl	eax, 2
		lea	ecx, ds:0[eax*8]
		sub	ecx, eax
		mov	eax, [ebp+buffer]
		add	eax, ecx
		mov	eax, [eax+8]
		shl	eax, 4
		neg	eax
		mov	ecx, eax
		mov	eax, [ebp+linelim_0]
		add	eax, ecx
		mov	[edx], eax
		jmp	loc_8004775
; ---------------------------------------------------------------------------

loc_800455E:				; CODE XREF: mergefps+527j
		mov	[ebp+i], 1
		jmp	short loc_800459B
; ---------------------------------------------------------------------------

loc_8004567:				; CODE XREF: mergefps+5E7j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		cmp	edx, eax
		jbe	short loc_8004597
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	edx, [eax]
		sub	edx, 1
		mov	[eax], edx

loc_8004597:				; CODE XREF: mergefps+5C5j
		add	[ebp+i], 1

loc_800459B:				; CODE XREF: mergefps+5ABj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	short loc_8004567
		sub	[ebp+nfiles], 1
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		cmp	eax, [ebp+ntemps]
		jnb	short loc_8004607
		sub	[ebp+ntemps], 1
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; name
		call	zaptemp
		add	esp, 10h

loc_8004607:				; CODE XREF: mergefps+628j
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, [ebp+buffer]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		mov	[ebp+i], eax
		jmp	loc_800472A
; ---------------------------------------------------------------------------

loc_8004638:				; CODE XREF: mergefps+776j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	edx, eax
		mov	eax, [ebp+i]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+fps]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		lea	ecx, [edx+eax]
		mov	eax, [ebp+i]
		add	eax, 1
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+i]
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, [ebp+buffer]
		add	eax, edx
		mov	edx, [ebp+i]
		add	edx, 1
		shl	edx, 2
		lea	ecx, ds:0[edx*8]
		sub	ecx, edx
		mov	edx, [ebp+buffer]
		add	edx, ecx
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	ecx, [edx+0Ch]
		mov	[eax+0Ch], ecx
		mov	ecx, [edx+10h]
		mov	[eax+10h], ecx
		mov	ecx, [edx+14h]
		mov	[eax+14h], ecx
		mov	edx, [edx+18h]
		mov	[eax+18h], edx
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	edx, eax
		mov	eax, [ebp+i]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+base]
		add	edx, eax
		mov	eax, [ebp+i]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+base]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+i], 1

loc_800472A:				; CODE XREF: mergefps+679j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8004638
		mov	[ebp+i], 0
		jmp	short loc_8004768
; ---------------------------------------------------------------------------

loc_800473F:				; CODE XREF: mergefps+7B4j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+i]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+i], 1

loc_8004768:				; CODE XREF: mergefps+783j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	short loc_800473F
		jmp	loc_8004887
; ---------------------------------------------------------------------------

loc_8004775:				; CODE XREF: mergefps+4D6j
					; mergefps+59Fj
		mov	[ebp+lo], 1
		mov	eax, [ebp+nfiles]
		mov	[ebp+hi], eax
		mov	eax, [ebp+lo]
		mov	[ebp+probe], eax
		mov	eax, [ebp+ord]
		mov	eax, [eax]
		mov	[ebp+ord0], eax
		jmp	loc_8004815
; ---------------------------------------------------------------------------

loc_8004795:				; CODE XREF: mergefps+861j
		mov	eax, [ebp+probe]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	eax, [eax]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+ord0]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+cur]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; b
		push	eax		; a
		call	compare
		add	esp, 10h
		mov	[ebp+cmp], eax
		cmp	[ebp+cmp], 0
		js	short loc_80047F7
		cmp	[ebp+cmp], 0
		jnz	short loc_80047FF
		mov	eax, [ebp+probe]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, edx
		mov	eax, [eax]
		cmp	eax, [ebp+ord0]
		jbe	short loc_80047FF

loc_80047F7:				; CODE XREF: mergefps+81Fj
		mov	eax, [ebp+probe]
		mov	[ebp+hi], eax
		jmp	short loc_8004808
; ---------------------------------------------------------------------------

loc_80047FF:				; CODE XREF: mergefps+825j
					; mergefps+83Bj
		mov	eax, [ebp+probe]
		add	eax, 1
		mov	[ebp+lo], eax

loc_8004808:				; CODE XREF: mergefps+843j
		mov	edx, [ebp+lo]
		mov	eax, [ebp+hi]
		add	eax, edx
		shr	eax, 1
		mov	[ebp+probe], eax

loc_8004815:				; CODE XREF: mergefps+7D6j
		mov	eax, [ebp+lo]
		cmp	eax, [ebp+hi]
		jb	loc_8004795
		mov	eax, [ebp+lo]
		sub	eax, 1
		mov	[ebp+count_of_smaller_lines], eax
		mov	[ebp+j], 0
		jmp	short loc_800485C
; ---------------------------------------------------------------------------

loc_8004833:				; CODE XREF: mergefps+8A8j
		mov	eax, [ebp+j]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+j]
		add	eax, 1
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+j], 1

loc_800485C:				; CODE XREF: mergefps+877j
		mov	eax, [ebp+j]
		cmp	eax, [ebp+count_of_smaller_lines]
		jb	short loc_8004833
		mov	eax, [ebp+count_of_smaller_lines]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+ord]
		add	edx, eax
		mov	eax, [ebp+ord0]
		mov	[edx], eax
		mov	eax, ds:nprocs
		cmp	eax, 2
		jbe	short loc_8004887
		call	reap_some

loc_8004887:				; CODE XREF: mergefps+37Dj
					; mergefps+7B6j ...
		cmp	[ebp+nfiles], 0
		jnz	loc_800433C
		movzx	eax, ds:unique
		test	al, al
		jz	short loc_80048C7
		cmp	[ebp+savedline], 0
		jz	short loc_80048C7
		mov	edx, [ebp+saved.length]
		mov	eax, [ebp+saved.text]
		push	[ebp+output_file] ; output_file
		push	[ebp+ofp]	; fp
		push	edx		; n_bytes
		push	eax		; buf
		call	write_bytes
		add	esp, 10h
		mov	eax, [ebp+saved.text]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h

loc_80048C7:				; CODE XREF: mergefps+8E0j
					; mergefps+8E6j
		sub	esp, 8
		push	[ebp+output_file] ; file
		push	[ebp+ofp]	; fp
		call	xfclose
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+fps]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+buffer]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+ord]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+base]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+cur]	; ptr
		call	free
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8004930
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8004930:				; CODE XREF: mergefps+96Fj
		mov	ebx, [ebp+var_4]
		leave
		retn
mergefps	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl mergefiles(sortfile *files, size_t ntemps, size_t nfiles, FILE	*ofp, const char *output_file)
mergefiles	proc near		; CODE XREF: avoid_trashing_input+220p
					; merge+7Cp ...

output_file	= dword	ptr -24h
ofp		= dword	ptr -20h
files		= dword	ptr -1Ch
fps		= dword	ptr -14h
nopened		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
ntemps		= dword	ptr  0Ch
nfiles		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+files], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+ofp], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+output_file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 4
		lea	eax, [ebp+fps]
		push	eax		; pfps
		push	[ebp+nfiles]	; nfiles
		push	[ebp+files]	; files
		call	open_input_files
		add	esp, 10h
		mov	[ebp+nopened], eax
		mov	eax, [ebp+nopened]
		cmp	eax, [ebp+nfiles]
		jnb	short loc_80049AA
		cmp	[ebp+nopened], 1
		ja	short loc_80049AA
		mov	eax, [ebp+nopened]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aOpenFailed ; "open failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_80049AA:				; CODE XREF: mergefiles+42j
					; mergefiles+48j
		mov	eax, [ebp+fps]
		sub	esp, 8
		push	eax		; fps
		push	[ebp+output_file] ; output_file
		push	[ebp+ofp]	; ofp
		push	[ebp+nopened]	; nfiles
		push	[ebp+ntemps]	; ntemps
		push	[ebp+files]	; files
		call	mergefps
		add	esp, 20h
		mov	eax, [ebp+nopened]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80049DC
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80049DC:				; CODE XREF: mergefiles+A0j
		mov	ebx, [ebp+var_4]
		leave
		retn
mergefiles	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mergelines(line *t, const line *lo, size_t nlo, const line *hi, size_t nhi)
mergelines	proc near		; CODE XREF: sortlines+11Bp
					; sortlines_temp+10Bp

t		= dword	ptr  8
lo		= dword	ptr  0Ch
nlo		= dword	ptr  10h
hi		= dword	ptr  14h
nhi		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 8

loc_80049E7:				; CODE XREF: mergelines+4Fj
					; mergelines+7Fj
		mov	eax, [ebp+hi]
		lea	edx, [eax-10h]
		mov	eax, [ebp+lo]
		sub	eax, 10h
		sub	esp, 8
		push	edx		; b
		push	eax		; a
		call	compare
		add	esp, 10h
		test	eax, eax
		jg	short loc_8004A34
		sub	[ebp+t], 10h
		sub	[ebp+lo], 10h
		mov	eax, [ebp+t]
		mov	edx, [ebp+lo]
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		sub	[ebp+nlo], 1
		cmp	[ebp+nlo], 0
		jnz	short loc_80049E7
		jmp	short locret_8004A90
; ---------------------------------------------------------------------------

loc_8004A34:				; CODE XREF: mergelines+21j
		sub	[ebp+t], 10h
		sub	[ebp+hi], 10h
		mov	eax, [ebp+t]
		mov	edx, [ebp+hi]
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		sub	[ebp+nhi], 1
		cmp	[ebp+nhi], 0
		jnz	short loc_80049E7

loc_8004A62:				; CODE XREF: mergelines+ADj
		sub	[ebp+t], 10h
		sub	[ebp+lo], 10h
		mov	eax, [ebp+t]
		mov	edx, [ebp+lo]
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		sub	[ebp+nlo], 1
		cmp	[ebp+nlo], 0
		jnz	short loc_8004A62

locret_8004A90:				; CODE XREF: mergelines+51j
		leave
		retn
mergelines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sortlines(line *lines, size_t nlines, line *temp)
sortlines	proc near		; CODE XREF: sortlines+C5p
					; sortlines_temp+F1p ...

nlo		= dword	ptr -2Ch
nhi		= dword	ptr -28h
lo		= dword	ptr -24h
hi		= dword	ptr -20h
sorted_lo	= dword	ptr -1Ch
tmp		= line ptr -18h
lines		= dword	ptr  8
nlines		= dword	ptr  0Ch
temp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		cmp	[ebp+nlines], 2
		jnz	short loc_8004B1C
		mov	eax, [ebp+lines]
		lea	edx, [eax-20h]
		mov	eax, [ebp+lines]
		sub	eax, 10h
		sub	esp, 8
		push	edx		; b
		push	eax		; a
		call	compare
		add	esp, 10h
		test	eax, eax
		jle	loc_8004BB5
		mov	eax, [ebp+lines]
		mov	edx, [eax-10h]
		mov	[ebp+tmp.text],	edx
		mov	edx, [eax-0Ch]
		mov	[ebp+tmp.length], edx
		mov	edx, [eax-8]
		mov	[ebp+tmp.keybeg], edx
		mov	eax, [eax-4]
		mov	[ebp+tmp.keylim], eax
		mov	eax, [ebp+lines]
		lea	edx, [eax-10h]
		mov	eax, [ebp+lines]
		mov	ecx, [eax-20h]
		mov	[edx], ecx
		mov	ecx, [eax-1Ch]
		mov	[edx+4], ecx
		mov	ecx, [eax-18h]
		mov	[edx+8], ecx
		mov	eax, [eax-14h]
		mov	[edx+0Ch], eax
		mov	eax, [ebp+lines]
		sub	eax, 20h
		mov	edx, [ebp+tmp.text]
		mov	[eax], edx
		mov	edx, [ebp+tmp.length]
		mov	[eax+4], edx
		mov	edx, [ebp+tmp.keybeg]
		mov	[eax+8], edx
		mov	edx, [ebp+tmp.keylim]
		mov	[eax+0Ch], edx
		jmp	loc_8004BB5
; ---------------------------------------------------------------------------

loc_8004B1C:				; CODE XREF: sortlines+Aj
		mov	eax, [ebp+nlines]
		shr	eax, 1
		mov	[ebp+nlo], eax
		mov	eax, [ebp+nlines]
		sub	eax, [ebp+nlo]
		mov	[ebp+nhi], eax
		mov	eax, [ebp+lines]
		mov	[ebp+lo], eax
		mov	eax, [ebp+nlo]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+lines]
		add	eax, edx
		mov	[ebp+hi], eax
		mov	eax, [ebp+temp]
		mov	[ebp+sorted_lo], eax
		sub	esp, 4
		push	[ebp+temp]	; temp
		push	[ebp+nhi]	; nlines
		push	[ebp+hi]	; lines
		call	sortlines
		add	esp, 10h
		cmp	[ebp+nlo], 1
		jbe	short loc_8004B7B
		sub	esp, 4
		push	[ebp+sorted_lo]	; temp
		push	[ebp+nlo]	; nlines
		push	[ebp+lo]	; lines
		call	sortlines_temp
		add	esp, 10h
		jmp	short loc_8004B9B
; ---------------------------------------------------------------------------

loc_8004B7B:				; CODE XREF: sortlines+D1j
		mov	eax, [ebp+sorted_lo]
		lea	edx, [eax-10h]
		mov	eax, [ebp+lo]
		mov	ecx, [eax-10h]
		mov	[edx], ecx
		mov	ecx, [eax-0Ch]
		mov	[edx+4], ecx
		mov	ecx, [eax-8]
		mov	[edx+8], ecx
		mov	eax, [eax-4]
		mov	[edx+0Ch], eax

loc_8004B9B:				; CODE XREF: sortlines+E7j
		sub	esp, 0Ch
		push	[ebp+nhi]	; nhi
		push	[ebp+hi]	; hi
		push	[ebp+nlo]	; nlo
		push	[ebp+sorted_lo]	; lo
		push	[ebp+lines]	; t
		call	mergelines
		add	esp, 20h

loc_8004BB5:				; CODE XREF: sortlines+27j
					; sortlines+85j
		nop
		leave
		retn
sortlines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sortlines_temp(line *lines, size_t nlines, line *temp)
sortlines_temp	proc near		; CODE XREF: sortlines+DFp
					; sortlines_temp+D7p

swap		= dword	ptr -20h
nlo		= dword	ptr -1Ch
nhi		= dword	ptr -18h
lo		= dword	ptr -14h
hi		= dword	ptr -10h
sorted_hi	= dword	ptr -0Ch
lines		= dword	ptr  8
nlines		= dword	ptr  0Ch
temp		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		cmp	[ebp+nlines], 2
		jnz	loc_8004C48
		mov	eax, [ebp+lines]
		lea	edx, [eax-20h]
		mov	eax, [ebp+lines]
		sub	eax, 10h
		sub	esp, 8
		push	edx		; b
		push	eax		; a
		call	compare
		add	esp, 10h
		test	eax, eax
		setnle	al
		movzx	eax, al
		mov	[ebp+swap], eax
		mov	eax, [ebp+temp]
		sub	eax, 10h
		mov	edx, [ebp+swap]
		not	edx
		mov	ecx, edx
		shl	ecx, 4
		mov	edx, [ebp+lines]
		add	edx, ecx
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+temp]
		sub	eax, 20h
		mov	edx, [ebp+swap]
		sub	edx, 2
		mov	ecx, edx
		shl	ecx, 4
		mov	edx, [ebp+lines]
		add	edx, ecx
		mov	ecx, [edx]
		mov	[eax], ecx
		mov	ecx, [edx+4]
		mov	[eax+4], ecx
		mov	ecx, [edx+8]
		mov	[eax+8], ecx
		mov	edx, [edx+0Ch]
		mov	[eax+0Ch], edx
		jmp	loc_8004CCB
; ---------------------------------------------------------------------------

loc_8004C48:				; CODE XREF: sortlines_temp+Aj
		mov	eax, [ebp+nlines]
		shr	eax, 1
		mov	[ebp+nlo], eax
		mov	eax, [ebp+nlines]
		sub	eax, [ebp+nlo]
		mov	[ebp+nhi], eax
		mov	eax, [ebp+lines]
		mov	[ebp+lo], eax
		mov	eax, [ebp+nlo]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+lines]
		add	eax, edx
		mov	[ebp+hi], eax
		mov	eax, [ebp+nlo]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+temp]
		add	eax, edx
		mov	[ebp+sorted_hi], eax
		sub	esp, 4
		push	[ebp+sorted_hi]	; temp
		push	[ebp+nhi]	; nlines
		push	[ebp+hi]	; lines
		call	sortlines_temp
		add	esp, 10h
		cmp	[ebp+nlo], 1
		jbe	short loc_8004CB1
		sub	esp, 4
		push	[ebp+temp]	; temp
		push	[ebp+nlo]	; nlines
		push	[ebp+lo]	; lines
		call	sortlines
		add	esp, 10h

loc_8004CB1:				; CODE XREF: sortlines_temp+E3j
		sub	esp, 0Ch
		push	[ebp+nhi]	; nhi
		push	[ebp+sorted_hi]	; hi
		push	[ebp+nlo]	; nlo
		push	[ebp+lo]	; lo
		push	[ebp+temp]	; t
		call	mergelines
		add	esp, 20h

loc_8004CCB:				; CODE XREF: sortlines_temp+8Bj
		nop
		leave
		retn
sortlines_temp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl avoid_trashing_input(sortfile *files, size_t ntemps, size_t nfiles, const char	*outfile)
avoid_trashing_input proc near		; CODE XREF: merge+209p

outfile		= dword	ptr -0F0h
files		= dword	ptr -0ECh
got_outstat	= byte ptr -0E3h
same		= byte ptr -0E2h
is_stdin	= byte ptr -0E1h
tftp		= dword	ptr -0E0h
pid		= dword	ptr -0DCh
i		= dword	ptr -0D8h
num_merged	= dword	ptr -0D4h
temp		= dword	ptr -0D0h
outstat		= stat ptr -0CCh
instat		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
ntemps		= dword	ptr  0Ch
nfiles		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0F0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+files], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+outfile], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+got_outstat], 0
		mov	eax, [ebp+ntemps]
		mov	[ebp+i], eax
		jmp	loc_8004FCF
; ---------------------------------------------------------------------------

loc_8004D0B:				; CODE XREF: avoid_trashing_input+30Aj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset file	; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+outfile], 0
		jz	short loc_8004D8E
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+outfile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8004D8E
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8004D8E
		mov	[ebp+same], 1
		jmp	loc_8004E86
; ---------------------------------------------------------------------------

loc_8004D8E:				; CODE XREF: avoid_trashing_input+77j
					; avoid_trashing_input+A4j ...
		movzx	eax, [ebp+got_outstat]
		xor	eax, 1
		test	al, al
		jz	short loc_8004DEC
		cmp	[ebp+outfile], 0
		jz	short loc_8004DC4
		sub	esp, 8
		lea	eax, [ebp+outstat]
		push	eax
		push	[ebp+outfile]
		call	stat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		jmp	short loc_8004DDD
; ---------------------------------------------------------------------------

loc_8004DC4:				; CODE XREF: avoid_trashing_input+D5j
		sub	esp, 8
		lea	eax, [ebp+outstat]
		push	eax
		push	1
		call	fstat64
		add	esp, 10h
		test	eax, eax
		setnz	al

loc_8004DDD:				; CODE XREF: avoid_trashing_input+F4j
		test	al, al
		jnz	loc_8004FE0
		mov	[ebp+got_outstat], 1

loc_8004DEC:				; CODE XREF: avoid_trashing_input+CCj
		cmp	[ebp+is_stdin],	0
		jz	short loc_8004E0C
		sub	esp, 8
		lea	eax, [ebp+instat]
		push	eax
		push	0
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8004E37
		jmp	short loc_8004E74
; ---------------------------------------------------------------------------

loc_8004E0C:				; CODE XREF: avoid_trashing_input+125j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+instat]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8004E74

loc_8004E37:				; CODE XREF: avoid_trashing_input+13Aj
		mov	ecx, dword ptr [ebp+instat.st_ino]
		mov	ebx, dword ptr [ebp+instat.st_ino+4]
		mov	eax, dword ptr [ebp+outstat.st_ino]
		mov	edx, dword ptr [ebp+outstat.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8004E74
		mov	ecx, dword ptr [ebp+instat.st_dev]
		mov	ebx, dword ptr [ebp+instat.st_dev+4]
		mov	eax, dword ptr [ebp+outstat.st_dev]
		mov	edx, dword ptr [ebp+outstat.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8004E74
		mov	eax, 1
		jmp	short loc_8004E79
; ---------------------------------------------------------------------------

loc_8004E74:				; CODE XREF: avoid_trashing_input+13Cj
					; avoid_trashing_input+167j ...
		mov	eax, 0

loc_8004E79:				; CODE XREF: avoid_trashing_input+1A4j
		mov	[ebp+same], al
		and	[ebp+same], 1

loc_8004E86:				; CODE XREF: avoid_trashing_input+BBj
		cmp	[ebp+same], 0
		jz	loc_8004FC8
		sub	esp, 8
		lea	eax, [ebp+pid]
		push	eax		; ppid
		lea	eax, [ebp+tftp]
		push	eax		; pfp
		call	create_temp
		add	esp, 10h
		mov	[ebp+temp], eax
		mov	[ebp+num_merged], 0

loc_8004EBC:				; CODE XREF: avoid_trashing_input+2F4j
		mov	edx, [ebp+tftp]
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+i]
		mov	ecx, [ebp+i]
		lea	ebx, ds:0[ecx*8]
		mov	ecx, [ebp+files]
		add	ecx, ebx
		sub	esp, 0Ch
		push	[ebp+temp]	; output_file
		push	edx		; ofp
		push	eax		; nfiles
		push	0		; ntemps
		push	ecx		; files
		call	mergefiles
		add	esp, 20h
		add	[ebp+num_merged], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+temp]
		mov	[edx], eax
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+pid]
		mov	[edx+4], eax
		mov	edx, [ebp+i]
		mov	eax, [ebp+num_merged]
		add	eax, edx
		cmp	eax, [ebp+nfiles]
		jnb	short loc_8004F9A
		mov	eax, [ebp+num_merged]
		lea	ecx, ds:0[eax*8]
		mov	edx, [ebp+i]
		mov	eax, [ebp+num_merged]
		add	eax, edx
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+i]
		add	eax, 1
		lea	ebx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, ebx
		sub	esp, 4
		push	ecx		; n
		push	edx		; src
		push	eax		; dest
		call	memmove
		add	esp, 10h

loc_8004F9A:				; CODE XREF: avoid_trashing_input+27Aj
		add	[ebp+ntemps], 1
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+num_merged]
		add	eax, 1
		mov	[ebp+nfiles], eax
		mov	eax, [ebp+num_merged]
		add	[ebp+i], eax
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8004EBC

loc_8004FC8:				; CODE XREF: avoid_trashing_input+1BFj
		add	[ebp+i], 1

loc_8004FCF:				; CODE XREF: avoid_trashing_input+38j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jb	loc_8004D0B
		jmp	short loc_8004FE1
; ---------------------------------------------------------------------------

loc_8004FE0:				; CODE XREF: avoid_trashing_input+111j
		nop

loc_8004FE1:				; CODE XREF: avoid_trashing_input+310j
		mov	eax, [ebp+nfiles]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8004FF5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8004FF5:				; CODE XREF: avoid_trashing_input+320j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
avoid_trashing_input endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl merge(sortfile *files, size_t ntemps, size_t nfiles, const char *output_file)
merge		proc near		; CODE XREF: sort+2C9p	main+1572p

output_file	= dword	ptr -50h
files		= dword	ptr -4Ch
fps		= dword	ptr -48h
tfp		= dword	ptr -44h
pid		= dword	ptr -40h
in		= dword	ptr -3Ch
out		= dword	ptr -38h
nopened		= dword	ptr -34h
temp		= dword	ptr -30h
num_merged	= dword	ptr -2Ch
remainder	= dword	ptr -28h
cheap_slots	= dword	ptr -24h
nshortmerge	= dword	ptr -20h
temp_0		= dword	ptr -1Ch
num_merged_0	= dword	ptr -18h
temp_1		= dword	ptr -14h
ofp		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
ntemps		= dword	ptr  0Ch
nfiles		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 50h
		mov	eax, [ebp+arg_0]
		mov	[ebp+files], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+output_file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_80051EB
; ---------------------------------------------------------------------------

loc_8005020:				; CODE XREF: merge+1F7j
		mov	[ebp+in], 0
		mov	eax, [ebp+in]
		mov	[ebp+out], eax
		jmp	loc_80050C3
; ---------------------------------------------------------------------------

loc_8005032:				; CODE XREF: merge+D6j
		sub	esp, 8
		lea	eax, [ebp+pid]
		push	eax		; ppid
		lea	eax, [ebp+tfp]
		push	eax		; pfp
		call	create_temp
		add	esp, 10h
		mov	[ebp+temp], eax
		mov	ebx, [ebp+tfp]
		mov	ecx, nmerge
		mov	edx, nmerge
		mov	eax, [ebp+ntemps]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	edx, [ebp+in]
		lea	esi, ds:0[edx*8]
		mov	edx, [ebp+files]
		add	edx, esi
		sub	esp, 0Ch
		push	[ebp+temp]	; output_file
		push	ebx		; ofp
		push	ecx		; nfiles
		push	eax		; ntemps
		push	edx		; files
		call	mergefiles
		add	esp, 20h
		mov	[ebp+num_merged], eax
		mov	eax, [ebp+ntemps]
		cmp	[ebp+num_merged], eax
		cmovbe	eax, [ebp+num_merged]
		sub	[ebp+ntemps], eax
		mov	eax, [ebp+out]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+temp]
		mov	[edx], eax
		mov	eax, [ebp+out]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+pid]
		mov	[edx+4], eax
		mov	eax, [ebp+num_merged]
		add	[ebp+in], eax
		add	[ebp+out], 1

loc_80050C3:				; CODE XREF: merge+31j
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+in]
		mov	edx, eax
		mov	eax, nmerge
		cmp	edx, eax
		jnb	loc_8005032
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+in]
		mov	[ebp+remainder], eax
		mov	ecx, nmerge
		mov	ebx, nmerge
		mov	eax, [ebp+out]
		mov	edx, 0
		div	ebx
		mov	eax, edx
		sub	ecx, eax
		mov	eax, ecx
		mov	[ebp+cheap_slots], eax
		mov	eax, [ebp+cheap_slots]
		cmp	eax, [ebp+remainder]
		jnb	loc_80051A3
		mov	eax, [ebp+remainder]
		sub	eax, [ebp+cheap_slots]
		add	eax, 1
		mov	[ebp+nshortmerge], eax
		sub	esp, 8
		lea	eax, [ebp+pid]
		push	eax		; ppid
		lea	eax, [ebp+tfp]
		push	eax		; pfp
		call	create_temp
		add	esp, 10h
		mov	[ebp+temp_0], eax
		mov	edx, [ebp+tfp]
		mov	eax, [ebp+ntemps]
		cmp	[ebp+nshortmerge], eax
		cmovbe	eax, [ebp+nshortmerge]
		mov	ecx, [ebp+in]
		lea	ebx, ds:0[ecx*8]
		mov	ecx, [ebp+files]
		add	ecx, ebx
		sub	esp, 0Ch
		push	[ebp+temp_0]	; output_file
		push	edx		; ofp
		push	[ebp+nshortmerge] ; nfiles
		push	eax		; ntemps
		push	ecx		; files
		call	mergefiles
		add	esp, 20h
		mov	[ebp+num_merged_0], eax
		mov	eax, [ebp+ntemps]
		cmp	[ebp+num_merged_0], eax
		cmovbe	eax, [ebp+num_merged_0]
		sub	[ebp+ntemps], eax
		mov	eax, [ebp+out]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+temp_0]
		mov	[edx], eax
		mov	eax, [ebp+out]
		lea	edx, [eax+1]
		mov	[ebp+out], edx
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+pid]
		mov	[edx+4], eax
		mov	eax, [ebp+num_merged_0]
		add	[ebp+in], eax

loc_80051A3:				; CODE XREF: merge+10Aj
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+in]
		lea	ecx, ds:0[eax*8]
		mov	eax, [ebp+in]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+out]
		lea	ebx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, ebx
		sub	esp, 4
		push	ecx		; n
		push	edx		; src
		push	eax		; dest
		call	memmove
		add	esp, 10h
		mov	eax, [ebp+out]
		add	[ebp+ntemps], eax
		mov	eax, [ebp+out]
		sub	eax, [ebp+in]
		add	[ebp+nfiles], eax

loc_80051EB:				; CODE XREF: merge+1Fj
		mov	eax, nmerge
		cmp	eax, [ebp+nfiles]
		jb	loc_8005020
		push	[ebp+output_file] ; outfile
		push	[ebp+nfiles]	; nfiles
		push	[ebp+ntemps]	; ntemps
		push	[ebp+files]	; files
		call	avoid_trashing_input
		add	esp, 10h
		mov	[ebp+nfiles], eax

loc_8005210:				; CODE XREF: merge+3BFj
		sub	esp, 4
		lea	eax, [ebp+fps]
		push	eax		; pfps
		push	[ebp+nfiles]	; nfiles
		push	[ebp+files]	; files
		call	open_input_files
		add	esp, 10h
		mov	[ebp+nopened], eax
		mov	eax, [ebp+nopened]
		cmp	eax, [ebp+nfiles]
		jnz	short loc_80052AF
		sub	esp, 8
		push	offset modes	; "w"
		push	[ebp+output_file] ; file
		call	stream_open
		add	esp, 10h
		mov	[ebp+ofp], eax
		cmp	[ebp+ofp], 0
		jz	short loc_8005281
		mov	eax, [ebp+fps]
		sub	esp, 8
		push	eax		; fps
		push	[ebp+output_file] ; output_file
		push	[ebp+ofp]	; ofp
		push	[ebp+nfiles]	; nfiles
		push	[ebp+ntemps]	; ntemps
		push	[ebp+files]	; files
		call	mergefps
		add	esp, 20h
		nop
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	loc_80053C5
		jmp	loc_80053C0
; ---------------------------------------------------------------------------

loc_8005281:				; CODE XREF: merge+24Ej
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 18h
		jnz	short loc_8005293
		cmp	[ebp+nopened], 2
		ja	short loc_80052E0

loc_8005293:				; CODE XREF: merge+28Fj
		sub	esp, 0Ch
		push	offset aOpenFailed ; "open failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+output_file] ; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_80052AF:				; CODE XREF: merge+232j
		cmp	[ebp+nopened], 2
		ja	short loc_80052E0
		mov	eax, [ebp+nopened]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aOpenFailed ; "open failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_80052E0:				; CODE XREF: merge+295j merge+2B7j ...
		sub	[ebp+nopened], 1
		mov	eax, [ebp+nopened]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, [ebp+fps]
		mov	ecx, [ebp+nopened]
		shl	ecx, 2
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h
		cmp	[ebp+nopened], 2
		setnbe	al
		movzx	eax, al
		sub	esp, 4
		push	eax		; survive_fd_exhaustion
		lea	eax, [ebp+pid]
		push	eax		; ppid
		lea	eax, [ebp+tfp]
		push	eax		; pfp
		call	maybe_create_temp
		add	esp, 10h
		mov	[ebp+temp_1], eax
		cmp	[ebp+temp_1], 0
		jz	short loc_80052E0
		mov	ecx, [ebp+fps]
		mov	edx, [ebp+tfp]
		mov	eax, [ebp+ntemps]
		cmp	[ebp+nopened], eax
		cmovbe	eax, [ebp+nopened]
		sub	esp, 8
		push	ecx		; fps
		push	[ebp+temp_1]	; output_file
		push	edx		; ofp
		push	[ebp+nopened]	; nfiles
		push	eax		; ntemps
		push	[ebp+files]	; files
		call	mergefps
		add	esp, 20h
		mov	eax, [ebp+ntemps]
		cmp	[ebp+nopened], eax
		cmovbe	eax, [ebp+nopened]
		sub	[ebp+ntemps], eax
		mov	eax, [ebp+files]
		mov	edx, [ebp+temp_1]
		mov	[eax], edx
		mov	edx, [ebp+pid]
		mov	eax, [ebp+files]
		mov	[eax+4], edx
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+nopened]
		lea	ecx, ds:0[eax*8]
		mov	eax, [ebp+nopened]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, [ebp+files]
		add	eax, 8
		sub	esp, 4
		push	ecx		; n
		push	edx		; src
		push	eax		; dest
		call	memmove
		add	esp, 10h
		add	[ebp+ntemps], 1
		mov	eax, [ebp+nfiles]
		sub	eax, [ebp+nopened]
		add	eax, 1
		mov	[ebp+nfiles], eax
		jmp	loc_8005210
; ---------------------------------------------------------------------------

loc_80053C0:				; CODE XREF: merge+280j
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80053C5:				; CODE XREF: merge+27Aj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
merge		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sort(char *const	*files,	size_t nfiles, const char *output_file)
sort		proc near		; CODE XREF: main+1591p

output_file	= dword	ptr -60h
files		= dword	ptr -5Ch
output_file_created= byte ptr -55h
fp		= dword	ptr -54h
tfp		= dword	ptr -50h
ntemps		= dword	ptr -4Ch
temp_output	= dword	ptr -48h
line		= dword	ptr -44h
i		= dword	ptr -40h
node		= dword	ptr -3Ch
file		= dword	ptr -38h
bytes_per_line	= dword	ptr -34h
linebase	= dword	ptr -30h
tempfiles	= dword	ptr -2Ch
buf		= buffer ptr -28h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
nfiles		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 68h
		mov	eax, [ebp+arg_0]
		mov	[ebp+files], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+output_file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ntemps], 0
		mov	[ebp+output_file_created], 0
		mov	[ebp+buf.alloc], 0
		jmp	loc_80055F9
; ---------------------------------------------------------------------------

loc_8005400:				; CODE XREF: sort+231j
		mov	eax, [ebp+files]
		mov	eax, [eax]
		mov	[ebp+file], eax
		sub	esp, 8
		push	offset how	; "r"
		push	[ebp+file]	; file
		call	xfopen
		add	esp, 10h
		mov	[ebp+fp], eax
		mov	[ebp+bytes_per_line], 18h
		mov	eax, [ebp+buf.alloc]
		test	eax, eax
		jnz	short loc_8005459
		sub	esp, 0Ch
		push	[ebp+bytes_per_line] ; line_bytes
		push	[ebp+nfiles]	; nfiles
		push	[ebp+files]	; files
		push	1		; nfps
		lea	eax, [ebp+fp]
		push	eax		; fps
		call	sort_buffer_size
		add	esp, 20h
		sub	esp, 4
		push	eax		; alloc
		push	[ebp+bytes_per_line] ; line_bytes
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	initbuf
		add	esp, 10h

loc_8005459:				; CODE XREF: sort+5Ej
		mov	[ebp+buf.eof], 0
		add	[ebp+files], 4
		sub	[ebp+nfiles], 1
		jmp	loc_80055C9
; ---------------------------------------------------------------------------

loc_800546A:				; CODE XREF: sort+215j
		movzx	eax, [ebp+buf.eof]
		test	al, al
		jz	short loc_80054A0
		cmp	[ebp+nfiles], 0
		jz	short loc_80054A0
		mov	eax, [ebp+bytes_per_line]
		lea	ecx, [eax+1]
		mov	edx, [ebp+buf.alloc]
		mov	eax, [ebp+buf.used]
		sub	edx, eax
		mov	eax, [ebp+buf.nlines]
		imul	eax, [ebp+bytes_per_line]
		sub	edx, eax
		mov	eax, edx
		cmp	ecx, eax
		jnb	short loc_80054A0
		mov	eax, [ebp+buf.used]
		mov	[ebp+buf.left],	eax
		jmp	loc_80055E7
; ---------------------------------------------------------------------------

loc_80054A0:				; CODE XREF: sort+A4j sort+AAj ...
		sub	esp, 0Ch
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	buffer_linelim
		add	esp, 10h
		mov	[ebp+line], eax
		mov	eax, [ebp+buf.nlines]
		shl	eax, 4
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+line]
		add	eax, edx
		mov	[ebp+linebase],	eax
		mov	eax, [ebp+buf.nlines]
		cmp	eax, 1
		jbe	short loc_80054E1
		mov	eax, [ebp+buf.nlines]
		sub	esp, 4
		push	[ebp+linebase]	; temp
		push	eax		; nlines
		push	[ebp+line]	; lines
		call	sortlines
		add	esp, 10h

loc_80054E1:				; CODE XREF: sort+FEj
		movzx	eax, [ebp+buf.eof]
		test	al, al
		jz	short loc_8005530
		cmp	[ebp+nfiles], 0
		jnz	short loc_8005530
		cmp	[ebp+ntemps], 0
		jnz	short loc_8005530
		mov	eax, [ebp+buf.left]
		test	eax, eax
		jnz	short loc_8005530
		mov	eax, [ebp+fp]
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h
		sub	esp, 8
		push	offset modes	; "w"
		push	[ebp+output_file] ; file
		call	xfopen
		add	esp, 10h
		mov	[ebp+tfp], eax
		mov	eax, [ebp+output_file]
		mov	[ebp+temp_output], eax
		mov	[ebp+output_file_created], 1
		jmp	short loc_8005548
; ---------------------------------------------------------------------------

loc_8005530:				; CODE XREF: sort+11Bj	sort+121j ...
		add	[ebp+ntemps], 1
		sub	esp, 8
		push	0		; ppid
		lea	eax, [ebp+tfp]
		push	eax		; pfp
		call	create_temp
		add	esp, 10h
		mov	[ebp+temp_output], eax

loc_8005548:				; CODE XREF: sort+162j	sort+1D4j
		sub	[ebp+line], 10h
		mov	ecx, [ebp+tfp]
		mov	eax, [ebp+line]
		mov	edx, [eax+4]
		mov	eax, [ebp+line]
		mov	eax, [eax]
		push	[ebp+temp_output] ; output_file
		push	ecx		; fp
		push	edx		; n_bytes
		push	eax		; buf
		call	write_bytes
		add	esp, 10h
		movzx	eax, ds:unique
		test	al, al
		jz	short loc_800559A
		jmp	short loc_8005579
; ---------------------------------------------------------------------------

loc_8005575:				; CODE XREF: sort+1CCj
		sub	[ebp+line], 10h

loc_8005579:				; CODE XREF: sort+1A7j
		mov	eax, [ebp+linebase]
		cmp	eax, [ebp+line]
		jnb	short loc_800559A
		mov	eax, [ebp+line]
		sub	eax, 10h
		sub	esp, 8
		push	eax		; b
		push	[ebp+line]	; a
		call	compare
		add	esp, 10h
		test	eax, eax
		jz	short loc_8005575

loc_800559A:				; CODE XREF: sort+1A5j	sort+1B3j
		mov	eax, [ebp+linebase]
		cmp	eax, [ebp+line]
		jb	short loc_8005548
		mov	eax, [ebp+tfp]
		sub	esp, 8
		push	[ebp+temp_output] ; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h
		mov	eax, ds:nprocs
		cmp	eax, 2
		jbe	short loc_80055C3
		call	reap_some

loc_80055C3:				; CODE XREF: sort+1F0j
		cmp	[ebp+output_file_created], 0
		jnz	short loc_8005605

loc_80055C9:				; CODE XREF: sort+99j
		mov	eax, [ebp+fp]
		sub	esp, 4
		push	[ebp+file]	; file
		push	eax		; fp
		lea	eax, [ebp+buf]
		push	eax		; buf
		call	fillbuf
		add	esp, 10h
		test	al, al
		jnz	loc_800546A

loc_80055E7:				; CODE XREF: sort+CFj
		mov	eax, [ebp+fp]
		sub	esp, 8
		push	[ebp+file]	; file
		push	eax		; fp
		call	xfclose
		add	esp, 10h

loc_80055F9:				; CODE XREF: sort+2Fj
		cmp	[ebp+nfiles], 0
		jnz	loc_8005400
		jmp	short finish
; ---------------------------------------------------------------------------

loc_8005605:				; CODE XREF: sort+1FBj
		nop

finish:					; CODE XREF: sort+237j
		mov	eax, [ebp+buf.buf]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+output_file_created]
		xor	eax, 1
		test	al, al
		jz	loc_80056AB
		mov	eax, ds:temphead
		mov	[ebp+node], eax
		sub	esp, 8
		push	8
		push	[ebp+ntemps]
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+tempfiles], eax
		mov	[ebp+i], 0
		jmp	short loc_8005683
; ---------------------------------------------------------------------------

loc_8005648:				; CODE XREF: sort+2BBj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+tempfiles]
		add	eax, edx
		mov	edx, [ebp+node]
		add	edx, 8
		mov	[eax], edx
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+tempfiles]
		add	edx, eax
		mov	eax, [ebp+node]
		mov	eax, [eax+4]
		mov	[edx+4], eax
		mov	eax, [ebp+node]
		mov	eax, [eax]
		mov	[ebp+node], eax
		add	[ebp+i], 1

loc_8005683:				; CODE XREF: sort+27Aj
		cmp	[ebp+node], 0
		jnz	short loc_8005648
		push	[ebp+output_file] ; output_file
		push	[ebp+ntemps]	; nfiles
		push	[ebp+ntemps]	; ntemps
		push	[ebp+tempfiles]	; files
		call	merge
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tempfiles]	; ptr
		call	free
		add	esp, 10h

loc_80056AB:				; CODE XREF: sort+252j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80056BD
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80056BD:				; CODE XREF: sort+2EAj
		leave
		retn
sort		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl insertkey(keyfield *key_arg)
insertkey	proc near		; CODE XREF: main+76Ap	main+AFCp ...

p		= dword	ptr -10h
key		= dword	ptr -0Ch
key_arg		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	2Ch		; size_t
		push	[ebp+key_arg]	; void *
		call	xmemdup
		add	esp, 10h
		mov	[ebp+key], eax
		mov	[ebp+p], offset	keylist
		jmp	short loc_80056EC
; ---------------------------------------------------------------------------

loc_80056E1:				; CODE XREF: insertkey+34j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		add	eax, 28h
		mov	[ebp+p], eax

loc_80056EC:				; CODE XREF: insertkey+20j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80056E1
		mov	eax, [ebp+p]
		mov	edx, [ebp+key]
		mov	[eax], edx
		mov	eax, [ebp+key]
		mov	dword ptr [eax+28h], 0
		nop
		leave
		retn
insertkey	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl badfieldspec(const char *spec, const char *msgid)
badfieldspec	proc near		; CODE XREF: main+75Cp	main+94Fp ...

spec		= dword	ptr  8
msgid		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0Ch
		push	[ebp+spec]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	[ebp+msgid]	; msgid
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSInvalidFieldS ; "%s: invalid field specification %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h
		call	abort
badfieldspec	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl incompatible_options(const char *opts)
incompatible_options proc near		; CODE XREF: check_ordering_compatibility+17Bp
					; main+875p ...

opts		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset aOptionsSAreInc ; "options `-%s' are incompatible"
		call	gettext
		add	esp, 10h
		push	[ebp+opts]
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h
		call	abort
incompatible_options endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void check_ordering_compatibility()
check_ordering_compatibility proc near	; CODE XREF: main:loc_8006E9Dp

key		= dword	ptr -34h
p		= dword	ptr -30h
opts		= byte ptr -2Bh
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		jmp	loc_800590A
; ---------------------------------------------------------------------------

loc_800579F:				; CODE XREF: check_ordering_compatibility+18Dj
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		movzx	edx, al
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ah]
		movzx	eax, al
		add	edx, eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ch]
		movzx	eax, al
		add	edx, eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+24h]
		movzx	eax, al
		add	edx, eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+26h]
		movzx	eax, al
		add	edx, eax
		mov	eax, [ebp+key]
		mov	eax, [eax+10h]
		test	eax, eax
		setnz	al
		movzx	eax, al
		add	edx, eax
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Dh]
		movzx	eax, al
		add	eax, edx
		cmp	eax, 1
		jg	short loc_8005817
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		test	al, al
		jz	loc_8005901
		mov	eax, [ebp+key]
		mov	eax, [eax+14h]
		test	eax, eax
		jz	loc_8005901

loc_8005817:				; CODE XREF: check_ordering_compatibility+77j
		lea	eax, [ebp+opts]
		mov	[ebp+p], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+10h]
		cmp	eax, offset nondictionary
		jnz	short loc_8005836
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	64h

loc_8005836:				; CODE XREF: check_ordering_compatibility+A7j
		mov	eax, [ebp+key]
		mov	eax, [eax+14h]
		test	eax, eax
		jz	short loc_800584C
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	66h

loc_800584C:				; CODE XREF: check_ordering_compatibility+BDj
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	short loc_8005863
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	67h

loc_8005863:				; CODE XREF: check_ordering_compatibility+D4j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jz	short loc_800587A
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	68h

loc_800587A:				; CODE XREF: check_ordering_compatibility+EBj
		mov	eax, [ebp+key]
		mov	eax, [eax+10h]
		cmp	eax, offset nonprinting
		jnz	short loc_8005893
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	69h

loc_8005893:				; CODE XREF: check_ordering_compatibility+104j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+24h]
		test	al, al
		jz	short loc_80058AA
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	4Dh

loc_80058AA:				; CODE XREF: check_ordering_compatibility+11Bj
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ah]
		test	al, al
		jz	short loc_80058C1
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	6Eh

loc_80058C1:				; CODE XREF: check_ordering_compatibility+132j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+26h]
		test	al, al
		jz	short loc_80058D8
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	56h

loc_80058D8:				; CODE XREF: check_ordering_compatibility+149j
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		test	al, al
		jz	short loc_80058EF
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		mov	byte ptr [eax],	52h

loc_80058EF:				; CODE XREF: check_ordering_compatibility+160j
		mov	eax, [ebp+p]
		mov	byte ptr [eax],	0
		sub	esp, 0Ch
		lea	eax, [ebp+opts]
		push	eax		; opts
		call	incompatible_options
; ---------------------------------------------------------------------------

loc_8005901:				; CODE XREF: check_ordering_compatibility+82j
					; check_ordering_compatibility+90j
		mov	eax, [ebp+key]
		mov	eax, [eax+28h]
		mov	[ebp+key], eax

loc_800590A:				; CODE XREF: check_ordering_compatibility+19j
		cmp	[ebp+key], 0
		jnz	loc_800579F
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8005926
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8005926:				; CODE XREF: check_ordering_compatibility+19Ej
		leave
		retn
check_ordering_compatibility endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl parse_field_count(const char *string, size_t *val, const char *msgid)
parse_field_count proc near		; CODE XREF: main+5F3p	main+630p ...

msgid		= dword	ptr -34h
val		= dword	ptr -30h
string		= dword	ptr -2Ch
suffix		= dword	ptr -1Ch
n		= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+string], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+val], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+msgid], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		lea	eax, [ebp+suffix]
		push	eax
		push	[ebp+string]
		call	xstrtoumax
		add	esp, 20h
		cmp	eax, 4		; switch 5 cases
		ja	loc_8005A02	; jumptable 0800597A default case
		mov	eax, ds:off_8008D00[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_800597C:				; CODE XREF: parse_field_count+52j
					; DATA XREF: .rodata:off_8008D00o
		mov	eax, dword ptr [ebp+n] ; jumptable 0800597A cases 0,2
		mov	edx, dword ptr [ebp+n+4]
		mov	edx, eax
		mov	eax, [ebp+val]
		mov	[eax], edx
		mov	eax, [ebp+val]
		mov	eax, [eax]
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8005A01

loc_80059A7:				; CODE XREF: parse_field_count+52j
					; DATA XREF: .rodata:off_8008D00o
		mov	eax, [ebp+val]	; jumptable 0800597A cases 1,3
		mov	dword ptr [eax], 0FFFFFFFFh
		jmp	short loc_8005A02 ; jumptable 0800597A default case
; ---------------------------------------------------------------------------

loc_80059B2:				; CODE XREF: parse_field_count+52j
					; DATA XREF: .rodata:off_8008D00o
		cmp	[ebp+msgid], 0	; jumptable 0800597A case 4
		jz	short loc_80059FA
		sub	esp, 0Ch
		push	[ebp+string]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	[ebp+msgid]	; msgid
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSInvalidCountA ; "%s: invalid count at start of	%s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h

loc_80059FA:				; CODE XREF: parse_field_count+8Ej
		mov	eax, 0
		jmp	short loc_8005A05
; ---------------------------------------------------------------------------

loc_8005A01:				; CODE XREF: parse_field_count+7Dj
		nop

loc_8005A02:				; CODE XREF: parse_field_count+45j
					; parse_field_count+88j
		mov	eax, [ebp+suffix] ; jumptable 0800597A default case

loc_8005A05:				; CODE XREF: parse_field_count+D7j
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8005A16
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8005A16:				; CODE XREF: parse_field_count+E7j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
parse_field_count endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sighandler(int sig)
sighandler	proc near		; DATA XREF: main+23Co

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	cleanup
		sub	esp, 8
		push	0		; handler
		push	[ebp+sig]	; sig
		call	signal
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+sig]	; sig
		call	raise
		add	esp, 10h
		nop
		leave
		retn
sighandler	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	set_ordering(const char	*s, keyfield *key, blanktype blanktype)
set_ordering	proc near		; CODE XREF: main+67Dp	main+73Fp ...

s		= dword	ptr  8
key		= dword	ptr  0Ch
blanktype	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		jmp	loc_8005B11
; ---------------------------------------------------------------------------

loc_8005A51:				; CODE XREF: set_ordering+D0j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 4Dh	; switch 38 cases
		cmp	eax, 25h
		ja	loc_8005B04	; jumptable 08005A6D default case
		mov	eax, ds:off_8008D14[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8005A6F:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		cmp	[ebp+blanktype], 0 ; jumptable 08005A6D	case 98
		jz	short loc_8005A7B
		cmp	[ebp+blanktype], 2
		jnz	short loc_8005A82

loc_8005A7B:				; CODE XREF: set_ordering+2Aj
		mov	eax, [ebp+key]
		mov	byte ptr [eax+18h], 1

loc_8005A82:				; CODE XREF: set_ordering+30j
		cmp	[ebp+blanktype], 1
		jz	short loc_8005A8E
		cmp	[ebp+blanktype], 2
		jnz	short loc_8005B09

loc_8005A8E:				; CODE XREF: set_ordering+3Dj
		mov	eax, [ebp+key]
		mov	byte ptr [eax+19h], 1
		jmp	short loc_8005B09
; ---------------------------------------------------------------------------

loc_8005A97:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 100
		mov	dword ptr [eax+10h], offset nondictionary
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AA3:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 102
		mov	dword ptr [eax+14h], offset fold_toupper
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AAF:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 103
		mov	byte ptr [eax+1Ch], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AB8:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 104
		mov	byte ptr [eax+1Dh], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AC1:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 105
		mov	eax, [eax+10h]
		test	eax, eax
		jnz	short loc_8005B0C
		mov	eax, [ebp+key]
		mov	dword ptr [eax+10h], offset nonprinting
		jmp	short loc_8005B0C
; ---------------------------------------------------------------------------

loc_8005AD7:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 77
		mov	byte ptr [eax+24h], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AE0:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 110
		mov	byte ptr [eax+1Ah], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AE9:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 82
		mov	byte ptr [eax+1Bh], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AF2:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 114
		mov	byte ptr [eax+25h], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005AFB:				; CODE XREF: set_ordering+24j
					; DATA XREF: .rodata:off_8008D14o
		mov	eax, [ebp+key]	; jumptable 08005A6D case 86
		mov	byte ptr [eax+26h], 1
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005B04:				; CODE XREF: set_ordering+17j
					; set_ordering+24j
					; DATA XREF: ...
		mov	eax, [ebp+s]	; jumptable 08005A6D default case
		jmp	short loc_8005B22
; ---------------------------------------------------------------------------

loc_8005B09:				; CODE XREF: set_ordering+43j
					; set_ordering+4Cj
		nop
		jmp	short loc_8005B0D
; ---------------------------------------------------------------------------

loc_8005B0C:				; CODE XREF: set_ordering+80j
					; set_ordering+8Cj
		nop

loc_8005B0D:				; CODE XREF: set_ordering+58j
					; set_ordering+64j ...
		add	[ebp+s], 1

loc_8005B11:				; CODE XREF: set_ordering+3j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8005A51
		mov	eax, [ebp+s]

loc_8005B22:				; CODE XREF: set_ordering+BEj
		pop	ebp
		retn
set_ordering	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; keyfield *__cdecl key_init(keyfield *key)
key_init	proc near		; CODE XREF: main+5CFp	main+8F9p

key		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 4
		push	2Ch		; n
		push	0		; c
		push	[ebp+key]	; s
		call	memset
		add	esp, 10h
		mov	eax, [ebp+key]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	eax, [ebp+key]
		mov	dword ptr [eax+20h], 0FFFFFFFFh
		mov	eax, [ebp+key]
		leave
		retn
key_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -1ECh
checkonly	= byte ptr -1E3h
mergeonly	= byte ptr -1E2h
need_random	= byte ptr -1E1h
obsolete_usage	= byte ptr -1E0h
newtab		= byte ptr -1DFh
posixly_correct	= byte ptr -1DEh
minus_pos_usage	= byte ptr -1DDh
key		= dword	ptr -1DCh
s		= dword	ptr -1D8h
c		= dword	ptr -1D4h
random_source	= dword	ptr -1D0h
nfiles		= dword	ptr -1CCh
files		= dword	ptr -1C8h
files_from	= dword	ptr -1C4h
outfile		= dword	ptr -1C0h
i		= dword	ptr -1BCh
p		= dword	ptr -1B8h
stream		= dword	ptr -1B4h
i_0		= dword	ptr -1B0h
i_1		= dword	ptr -1ACh
locale		= dword	ptr -1A8h
optarg1		= dword	ptr -1A4h
file_number	= dword	ptr -1A0h
tmp_dir		= dword	ptr -19Ch
sortfiles	= dword	ptr -198h
key_buf		= keyfield ptr -194h
gkey		= keyfield ptr -168h
oi		= dword	ptr -13Ch
var_138		= dword	ptr -138h
act		= sigaction ptr	-0ACh
str		= byte ptr -1Eh
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 1E8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+c], 0
		mov	[ebp+checkonly], 0
		mov	[ebp+mergeonly], 0
		mov	[ebp+random_source], 0
		mov	[ebp+need_random], 0
		mov	[ebp+nfiles], 0
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+posixly_correct], al
		call	posix2_version
		cmp	eax, 30DAFh
		setle	al
		mov	[ebp+obsolete_usage], al
		mov	[ebp+files_from], 0
		mov	[ebp+outfile], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	3
		call	hard_locale
		add	esp, 10h
		mov	ds:hard_LC_COLLATE, al
		sub	esp, 0Ch
		push	2
		call	hard_locale
		add	esp, 10h
		mov	ds:hard_LC_TIME, al
		call	localeconv
		mov	[ebp+locale], eax
		mov	eax, [ebp+locale]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		mov	ds:decimal_point, eax
		mov	eax, ds:decimal_point
		test	eax, eax
		jz	short loc_8005CBB
		mov	eax, [ebp+locale]
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8005CC5

loc_8005CBB:				; CODE XREF: main+152j
		mov	ds:decimal_point, 2Eh

loc_8005CC5:				; CODE XREF: main+164j
		mov	eax, [ebp+locale]
		mov	eax, [eax+4]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		mov	ds:thousands_sep, eax
		mov	eax, ds:thousands_sep
		test	eax, eax
		jz	short loc_8005D04
		mov	eax, [ebp+locale]
		mov	eax, [eax+4]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8005D0E

loc_8005D04:				; CODE XREF: main+19Aj
		mov	ds:thousands_sep, 0FFFFFFFFh

loc_8005D0E:				; CODE XREF: main+1ADj
		mov	ds:have_read_stdin, 0
		call	inittables
		sub	esp, 0Ch
		push	offset caught_signals ;	set
		call	sigemptyset
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8005D88
; ---------------------------------------------------------------------------

loc_8005D36:				; CODE XREF: main+23Aj
		mov	eax, [ebp+i]
		mov	eax, ds:sig_6920[eax*4]
		sub	esp, 4
		lea	edx, [ebp+act]
		push	edx		; oact
		push	0		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h
		mov	eax, dword ptr [ebp+act.__sigaction_handler]
		cmp	eax, 1
		jz	short loc_8005D81
		mov	eax, [ebp+i]
		mov	eax, ds:sig_6920[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigaddset
		add	esp, 10h

loc_8005D81:				; CODE XREF: main+20Cj
		add	[ebp+i], 1

loc_8005D88:				; CODE XREF: main+1DFj
		cmp	[ebp+i], 0Ah
		jbe	short loc_8005D36
		mov	dword ptr [ebp+act.__sigaction_handler], offset	sighandler
		lea	eax, [ebp+act.sa_mask]
		mov	esi, offset caught_signals
		mov	edx, 20h
		mov	edi, eax
		mov	ecx, edx
		rep movsd
		mov	[ebp+act.sa_flags], 0
		mov	[ebp+i], 0
		jmp	short loc_8005E0F
; ---------------------------------------------------------------------------

loc_8005DC4:				; CODE XREF: main+2C1j
		mov	eax, [ebp+i]
		mov	eax, ds:sig_6920[eax*4]
		sub	esp, 8
		push	eax		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8005E08
		mov	eax, [ebp+i]
		mov	eax, ds:sig_6920[eax*4]
		sub	esp, 4
		push	0		; oact
		lea	edx, [ebp+act]
		push	edx		; act
		push	eax		; sig
		call	sigaction_0
		add	esp, 10h

loc_8005E08:				; CODE XREF: main+28Fj
		add	[ebp+i], 1

loc_8005E0F:				; CODE XREF: main+26Dj
		cmp	[ebp+i], 0Ah
		jbe	short loc_8005DC4
		sub	esp, 8
		push	0		; handler
		push	11h		; sig
		call	signal
		add	esp, 10h
		sub	esp, 0Ch
		push	offset exit_cleanup ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+gkey.eword], 0FFFFFFFFh
		mov	eax, [ebp+gkey.eword]
		mov	[ebp+gkey.sword], eax
		mov	[ebp+gkey.ignore], 0
		mov	[ebp+gkey.translate], 0
		mov	[ebp+gkey.human_numeric], 0
		movzx	eax, [ebp+gkey.human_numeric]
		mov	[ebp+gkey.general_numeric], al
		movzx	eax, [ebp+gkey.general_numeric]
		mov	[ebp+gkey.numeric], al
		mov	[ebp+gkey.si_present], 0FFFFFFFFh
		mov	[ebp+gkey.version], 0
		movzx	eax, [ebp+gkey.version]
		mov	[ebp+gkey.random], al
		mov	[ebp+gkey.reverse], 0
		movzx	eax, [ebp+gkey.reverse]
		mov	[ebp+gkey.month], al
		mov	[ebp+gkey.skipeblanks],	0
		movzx	eax, [ebp+gkey.skipeblanks]
		mov	[ebp+gkey.skipsblanks],	al
		mov	eax, [ebx]
		sub	esp, 8
		push	4
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+files], eax

loc_8005EDE:				; CODE XREF: main+DEAj
					; main:loc_8006945j
		mov	[ebp+oi], 0FFFFFFFFh
		cmp	[ebp+c], 0FFFFFFFFh
		jz	loc_8005FD7
		cmp	[ebp+posixly_correct], 0
		jz	loc_8005FA4
		cmp	[ebp+nfiles], 0
		jz	loc_8005FA4
		movzx	eax, [ebp+obsolete_usage]
		xor	eax, 1
		test	al, al
		jnz	loc_8005FD7
		cmp	[ebp+checkonly], 0
		jnz	loc_8005FD7
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jz	loc_8005FD7
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_8005FD7
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 6Fh
		jnz	short loc_8005FD7
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8005FA4
		mov	eax, ds:optind
		add	eax, 1
		cmp	eax, [ebx]
		jz	short loc_8005FD7

loc_8005FA4:				; CODE XREF: main+3A7j	main+3B4j ...
		sub	esp, 0Ch
		lea	eax, [ebp+oi]
		push	eax		; longind
		push	offset long_options ; longopts
		push	offset short_options ; "-bcCdfghik:mMno:rRsS:t:T:uVy:z"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8006037

loc_8005FD7:				; CODE XREF: main+39Aj	main+3C6j ...
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_8005FF2
		cmp	[ebp+files_from], 0
		jnz	loc_800694A
		jmp	loc_8006C20
; ---------------------------------------------------------------------------

loc_8005FF2:				; CODE XREF: main+489j
		mov	eax, [ebp+nfiles]
		lea	edx, [eax+1]
		mov	[ebp+nfiles], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		lea	ecx, [edx+eax]
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ecx], eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006037:				; CODE XREF: main+480j
		mov	eax, [ebp+c]
		add	eax, 83h	; switch 265 cases
		cmp	eax, 108h
		ja	loc_8006934	; jumptable 08006054 default case
		mov	eax, ds:off_8009084[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8006056:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	[ebp+key], 0	; jumptable 08006054 case 1
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	loc_80062C7
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jz	short loc_80060C4
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_80060C4
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_80060C4
		mov	eax, 1
		jmp	short loc_80060C9
; ---------------------------------------------------------------------------

loc_80060C4:				; CODE XREF: main+522j	main+53Fj ...
		mov	eax, 0

loc_80060C9:				; CODE XREF: main+56Dj
		mov	[ebp+minus_pos_usage], al
		and	[ebp+minus_pos_usage], 1
		movzx	eax, [ebp+obsolete_usage]
		cmp	[ebp+minus_pos_usage], 0
		jz	short loc_80060FB
		movzx	edx, [ebp+posixly_correct]
		xor	edx, 1
		test	dl, dl
		jz	short loc_80060FB
		mov	edx, 1
		jmp	short loc_8006100
; ---------------------------------------------------------------------------

loc_80060FB:				; CODE XREF: main+58Fj	main+59Dj
		mov	edx, 0

loc_8006100:				; CODE XREF: main+5A4j
		or	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+obsolete_usage], al
		cmp	[ebp+obsolete_usage], 0
		jz	loc_80062C7
		sub	esp, 0Ch
		lea	eax, [ebp+key_buf]
		push	eax		; key
		call	key_init
		add	esp, 10h
		mov	[ebp+key], eax
		mov	eax, [ebp+key]
		mov	edx, ds:optarg
		add	edx, 1
		sub	esp, 4
		push	0		; msgid
		push	eax		; val
		push	edx		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax
		cmp	[ebp+s], 0
		jz	short loc_8006193
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8006193
		mov	eax, [ebp+key]
		lea	edx, [eax+4]
		mov	eax, [ebp+s]
		add	eax, 1
		sub	esp, 4
		push	0		; msgid
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax

loc_8006193:				; CODE XREF: main+608j	main+615j
		mov	eax, [ebp+key]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80061B8
		mov	eax, [ebp+key]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_80061B8
		mov	eax, [ebp+key]
		mov	dword ptr [eax], 0FFFFFFFFh

loc_80061B8:				; CODE XREF: main+648j	main+655j
		cmp	[ebp+s], 0
		jz	short loc_80061E1
		sub	esp, 4
		push	0		; blanktype
		push	[ebp+key]	; key
		push	[ebp+s]		; s
		call	set_ordering
		add	esp, 10h
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80061F0

loc_80061E1:				; CODE XREF: main+66Aj
		mov	[ebp+key], 0
		jmp	loc_80062C7
; ---------------------------------------------------------------------------

loc_80061F0:				; CODE XREF: main+68Aj
		cmp	[ebp+minus_pos_usage], 0
		jz	loc_80062B6
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+optarg1], eax
		mov	eax, [ebp+key]
		lea	edx, [eax+8]
		mov	eax, [ebp+optarg1]
		add	eax, 1
		sub	esp, 4
		push	offset aInvalidNumberA ; "invalid number after `-'"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8006283
		mov	eax, [ebp+key]
		lea	edx, [eax+0Ch]
		mov	eax, [ebp+s]
		add	eax, 1
		sub	esp, 4
		push	offset aInvalidNumbe_0 ; "invalid number after `.'"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax

loc_8006283:				; CODE XREF: main+702j
		sub	esp, 4
		push	1		; blanktype
		push	[ebp+key]	; key
		push	[ebp+s]		; s
		call	set_ordering
		add	esp, 10h
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80062B6
		sub	esp, 8
		push	offset aStrayCharacter ; "stray	character in field spec"
		push	[ebp+optarg1]	; spec
		call	badfieldspec
; ---------------------------------------------------------------------------

loc_80062B6:				; CODE XREF: main+6A2j	main+74Cj
		sub	esp, 0Ch
		push	[ebp+key]	; key_arg
		call	insertkey
		add	esp, 10h

loc_80062C7:				; CODE XREF: main+515j	main+5BFj ...
		cmp	[ebp+key], 0
		jnz	loc_800693E
		mov	eax, [ebp+nfiles]
		lea	edx, [eax+1]
		mov	[ebp+nfiles], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	edx, eax
		mov	eax, ds:optarg
		mov	[edx], eax
		jmp	loc_800693E
; ---------------------------------------------------------------------------

loc_80062FE:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	edx, ds:argmatch_die ; jumptable 08006054 case 133
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	1
		push	offset sort_types ; "ghMnRVwaiting for %s [-d]"
		push	offset sort_args
		push	eax
		push	offset aSort	; "--sort"
		call	__xargmatch_internal
		add	esp, 20h
		movzx	eax, byte ptr ds:sort_types[eax] ; "ghMnRVwaiting for %s [-d]"
		movsx	eax, al
		mov	[ebp+c], eax

loc_8006337:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, [ebp+c]	; jumptable 08006054 cases 77,82,86,98,100,102-105,110,114
		mov	[ebp+str], al
		mov	[ebp+str+1], 0
		sub	esp, 4
		push	2		; blanktype
		lea	eax, [ebp+gkey]
		push	eax		; key
		lea	eax, [ebp+str]
		push	eax		; s
		call	set_ordering
		add	esp, 10h
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006361:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:optarg	; jumptable 08006054 case 128
		test	eax, eax
		jz	short loc_800639F
		mov	edx, ds:argmatch_die
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	1
		push	offset check_types ; "CCcgeneral-numeric"
		push	offset check_args
		push	eax
		push	offset aCheck	; "--check"
		call	__xargmatch_internal
		add	esp, 20h
		movzx	eax, byte ptr ds:check_types[eax] ; "CCcgeneral-numeric"
		movsx	eax, al
		jmp	short loc_80063A4
; ---------------------------------------------------------------------------

loc_800639F:				; CODE XREF: main+813j
		mov	eax, 63h

loc_80063A4:				; CODE XREF: main+848j
		mov	[ebp+c], eax

loc_80063AA:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		cmp	[ebp+checkonly], 0 ; jumptable 08006054	cases 67,99
		jz	short loc_80063CF
		movsx	eax, [ebp+checkonly]
		cmp	eax, [ebp+c]
		jz	short loc_80063CF
		sub	esp, 0Ch
		push	offset opts	; "cC"
		call	incompatible_options
; ---------------------------------------------------------------------------

loc_80063CF:				; CODE XREF: main+85Cj	main+86Bj
		mov	eax, [ebp+c]
		mov	[ebp+checkonly], al
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_80063E0:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:compress_program ; jumptable 08006054 case 129
		test	eax, eax
		jz	short loc_8006425
		mov	edx, ds:optarg
		mov	eax, ds:compress_program
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8006425
		sub	esp, 0Ch
		push	offset aMultipleCompre ; "multiple compress programs specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006425:				; CODE XREF: main+892j	main+8AEj
		mov	eax, ds:optarg
		mov	ds:compress_program, eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006434:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:optarg	; jumptable 08006054 case 130
		mov	[ebp+files_from], eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006444:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		sub	esp, 0Ch	; jumptable 08006054 case 107
		lea	eax, [ebp+key_buf]
		push	eax		; key
		call	key_init
		add	esp, 10h
		mov	[ebp+key], eax
		mov	edx, [ebp+key]
		mov	eax, ds:optarg
		sub	esp, 4
		push	offset aInvalidNumbe_1 ; "invalid number at field start"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+key]
		mov	eax, [eax]
		lea	ecx, [eax-1]
		mov	edx, [ebp+key]
		mov	[edx], ecx
		test	eax, eax
		jnz	short loc_80064A9
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aFieldNumberIsZ ; "field	number is zero"
		push	eax		; spec
		call	badfieldspec
; ---------------------------------------------------------------------------

loc_80064A9:				; CODE XREF: main+93Fj
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_800650C
		mov	eax, [ebp+key]
		lea	edx, [eax+4]
		mov	eax, [ebp+s]
		add	eax, 1
		sub	esp, 4
		push	offset aInvalidNumbe_0 ; "invalid number after `.'"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+4]
		lea	ecx, [eax-1]
		mov	edx, [ebp+key]
		mov	[edx+4], ecx
		test	eax, eax
		jnz	short loc_800650C
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aCharacterOffse ; "character offset is zero"
		push	eax		; spec
		call	badfieldspec
; ---------------------------------------------------------------------------

loc_800650C:				; CODE XREF: main+95Fj	main+9A2j
		mov	eax, [ebp+key]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8006531
		mov	eax, [ebp+key]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8006531
		mov	eax, [ebp+key]
		mov	dword ptr [eax], 0FFFFFFFFh

loc_8006531:				; CODE XREF: main+9C1j	main+9CEj
		sub	esp, 4
		push	0		; blanktype
		push	[ebp+key]	; key
		push	[ebp+s]		; s
		call	set_ordering
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ch
		jz	short loc_800657C
		mov	eax, [ebp+key]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	eax, [ebp+key]
		mov	dword ptr [eax+0Ch], 0
		jmp	loc_8006628
; ---------------------------------------------------------------------------

loc_800657C:				; CODE XREF: main+A06j
		mov	eax, [ebp+key]
		lea	edx, [eax+8]
		mov	eax, [ebp+s]
		add	eax, 1
		sub	esp, 4
		push	offset aInvalidNumbe_2 ; "invalid number after `,'"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+key]
		mov	eax, [eax+8]
		lea	ecx, [eax-1]
		mov	edx, [ebp+key]
		mov	[edx+8], ecx
		test	eax, eax
		jnz	short loc_80065D2
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aFieldNumberIsZ ; "field	number is zero"
		push	eax		; spec
		call	badfieldspec
; ---------------------------------------------------------------------------

loc_80065D2:				; CODE XREF: main+A68j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8006609
		mov	eax, [ebp+key]
		lea	edx, [eax+0Ch]
		mov	eax, [ebp+s]
		add	eax, 1
		sub	esp, 4
		push	offset aInvalidNumbe_0 ; "invalid number after `.'"
		push	edx		; val
		push	eax		; string
		call	parse_field_count
		add	esp, 10h
		mov	[ebp+s], eax

loc_8006609:				; CODE XREF: main+A88j
		sub	esp, 4
		push	1		; blanktype
		push	[ebp+key]	; key
		push	[ebp+s]		; s
		call	set_ordering
		add	esp, 10h
		mov	[ebp+s], eax

loc_8006628:				; CODE XREF: main+A22j
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8006648
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset aStrayCharacter ; "stray	character in field spec"
		push	eax		; spec
		call	badfieldspec
; ---------------------------------------------------------------------------

loc_8006648:				; CODE XREF: main+ADEj
		sub	esp, 0Ch
		push	[ebp+key]	; key_arg
		call	insertkey
		add	esp, 10h
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_800665E:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	[ebp+mergeonly], 1 ; jumptable 08006054	case 109
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_800666A:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	ecx, ds:optarg	; jumptable 08006054 case 131
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, [ebp+oi]
		sub	esp, 4
		push	ecx		; s
		push	edx		; c
		push	eax		; oi
		call	specify_nmerge
		add	esp, 10h
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006692:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		cmp	[ebp+outfile], 0 ; jumptable 08006054 case 111
		jz	short loc_80066D6
		mov	eax, ds:optarg
		sub	esp, 8
		push	eax		; s2
		push	[ebp+outfile]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80066D6
		sub	esp, 0Ch
		push	offset aMultipleOutput ; "multiple output files	specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_80066D6:				; CODE XREF: main+B44j	main+B5Fj
		mov	eax, ds:optarg
		mov	[ebp+outfile], eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_80066E6:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		cmp	[ebp+random_source], 0 ; jumptable 08006054 case 132
		jz	short loc_800672A
		mov	eax, ds:optarg
		sub	esp, 8
		push	eax		; s2
		push	[ebp+random_source] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800672A
		sub	esp, 0Ch
		push	offset aMultipleRandom ; "multiple random sources specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_800672A:				; CODE XREF: main+B98j	main+BB3j
		mov	eax, ds:optarg
		mov	[ebp+random_source], eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_800673A:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	ds:stable, 1	; jumptable 08006054 case 115
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006746:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	ecx, ds:optarg	; jumptable 08006054 case 83
		mov	eax, [ebp+c]
		movsx	edx, al
		mov	eax, [ebp+oi]
		sub	esp, 4
		push	ecx		; s
		push	edx		; c
		push	eax		; oi
		call	specify_sort_size
		add	esp, 10h
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_800676E:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:optarg	; jumptable 08006054 case 116
		movzx	eax, byte ptr [eax]
		mov	[ebp+newtab], al
		cmp	[ebp+newtab], 0
		jnz	short loc_80067A5
		sub	esp, 0Ch
		push	offset aEmptyTab ; "empty tab"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_80067A5:				; CODE XREF: main+C2Ej
		mov	eax, ds:optarg
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8006808
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset a0	; "\\0"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80067D7
		mov	[ebp+newtab], 0
		jmp	short loc_8006808
; ---------------------------------------------------------------------------

loc_80067D7:				; CODE XREF: main+C77j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aMultiCharacter ; "multi-character tab %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006808:				; CODE XREF: main+C5Dj	main+C80j
		mov	eax, tab
		cmp	eax, 80h
		jz	short loc_8006844
		movsx	edx, [ebp+newtab]
		mov	eax, tab
		cmp	edx, eax
		jz	short loc_8006844
		sub	esp, 0Ch
		push	offset aIncompatibleTa ; "incompatible tabs"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006844:				; CODE XREF: main+CBDj	main+CCDj
		movsx	eax, [ebp+newtab]
		mov	tab, eax
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006855:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:optarg	; jumptable 08006054 case 84
		sub	esp, 0Ch
		push	eax		; dir
		call	add_temp_dir
		add	esp, 10h
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_800686B:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	ds:unique, 1	; jumptable 08006054 case 117
		jmp	loc_8006945
; ---------------------------------------------------------------------------

loc_8006877:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	eax, ds:optind	; jumptable 08006054 case 121
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	edx, [eax]
		mov	eax, ds:optarg
		cmp	edx, eax
		jnz	loc_8006944
		mov	eax, ds:optarg
		mov	[ebp+p], eax
		jmp	short loc_80068B3
; ---------------------------------------------------------------------------

loc_80068AC:				; CODE XREF: main+D70j
		add	[ebp+p], 1

loc_80068B3:				; CODE XREF: main+D55j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_80068AC
		mov	edx, ds:optind
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		setnz	al
		movzx	eax, al
		sub	edx, eax
		mov	eax, edx
		mov	ds:optind, eax
		jmp	short loc_8006944
; ---------------------------------------------------------------------------

loc_80068E9:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	byte ptr eolchar, 0 ; jumptable	08006054 case 122
		jmp	short loc_8006945
; ---------------------------------------------------------------------------

loc_80068F2:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		sub	esp, 0Ch	; jumptable 08006054 case -130
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80068FC:				; CODE XREF: main+4FFj
					; DATA XREF: .rodata:off_8009084o
		mov	edx, ds:Version	; jumptable 08006054 case -131
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aPaulEggert ; "Paul Eggert"
		push	offset aMikeHaertel ; "Mike Haertel"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aSort_0	; "sort"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8006934:				; CODE XREF: main+4F2j	main+4FFj
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 08006054 default case
		push	2		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800693E:				; CODE XREF: main+779j	main+7A4j
		nop
		jmp	loc_8005EDE
; ---------------------------------------------------------------------------

loc_8006944:				; CODE XREF: main+D44j	main+D92j
		nop

loc_8006945:				; CODE XREF: main+4DDj	main+807j ...
		jmp	loc_8005EDE
; ---------------------------------------------------------------------------

loc_800694A:				; CODE XREF: main+492j
		cmp	[ebp+nfiles], 0
		jz	short loc_80069BA
		mov	eax, [ebp+files]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aFileOperandsCa ; "file operands	cannot be combined with	-"...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	edx
		push	offset aS	; "%s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80069BA:				; CODE XREF: main+DFCj
		sub	esp, 8
		push	offset file	; "-"
		push	[ebp+files_from] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80069E1
		mov	eax, ds:stdin
		mov	[ebp+stream], eax
		jmp	short loc_8006A3F
; ---------------------------------------------------------------------------

loc_80069E1:				; CODE XREF: main+E7Dj
		sub	esp, 8
		push	offset how	; "r"
		push	[ebp+files_from]
		call	fopen_safer
		add	esp, 10h
		mov	[ebp+stream], eax
		cmp	[ebp+stream], 0
		jnz	short loc_8006A3F
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006A3F:				; CODE XREF: main+E8Aj	main+EAFj
		sub	esp, 0Ch
		lea	eax, [ebp+oi]
		push	eax
		call	readtokens0_init
		add	esp, 10h
		sub	esp, 8
		lea	eax, [ebp+oi]
		push	eax
		push	[ebp+stream]
		call	readtokens0
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_8006A85
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8006AB6

loc_8006A85:				; CODE XREF: main+F19j
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotReadFile ; "cannot read file names from %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006AB6:				; CODE XREF: main+F2Ej
		mov	eax, [ebp+oi]
		test	eax, eax
		jz	loc_8006BEF
		sub	esp, 0Ch
		push	[ebp+files]	; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+var_138]
		mov	[ebp+files], eax
		mov	eax, [ebp+oi]
		mov	[ebp+nfiles], eax
		mov	[ebp+i_0], 0
		jmp	loc_8006BDB
; ---------------------------------------------------------------------------

loc_8006AFC:				; CODE XREF: main+1092j
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset file	; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8006B6D
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWhenReadingFil ; "when reading file names from stdin, no "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h
		jmp	short loc_8006BD4
; ---------------------------------------------------------------------------

loc_8006B6D:				; CODE XREF: main+FD1j
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8006BD4
		mov	eax, [ebp+i_0]
		add	eax, 1
		mov	[ebp+file_number], eax
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quotearg_colon
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSLuInvalidZero ; "%s:%lu: invalid zero-length file name"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+file_number]
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h

loc_8006BD4:				; CODE XREF: main+1016j main+1034j
		add	[ebp+i_0], 1

loc_8006BDB:				; CODE XREF: main+FA2j
		mov	eax, [ebp+i_0]
		cmp	eax, [ebp+nfiles]
		jb	loc_8006AFC
		jmp	short loc_8006C20
; ---------------------------------------------------------------------------

loc_8006BEF:				; CODE XREF: main+F69j
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aNoInputFromS ; "no input from %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8006C20:				; CODE XREF: main+498j	main+1098j
		mov	eax, ds:keylist
		mov	[ebp+key], eax
		jmp	loc_8006DEA
; ---------------------------------------------------------------------------

loc_8006C30:				; CODE XREF: main+129Cj
		mov	eax, [ebp+key]
		mov	eax, [eax+10h]
		test	eax, eax
		jnz	loc_8006DBD
		mov	eax, [ebp+key]
		mov	eax, [eax+14h]
		test	eax, eax
		jnz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+18h]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+25h]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+19h]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+24h]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ah]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+26h]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Ch]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Dh]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		xor	eax, 1
		test	al, al
		jz	loc_8006DBD
		mov	edx, [ebp+gkey.ignore]
		mov	eax, [ebp+key]
		mov	[eax+10h], edx
		mov	edx, [ebp+gkey.translate]
		mov	eax, [ebp+key]
		mov	[eax+14h], edx
		movzx	edx, [ebp+gkey.skipsblanks]
		mov	eax, [ebp+key]
		mov	[eax+18h], dl
		movzx	edx, [ebp+gkey.skipeblanks]
		mov	eax, [ebp+key]
		mov	[eax+19h], dl
		movzx	edx, [ebp+gkey.month]
		mov	eax, [ebp+key]
		mov	[eax+24h], dl
		movzx	edx, [ebp+gkey.numeric]
		mov	eax, [ebp+key]
		mov	[eax+1Ah], dl
		movzx	edx, [ebp+gkey.general_numeric]
		mov	eax, [ebp+key]
		mov	[eax+1Ch], dl
		movzx	edx, [ebp+gkey.human_numeric]
		mov	eax, [ebp+key]
		mov	[eax+1Dh], dl
		movzx	edx, [ebp+gkey.random]
		mov	eax, [ebp+key]
		mov	[eax+1Bh], dl
		movzx	edx, [ebp+gkey.reverse]
		mov	eax, [ebp+key]
		mov	[eax+25h], dl
		movzx	edx, [ebp+gkey.version]
		mov	eax, [ebp+key]
		mov	[eax+26h], dl

loc_8006DBD:				; CODE XREF: main+10E6j main+10F7j ...
		mov	eax, [ebp+key]
		movzx	eax, byte ptr [eax+1Bh]
		or	al, [ebp+need_random]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+need_random], al
		mov	eax, [ebp+key]
		mov	eax, [eax+28h]
		mov	[ebp+key], eax

loc_8006DEA:				; CODE XREF: main+10D6j
		cmp	[ebp+key], 0
		jnz	loc_8006C30
		mov	eax, ds:keylist
		test	eax, eax
		jnz	loc_8006E9D
		mov	eax, [ebp+gkey.ignore]
		test	eax, eax
		jnz	short loc_8006E70
		mov	eax, [ebp+gkey.translate]
		test	eax, eax
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.skipsblanks]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.skipeblanks]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.month]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.numeric]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.general_numeric]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.human_numeric]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.random]
		test	al, al
		jnz	short loc_8006E70
		movzx	eax, [ebp+gkey.version]
		test	al, al
		jz	short loc_8006E9D

loc_8006E70:				; CODE XREF: main+12B7j main+12C1j ...
		sub	esp, 0Ch
		lea	eax, [ebp+gkey]
		push	eax		; key_arg
		call	insertkey
		add	esp, 10h
		movzx	eax, [ebp+gkey.random]
		or	al, [ebp+need_random]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+need_random], al

loc_8006E9D:				; CODE XREF: main+12A9j main+1319j
		call	check_ordering_compatibility
		movzx	eax, [ebp+gkey.reverse]
		mov	ds:reverse, al
		cmp	[ebp+need_random], 0
		jz	short loc_8006EF7
		sub	esp, 8
		push	10h
		push	[ebp+random_source]
		call	randread_new
		add	esp, 10h
		mov	ds:randread_source_0, eax
		mov	eax, ds:randread_source_0
		test	eax, eax
		jnz	short loc_8006EF7
		sub	esp, 0Ch
		push	offset aOpenFailed ; "open failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+random_source] ; file
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_8006EF7:				; CODE XREF: main+1360j main+1381j
		mov	eax, ds:temp_dir_count
		test	eax, eax
		jnz	short loc_8006F38
		sub	esp, 0Ch
		push	offset aTmpdir	; "TMPDIR"
		call	getenv
		add	esp, 10h
		mov	[ebp+tmp_dir], eax
		cmp	[ebp+tmp_dir], 0
		jz	short loc_8006F27
		mov	eax, [ebp+tmp_dir]
		jmp	short loc_8006F2C
; ---------------------------------------------------------------------------

loc_8006F27:				; CODE XREF: main+13C8j
		mov	eax, offset aTmp ; "/tmp"

loc_8006F2C:				; CODE XREF: main+13D0j
		sub	esp, 0Ch
		push	eax		; dir
		call	add_temp_dir
		add	esp, 10h

loc_8006F38:				; CODE XREF: main+13A9j
		cmp	[ebp+nfiles], 0
		jnz	short loc_8006F66
		mov	[ebp+nfiles], 1
		sub	esp, 0Ch
		push	[ebp+files]	; ptr
		call	free
		add	esp, 10h
		mov	[ebp+files], offset minus_6986

loc_8006F66:				; CODE XREF: main+13EAj
		mov	eax, ds:sort_size
		test	eax, eax
		jz	short loc_8006F8F
		mov	edx, nmerge
		mov	eax, edx
		shl	eax, 3
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, ds:sort_size
		cmp	edx, eax
		cmovnb	eax, edx
		mov	ds:sort_size, eax

loc_8006F8F:				; CODE XREF: main+1418j
		cmp	[ebp+checkonly], 0
		jz	loc_800703E
		cmp	[ebp+nfiles], 1
		jbe	short loc_8006FE7
		movsx	ebx, [ebp+checkonly]
		mov	eax, [ebp+files]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aExtraOperandSN ; "extra	operand	%s not allowed with -%c"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h

loc_8006FE7:				; CODE XREF: main+144Ej
		cmp	[ebp+outfile], 0
		jz	short loc_8007009
		movzx	eax, [ebp+checkonly]
		mov	opts_6987, al
		sub	esp, 0Ch
		push	offset opts_6987 ; opts
		call	incompatible_options
; ---------------------------------------------------------------------------

loc_8007009:				; CODE XREF: main+1499j
		movsx	edx, [ebp+checkonly]
		mov	eax, [ebp+files]
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; checkonly
		push	eax		; file_name
		call	check
		add	esp, 10h
		test	al, al
		jz	short loc_8007030
		mov	eax, 0
		jmp	short loc_8007035
; ---------------------------------------------------------------------------

loc_8007030:				; CODE XREF: main+14D2j
		mov	eax, 1

loc_8007035:				; CODE XREF: main+14D9j
		sub	esp, 0Ch
		push	eax		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800703E:				; CODE XREF: main+1441j
		cmp	[ebp+mergeonly], 0
		jz	loc_80070D1
		sub	esp, 8
		push	8		; size_t
		push	[ebp+nfiles]	; size_t
		call	xcalloc
		add	esp, 10h
		mov	[ebp+sortfiles], eax
		mov	[ebp+i_1], 0
		jmp	short loc_80070A5
; ---------------------------------------------------------------------------

loc_8007070:				; CODE XREF: main+155Cj
		mov	eax, [ebp+i_1]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+sortfiles]
		add	edx, eax
		mov	eax, [ebp+i_1]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+files]
		add	eax, ecx
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+i_1], 1

loc_80070A5:				; CODE XREF: main+1519j
		mov	eax, [ebp+i_1]
		cmp	eax, [ebp+nfiles]
		jb	short loc_8007070
		push	[ebp+outfile]	; output_file
		push	[ebp+nfiles]	; nfiles
		push	0		; ntemps
		push	[ebp+sortfiles]	; files
		call	merge
		add	esp, 10h
		jmp	short loc_80070EE
; ---------------------------------------------------------------------------

loc_80070D1:				; CODE XREF: main+14F0j
		sub	esp, 4
		push	[ebp+outfile]	; output_file
		push	[ebp+nfiles]	; nfiles
		push	[ebp+files]	; files
		call	sort
		add	esp, 10h

loc_80070EE:				; CODE XREF: main+157Aj
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_800712D
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_800712D
		sub	esp, 0Ch
		push	offset aCloseFailed ; "close failed"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset file	; "-"
		push	eax		; message
		call	die
; ---------------------------------------------------------------------------

loc_800712D:				; CODE XREF: main+15A2j main+15B8j
		sub	esp, 0Ch
		push	0		; status

loc_8007132:				; DATA XREF: .eh_frame:08009650o
					; .eh_frame:08009670o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 8007140h
; char eolchar[2]
eolchar		db 0Ah,0		; DATA XREF: fillbuf+2Cr
					; main:loc_80068E9w
		align 20h
; month	monthtab[12]
monthtab	month <offset aApr, 4>	; DATA XREF: inittables+13Bw
					; inittables+1BAo ...
		month <offset aAug, 8>	; "APR"
		month <offset aDec, 0Ch>
		month <offset aFeb, 2>
		month <offset aJan, 1>
		month <offset aJul, 7>
		month <offset aJun, 6>
		month <offset aMar, 3>
		month <offset aMay, 5>
		month <offset aNov, 0Bh>
		month <offset aOct, 0Ah>
		month <offset aSep, 9>
; size_t merge_buffer_size
merge_buffer_size dd 40000h		; DATA XREF: fillbuf+3Fr fillbuf+37Dw	...
; int tab
tab		dd 80h			; DATA XREF: begfield+30r begfield+57r ...
; size_t nmerge
nmerge		dd 10h			; DATA XREF: specify_nmerge+72w
					; specify_nmerge+77r ...
; tempnode *volatile *temptail
temptail	dd offset temphead	; DATA XREF: create_temp_file+138r
					; create_temp_file+14Bw ...
; Function-local static	variable
; char *minus_6986
minus_6986	dd offset file		; DATA XREF: main+1407o
					; "-"
; Function-local static	variable
; char opts_6987[3]
opts_6987	db 0			; DATA XREF: main+14A2w main+14AAo
		db 6Fh,	0
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 80071E0h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; int decimal_point
decimal_point	dd ?			; DATA XREF: numcompare+58r
					; find_unit_order+37r ...
; int thousands_sep
thousands_sep	dd ?			; DATA XREF: numcompare+52r
					; find_unit_order+63r ...
; _Bool	hard_LC_COLLATE
hard_LC_COLLATE	db ?			; DATA XREF: compare_random+26r
					; keycompare:loc_80031B9r ...
; _Bool	hard_LC_TIME
hard_LC_TIME	db ?			; DATA XREF: inittables+DDr main+119w
		align 20h
; _Bool	blanks[256]
blanks		db 100h	dup(?)		; DATA XREF: inittables+32o
					; begfield+A8r	...
; _Bool	nonprinting[256]
nonprinting	db 100h	dup(?)		; DATA XREF: inittables+5Ao
					; check_ordering_compatibility+FFo ...
; _Bool	nondictionary[256]
nondictionary	db 100h	dup(?)		; DATA XREF: inittables+A9o
					; check_ordering_compatibility+A2o ...
; char fold_toupper[256]
fold_toupper	db 100h	dup(?)		; DATA XREF: inittables+C5o
					; inittables+183r ...
; size_t sort_size
sort_size	dd ?			; DATA XREF: specify_sort_size+1A7r
					; specify_sort_size+1CBw ...
; const	char **temp_dirs
temp_dirs	dd ?			; DATA XREF: create_temp_file+29r
					; add_temp_dir+15r ...
; size_t temp_dir_count
temp_dir_count	dd ?			; DATA XREF: create_temp_file+F3r
					; add_temp_dir+6r ...
; size_t temp_dir_alloc
temp_dir_alloc	dd ?			; DATA XREF: add_temp_dir+Cr
					; add_temp_dir+1Fo
; _Bool	reverse
reverse		db ?			; DATA XREF: compare:loc_8003BB7r
					; main+1354w
; _Bool	stable
stable		db ?			; DATA XREF: compare+34r
					; main:loc_800673Aw
; _Bool	unique
unique		db ?			; DATA XREF: compare+29r check+5Er ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: stream_open+34w
					; main:loc_8005D0Ew ...
; keyfield *keylist
keylist		dd ?			; DATA XREF: fillbuf+24r
					; keycompare+27r ...
; const	char *compress_program
compress_program dd ?			; DATA XREF: reap+38r
					; reap:loc_8000612r ...
		align 10h
; sigset_t caught_signals
caught_signals	sigset_t <?>		; DATA XREF: cs_enter+2Do main+1C8o ...
; tempnode *volatile temphead
temphead	dd ?			; DATA XREF: cleanup+6r cleanup+30w ...
; Hash_table *proctab
proctab		dd ?			; DATA XREF: register_proc+11r
					; register_proc+38w ...
; size_t nprocs
nprocs		dd ?			; DATA XREF: reap:loc_8000636r
					; reap+BDw ...
; randread_source *randread_source_0
randread_source_0 dd ?			; DATA XREF: random_state:loc_8002ADAr
					; main+1375w ...
; Function-local static	variable
; size_t temp_dir_index_6180
temp_dir_index_6180 dd ?		; DATA XREF: create_temp_file+2Er
					; create_temp_file+E0r	...
; Function-local static	variable
; size_t size_bound_6331
size_bound_6331	dd ?			; DATA XREF: sort_buffer_size:loc_8001DCAr
					; sort_buffer_size+183w ...
; Function-local static	variable
; md5_ctx *state_6499
state_6499	dd ?			; DATA XREF: random_state+1Ar
					; random_state+53r ...
; Function-local static	variable
; size_t used_6500
used_6500	dd ?			; DATA XREF: random_state+2Er
					; random_state+3Cr ...
; Function-local static	variable
; size_t allocated_6501
allocated_6501	dd ?			; DATA XREF: random_state+49r
					; random_state+60o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80076E0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+D0o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+DC2o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aApr		db 'APR',0              ; DATA XREF: .data:monthtabo
aAug		db 'AUG',0              ; DATA XREF: .data:monthtabo
aDec		db 'DEC',0              ; DATA XREF: .data:monthtabo
aFeb		db 'FEB',0              ; DATA XREF: .data:monthtabo
aJan		db 'JAN',0              ; DATA XREF: .data:monthtabo
aJul		db 'JUL',0              ; DATA XREF: .data:monthtabo
aJun		db 'JUN',0              ; DATA XREF: .data:monthtabo
aMar		db 'MAR',0              ; DATA XREF: .data:monthtabo
aMay		db 'MAY',0              ; DATA XREF: .data:monthtabo
aNov		db 'NOV',0              ; DATA XREF: .data:monthtabo
aOct		db 'OCT',0              ; DATA XREF: .data:monthtabo
aSep		db 'SEP',0              ; DATA XREF: .data:monthtabo
; char aStandardOutput[]
aStandardOutput	db 'standard output',0  ; DATA XREF: die+10o
; char format[]
format		db '%s: %s',0           ; DATA XREF: die+32o
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s [OPTION]... --files0-from=F',0Ah,0
		align 10h
; char aWriteSortedCon[]
aWriteSortedCon	db 'Write sorted concatenation of all FILE(s) to standard output.',0Ah
					; DATA XREF: usage+6Eo
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+91o
		db 'ns too.',0Ah,0
; char aOrderingOption[]
aOrderingOption	db 'Ordering options:',0Ah ; DATA XREF: usage+B4o
		db 0Ah,0
		align 10h
; char aBIgnoreLeading[]
aBIgnoreLeading	db '  -b, --ignore-leading-blanks  ignore leading blanks',0Ah
					; DATA XREF: usage+D7o
		db '  -d, --dictionary-order      consider only blanks and alphanumer'
		db 'ic characters',0Ah
		db '  -f, --ignore-case           fold lower case to upper case chara'
		db 'cters',0Ah,0
; char aGGeneralNumeri[]
aGGeneralNumeri	db '  -g, --general-numeric-sort  compare according to general numeri'
					; DATA XREF: usage+FAo
		db 'cal value',0Ah
		db '  -i, --ignore-nonprinting    consider only printable characters',0Ah
		db '  -M, --month-sort            compare (unknown) < `JAN',27h,' < ... '
		db '< `DEC',27h,0Ah,0
		align 10h
; char aHHumanNumericS[]
aHHumanNumericS	db '  -h, --human-numeric-sort    compare human readable numbers (e.g'
					; DATA XREF: usage+11Do
		db '., 2K 1G)',0Ah,0
; char aNNumericSortCo[]
aNNumericSortCo	db '  -n, --numeric-sort          compare according to string numeric'
					; DATA XREF: usage+140o
		db 'al value',0Ah
		db '  -R, --random-sort           sort by random hash of keys',0Ah
		db '      --random-source=FILE    get random bytes from FILE',0Ah
		db '  -r, --reverse               reverse the result of comparisons',0Ah
		db 0
		align 4
; char aSortWordSortAc[]
aSortWordSortAc	db '      --sort=WORD             sort according to WORD:',0Ah
					; DATA XREF: usage+163o
		db '                                general-numeric -g, human-numeric'
		db ' -h, month -M,',0Ah
		db '                                numeric -n, random -R, version -V'
		db 0Ah
		db '  -V, --version-sort          natural sort of (version) numbers w'
		db 'ithin text',0Ah
		db 0Ah,0
; char aOtherOptions[]
aOtherOptions	db 'Other options:',0Ah ; DATA XREF: usage+186o
		db 0Ah,0
		align 4
; char aBatchSizeNmerg[]
aBatchSizeNmerg	db '      --batch-size=NMERGE   merge at most NMERGE inputs at once;',0Ah
					; DATA XREF: usage+1A9o
		db '                            for more use temp files',0Ah,0
		align 4
; char aCCheckCheckDia[]
aCCheckCheckDia	db '  -c, --check, --check=diagnose-first  check for sorted input; do'
					; DATA XREF: usage+1CCo
		db ' not sort',0Ah
		db '  -C, --check=quiet, --check=silent  like -c, but do not report f'
		db 'irst bad line',0Ah
		db '      --compress-program=PROG  compress temporaries with PROG;',0Ah
		db '                              decompress them with PROG -d',0Ah
		db '      --files0-from=F       read input from the files specified b'
		db 'y',0Ah
		db '                            NUL-terminated names in file F;',0Ah
		db '                            If F is - then read names from standa'
		db 'rd input',0Ah,0
		align 4
; char aKKeyPos1Pos2St[]
aKKeyPos1Pos2St	db '  -k, --key=POS1[,POS2]     start a key at POS1 (origin 1), end i'
					; DATA XREF: usage+1EFo
		db 't at POS2',0Ah
		db '                            (default end of line)',0Ah
		db '  -m, --merge               merge already sorted files; do not so'
		db 'rt',0Ah,0
		align 10h
; char aOOutputFileWri[]
aOOutputFileWri	db '  -o, --output=FILE         write result to FILE instead of stand'
					; DATA XREF: usage+212o
		db 'ard output',0Ah
		db '  -s, --stable              stabilize sort by disabling last-reso'
		db 'rt comparison',0Ah
		db '  -S, --buffer-size=SIZE    use SIZE for main memory buffer',0Ah,0
; char aTFieldSeparato[]
aTFieldSeparato	db '  -t, --field-separator=SEP  use SEP instead of non-blank to blan'
					; DATA XREF: usage+22Fo
		db 'k transition',0Ah
		db '  -T, --temporary-directory=DIR  use DIR for temporaries, not $TM'
		db 'PDIR or %s;',0Ah
		db '                              multiple options specify multiple d'
		db 'irectories',0Ah
		db '  -u, --unique              with -c, check for strict ordering;',0Ah
		db '                              without -c, output only the first o'
		db 'f an equal run',0Ah,0
aTmp		db '/tmp',0             ; DATA XREF: usage+23Fo
					; main:loc_8006F27o
		align 4
; char aZZeroTerminate[]
aZZeroTerminate	db '  -z, --zero-terminated     end lines with 0 byte, not newline',0Ah,0
					; DATA XREF: usage+256o
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+279o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+29Co
		align 10h
; char aPosIsF_cOptsWh[]
aPosIsF_cOptsWh	db 0Ah			; DATA XREF: usage+2BFo
		db 'POS is F[.C][OPTS], where F is the field number and C the charact'
		db 'er position',0Ah
		db 'in the field; both are origin 1.  If neither -t nor -b is in effe'
		db 'ct, characters',0Ah
		db 'in a field are counted from the beginning of the preceding whites'
		db 'pace.  OPTS is',0Ah
		db 'one or more single-letter ordering options, which override global'
		db ' ordering',0Ah
		db 'options for that key.  If no key is given, use the entire line as'
		db ' the key.',0Ah
		db 0Ah
		db 'SIZE may be followed by the following multiplicative suffixes:',0Ah,0
		align 4
; char a1OfMemoryB1K10[]
a1OfMemoryB1K10	db '% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, '
					; DATA XREF: usage+2E2o
		db 'E, Z, Y.',0Ah
		db 0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah
		db '*** WARNING ***',0Ah
		db 'The locale specified by the environment affects sort order.',0Ah
		db 'Set LC_ALL=C to get the traditional sort order that uses',0Ah
		db 'native byte values.',0Ah,0
; char short_options[31]
short_options	db '-bcCdfghik:mMno:rRsS:t:T:uVy:z',0 ; DATA XREF: main+45Eo
aIgnoreLeadingB	db 'ignore-leading-blanks',0 ; DATA XREF: .rodata:long_optionso
aCheck_0	db 'check',0            ; DATA XREF: .rodata:long_optionso
aCompressProgra	db 'compress-program',0 ; DATA XREF: .rodata:long_optionso
aDictionaryOrde	db 'dictionary-order',0 ; DATA XREF: .rodata:long_optionso
aIgnoreCase	db 'ignore-case',0      ; DATA XREF: .rodata:long_optionso
aFiles0From	db 'files0-from',0      ; DATA XREF: .rodata:long_optionso
aGeneralNumeric	db 'general-numeric-sort',0 ; DATA XREF: .rodata:long_optionso
aIgnoreNonprint	db 'ignore-nonprinting',0 ; DATA XREF: .rodata:long_optionso
aKey		db 'key',0              ; DATA XREF: .rodata:long_optionso
aMerge		db 'merge',0            ; DATA XREF: .rodata:long_optionso
aMonthSort	db 'month-sort',0       ; DATA XREF: .rodata:long_optionso
aNumericSort	db 'numeric-sort',0     ; DATA XREF: .rodata:long_optionso
aHumanNumericSo	db 'human-numeric-sort',0 ; DATA XREF: .rodata:long_optionso
aVersionSort	db 'version-sort',0     ; DATA XREF: .rodata:long_optionso
aRandomSort	db 'random-sort',0      ; DATA XREF: .rodata:long_optionso
aRandomSource	db 'random-source',0    ; DATA XREF: .rodata:long_optionso
aSort_0		db 'sort',0             ; DATA XREF: main+DC7o
					; .rodata:long_optionso
aOutput		db 'output',0           ; DATA XREF: .rodata:long_optionso
aReverse	db 'reverse',0          ; DATA XREF: .rodata:long_optionso
aStable		db 'stable',0           ; DATA XREF: .rodata:long_optionso
aBatchSize	db 'batch-size',0       ; DATA XREF: .rodata:long_optionso
aBufferSize	db 'buffer-size',0      ; DATA XREF: .rodata:long_optionso
aFieldSeparator	db 'field-separator',0  ; DATA XREF: .rodata:long_optionso
aTemporaryDirec	db 'temporary-directory',0 ; DATA XREF: .rodata:long_optionso
aUnique		db 'unique',0           ; DATA XREF: .rodata:long_optionso
aZeroTerminated	db 'zero-terminated',0  ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
					; .rodata:sort_argso
		align 20h
; const	option long_options[29]
long_options	option <offset aIgnoreLeadingB,	0, 0, 62h> ; DATA XREF:	specify_nmerge+C5o
					; specify_nmerge+106o ...
		option <offset aCheck_0, 2, 0, 80h> ; "ignore-leading-blanks"
		option <offset aCompressProgra,	1, 0, 81h>
		option <offset aDictionaryOrde,	0, 0, 64h>
		option <offset aIgnoreCase, 0, 0, 66h>
		option <offset aFiles0From, 1, 0, 82h>
		option <offset aGeneralNumeric,	0, 0, 67h>
		option <offset aIgnoreNonprint,	0, 0, 69h>
		option <offset aKey, 1,	0, 6Bh>
		option <offset aMerge, 0, 0, 6Dh>
		option <offset aMonthSort, 0, 0, 4Dh>
		option <offset aNumericSort, 0,	0, 6Eh>
		option <offset aHumanNumericSo,	0, 0, 68h>
		option <offset aVersionSort, 0,	0, 56h>
		option <offset aRandomSort, 0, 0, 52h>
		option <offset aRandomSource, 1, 0, 84h>
		option <offset aSort_0,	1, 0, 85h>
		option <offset aOutput,	1, 0, 6Fh>
		option <offset aReverse, 0, 0, 72h>
		option <offset aStable,	0, 0, 73h>
		option <offset aBatchSize, 1, 0, 83h>
		option <offset aBufferSize, 1, 0, 53h>
		option <offset aFieldSeparator,	1, 0, 74h>
		option <offset aTemporaryDirec,	1, 0, 54h>
		option <offset aUnique,	0, 0, 75h>
		option <offset aZeroTerminated,	0, 0, 7Ah>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
aQuiet		db 'quiet',0            ; DATA XREF: .rodata:check_argso
aSilent		db 'silent',0           ; DATA XREF: .rodata:check_argso
aDiagnoseFirst	db 'diagnose-first',0   ; DATA XREF: .rodata:check_argso
; const	char *const check_args[4]
check_args	dd offset aQuiet, offset aSilent, offset aDiagnoseFirst
					; DATA XREF: main+82Bo
		dd 0			; "quiet"
; char check_types[19]
check_types	db 'CCcgeneral-numeric',0 ; DATA XREF: main+826o main+83Er ...
aHumanNumeric	db 'human-numeric',0    ; DATA XREF: .rodata:sort_argso
aMonth		db 'month',0            ; DATA XREF: .rodata:sort_argso
aNumeric	db 'numeric',0          ; DATA XREF: .rodata:sort_argso
aRandom		db 'random',0           ; DATA XREF: .rodata:sort_argso
		align 4
; const	char *const sort_args[7]
sort_args	dd offset check_types+3, offset	aHumanNumeric, offset aMonth
					; DATA XREF: main+7BFo
		dd offset aNumeric, offset aRandom, offset aVersion, 0 ; "version"
; char sort_types[26]
sort_types	db 'ghMnRVwaiting for %s [-d]',0 ; DATA XREF: main+7BAo
					; main+7D2r ...
; char aSDTerminatedAb[]
aSDTerminatedAb	db '%s [-d] terminated abnormally',0 ; DATA XREF: reap+9Ao
; char aCannotCreateTe[]
aCannotCreateTe	db 'cannot create temporary file in %s',0 ; DATA XREF: create_temp_file+1D0o
; char file[]
file		db '-',0                ; DATA XREF: stream_open+16o
					; sort_buffer_size+ACo	...
; char aOpenFailed[]
aOpenFailed	db 'open failed',0      ; DATA XREF: xfopen+23o mergefiles+5Eo ...
; char aFflushFailed[]
aFflushFailed	db 'fflush failed',0    ; DATA XREF: xfclose+56o
; char aCloseFailed[]
aCloseFailed	db 'close failed',0     ; DATA XREF: xfclose+84o main+15BDo
; char aDup2Failed[]
aDup2Failed	db 'dup2 failed',0      ; DATA XREF: dup2_or_die+1Fo
; char aCouldnTExecute[]
aCouldnTExecute	db 'couldn',27h,'t execute %s',0 ; DATA XREF: maybe_create_temp+144o
; char modes[]
modes		db 'w',0                ; DATA XREF: maybe_create_temp+179o
					; merge+237o ...
		align 4
; char aCouldnTCreateT[]
aCouldnTCreateT	db 'couldn',27h,'t create temporary file',0
					; DATA XREF: maybe_create_temp+19Ao
		align 4
; char aCouldnTCreateP[]
aCouldnTCreateP	db 'couldn',27h,'t create process for %s -d',0 ; DATA XREF: open_temp+85o
aD		db '-d',0               ; DATA XREF: open_temp+120o
; char aCouldnTExecu_0[]
aCouldnTExecu_0	db 'couldn',27h,'t execute %s -d',0 ; DATA XREF: open_temp+138o
; char how[]
how		db 'r',0                ; DATA XREF: open_temp+17Eo check+2Bo ...
; char aWriteFailed[]
aWriteFailed	db 'write failed',0     ; DATA XREF: write_bytes+21o
; char aWarningCannotR[]
aWarningCannotR	db 'warning: cannot remove: %s',0 ; DATA XREF: zaptemp+EAo
; char aInvalidSArgume[]
aInvalidSArgume	db 'invalid --%s argument %s',0 ; DATA XREF: specify_nmerge+CFo
a2		db '2',0                ; DATA XREF: specify_nmerge+F1o
; char aMinimumSArgume[]
aMinimumSArgume	db 'minimum --%s argument is %s',0 ; DATA XREF: specify_nmerge+110o
; char aSArgumentSTooL[]
aSArgumentSTooL	db '--%s argument %s too large',0 ; DATA XREF: specify_nmerge+170o
; char aMaximumSArgume[]
aMaximumSArgume	db 'maximum --%s argument with current rlimit is %s',0
					; DATA XREF: specify_nmerge+1B3o
aEggkkmmpttyz	db 'EgGkKmMPtTYZ',0     ; DATA XREF: specify_sort_size+22o
; char aStatFailed[]
aStatFailed	db 'stat failed',0      ; DATA XREF: sort_buffer_size+120o
; char aReadFailed[]
aReadFailed	db 'read failed',0      ; DATA XREF: fillbuf+18Eo
		align 4
; char aBothSiAndIecPr[]
aBothSiAndIecPr	db 'both SI and IEC prefixes present on units',0
					; DATA XREF: check_mixed_SI_IEC+32o
; char aSSSDisorder[]
aSSSDisorder	db '%s: %s:%s: disorder: ',0 ; DATA XREF: check+167o
; char aStandardError[]
aStandardError	db 'standard error',0   ; DATA XREF: check+193o
		align 4
; char aSInvalidFieldS[]
aSInvalidFieldS	db '%s: invalid field specification %s',0 ; DATA XREF: badfieldspec+28o
		align 4
; char aOptionsSAreInc[]
aOptionsSAreInc	db 'options `-%s',27h,' are incompatible',0
					; DATA XREF: incompatible_options+9o
; char locale
locale		db 0			; DATA XREF: parse_field_count+28o
					; main+B9o
; char aSInvalidCountA[]
aSInvalidCountA	db '%s: invalid count at start of %s',0 ; DATA XREF: parse_field_count+B3o
		align 10h
off_8008D00	dd offset loc_800597C	; DATA XREF: parse_field_count+4Br
		dd offset loc_80059A7	; jump table for switch	statement
		dd offset loc_800597C
		dd offset loc_80059A7
		dd offset loc_80059B2
off_8008D14	dd offset loc_8005AD7	; DATA XREF: set_ordering+1Dr
		dd offset loc_8005B04	; jump table for switch	statement
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005AE9
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005AFB
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005A6F
		dd offset loc_8005B04
		dd offset loc_8005A97
		dd offset loc_8005B04
		dd offset loc_8005AA3
		dd offset loc_8005AAF
		dd offset loc_8005AB8
		dd offset loc_8005AC1
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005AE0
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005B04
		dd offset loc_8005AF2
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: main+63o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+CBo
; char aInvalidNumberA[]
aInvalidNumberA	db 'invalid number after `-',27h,0 ; DATA XREF: main+6E2o
; char aInvalidNumbe_0[]
aInvalidNumbe_0	db 'invalid number after `.',27h,0 ; DATA XREF: main+719o
					; main+976o ...
; char aStrayCharacter[]
aStrayCharacter	db 'stray character in field spec',0 ; DATA XREF: main+751o
					; main+AE8o
aSort		db '--sort',0           ; DATA XREF: main+7C5o
aCheck		db '--check',0          ; DATA XREF: main+831o
; char opts[]
opts		db 'cC',0               ; DATA XREF: main+870o
		align 4
; char aMultipleCompre[]
aMultipleCompre	db 'multiple compress programs specified',0 ; DATA XREF: main+8B3o
; char aInvalidNumbe_1[]
aInvalidNumbe_1	db 'invalid number at field start',0 ; DATA XREF: main+915o
; char aFieldNumberIsZ[]
aFieldNumberIsZ	db 'field number is zero',0 ; DATA XREF: main+949o main+A72o
; char aCharacterOffse[]
aCharacterOffse	db 'character offset is zero',0 ; DATA XREF: main+9ACo
; char aInvalidNumbe_2[]
aInvalidNumbe_2	db 'invalid number after `,',27h,0 ; DATA XREF: main+A3Co
		align 4
; char aMultipleOutput[]
aMultipleOutput	db 'multiple output files specified',0 ; DATA XREF: main+B64o
; char aMultipleRandom[]
aMultipleRandom	db 'multiple random sources specified',0 ; DATA XREF: main+BB8o
; char aEmptyTab[]
aEmptyTab	db 'empty tab',0        ; DATA XREF: main+C33o
; char a0[]
a0		db '\0',0               ; DATA XREF: main+C67o
; char aMultiCharacter[]
aMultiCharacter	db 'multi-character tab %s',0 ; DATA XREF: main+C98o
; char aIncompatibleTa[]
aIncompatibleTa	db 'incompatible tabs',0 ; DATA XREF: main+CD2o
aPaulEggert	db 'Paul Eggert',0      ; DATA XREF: main+DB7o
aMikeHaertel	db 'Mike Haertel',0     ; DATA XREF: main+DBCo
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+E17o
		align 4
; char aFileOperandsCa[]
aFileOperandsCa	db 'file operands cannot be combined with --files0-from',0
					; DATA XREF: main+E35o
; char aS[]
aS		db '%s',0Ah,0           ; DATA XREF: main+E4Do
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: main+EC7o
		align 4
; char aCannotReadFile[]
aCannotReadFile	db 'cannot read file names from %s',0 ; DATA XREF: main+F46o
		align 4
; char aWhenReadingFil[]
aWhenReadingFil	db 'when reading file names from stdin, no file name of %s allowed',0
					; DATA XREF: main+FFBo
		align 4
; char aSLuInvalidZero[]
aSLuInvalidZero	db '%s:%lu: invalid zero-length file name',0 ; DATA XREF: main+105Bo
; char aNoInputFromS[]
aNoInputFromS	db 'no input from %s',0 ; DATA XREF: main+10B0o
; char aTmpdir[]
aTmpdir		db 'TMPDIR',0           ; DATA XREF: main+13AEo
		align 4
; char aExtraOperandSN[]
aExtraOperandSN	db 'extra operand %s not allowed with -%c',0 ; DATA XREF: main+1473o
		align 4
off_8009084	dd offset loc_80068FC, offset loc_80068F2, offset loc_8006934
					; DATA XREF: main+4F8r
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934 ;	jump table for switch statement
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006056, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_80063AA, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006337, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006337, offset loc_8006746, offset loc_8006855
		dd offset loc_8006934, offset loc_8006337, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006337, offset loc_80063AA
		dd offset loc_8006337, offset loc_8006934, offset loc_8006337
		dd offset loc_8006337, offset loc_8006337, offset loc_8006337
		dd offset loc_8006934, offset loc_8006444, offset loc_8006934
		dd offset loc_800665E, offset loc_8006337, offset loc_8006692
		dd offset loc_8006934, offset loc_8006934, offset loc_8006337
		dd offset loc_800673A, offset loc_800676E, offset loc_800686B
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006877, offset loc_80068E9, offset loc_8006934
		dd offset loc_8006934, offset loc_8006934, offset loc_8006934
		dd offset loc_8006934, offset loc_8006361, offset loc_80063E0
		dd offset loc_8006434, offset loc_800666A, offset loc_80066E6
		dd offset loc_80062FE
; Function-local static	variable
; const	char slashbase_6179[12]
slashbase_6179	dd 726F732Fh		; DATA XREF: create_temp_file+ADr
dword_80094AC	dd 58585874h		; DATA XREF: create_temp_file+B5r
dword_80094B0	dd 585858h		; DATA XREF: create_temp_file+BEr
		align 10h
; Function-local static	variable
; const	char orders_6451[256]
orders_6451	db 0			; DATA XREF: find_unit_order+9Er
		align 4
		dd 10h dup(0)
		dd 3000600h, 1000000h, 200h, 5,	4, 70800h, 3 dup(0)
		dd 1000000h, 25h dup(0)
; Function-local static	variable
; const	int sig_6920[11]
sig_6920	dd 0Eh			; DATA XREF: main+1E7r	main+214r ...
		dd 1, 2, 0Dh, 3, 0Fh, 1Dh, 1Bh,	1Ah, 18h, 19h, 0
dbl_80095F0	dq 0.25			; DATA XREF: pipe_fork+20r
		align 10h
tbyte_8009600	dt 1.8446744073709551616e19 ; DATA XREF: specify_sort_size+F1r
		align 10h
dbl_8009610	dq 100.0		; DATA XREF: specify_sort_size+101r
dbl_8009618	dq 1.844674407370955e19	; DATA XREF: specify_sort_size+10Cr
dbl_8009620	dq 9.223372036854776e18	; DATA XREF: specify_sort_size+120r
					; specify_sort_size+152r
dbl_8009628	dq 8.0			; DATA XREF: default_sort_size+25r
					; default_sort_size+3Er
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8009630h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8007132-8010782h
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 1Ch, 3Ch
		dd offset loc_8007132-801078Eh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 5Ch
		dd offset loc_8007132-801079Ch
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	80h
		dd offset loc_8007132-80106A4h
		dd 4Ch,	80E4100h, 0D420285h, 3834405h, 1Ch, 9Ch
		dd offset loc_8007132-8010674h
		dd 30Ch, 80E4100h, 0D420285h, 3864205h,	483h, 28h, 0BCh
		dd offset loc_8007132-8010388h
		dd 83h,	80E4100h, 0D420285h, 3874905h, 5830486h, 41C37102h
		dd 41C741C6h, 4040CC5h,	1Ch, 0E8h
		dd offset loc_8007132-8010331h
		dd 24h,	80E4100h, 0D420285h, 0CC56005h,	404h, 1Ch, 108h
		dd offset loc_8007132-801032Dh
		dd 1Dh,	80E4100h, 0D420285h, 0CC55905h,	404h, 1Ch, 128h
		dd offset loc_8007132-8010330h
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 24h, 148h
		dd offset loc_8007132-801032Dh
		dd 0DDh, 80E4100h, 0D420285h, 3864505h,	0D2020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 170h
		dd offset loc_8007132-8010278h
		dd 0E7h, 80E4100h, 0D420285h, 0C5E30205h, 4040Ch, 1Ch
		dd 190h
		dd offset loc_8007132-80101B1h
		dd 53h,	80E4100h, 0D420285h, 0C54F0205h, 4040Ch, 1Ch, 1B0h
		dd offset loc_8007132-801017Eh
		dd 0A0h, 80E4100h, 0D420285h, 0C59C0205h, 4040Ch, 1Ch
		dd 1D0h
		dd offset loc_8007132-80100FEh
		dd 38h,	80E4100h, 0D420285h, 0CC57405h,	404h, 1Ch, 1F0h
		dd offset loc_8007132-80100E6h
		dd 3Dh,	80E4100h, 0D420285h, 0CC57905h,	404h, 28h, 210h
		dd offset loc_8007132-80100C9h
		dd 81h,	80E4100h, 0D420285h, 3874905h, 5830486h, 41C37102h
		dd 41C741C6h, 4040CC5h,	2Ch, 23Ch
		dd offset loc_8007132-8010074h
		dd 23Bh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3022B03h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 26Ch
		dd offset loc_8007132-800FE69h
		dd 55h,	80E4100h, 0D420285h, 0C5510205h, 4040Ch, 1Ch, 28Ch
		dd offset loc_8007132-800FE34h
		dd 41h,	80E4100h, 0D420285h, 0CC57D05h,	404h, 1Ch, 2ACh
		dd offset loc_8007132-800FE13h
		dd 0A7h, 80E4100h, 0D420285h, 0C5A30205h, 4040Ch, 20h
		dd 2CCh
		dd offset loc_8007132-800FD8Ch
		dd 4Ah,	80E4100h, 0D420285h, 3834405h, 0C3C54202h, 4040Ch
		dd 2Ch,	2F0h
		dd offset loc_8007132-800FD66h
		dd 1CFh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C301BF03h
		dd 0C741C641h, 40CC541h, 4, 28h, 320h
		dd offset loc_8007132-800FBC7h
		dd 1DFh, 80E4100h, 0D420285h, 3864505h,	0D4030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 34Ch
		dd offset loc_8007132-800FA14h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55705h,	404h, 28h, 36Ch
		dd offset loc_8007132-800FA19h
		dd 1D6h, 80E4100h, 0D420285h, 3864505h,	0CB030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 398h
		dd offset loc_8007132-800F86Fh
		dd 3Dh,	80E4100h, 0D420285h, 0CC57905h,	404h, 1Ch, 3B8h
		dd offset loc_8007132-800F852h
		dd 54h,	80E4100h, 0D420285h, 0C5500205h, 4040Ch, 2Ch, 3D8h
		dd offset loc_8007132-800F81Eh
		dd 14Dh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3013D03h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 408h
		dd offset loc_8007132-800F701h
		dd 2Bh,	80E4100h, 0D420285h, 0CC56705h,	404h, 20h, 428h
		dd offset loc_8007132-800F6F6h
		dd 1CDh, 80E4100h, 0D420285h, 3834405h,	0C501C503h, 4040CC3h
		dd 28h,	44Ch
		dd offset loc_8007132-800F54Dh
		dd 208h, 80E4100h, 0D420285h, 3864505h,	0FD030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 478h
		dd offset loc_8007132-800F371h
		dd 24Bh, 80E4100h, 0D420285h, 3864505h,	40030483h, 0C641C302h
		dd 40CC541h, 4,	20h, 4A4h
		dd offset loc_8007132-800F152h
		dd 19Dh, 80E4100h, 0D420285h, 3834405h,	0C5019503h, 4040CC3h
		dd 20h,	4C8h
		dd offset loc_8007132-800EFD9h
		dd 218h, 80E4100h, 0D420285h, 3834705h,	0C5020D03h, 4040CC3h
		dd 1Ch,	4ECh
		dd offset loc_8007132-800EDE5h
		dd 87h,	80E4100h, 0D420285h, 0C5830205h, 4040Ch, 1Ch, 50Ch
		dd offset loc_8007132-800ED7Eh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 1Ch, 52Ch
		dd offset loc_8007132-800ED8Ch
		dd 14Ah, 80E4100h, 0D420285h, 1460305h,	4040CC5h, 1Ch
		dd 54Ch
		dd offset loc_8007132-800EC62h
		dd 167h, 80E4100h, 0D420285h, 1630305h,	4040CC5h, 20h
		dd 56Ch
		dd offset loc_8007132-800EB1Bh
		dd 3DCh, 80E4100h, 0D420285h, 3834405h,	0C503D403h, 4040CC3h
		dd 1Ch,	590h
		dd offset loc_8007132-800E763h
		dd 6Fh,	80E4100h, 0D420285h, 0C56B0205h, 4040Ch, 1Ch, 5B0h
		dd offset loc_8007132-800E714h
		dd 5Bh,	80E4100h, 0D420285h, 0C5570205h, 4040Ch, 1Ch, 5D0h
		dd offset loc_8007132-800E6D9h
		dd 0D5h, 80E4100h, 0D420285h, 0C5D10205h, 4040Ch, 1Ch
		dd 5F0h
		dd offset loc_8007132-800E624h
		dd 0B5h, 80E4100h, 0D420285h, 0C5B10205h, 4040Ch, 1Ch
		dd 610h
		dd offset loc_8007132-800E58Fh
		dd 128h, 80E4100h, 0D420285h, 1240305h,	4040CC5h, 20h
		dd 630h
		dd offset loc_8007132-800E487h
		dd 144h, 80E4100h, 0D420285h, 3834405h,	0C5013C03h, 4040CC3h
		dd 28h,	654h
		dd offset loc_8007132-800E367h
		dd 0F3h, 80E4100h, 0D420285h, 3874605h,	5830486h, 41C3E402h
		dd 41C741C6h, 4040CC5h,	28h, 680h
		dd offset loc_8007132-800E2A0h
		dd 177h, 80E4100h, 0D420285h, 3874805h,	69030486h, 0C741C601h
		dd 40CC541h, 4,	1Ch, 6ACh
		dd offset loc_8007132-800E155h
		dd 1ECh, 80E4100h, 0D420285h, 1E80305h,	4040CC5h, 1Ch
		dd 6CCh
		dd offset loc_8007132-800DF89h
		dd 6Dh,	80E4100h, 0D420285h, 0C5690205h, 4040Ch, 20h, 6ECh
		dd offset loc_8007132-800DF3Ch
		dd 0BA4h, 80E4100h, 0D420285h, 3834705h, 0C50B9903h, 4040CC3h
		dd 1Ch,	710h
		dd offset loc_8007132-800D3BCh
		dd 115h, 80E4100h, 0D420285h, 1110305h,	4040CC5h, 28h
		dd 730h
		dd offset loc_8007132-800D2C7h
		dd 30Dh, 80E4100h, 0D420285h, 3864805h,	0FF030483h, 0C641C302h
		dd 40CC541h, 4,	20h, 75Ch
		dd offset loc_8007132-800CFE6h
		dd 0DEh, 80E4100h, 0D420285h, 3834405h,	0C3C5D602h, 4040Ch
		dd 20h,	780h
		dd offset loc_8007132-800CF2Ch
		dd 97Bh, 80E4100h, 0D420285h, 3834405h,	0C5097303h, 4040CC3h
		dd 20h,	7A4h
		dd offset loc_8007132-800C5D5h
		dd 0ACh, 80E4100h, 0D420285h, 3834405h,	0C3C5A402h, 4040Ch
		dd 1Ch,	7C8h
		dd offset loc_8007132-800C54Dh
		dd 0B1h, 80E4100h, 0D420285h, 0C5AD0205h, 4040Ch, 1Ch
		dd 7E8h
		dd offset loc_8007132-800C4BCh
		dd 126h, 80E4100h, 0D420285h, 1220305h,	4040CC5h, 1Ch
		dd 808h
		dd offset loc_8007132-800C3B6h
		dd 116h, 80E4100h, 0D420285h, 1120305h,	4040CC5h, 28h
		dd 828h
		dd offset loc_8007132-800C2C0h
		dd 32Eh, 80E4100h, 0D420285h, 3864805h,	20030483h, 0C641C303h
		dd 40CC541h, 4,	28h, 854h
		dd offset loc_8007132-800BFBEh
		dd 3D0h, 80E4100h, 0D420285h, 3864505h,	0C5030483h, 0C641C303h
		dd 40CC541h, 4,	1Ch, 880h
		dd offset loc_8007132-800BC1Ah
		dd 2F3h, 80E4100h, 0D420285h, 2EF0305h,	4040CC5h, 1Ch
		dd 8A0h
		dd offset loc_8007132-800B947h
		dd 4Bh,	80E4100h, 0D420285h, 0C5470205h, 4040Ch, 1Ch, 8C0h
		dd offset loc_8007132-800B91Ch
		dd 4Ch,	80E4100h, 0D420285h, 3864205h, 483h, 18h, 8E0h
		dd offset loc_8007132-800B8F0h
		dd 2Bh,	80E4100h, 0D420285h, 5,	1Ch, 8FCh
		dd offset loc_8007132-800B8E1h
		dd 1A7h, 80E4100h, 0D420285h, 1A30305h,	4040CC5h, 24h
		dd 91Ch
		dd offset loc_8007132-800B75Ah
		dd 0F5h, 80E4100h, 0D420285h, 3864505h,	0EA020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 944h
		dd offset loc_8007132-800B68Dh
		dd 2Ch,	80E4100h, 0D420285h, 0CC56805h,	404h, 1Ch, 964h
		dd offset loc_8007132-800B681h
		dd 0DBh, 80E4100h, 0D420285h, 0C5D70205h, 4040Ch, 1Ch
		dd 984h
		dd offset loc_8007132-800B5C6h
		dd 31h,	80E4100h, 0D420285h, 0CC56D05h,	404h, 2Ch, 9A4h
		dd offset loc_8007132-800B5B5h
		dd 15E2h, 10C4400h, 5104700h, 46007502h, 7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+C0p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: die:loc_8000166p
					; reap+50p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: die+3Ap reap+5Cp	...
; void exit(int	status)
		extrn exit:near		; CODE XREF: die+47p usage+307p ...
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r	check+176r ...
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep	check+188p ...
; int sigprocmask(int how, const sigset_t *set,	sigset_t *oset)
		extrn sigprocmask:near	; CODE XREF: cs_enter+34p cs_leave+19p
		extrn __stack_chk_fail:near ; CODE XREF: cs_enter+74p reap+D1p ...
; __pid_t waitpid(__pid_t pid, int *stat_loc, int options)
		extrn waitpid:near	; CODE XREF: reap+27p
; void free(void *ptr)
		extrn free:near		; CODE XREF: wait_proc+84p
					; create_temp_file+1FCp ...
		extrn hash_initialize:near ; CODE XREF:	register_proc+30p
		extrn xalloc_die:near	; CODE XREF: register_proc+46p
					; register_proc+CEp ...
		extrn hash_lookup:near	; CODE XREF: register_proc+5Ep
					; update_proc+24p ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: register_proc+8Fp
					; create_temp_file+65p	...
		extrn hash_insert:near	; CODE XREF: register_proc+C2p
		extrn hash_delete:near	; CODE XREF: wait_proc+76p
; int unlink(const char	*name)
		extrn unlink:near	; CODE XREF: cleanup+1Ap zaptemp+8Ap
		extrn close_stdout:near	; CODE XREF: exit_cleanup:loc_800090Fp
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: create_temp_file+4Ap
					; inittables+115p
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: create_temp_file+97p
					; check+256p ...
		extrn mkstemp_safer:near ; CODE	XREF: create_temp_file+121p
		extrn quote:near	; CODE XREF: create_temp_file+1C3p
					; specify_nmerge+B5p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: stream_open+1Ep
					; struct_month_cmp+21p	...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: stream_open+3Br main+E7Fr ...
		extrn fopen_safer:near	; CODE XREF: stream_open+4Bp main+E9Ap
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: xfclose+Cp
					; sort_buffer_size+71p
; int feof_unlocked(FILE *stream)
		extrn feof_unlocked:near ; CODE	XREF: xfclose+25p fillbuf+1ADp
; void clearerr_unlocked(FILE *stream)
		extrn clearerr_unlocked:near ; CODE XREF: xfclose+37p
; int fflush_unlocked(FILE *stream)
		extrn fflush_unlocked:near ; CODE XREF:	xfclose+47p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: xfclose+75p main+F24p ...
; int dup2(int fd, int fd2)
		extrn dup2:near		; CODE XREF: dup2_or_die+10p
; int pipe(int *pipedes)
		extrn pipe:near		; CODE XREF: pipe_fork+35p
; __pid_t fork(void)
		extrn fork:near		; CODE XREF: pipe_fork+76p
		extrn xnanosleep:near	; CODE XREF: pipe_fork+100p
; int close(int	fd)
		extrn close:near	; CODE XREF: pipe_fork+14Ep
					; pipe_fork+165p ...
; int execlp(const char	*file, const char *arg,	...)
		extrn execlp:near	; CODE XREF: maybe_create_temp+12Fp
					; open_temp+127p
; FILE *fdopen(int fd, const char *modes)
		extrn fdopen:near	; CODE XREF: maybe_create_temp+17Fp
					; open_temp+184p
		extrn open64:near	; CODE XREF: open_temp+36p
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	write_bytes+11p
		extrn x2nrealloc:near	; CODE XREF: add_temp_dir+25p
					; fillbuf+3A4p	...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: inittables:loc_80014ABp
					; inittables+39p ...
; int toupper(int c)
		extrn toupper:near	; CODE XREF: inittables+B8p
; char *nl_langinfo(nl_item item)
		extrn nl_langinfo:near	; CODE XREF: inittables+104p
; void qsort(void *base, size_t	nmemb, size_t size, __compar_fn_t compar)
		extrn qsort:near	; CODE XREF: inittables+1BFp
		extrn xstrtoumax:near	; CODE XREF: specify_nmerge+2Fp
					; specify_sort_size+34p ...
		extrn getrlimit64:near	; CODE XREF: specify_nmerge+43p
					; default_sort_size+9Dp ...
		extrn uinttostr:near	; CODE XREF: specify_nmerge+199p
		extrn xstrtol_fatal:near ; CODE	XREF: specify_nmerge+1EAp
					; specify_sort_size+22Dp
; double physmem_total(void)
		extrn physmem_total:near ; CODE	XREF: specify_sort_size:loc_8001946p
					; default_sort_size+1Ap
; double physmem_available(void)
		extrn physmem_available:near ; CODE XREF: default_sort_size+12p
		extrn fstat64:near	; CODE XREF: sort_buffer_size+83p
					; sort_buffer_size+C7p	...
		extrn stat64:near	; CODE XREF: sort_buffer_size+F5p
					; avoid_trashing_input+E7p ...
; void *malloc(size_t size)
		extrn malloc:near	; CODE XREF: initbuf+18p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: fillbuf+97p
					; avoid_trashing_input+2C4p ...
; size_t fread_unlocked(void *ptr, size_t size,	size_t n, FILE *stream)
		extrn fread_unlocked:near ; CODE XREF: fillbuf+151p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	fillbuf+17Fp
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: fillbuf+2EDp
		extrn strnumcmp:near	; CODE XREF: numcompare+65p
					; human_numcompare+9Dp
; double strtod(const char *nptr, char **endptr)
		extrn strtod:near	; CODE XREF: general_numcompare+27p
					; general_numcompare+3Cp
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: general_numcompare+F7p
					; cmp_hashes+103p ...
		extrn randread:near	; CODE XREF: random_state+96p
		extrn md5_init_ctx:near	; CODE XREF: random_state+A4p
		extrn md5_process_bytes:near ; CODE XREF: random_state+B8p
					; cmp_hashes+8Bp ...
		extrn md5_finish_ctx:near ; CODE XREF: cmp_hashes+A4p
					; cmp_hashes+E5p
		extrn xmemxfrm:near	; CODE XREF: compare_random+78p
					; compare_random+DDp ...
		extrn filevercmp:near	; CODE XREF: compare_version+41p
		extrn xmemcoll:near	; CODE XREF: keycompare+4EAp
					; keycompare+566p ...
		extrn umaxtostr:near	; CODE XREF: check+154p
; void *xrealloc(void *, size_t)
		extrn xrealloc:near	; CODE XREF: check+237p mergefps+423p
		extrn xnmalloc:near	; CODE XREF: open_input_files+Fp
					; mergefps+32p	...
; void *xmemdup(const void *, size_t, size_t)
		extrn xmemdup:near	; CODE XREF: insertkey+Ep
; void abort(void)
		extrn abort:near	; CODE XREF: badfieldspec+47p
					; incompatible_options+26p
; __sighandler_t signal(int sig, __sighandler_t	handler)
		extrn signal:near	; CODE XREF: sighandler+13p main+2CAp
; int raise(int	sig)
		extrn raise:near	; CODE XREF: sighandler+21p
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: key_init+10p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: main+68p main+13B3p
		extrn posix2_version:near ; CODE XREF: main+7Bp
		extrn set_program_name:near ; CODE XREF: main+AEp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+D5p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+E5p
		extrn hard_locale:near	; CODE XREF: main+FFp main+111p
; struct lconv *localeconv(void)
		extrn localeconv:near	; CODE XREF: main+11Ep
; int sigemptyset(sigset_t *set)
		extrn sigemptyset:near	; CODE XREF: main+1CDp
; int sigaction_0(int sig, const struct	sigaction *act,	struct sigaction *oact)
		extrn sigaction_0:near	; CODE XREF: main+1FBp	main+2ABp
; int sigaddset(sigset_t *set, int signo)
		extrn sigaddset:near	; CODE XREF: main+224p
; int sigismember(const	sigset_t *set, int signo)
		extrn sigismember:near	; CODE XREF: main+285p
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+2DAp
; int optind
		extrn optind:dword	; DATA XREF: main+3D9r	main+3E6r ...
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+46Bp
; char *optarg
		extrn optarg:dword	; DATA XREF: main+50Br	main+5E3r ...
		extrn argmatch_die:dword ; DATA	XREF: main:loc_80062FEr
					; main+815r
		extrn __xargmatch_internal:near	; CODE XREF: main+7CAp
					; main+836p
		extrn Version:dword	; DATA XREF: main:loc_80068FCr
		extrn version_etc:near	; CODE XREF: main+DCDp
		extrn readtokens0_init:near ; CODE XREF: main+EF4p
		extrn readtokens0:near	; CODE XREF: main+F0Cp
		extrn quotearg_colon:near ; CODE XREF: main+104Ep
		extrn randread_new:near	; CODE XREF: main+136Dp
; void *xcalloc(size_t,	size_t)
		extrn xcalloc:near	; CODE XREF: main+1501p


		end
