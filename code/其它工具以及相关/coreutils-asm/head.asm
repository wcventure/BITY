;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	9EFC139678FE8301C2066FB56ACD11CC
; Input	CRC32 :	08015F75

; File Name   :	D:\coreutils-o\head.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'head.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+155p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+194p	main+2FDp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000159
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000276
; ---------------------------------------------------------------------------

loc_8000159:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintTheFirst1 ; "Print	the first 10 lines of each FILE	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCBytesKPrintTh ; "  -c,	--bytes=[-]K	     print the fi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aQQuietSilentNe ; "  -q,	--quiet, --silent    never print "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aKMayHaveAMulti ; "\nK may have a multiplier suffix:\nb 51"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000276:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl diagnose_copy_fd_failure(Copy_fd_status err, const char *filename)
diagnose_copy_fd_failure proc near	; CODE XREF: elide_tail_bytes_file+247p
					; elide_tail_lines_seekable+384p

err		= dword	ptr  8
filename	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		mov	eax, [ebp+err]
		cmp	eax, 2
		jz	short loc_80002D4
		cmp	eax, 3
		jz	short loc_800030C
		cmp	eax, 1
		jnz	loc_8000344
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000349
; ---------------------------------------------------------------------------

loc_80002D4:				; CODE XREF: diagnose_copy_fd_failure+Bj
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorWritingS ;	"error writing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000349
; ---------------------------------------------------------------------------

loc_800030C:				; CODE XREF: diagnose_copy_fd_failure+10j
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSFileHasShrunk ; "%s: file has shrunk too much"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000349
; ---------------------------------------------------------------------------

loc_8000344:				; CODE XREF: diagnose_copy_fd_failure+15j
		call	abort
; ---------------------------------------------------------------------------

loc_8000349:				; CODE XREF: diagnose_copy_fd_failure+51j
					; diagnose_copy_fd_failure+89j	...
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
diagnose_copy_fd_failure endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_header(const char *filename)
write_header	proc near		; CODE XREF: head+2Fp

filename	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, first_file_5162
		test	al, al
		jz	short loc_8000369
		mov	eax, offset locale
		jmp	short loc_800036E
; ---------------------------------------------------------------------------

loc_8000369:				; CODE XREF: write_header+Fj
		mov	eax, offset asc_800288F	; "\n"

loc_800036E:				; CODE XREF: write_header+16j
		sub	esp, 4
		push	[ebp+filename]
		push	eax
		push	offset format	; "%s==> %s <==\n"
		call	printf
		add	esp, 10h
		mov	first_file_5162, 0
		nop
		leave
		retn
write_header	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; Copy_fd_status __cdecl copy_fd(int src_fd, FILE *o_stream, uintmax_t n_bytes)
copy_fd		proc near		; CODE XREF: elide_tail_bytes_file+21Ap
					; elide_tail_lines_seekable+35Ep

n_bytes		= qword	ptr -2028h
o_stream	= dword	ptr -201Ch
buf_size	= dword	ptr -2018h
n_to_read	= dword	ptr -2014h
n_read		= dword	ptr -2010h
buf		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
src_fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 2024h
		mov	eax, [ebp+arg_4]
		mov	[ebp+o_stream],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_bytes], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_bytes+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+buf_size],	2000h
		jmp	loc_800048C
; ---------------------------------------------------------------------------

loc_80003CB:				; CODE XREF: copy_fd+10Ej
		mov	ecx, [ebp+buf_size]
		mov	ebx, 0
		mov	eax, dword ptr [ebp+n_bytes]
		mov	edx, dword ptr [ebp+n_bytes+4]
		cmp	ebx, edx
		jb	short loc_80003F2
		cmp	ebx, edx
		ja	short loc_80003EE
		cmp	ecx, eax
		jbe	short loc_80003F2

loc_80003EE:				; CODE XREF: copy_fd+5Cj
		mov	ecx, eax
		mov	ebx, edx

loc_80003F2:				; CODE XREF: copy_fd+58j copy_fd+60j
		mov	[ebp+n_to_read], ecx
		sub	esp, 4
		push	[ebp+n_to_read]
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+src_fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8000429
		mov	eax, 1
		jmp	short loc_80004A5
; ---------------------------------------------------------------------------

loc_8000429:				; CODE XREF: copy_fd+94j
		mov	eax, [ebp+n_read]
		mov	edx, 0
		sub	dword ptr [ebp+n_bytes], eax
		sbb	dword ptr [ebp+n_bytes+4], edx
		cmp	[ebp+n_read], 0
		jnz	short loc_8000460
		mov	eax, dword ptr [ebp+n_bytes+4]
		or	eax, dword ptr [ebp+n_bytes]
		test	eax, eax
		jz	short loc_8000460
		mov	eax, 3
		jmp	short loc_80004A5
; ---------------------------------------------------------------------------

loc_8000460:				; CODE XREF: copy_fd+BBj copy_fd+CBj
		push	[ebp+o_stream]	; stream
		push	[ebp+n_read]	; n
		push	1		; size
		lea	eax, [ebp+buf]
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+n_read]
		jnb	short loc_800048C
		mov	eax, 2
		jmp	short loc_80004A5
; ---------------------------------------------------------------------------

loc_800048C:				; CODE XREF: copy_fd+3Aj copy_fd+F7j
		mov	eax, dword ptr [ebp+n_bytes+4]
		or	eax, dword ptr [ebp+n_bytes]
		test	eax, eax
		jnz	loc_80003CB
		mov	eax, 0

loc_80004A5:				; CODE XREF: copy_fd+9Bj copy_fd+D2j ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_80004B6
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80004B6:				; CODE XREF: copy_fd+123j
		mov	ebx, [ebp+var_4]
		leave
		retn
copy_fd		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	elide_tail_bytes_pipe(const char *filename, int	fd, uintmax_t n_elide_0)
elide_tail_bytes_pipe proc near		; CODE XREF: elide_tail_bytes_file+76p

n_elide_0	= qword	ptr -88h
filename	= dword	ptr -7Ch
ok		= byte ptr -6Bh
first		= byte ptr -6Ah
eof		= byte ptr -69h
i		= byte ptr -68h
ok_0		= byte ptr -67h
eof_0		= byte ptr -66h
buffered_enough	= byte ptr -65h
delta		= dword	ptr -64h
n_read_0	= dword	ptr -60h
i_0		= dword	ptr -5Ch
i_next		= dword	ptr -58h
n_elide		= dword	ptr -54h
n_to_read	= dword	ptr -50h
n_read		= dword	ptr -4Ch
rem		= dword	ptr -48h
n_elide_round	= dword	ptr -44h
n_bufs		= dword	ptr -40h
b_0		= dword	ptr -3Ch
n_bytes_left_in_b_i= dword ptr -38h
y		= dword	ptr -34h
x		= dword	ptr -30h
b		= dword	ptr -2Ch
umax_buf	= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_elide_0], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_elide_0+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, dword ptr [ebp+n_elide_0]
		mov	[ebp+n_elide], eax
		mov	eax, dword ptr [ebp+n_elide_0]
		mov	edx, dword ptr [ebp+n_elide_0+4]
		add	eax, 2000h
		adc	edx, 0
		cmp	edx, 0
		jbe	short loc_8000543
		sub	esp, 4
		lea	eax, [ebp+umax_buf]
		push	eax
		push	dword ptr [ebp+n_elide_0+4]
		push	dword ptr [ebp+n_elide_0]
		call	umaxtostr
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSNumberOfBytes ; "%s: number of	bytes is too large"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000543:				; CODE XREF: elide_tail_bytes_pipe+4Bj
		cmp	[ebp+n_elide], 100000h
		ja	loc_80006FD
		mov	[ebp+ok], 1
		mov	[ebp+first], 1
		mov	[ebp+eof], 0
		mov	eax, [ebp+n_elide]
		add	eax, 2000h
		mov	[ebp+n_to_read], eax
		sub	esp, 8
		push	[ebp+n_to_read]
		push	2
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+b], eax
		mov	edx, [ebp+b]
		mov	eax, [ebp+n_to_read]
		add	eax, edx
		mov	[ebp+b+4], eax
		mov	[ebp+i], 0
		jmp	loc_80006D6
; ---------------------------------------------------------------------------

loc_800058E:				; CODE XREF: elide_tail_bytes_pipe+224j
		movzx	eax, [ebp+i]
		mov	eax, [ebp+eax*4+b]
		sub	esp, 4
		push	[ebp+n_to_read]
		push	eax
		push	[ebp+fd]
		call	full_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		mov	[ebp+delta], 0
		mov	eax, [ebp+n_read]
		cmp	eax, [ebp+n_to_read]
		jnb	short loc_800061F
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000604
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	loc_80006E5
; ---------------------------------------------------------------------------

loc_8000604:				; CODE XREF: elide_tail_bytes_pipe+108j
		mov	eax, [ebp+n_read]
		cmp	eax, [ebp+n_elide]
		ja	short loc_800061B
		cmp	[ebp+first], 0
		jnz	short loc_800061B
		mov	eax, [ebp+n_elide]
		sub	eax, [ebp+n_read]
		mov	[ebp+delta], eax

loc_800061B:				; CODE XREF: elide_tail_bytes_pipe+14Fj
					; elide_tail_bytes_pipe+155j
		mov	[ebp+eof], 1

loc_800061F:				; CODE XREF: elide_tail_bytes_pipe+FDj
		movzx	eax, [ebp+first]
		xor	eax, 1
		test	al, al
		jz	short loc_8000657
		mov	edx, ds:stdout
		mov	eax, [ebp+n_elide]
		sub	eax, [ebp+delta]
		movzx	ecx, [ebp+i]
		xor	ecx, 1
		movzx	ecx, cl
		mov	ecx, [ebp+ecx*4+b]
		add	ecx, 2000h
		push	edx		; stream
		push	eax		; n
		push	1		; size
		push	ecx		; ptr
		call	fwrite_unlocked
		add	esp, 10h

loc_8000657:				; CODE XREF: elide_tail_bytes_pipe+16Dj
		mov	[ebp+first], 0
		mov	eax, [ebp+n_elide]
		cmp	eax, [ebp+n_read]
		jnb	short loc_80006C0
		mov	ecx, ds:stdout
		mov	eax, [ebp+n_read]
		sub	eax, [ebp+n_elide]
		mov	edx, eax
		movzx	eax, [ebp+i]
		mov	eax, [ebp+eax*4+b]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+n_read]
		sub	eax, [ebp+n_elide]
		cmp	edx, eax
		jnb	short loc_80006C0
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	short loc_80006E5
; ---------------------------------------------------------------------------

loc_80006C0:				; CODE XREF: elide_tail_bytes_pipe+1A6j
					; elide_tail_bytes_pipe+1D5j
		movzx	eax, [ebp+i]
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+i], al
		and	[ebp+i], 1

loc_80006D6:				; CODE XREF: elide_tail_bytes_pipe+CEj
		movzx	eax, [ebp+eof]
		xor	eax, 1
		test	al, al
		jnz	loc_800058E

loc_80006E5:				; CODE XREF: elide_tail_bytes_pipe+144j
					; elide_tail_bytes_pipe+203j
		mov	eax, [ebp+b]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		jmp	loc_80009DE
; ---------------------------------------------------------------------------

loc_80006FD:				; CODE XREF: elide_tail_bytes_pipe+8Fj
		mov	[ebp+ok_0], 1
		mov	[ebp+eof_0], 0
		mov	eax, [ebp+n_elide]
		and	eax, 1FFFh
		mov	edx, 2000h
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+rem], eax
		mov	edx, [ebp+n_elide]
		mov	eax, [ebp+rem]
		add	eax, edx
		mov	[ebp+n_elide_round], eax
		mov	eax, [ebp+n_elide_round]
		shr	eax, 0Dh
		add	eax, 1
		mov	[ebp+n_bufs], eax
		sub	esp, 8
		push	4		; size_t
		push	[ebp+n_bufs]	; size_t
		call	xcalloc
		add	esp, 10h
		mov	[ebp+b_0], eax
		mov	[ebp+buffered_enough], 0
		mov	[ebp+i_0], 0
		mov	[ebp+i_next], 1
		jmp	loc_8000898
; ---------------------------------------------------------------------------

loc_800075A:				; CODE XREF: elide_tail_bytes_pipe+3E6j
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8000791
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		lea	ebx, [edx+eax]
		sub	esp, 0Ch
		push	2000h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebx], eax

loc_8000791:				; CODE XREF: elide_tail_bytes_pipe+2B2j
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		push	2000h
		push	eax
		push	[ebp+fd]
		call	full_read
		add	esp, 10h
		mov	[ebp+n_read_0],	eax
		cmp	[ebp+n_read_0],	1FFFh
		ja	short loc_8000810
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_800080C
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok_0], 0
		jmp	free_mem
; ---------------------------------------------------------------------------

loc_800080C:				; CODE XREF: elide_tail_bytes_pipe+310j
		mov	[ebp+eof_0], 1

loc_8000810:				; CODE XREF: elide_tail_bytes_pipe+305j
		mov	eax, [ebp+i_0]
		add	eax, 1
		cmp	eax, [ebp+n_bufs]
		jnz	short loc_800081F
		mov	[ebp+buffered_enough], 1

loc_800081F:				; CODE XREF: elide_tail_bytes_pipe+35Ej
		cmp	[ebp+buffered_enough], 0
		jz	short loc_8000881
		mov	edx, ds:stdout
		mov	eax, [ebp+i_next]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, ecx
		mov	eax, [eax]
		push	edx		; stream
		push	[ebp+n_read_0]	; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+n_read_0]
		jnb	short loc_8000881
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok_0], 0
		jmp	free_mem
; ---------------------------------------------------------------------------

loc_8000881:				; CODE XREF: elide_tail_bytes_pipe+368j
					; elide_tail_bytes_pipe+393j
		mov	eax, [ebp+i_next]
		mov	[ebp+i_0], eax
		mov	eax, [ebp+i_next]
		add	eax, 1
		mov	edx, 0
		div	[ebp+n_bufs]
		mov	[ebp+i_next], edx

loc_8000898:				; CODE XREF: elide_tail_bytes_pipe+29Aj
		movzx	eax, [ebp+eof_0]
		xor	eax, 1
		test	al, al
		jnz	loc_800075A
		cmp	[ebp+rem], 0
		jz	free_mem
		cmp	[ebp+buffered_enough], 0
		jz	loc_8000955
		mov	eax, 2000h
		sub	eax, [ebp+n_read_0]
		mov	[ebp+n_bytes_left_in_b_i], eax
		mov	eax, [ebp+rem]
		cmp	eax, [ebp+n_bytes_left_in_b_i]
		jnb	short loc_80008FD
		mov	eax, ds:stdout
		mov	edx, [ebp+i_0]
		lea	ecx, ds:0[edx*4]
		mov	edx, [ebp+b_0]
		add	edx, ecx
		mov	ecx, [edx]
		mov	edx, [ebp+n_read_0]
		add	edx, ecx
		push	eax		; stream
		push	[ebp+rem]	; n
		push	1		; size
		push	edx		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		jmp	free_mem
; ---------------------------------------------------------------------------

loc_80008FD:				; CODE XREF: elide_tail_bytes_pipe+411j
		mov	eax, ds:stdout
		mov	edx, [ebp+i_0]
		lea	ecx, ds:0[edx*4]
		mov	edx, [ebp+b_0]
		add	edx, ecx
		mov	ecx, [edx]
		mov	edx, [ebp+n_read_0]
		add	edx, ecx
		push	eax		; stream
		push	[ebp+n_bytes_left_in_b_i] ; n
		push	1		; size
		push	edx		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	ecx, ds:stdout
		mov	eax, [ebp+rem]
		sub	eax, [ebp+n_bytes_left_in_b_i]
		mov	edx, eax
		mov	eax, [ebp+i_next]
		lea	ebx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, ebx
		mov	eax, [eax]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short free_mem
; ---------------------------------------------------------------------------

loc_8000955:				; CODE XREF: elide_tail_bytes_pipe+3FAj
		mov	eax, [ebp+i_0]
		add	eax, 1
		cmp	eax, [ebp+n_bufs]
		jnz	short free_mem
		mov	eax, 2000h
		sub	eax, [ebp+rem]
		mov	[ebp+y], eax
		mov	eax, [ebp+n_read_0]
		sub	eax, [ebp+y]
		mov	[ebp+x], eax
		mov	edx, ds:stdout
		mov	eax, [ebp+i_next]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, ecx
		mov	eax, [eax]
		push	edx		; stream
		push	[ebp+x]		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h

free_mem:				; CODE XREF: elide_tail_bytes_pipe+34Cj
					; elide_tail_bytes_pipe+3C1j ...
		mov	[ebp+i_0], 0
		jmp	short loc_80009C4
; ---------------------------------------------------------------------------

loc_80009A3:				; CODE XREF: elide_tail_bytes_pipe+50Fj
		mov	eax, [ebp+i_0]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+b_0]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		add	[ebp+i_0], 1

loc_80009C4:				; CODE XREF: elide_tail_bytes_pipe+4E6j
		mov	eax, [ebp+i_0]
		cmp	eax, [ebp+n_bufs]
		jb	short loc_80009A3
		sub	esp, 0Ch
		push	[ebp+b_0]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+ok_0]

loc_80009DE:				; CODE XREF: elide_tail_bytes_pipe+23Dj
		mov	esi, [ebp+var_C]
		xor	esi, large gs:14h
		jz	short loc_80009EF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80009EF:				; CODE XREF: elide_tail_bytes_pipe+52Dj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
elide_tail_bytes_pipe endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	elide_tail_bytes_file(const char *filename, int	fd, uintmax_t n_elide)
elide_tail_bytes_file proc near		; CODE XREF: head+65p

n_elide		= qword	ptr -0A8h
filename	= dword	ptr -9Ch
err		= dword	ptr -94h
current_pos	= qword	ptr -90h
end_pos		= qword	ptr -88h
diff		= qword	ptr -80h
bytes_remaining	= qword	ptr -78h
stats		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0A0h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_elide], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_elide+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		movzx	eax, ds:presume_input_pipe
		test	al, al
		jnz	short loc_8000A57
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000A57
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8000A79

loc_8000A57:				; CODE XREF: elide_tail_bytes_file+3Aj
					; elide_tail_bytes_file+50j
		push	dword ptr [ebp+n_elide+4]
		push	dword ptr [ebp+n_elide]	; n_elide_0
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	elide_tail_bytes_pipe
		add	esp, 10h
		jmp	loc_8000C4A
; ---------------------------------------------------------------------------

loc_8000A79:				; CODE XREF: elide_tail_bytes_file+5Fj
		push	1
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+current_pos], eax
		mov	dword ptr [ebp+current_pos+4], edx
		mov	eax, dword ptr [ebp+current_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+current_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	short loc_8000AE7
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+end_pos], eax
		mov	dword ptr [ebp+end_pos+4], edx
		mov	eax, dword ptr [ebp+end_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+end_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jnz	short loc_8000B2A

loc_8000AE7:				; CODE XREF: elide_tail_bytes_file+B8j
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotLseekS ; "cannot lseek %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000C4A
; ---------------------------------------------------------------------------

loc_8000B2A:				; CODE XREF: elide_tail_bytes_file+EFj
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		sub	eax, dword ptr [ebp+current_pos]
		sbb	edx, dword ptr [ebp+current_pos+4]
		mov	dword ptr [ebp+diff], eax
		mov	dword ptr [ebp+diff+4],	edx
		cmp	dword ptr [ebp+diff+4],	0
		js	short loc_8000B56
		mov	eax, dword ptr [ebp+diff]
		mov	edx, dword ptr [ebp+diff+4]
		jmp	short loc_8000B60
; ---------------------------------------------------------------------------

loc_8000B56:				; CODE XREF: elide_tail_bytes_file+156j
		mov	eax, 0
		mov	edx, 0

loc_8000B60:				; CODE XREF: elide_tail_bytes_file+15Ej
		mov	dword ptr [ebp+bytes_remaining], eax
		mov	dword ptr [ebp+bytes_remaining+4], edx
		mov	eax, dword ptr [ebp+bytes_remaining]
		mov	edx, dword ptr [ebp+bytes_remaining+4]
		cmp	edx, dword ptr [ebp+n_elide+4]
		ja	short loc_8000B8E
		cmp	edx, dword ptr [ebp+n_elide+4]
		jb	short loc_8000B84
		cmp	eax, dword ptr [ebp+n_elide]
		ja	short loc_8000B8E

loc_8000B84:				; CODE XREF: elide_tail_bytes_file+184j
		mov	eax, 1
		jmp	loc_8000C4A
; ---------------------------------------------------------------------------

loc_8000B8E:				; CODE XREF: elide_tail_bytes_file+17Cj
					; elide_tail_bytes_file+18Cj
		mov	eax, dword ptr [ebp+current_pos]
		push	eax
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000BF2
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSCannotLseekBa ; "%s: cannot lseek back	to original posit"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8000C4A
; ---------------------------------------------------------------------------

loc_8000BF2:				; CODE XREF: elide_tail_bytes_file+1BAj
		mov	eax, dword ptr [ebp+bytes_remaining]
		mov	edx, dword ptr [ebp+bytes_remaining+4]
		sub	eax, dword ptr [ebp+n_elide]
		sbb	edx, dword ptr [ebp+n_elide+4]
		mov	ecx, ds:stdout
		push	edx
		push	eax		; n_bytes
		push	ecx		; o_stream
		push	[ebp+fd]	; src_fd
		call	copy_fd
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jnz	short loc_8000C2E
		mov	eax, 1
		jmp	short loc_8000C4A
; ---------------------------------------------------------------------------

loc_8000C2E:				; CODE XREF: elide_tail_bytes_file+22Fj
		sub	esp, 8
		push	[ebp+filename]	; filename
		push	[ebp+err]	; err
		call	diagnose_copy_fd_failure
		add	esp, 10h
		mov	eax, 0

loc_8000C4A:				; CODE XREF: elide_tail_bytes_file+7Ej
					; elide_tail_bytes_file+12Fj ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000C5B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000C5B:				; CODE XREF: elide_tail_bytes_file+25Ej
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
elide_tail_bytes_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	elide_tail_lines_pipe(const char *filename, int	fd, uintmax_t n_elide)
elide_tail_lines_pipe proc near		; CODE XREF: elide_tail_lines_file+A8p

n_elide		= qword	ptr -40h
ok		= byte ptr -31h
first		= dword	ptr -30h
last		= dword	ptr -2Ch
tmp		= dword	ptr -28h
total_lines	= dword	ptr -24h
p		= dword	ptr -20h
n		= dword	ptr -1Ch
p_0		= dword	ptr -18h
n_read		= dword	ptr -14h
buffer_end	= dword	ptr -10h
buffer_end_0	= dword	ptr -0Ch
filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 40h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_elide], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_elide+4], eax
		mov	[ebp+total_lines], 0
		mov	[ebp+ok], 1
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+last], eax
		mov	eax, [ebp+last]
		mov	[ebp+first], eax
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2004h], 0
		mov	eax, [ebp+first]
		mov	edx, [eax+2004h]
		mov	eax, [ebp+first]
		mov	[eax+2000h], edx
		mov	eax, [ebp+first]
		mov	dword ptr [eax+2008h], 0
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax

loc_8000CD9:				; CODE XREF: elide_tail_lines_pipe+1A4j
					; elide_tail_lines_pipe+222j ...
		mov	eax, [ebp+tmp]
		sub	esp, 4
		push	2000h
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+n_read], eax
		cmp	[ebp+n_read], 0
		jz	loc_8000EA1
		cmp	[ebp+n_read], 0FFFFFFFFh
		jz	loc_8000EA1
		mov	eax, [ebp+tmp]
		mov	edx, [ebp+n_read]
		mov	[eax+2000h], edx
		mov	eax, [ebp+tmp]
		mov	dword ptr [eax+2004h], 0
		mov	eax, [ebp+tmp]
		mov	dword ptr [eax+2008h], 0
		mov	edx, [ebp+tmp]
		mov	eax, [ebp+n_read]
		add	eax, edx
		mov	[ebp+buffer_end], eax
		mov	eax, [ebp+tmp]
		mov	[ebp+p], eax
		jmp	short loc_8000D59
; ---------------------------------------------------------------------------

loc_8000D40:				; CODE XREF: elide_tail_lines_pipe+119j
		add	[ebp+p], 1
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		lea	edx, [eax+1]
		mov	eax, [ebp+tmp]
		mov	[eax+2004h], edx

loc_8000D59:				; CODE XREF: elide_tail_lines_pipe+DCj
		mov	edx, [ebp+buffer_end]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+p]		; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	short loc_8000D40
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		add	[ebp+total_lines], eax
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		add	eax, edx
		cmp	eax, 1FFFh
		ja	short loc_8000E0B
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	ecx, [ebp+last]
		mov	ebx, [ecx+2000h]
		mov	ecx, [ebp+last]
		add	ecx, ebx
		sub	esp, 4
		push	edx		; n
		push	eax		; src
		push	ecx		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+last]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	edx, eax
		mov	eax, [ebp+last]
		mov	[eax+2000h], edx
		mov	eax, [ebp+last]
		mov	edx, [eax+2004h]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		add	edx, eax
		mov	eax, [ebp+last]
		mov	[eax+2004h], edx
		jmp	loc_8000CD9
; ---------------------------------------------------------------------------

loc_8000E0B:				; CODE XREF: elide_tail_lines_pipe+140j
		mov	eax, [ebp+last]
		mov	edx, [ebp+tmp]
		mov	[eax+2008h], edx
		mov	eax, [ebp+last]
		mov	eax, [eax+2008h]
		mov	[ebp+last], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_elide+4]
		jb	short loc_8000E89
		cmp	edx, dword ptr [ebp+n_elide+4]
		ja	short loc_8000E47
		cmp	eax, dword ptr [ebp+n_elide]
		jbe	short loc_8000E89

loc_8000E47:				; CODE XREF: elide_tail_lines_pipe+1DEj
		mov	ecx, ds:stdout
		mov	eax, [ebp+first]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+first]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2004h]
		sub	[ebp+total_lines], eax
		mov	eax, [ebp+first]
		mov	eax, [eax+2008h]
		mov	[ebp+first], eax
		jmp	loc_8000CD9
; ---------------------------------------------------------------------------

loc_8000E89:				; CODE XREF: elide_tail_lines_pipe+1D9j
					; elide_tail_lines_pipe+1E3j
		sub	esp, 0Ch
		push	200Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+tmp], eax
		jmp	loc_8000CD9
; ---------------------------------------------------------------------------

loc_8000EA1:				; CODE XREF: elide_tail_lines_pipe+95j
					; elide_tail_lines_pipe+9Fj
		sub	esp, 0Ch
		push	[ebp+tmp]	; ptr
		call	free
		add	esp, 10h
		cmp	[ebp+n_read], 0FFFFFFFFh
		jnz	short loc_8000EF4
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	free_lbuffers
; ---------------------------------------------------------------------------

loc_8000EF4:				; CODE XREF: elide_tail_lines_pipe+251j
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		test	eax, eax
		jz	short loc_8000F31
		mov	eax, [ebp+last]
		mov	eax, [eax+2000h]
		lea	edx, [eax-1]
		mov	eax, [ebp+last]
		movzx	eax, byte ptr [eax+edx]
		cmp	al, 0Ah
		jz	short loc_8000F31
		mov	eax, [ebp+last]
		mov	eax, [eax+2004h]
		lea	edx, [eax+1]
		mov	eax, [ebp+last]
		mov	[eax+2004h], edx
		add	[ebp+total_lines], 1

loc_8000F31:				; CODE XREF: elide_tail_lines_pipe+29Dj
					; elide_tail_lines_pipe+2B4j
		mov	eax, [ebp+first]
		mov	[ebp+tmp], eax
		jmp	short loc_8000F70
; ---------------------------------------------------------------------------

loc_8000F39:				; CODE XREF: elide_tail_lines_pipe+326j
					; elide_tail_lines_pipe+330j
		mov	ecx, ds:stdout
		mov	eax, [ebp+tmp]
		mov	edx, [eax+2000h]
		mov	eax, [ebp+tmp]
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		sub	[ebp+total_lines], eax
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax

loc_8000F70:				; CODE XREF: elide_tail_lines_pipe+2D5j
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_elide+4]
		ja	short loc_8000F39
		cmp	edx, dword ptr [ebp+n_elide+4]
		jb	short loc_8000F94
		cmp	eax, dword ptr [ebp+n_elide]
		ja	short loc_8000F39

loc_8000F94:				; CODE XREF: elide_tail_lines_pipe+32Bj
		mov	eax, [ebp+total_lines]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+n_elide+4]
		jb	loc_8001062
		cmp	edx, dword ptr [ebp+n_elide+4]
		ja	short loc_8000FB3
		cmp	eax, dword ptr [ebp+n_elide]
		jbe	loc_8001062

loc_8000FB3:				; CODE XREF: elide_tail_lines_pipe+346j
		mov	eax, dword ptr [ebp+n_elide]
		mov	edx, [ebp+total_lines]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n], eax
		mov	edx, [ebp+tmp]
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2000h]
		add	eax, edx
		mov	[ebp+buffer_end_0], eax
		mov	eax, [ebp+tmp]
		mov	[ebp+p_0], eax
		jmp	short loc_8000FF6
; ---------------------------------------------------------------------------

loc_8000FD9:				; CODE XREF: elide_tail_lines_pipe+3BCj
		add	[ebp+p_0], 1
		mov	eax, [ebp+tmp]
		mov	eax, [eax+2004h]
		lea	edx, [eax+1]
		mov	eax, [ebp+tmp]
		mov	[eax+2004h], edx
		sub	[ebp+n], 1

loc_8000FF6:				; CODE XREF: elide_tail_lines_pipe+375j
		cmp	[ebp+n], 0
		jz	short loc_8001020
		mov	edx, [ebp+buffer_end_0]
		mov	eax, [ebp+p_0]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+p_0]	; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p_0], eax
		cmp	[ebp+p_0], 0
		jnz	short loc_8000FD9

loc_8001020:				; CODE XREF: elide_tail_lines_pipe+398j
		mov	edx, ds:stdout
		mov	eax, [ebp+p_0]
		mov	ecx, [ebp+tmp]
		sub	eax, ecx
		mov	ecx, eax
		mov	eax, [ebp+tmp]
		push	edx		; stream
		push	ecx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h

free_lbuffers:				; CODE XREF: elide_tail_lines_pipe+28Dj
		jmp	short loc_8001062
; ---------------------------------------------------------------------------

loc_8001042:				; CODE XREF: elide_tail_lines_pipe+404j
		mov	eax, [ebp+first]
		mov	eax, [eax+2008h]
		mov	[ebp+tmp], eax
		sub	esp, 0Ch
		push	[ebp+first]	; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+tmp]
		mov	[ebp+first], eax

loc_8001062:				; CODE XREF: elide_tail_lines_pipe+33Dj
					; elide_tail_lines_pipe+34Bj ...
		cmp	[ebp+first], 0
		jnz	short loc_8001042
		movzx	eax, [ebp+ok]
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
elide_tail_lines_pipe endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	elide_tail_lines_seekable(const	char *pretty_filename, int fd, uintmax_t n_lines, off_t	start_pos, off_t end_pos)
elide_tail_lines_seekable proc near	; CODE XREF: elide_tail_lines_file+92p

var_2090	= dword	ptr -2090h
var_208C	= dword	ptr -208Ch
var_2088	= dword	ptr -2088h
var_2084	= dword	ptr -2084h
var_2080	= dword	ptr -2080h
var_207C	= dword	ptr -207Ch
end_pos		= qword	ptr -2078h
start_pos	= qword	ptr -2070h
n_lines		= qword	ptr -2068h
pretty_filename	= dword	ptr -205Ch
bytes_read	= dword	ptr -2050h
n		= dword	ptr -204Ch
nl		= dword	ptr -2048h
err		= dword	ptr -2044h
pos		= qword	ptr -2040h
offset_buf_0	= byte ptr -2031h
offset_buf	= byte ptr -201Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 208Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+pretty_filename], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_lines], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_lines+4], eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [ebp+start_pos], eax
		mov	eax, [ebp+arg_14]
		mov	dword ptr [ebp+start_pos+4], eax
		mov	eax, [ebp+arg_18]
		mov	dword ptr [ebp+end_pos], eax
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [ebp+end_pos+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		mov	dword ptr [ebp+pos], eax
		mov	dword ptr [ebp+pos+4], edx
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		sub	eax, dword ptr [ebp+start_pos]
		sbb	edx, dword ptr [ebp+start_pos+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, ebx
		sar	eax, 1Fh
		cdq
		mov	edi, ecx
		xor	edi, eax
		mov	[ebp+var_2088],	edi
		mov	edi, ebx
		xor	edi, edx
		mov	[ebp+var_2084],	edi
		mov	ecx, [ebp+var_2088]
		mov	ebx, [ebp+var_2084]
		sub	ecx, eax
		sbb	ebx, edx
		mov	edi, ecx
		and	edi, 1FFFh
		mov	[ebp+var_2080],	edi
		mov	edi, ebx
		and	edi, 0
		mov	[ebp+var_207C],	edi
		mov	esi, [ebp+var_2080]
		xor	esi, eax
		mov	[ebp+var_2090],	esi
		mov	edi, [ebp+var_207C]
		xor	edi, edx
		mov	[ebp+var_208C],	edi
		mov	esi, [ebp+var_2090]
		mov	edi, [ebp+var_208C]
		sub	esi, eax
		sbb	edi, edx
		mov	eax, esi
		mov	edx, edi
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_8001189
		mov	[ebp+bytes_read], 2000h

loc_8001189:				; CODE XREF: elide_tail_lines_seekable+10Aj
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+pos], eax
		sbb	dword ptr [ebp+pos+4], edx
		push	0
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos]
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_8001216
		sub	esp, 4
		lea	eax, [ebp+offset_buf]
		push	eax
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos]
		call	offtostr
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSCannotSeekToO ; "%s: cannot seek to offset %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	esi
		push	[ebp+pretty_filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_8001216:				; CODE XREF: elide_tail_lines_seekable+148j
		sub	esp, 4
		push	[ebp+bytes_read]
		lea	eax, [ebp+offset_buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8001283
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_8001283:				; CODE XREF: elide_tail_lines_seekable+1CBj
		cmp	[ebp+bytes_read], 0
		jz	short loc_80012AF
		mov	eax, [ebp+bytes_read]
		sub	eax, 1
		movzx	eax, [ebp+eax+offset_buf]
		cmp	al, 0Ah
		jz	short loc_80012AF
		add	dword ptr [ebp+n_lines], 0FFFFFFFFh
		adc	dword ptr [ebp+n_lines+4], 0FFFFFFFFh

loc_80012AF:				; CODE XREF: elide_tail_lines_seekable+217j
					; elide_tail_lines_seekable+22Cj ...
		mov	eax, [ebp+bytes_read]
		mov	[ebp+n], eax
		jmp	loc_8001434
; ---------------------------------------------------------------------------

loc_80012C0:				; CODE XREF: elide_tail_lines_seekable+3C8j
		sub	esp, 4
		push	[ebp+n]
		push	0Ah
		lea	eax, [ebp+offset_buf]
		push	eax
		call	memrchr
		add	esp, 10h
		mov	[ebp+nl], eax
		cmp	[ebp+nl], 0
		jz	loc_8001443
		mov	edx, [ebp+nl]
		lea	eax, [ebp+offset_buf]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n], eax
		mov	eax, dword ptr [ebp+n_lines]
		mov	edx, dword ptr [ebp+n_lines+4]
		mov	ecx, eax
		mov	ebx, edx
		add	ecx, 0FFFFFFFFh
		adc	ebx, 0FFFFFFFFh
		mov	dword ptr [ebp+n_lines], ecx
		mov	dword ptr [ebp+n_lines+4], ebx
		or	eax, edx
		test	eax, eax
		jnz	loc_8001434
		mov	eax, dword ptr [ebp+start_pos]
		mov	edx, dword ptr [ebp+start_pos+4]
		cmp	edx, dword ptr [ebp+pos+4]
		jg	loc_8001409
		cmp	edx, dword ptr [ebp+pos+4]
		jl	short loc_800135B
		cmp	eax, dword ptr [ebp+pos]
		jnb	loc_8001409

loc_800135B:				; CODE XREF: elide_tail_lines_seekable+2DAj
		push	0
		push	dword ptr [ebp+start_pos+4]
		push	dword ptr [ebp+start_pos]
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_80013AD
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aSUnableToResto ; "%s: unable to	restore	file pointer to	i"...
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_80013AD:				; CODE XREF: elide_tail_lines_seekable+303j
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		sub	eax, dword ptr [ebp+start_pos]
		sbb	edx, dword ptr [ebp+start_pos+4]
		mov	ecx, ds:stdout
		push	edx
		push	eax		; n_bytes
		push	ecx		; o_stream
		push	[ebp+fd]	; src_fd
		call	copy_fd
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_8001409
		sub	esp, 8
		push	[ebp+pretty_filename] ;	filename
		push	[ebp+err]	; err
		call	diagnose_copy_fd_failure
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_8001409:				; CODE XREF: elide_tail_lines_seekable+2CEj
					; elide_tail_lines_seekable+2E2j ...
		mov	eax, ds:stdout
		mov	edx, [ebp+n]
		add	edx, 1
		push	eax		; stream
		push	edx		; n
		push	1		; size
		lea	eax, [ebp+offset_buf]
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, 1
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_8001434:				; CODE XREF: elide_tail_lines_seekable+248j
					; elide_tail_lines_seekable+2B6j
		cmp	[ebp+n], 0
		jnz	loc_80012C0
		jmp	short loc_8001444
; ---------------------------------------------------------------------------

loc_8001443:				; CODE XREF: elide_tail_lines_seekable+274j
		nop

loc_8001444:				; CODE XREF: elide_tail_lines_seekable+3CEj
		mov	eax, dword ptr [ebp+pos]
		mov	edx, dword ptr [ebp+pos+4]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+start_pos+4]
		xor	eax, dword ptr [ebp+start_pos]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_800146E
		mov	eax, 1
		jmp	loc_800156D
; ---------------------------------------------------------------------------

loc_800146E:				; CODE XREF: elide_tail_lines_seekable+3EFj
		add	dword ptr [ebp+pos], 0FFFFE000h
		adc	dword ptr [ebp+pos+4], 0FFFFFFFFh
		push	0
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos]
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	short loc_80014F2
		sub	esp, 4
		lea	eax, [ebp+offset_buf_0]
		push	eax
		push	dword ptr [ebp+pos+4]
		push	dword ptr [ebp+pos]
		call	offtostr
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSCannotSeekToO ; "%s: cannot seek to offset %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 0Ch
		push	esi
		push	[ebp+pretty_filename]
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		mov	eax, 0
		jmp	short loc_800156D
; ---------------------------------------------------------------------------

loc_80014F2:				; CODE XREF: elide_tail_lines_seekable+427j
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+offset_buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_800155B
		sub	esp, 0Ch
		push	[ebp+pretty_filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_800156D
; ---------------------------------------------------------------------------

loc_800155B:				; CODE XREF: elide_tail_lines_seekable+4A6j
		cmp	[ebp+bytes_read], 0
		jnz	loc_80012AF
		mov	eax, 1

loc_800156D:				; CODE XREF: elide_tail_lines_seekable+19Ej
					; elide_tail_lines_seekable+20Bj ...
		mov	edx, [ebp+var_1C]
		xor	edx, large gs:14h
		jz	short loc_800157E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800157E:				; CODE XREF: elide_tail_lines_seekable+504j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
elide_tail_lines_seekable endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	elide_tail_lines_file(const char *filename, int	fd, uintmax_t n_elide)
elide_tail_lines_file proc near		; CODE XREF: head+4Fp

n_elide		= qword	ptr -20h
start_pos	= qword	ptr -18h
end_pos		= qword	ptr -10h
filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+n_elide], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+n_elide+4], eax
		movzx	eax, ds:presume_input_pipe
		xor	eax, 1
		test	al, al
		jz	short loc_8001622
		push	1
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+start_pos], eax
		mov	dword ptr [ebp+start_pos+4], edx
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+end_pos], eax
		mov	dword ptr [ebp+end_pos+4], edx
		cmp	dword ptr [ebp+start_pos+4], 0
		js	short loc_8001622
		mov	eax, dword ptr [ebp+start_pos]
		mov	edx, dword ptr [ebp+start_pos+4]
		cmp	edx, dword ptr [ebp+end_pos+4]
		jg	short loc_8001622
		cmp	edx, dword ptr [ebp+end_pos+4]
		jl	short loc_80015EF
		cmp	eax, dword ptr [ebp+end_pos]
		jnb	short loc_8001622

loc_80015EF:				; CODE XREF: elide_tail_lines_file+62j
		mov	eax, dword ptr [ebp+end_pos+4]
		or	eax, dword ptr [ebp+end_pos]
		test	eax, eax
		jnz	short loc_8001600
		mov	eax, 1
		jmp	short locret_8001636
; ---------------------------------------------------------------------------

loc_8001600:				; CODE XREF: elide_tail_lines_file+71j
		push	dword ptr [ebp+end_pos+4]
		push	dword ptr [ebp+end_pos]	; end_pos
		push	dword ptr [ebp+start_pos+4]
		push	dword ptr [ebp+start_pos] ; start_pos
		push	dword ptr [ebp+n_elide+4]
		push	dword ptr [ebp+n_elide]	; n_lines
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; pretty_filename
		call	elide_tail_lines_seekable
		add	esp, 20h
		jmp	short locret_8001636
; ---------------------------------------------------------------------------

loc_8001622:				; CODE XREF: elide_tail_lines_file+1Ej
					; elide_tail_lines_file+52j ...
		push	dword ptr [ebp+n_elide+4]
		push	dword ptr [ebp+n_elide]	; n_elide
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	elide_tail_lines_pipe
		add	esp, 10h

locret_8001636:				; CODE XREF: elide_tail_lines_file+78j
					; elide_tail_lines_file+9Aj
		leave
		retn
elide_tail_lines_file endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	head_bytes(const char *filename, int fd, uintmax_t bytes_to_write)
head_bytes	proc near		; CODE XREF: head+97p

bytes_to_write	= qword	ptr -2028h
filename	= dword	ptr -201Ch
bytes_to_read	= dword	ptr -2014h
bytes_read	= dword	ptr -2010h
buffer		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2020h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+bytes_to_write],	eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+bytes_to_write+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+bytes_to_read], 2000h
		jmp	loc_8001781
; ---------------------------------------------------------------------------

loc_8001678:				; CODE XREF: head_bytes+157j
		mov	eax, [ebp+bytes_to_read]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+bytes_to_write+4]
		jb	short loc_80016A7
		cmp	edx, dword ptr [ebp+bytes_to_write+4]
		ja	short loc_800169B
		cmp	eax, dword ptr [ebp+bytes_to_write]
		jbe	short loc_80016A7

loc_800169B:				; CODE XREF: head_bytes+59j
		mov	eax, dword ptr [ebp+bytes_to_write]
		mov	[ebp+bytes_to_read], eax

loc_80016A7:				; CODE XREF: head_bytes+51j
					; head_bytes+61j
		sub	esp, 4
		push	[ebp+bytes_to_read]
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8001714
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_800179D
; ---------------------------------------------------------------------------

loc_8001714:				; CODE XREF: head_bytes+97j
		cmp	[ebp+bytes_read], 0
		jz	short loc_8001797
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+bytes_read] ; n
		push	1		; size
		lea	eax, [ebp+buffer]
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+bytes_read]
		jnb	short loc_800176A
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800176A:				; CODE XREF: head_bytes+108j
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		sub	dword ptr [ebp+bytes_to_write],	eax
		sbb	dword ptr [ebp+bytes_to_write+4], edx

loc_8001781:				; CODE XREF: head_bytes+3Bj
		mov	eax, dword ptr [ebp+bytes_to_write+4]
		or	eax, dword ptr [ebp+bytes_to_write]
		test	eax, eax
		jnz	loc_8001678
		jmp	short loc_8001798
; ---------------------------------------------------------------------------

loc_8001797:				; CODE XREF: head_bytes+E3j
		nop

loc_8001798:				; CODE XREF: head_bytes+15Dj
		mov	eax, 1

loc_800179D:				; CODE XREF: head_bytes+D7j
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_80017AE
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80017AE:				; CODE XREF: head_bytes+16Fj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
head_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	head_lines(const char *filename, int fd, uintmax_t lines_to_write)
head_lines	proc near		; CODE XREF: head+81p

lines_to_write	= qword	ptr -2098h
filename	= dword	ptr -208Ch
bytes_to_write	= dword	ptr -2084h
bytes_read	= dword	ptr -2080h
e		= dword	ptr -207Ch
n_bytes_past_EOL= qword	ptr -2078h
st		= stat ptr -206Ch
buffer		= byte ptr -200Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 2090h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+lines_to_write],	eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+lines_to_write+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_80019CB
; ---------------------------------------------------------------------------

loc_80017EB:				; CODE XREF: head_lines+224j
		sub	esp, 4
		push	2000h
		lea	eax, [ebp+buffer]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		mov	[ebp+bytes_to_write], 0
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8001861
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aErrorReadingS ;	"error reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80019E7
; ---------------------------------------------------------------------------

loc_8001861:				; CODE XREF: head_lines+67j
		cmp	[ebp+bytes_read], 0
		jz	loc_80019E1
		jmp	loc_8001969
; ---------------------------------------------------------------------------

loc_8001873:				; CODE XREF: head_lines+1C0j
		mov	eax, [ebp+bytes_to_write]
		lea	edx, [eax+1]
		mov	[ebp+bytes_to_write], edx
		movzx	eax, [ebp+eax+buffer]
		cmp	al, 0Ah
		jnz	loc_8001969
		add	dword ptr [ebp+lines_to_write],	0FFFFFFFFh
		adc	dword ptr [ebp+lines_to_write+4], 0FFFFFFFFh
		mov	eax, dword ptr [ebp+lines_to_write+4]
		or	eax, dword ptr [ebp+lines_to_write]
		test	eax, eax
		jnz	loc_8001969
		mov	eax, [ebp+bytes_read]
		sub	eax, [ebp+bytes_to_write]
		mov	dword ptr [ebp+n_bytes_past_EOL], eax
		mov	dword ptr [ebp+n_bytes_past_EOL+4], 0
		mov	eax, dword ptr [ebp+n_bytes_past_EOL]
		mov	edx, dword ptr [ebp+n_bytes_past_EOL+4]
		neg	eax
		adc	edx, 0
		neg	edx
		push	1
		push	edx
		push	eax
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		test	edx, edx
		jns	loc_800197D
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+e], eax
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001932
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_800197D

loc_8001932:				; CODE XREF: head_lines+169j
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotRepositi ; "cannot reposition file pointer for %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+e]		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_800197D
; ---------------------------------------------------------------------------

loc_8001969:				; CODE XREF: head_lines+B9j
					; head_lines+D7j ...
		mov	eax, [ebp+bytes_to_write]
		cmp	eax, [ebp+bytes_read]
		jb	loc_8001873
		jmp	short loc_800197E
; ---------------------------------------------------------------------------

loc_800197D:				; CODE XREF: head_lines+13Fj
					; head_lines+17Bj ...
		nop

loc_800197E:				; CODE XREF: head_lines+1C6j
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+bytes_to_write] ; n
		push	1		; size
		lea	eax, [ebp+buffer]
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+bytes_to_write]
		jnb	short loc_80019CB
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80019CB:				; CODE XREF: head_lines+31j
					; head_lines+1ECj
		mov	eax, dword ptr [ebp+lines_to_write+4]
		or	eax, dword ptr [ebp+lines_to_write]
		test	eax, eax
		jnz	loc_80017EB
		jmp	short loc_80019E2
; ---------------------------------------------------------------------------

loc_80019E1:				; CODE XREF: head_lines+B3j
		nop

loc_80019E2:				; CODE XREF: head_lines+22Aj
		mov	eax, 1

loc_80019E7:				; CODE XREF: head_lines+A7j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80019F8
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80019F8:				; CODE XREF: head_lines+23Cj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
head_lines	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	head(const char	*filename, int fd, uintmax_t n_units, _Bool count_lines, _Bool elide_from_end)
head		proc near		; CODE XREF: head_file+D6p

elide_from_end	= byte ptr -18h
count_lines	= byte ptr -14h
n_units		= qword	ptr -10h
filename	= dword	ptr  8
fd		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+arg_10]
		mov	eax, [ebp+arg_14]
		mov	ecx, [ebp+arg_8]
		mov	dword ptr [ebp+n_units], ecx
		mov	ecx, [ebp+arg_C]
		mov	dword ptr [ebp+n_units+4], ecx
		mov	[ebp+count_lines], dl
		mov	[ebp+elide_from_end], al
		movzx	eax, ds:print_headers
		test	al, al
		jz	short loc_8001A36
		sub	esp, 0Ch
		push	[ebp+filename]	; filename
		call	write_header
		add	esp, 10h

loc_8001A36:				; CODE XREF: head+27j
		cmp	[ebp+elide_from_end], 0
		jz	short loc_8001A6E
		cmp	[ebp+count_lines], 0
		jz	short loc_8001A58
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_elide
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	elide_tail_lines_file
		add	esp, 10h
		jmp	short locret_8001A9E
; ---------------------------------------------------------------------------

loc_8001A58:				; CODE XREF: head+41j
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_elide
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	elide_tail_bytes_file
		add	esp, 10h
		jmp	short locret_8001A9E
; ---------------------------------------------------------------------------

loc_8001A6E:				; CODE XREF: head+3Bj
		cmp	[ebp+count_lines], 0
		jz	short loc_8001A8A
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; lines_to_write
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	head_lines
		add	esp, 10h
		jmp	short locret_8001A9E
; ---------------------------------------------------------------------------

loc_8001A8A:				; CODE XREF: head+73j
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; bytes_to_write
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	head_bytes
		add	esp, 10h

locret_8001A9E:				; CODE XREF: head+57j head+6Dj ...
		leave
		retn
head		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	head_file(const	char *filename,	uintmax_t n_units, _Bool count_lines, _Bool elide_from_end)
head_file	proc near		; CODE XREF: main+45Bp

elide_from_end	= byte ptr -28h
count_lines	= byte ptr -24h
n_units		= qword	ptr -20h
is_stdin	= byte ptr -0Eh
ok		= byte ptr -0Dh
fd		= dword	ptr -0Ch
filename	= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	edx, [ebp+arg_C]
		mov	eax, [ebp+arg_10]
		mov	ecx, [ebp+arg_4]
		mov	dword ptr [ebp+n_units], ecx
		mov	ecx, [ebp+arg_8]
		mov	dword ptr [ebp+n_units+4], ecx
		mov	[ebp+count_lines], dl
		mov	[ebp+elide_from_end], al
		sub	esp, 8
		push	offset asc_8002986 ; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_8001B04
		mov	ds:have_read_stdin, 1
		mov	[ebp+fd], 0
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	[ebp+filename],	eax
		jmp	short loc_8001B5D
; ---------------------------------------------------------------------------

loc_8001B04:				; CODE XREF: head_file+3Fj
		sub	esp, 8
		push	0
		push	[ebp+filename]
		call	open64
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		jns	short loc_8001B5D
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8001BDF
; ---------------------------------------------------------------------------

loc_8001B5D:				; CODE XREF: head_file+62j
					; head_file+7Bj
		movzx	edx, [ebp+elide_from_end]
		movzx	eax, [ebp+count_lines]
		sub	esp, 8
		push	edx		; elide_from_end
		push	eax		; count_lines
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_units
		push	[ebp+fd]	; fd
		push	[ebp+filename]	; filename
		call	head
		add	esp, 20h
		mov	[ebp+ok], al
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8001BDB
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001BDB
		sub	esp, 0Ch
		push	[ebp+filename]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClosingS ; "closing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8001BDF
; ---------------------------------------------------------------------------

loc_8001BDB:				; CODE XREF: head_file+EAj
					; head_file+FCj
		movzx	eax, [ebp+ok]

loc_8001BDF:				; CODE XREF: head_file+B8j
					; head_file+139j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
head_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl string_to_integer(_Bool count_lines, const char *n_string)
string_to_integer proc near		; CODE XREF: main+1CFp	main+287p ...

n_string	= dword	ptr -30h
count_lines	= byte ptr -2Ch
s_err		= dword	ptr -1Ch
n		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	[ebp+count_lines], al
		mov	eax, [ebp+arg_4]
		mov	[ebp+n_string],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aBkkmmgtpezy0 ; "bkKmMGTPEZY0"
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		push	0
		push	[ebp+n_string]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+s_err], eax
		cmp	[ebp+s_err], 1
		jnz	short loc_8001C78
		cmp	[ebp+count_lines], 0
		jz	short loc_8001C42
		sub	esp, 0Ch
		push	offset aNumberOfLines ;	"number	of lines"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		jmp	short loc_8001C54
; ---------------------------------------------------------------------------

loc_8001C42:				; CODE XREF: string_to_integer+46j
		sub	esp, 0Ch
		push	offset aNumberOfBytes ;	"number	of bytes"
		call	gettext
		add	esp, 10h
		mov	ebx, eax

loc_8001C54:				; CODE XREF: string_to_integer+5Aj
		sub	esp, 0Ch
		push	offset aSSIsSoLargeTha ; "%s: %s is so large that it is	not repre"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	[ebp+n_string]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_8001C78:				; CODE XREF: string_to_integer+40j
		cmp	[ebp+s_err], 0
		jz	short loc_8001CBE
		cmp	[ebp+count_lines], 0
		jz	short loc_8001C96
		sub	esp, 0Ch
		push	offset aInvalidNumberO ; "invalid number of lines"
		call	gettext
		add	esp, 10h
		jmp	short loc_8001CA6
; ---------------------------------------------------------------------------

loc_8001C96:				; CODE XREF: string_to_integer+9Cj
		sub	esp, 0Ch
		push	offset aInvalidNumbe_0 ; "invalid number of bytes"
		call	gettext
		add	esp, 10h

loc_8001CA6:				; CODE XREF: string_to_integer+AEj
		sub	esp, 0Ch
		push	eax
		push	[ebp+n_string]
		push	offset aSS_0	; "%s: %s"
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_8001CBE:				; CODE XREF: string_to_integer+96j
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8001CD5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001CD5:				; CODE XREF: string_to_integer+E8j
		mov	ebx, [ebp+var_4]
		leave
		retn
string_to_integer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -6Ch
ok		= byte ptr -60h
count_lines	= byte ptr -5Fh
elide_from_end	= byte ptr -5Eh
multiplier_char	= byte ptr -5Dh
header_mode	= dword	ptr -5Ch
i		= dword	ptr -58h
a		= dword	ptr -54h
n_string	= dword	ptr -50h
end_n_string	= dword	ptr -4Ch
c		= dword	ptr -48h
file_list	= dword	ptr -44h
n_units		= qword	ptr -40h
umax_buf	= byte ptr -31h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 6Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+header_mode], 0
		mov	[ebp+ok], 1
		mov	dword ptr [ebp+n_units], 0Ah
		mov	dword ptr [ebp+n_units+4], 0
		mov	[ebp+count_lines], 1
		mov	[ebp+elide_from_end], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:have_read_stdin, 0
		mov	ds:print_headers, 0
		cmp	dword ptr [ebx], 1
		jle	loc_8002049
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	loc_8002049
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_8002049
		mov	eax, [ebp+argv]
		mov	eax, [eax+4]
		mov	[ebp+a], eax
		add	[ebp+a], 1
		mov	eax, [ebp+a]
		mov	[ebp+n_string],	eax
		mov	[ebp+multiplier_char], 0

loc_8001DD7:				; CODE XREF: main+110j
		add	[ebp+a], 1
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8001DD7
		mov	eax, [ebp+a]
		mov	[ebp+end_n_string], eax
		jmp	loc_8001E77
; ---------------------------------------------------------------------------

loc_8001DF7:				; CODE XREF: main+1A5j
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 62h	; switch 21 cases
		cmp	eax, 14h
		ja	short loc_8001E42 ; jumptable 08001E0F default case
		mov	eax, ds:off_8002ABC[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001E11:				; CODE XREF: main+135j
					; DATA XREF: .rodata:off_8002ABCo
		mov	[ebp+count_lines], 0 ; jumptable 08001E0F case 99
		mov	[ebp+multiplier_char], 0
		jmp	short loc_8001E73
; ---------------------------------------------------------------------------

loc_8001E1B:				; CODE XREF: main+135j
					; DATA XREF: .rodata:off_8002ABCo
		mov	[ebp+count_lines], 0 ; jumptable 08001E0F cases	98,107,109
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		mov	[ebp+multiplier_char], al
		jmp	short loc_8001E73
; ---------------------------------------------------------------------------

loc_8001E2A:				; CODE XREF: main+135j
					; DATA XREF: .rodata:off_8002ABCo
		mov	[ebp+count_lines], 1 ; jumptable 08001E0F case 108
		jmp	short loc_8001E73
; ---------------------------------------------------------------------------

loc_8001E30:				; CODE XREF: main+135j
					; DATA XREF: .rodata:off_8002ABCo
		mov	[ebp+header_mode], 2 ; jumptable 08001E0F case 113
		jmp	short loc_8001E73
; ---------------------------------------------------------------------------

loc_8001E39:				; CODE XREF: main+135j
					; DATA XREF: .rodata:off_8002ABCo
		mov	[ebp+header_mode], 1 ; jumptable 08001E0F case 118
		jmp	short loc_8001E73
; ---------------------------------------------------------------------------

loc_8001E42:				; CODE XREF: main+12Cj	main+135j
					; DATA XREF: ...
		mov	eax, [ebp+a]	; jumptable 08001E0F default case
		movzx	eax, byte ptr [eax]
		movsx	ebx, al
		sub	esp, 0Ch
		push	offset aInvalidTrailin ; "invalid trailing option -- %c"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001E73:				; CODE XREF: main+13Fj	main+14Ej ...
		add	[ebp+a], 1

loc_8001E77:				; CODE XREF: main+118j
		mov	eax, [ebp+a]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001DF7
		mov	eax, [ebp+end_n_string]
		movzx	edx, [ebp+multiplier_char]
		mov	[eax], dl
		cmp	[ebp+multiplier_char], 0
		jz	short loc_8001E9E
		add	[ebp+end_n_string], 1
		mov	eax, [ebp+end_n_string]
		mov	byte ptr [eax],	0

loc_8001E9E:				; CODE XREF: main+1B8j
		movzx	eax, [ebp+count_lines]
		sub	esp, 8
		push	[ebp+n_string]	; n_string
		push	eax		; count_lines
		call	string_to_integer
		add	esp, 10h
		mov	dword ptr [ebp+n_units], eax
		mov	dword ptr [ebp+n_units+4], edx
		mov	eax, [ebp+argv]
		lea	edx, [eax+4]
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+argv], 4
		sub	dword ptr [ebx], 1
		jmp	loc_8002049
; ---------------------------------------------------------------------------

loc_8001ED0:				; CODE XREF: main+392j
		mov	eax, [ebp+c]
		cmp	eax, 6Eh
		jz	loc_8001F74
		cmp	eax, 6Eh
		jg	short loc_8001F01
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8001FD2
		cmp	eax, 63h
		jz	short loc_8001F2B
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8001FDC
		jmp	loc_8002014
; ---------------------------------------------------------------------------

loc_8001F01:				; CODE XREF: main+205j
		cmp	eax, 76h
		jz	loc_8001FC9
		cmp	eax, 80h
		jz	short loc_8001F1F
		cmp	eax, 71h
		jz	loc_8001FBD
		jmp	loc_8002014
; ---------------------------------------------------------------------------

loc_8001F1F:				; CODE XREF: main+235j
		mov	ds:presume_input_pipe, 1
		jmp	loc_8002049
; ---------------------------------------------------------------------------

loc_8001F2B:				; CODE XREF: main+215j
		mov	[ebp+count_lines], 0
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		setz	al
		mov	[ebp+elide_from_end], al
		cmp	[ebp+elide_from_end], 0
		jz	short loc_8001F52
		mov	eax, ds:optarg
		add	eax, 1
		mov	ds:optarg, eax

loc_8001F52:				; CODE XREF: main+269j
		mov	edx, ds:optarg
		movzx	eax, [ebp+count_lines]
		sub	esp, 8
		push	edx		; n_string
		push	eax		; count_lines
		call	string_to_integer
		add	esp, 10h
		mov	dword ptr [ebp+n_units], eax
		mov	dword ptr [ebp+n_units+4], edx
		jmp	loc_8002049
; ---------------------------------------------------------------------------

loc_8001F74:				; CODE XREF: main+1FCj
		mov	[ebp+count_lines], 1
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		setz	al
		mov	[ebp+elide_from_end], al
		cmp	[ebp+elide_from_end], 0
		jz	short loc_8001F9B
		mov	eax, ds:optarg
		add	eax, 1
		mov	ds:optarg, eax

loc_8001F9B:				; CODE XREF: main+2B2j
		mov	edx, ds:optarg
		movzx	eax, [ebp+count_lines]
		sub	esp, 8
		push	edx		; n_string
		push	eax		; count_lines
		call	string_to_integer
		add	esp, 10h
		mov	dword ptr [ebp+n_units], eax
		mov	dword ptr [ebp+n_units+4], edx
		jmp	loc_8002049
; ---------------------------------------------------------------------------

loc_8001FBD:				; CODE XREF: main+23Aj
		mov	[ebp+header_mode], 2
		jmp	loc_8002049
; ---------------------------------------------------------------------------

loc_8001FC9:				; CODE XREF: main+22Aj
		mov	[ebp+header_mode], 1
		jmp	short loc_8002049
; ---------------------------------------------------------------------------

loc_8001FD2:				; CODE XREF: main+20Cj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001FDC:				; CODE XREF: main+21Cj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aHead	; "head"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002014:				; CODE XREF: main+222j	main+240j
		mov	eax, [ebp+c]
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_800203F
		sub	esp, 0Ch
		push	offset aInvalidTrailin ; "invalid trailing option -- %c"
		call	gettext
		add	esp, 10h
		push	[ebp+c]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800203F:				; CODE XREF: main+343j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002049:				; CODE XREF: main+B0j main+C3j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "c:n:qv0123456789"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8001ED0
		cmp	[ebp+header_mode], 1
		jz	short loc_800208C
		cmp	[ebp+header_mode], 0
		jnz	short loc_8002093
		mov	eax, [ebx]
		lea	edx, [eax-1]
		mov	eax, ds:optind
		cmp	edx, eax
		jle	short loc_8002093

loc_800208C:				; CODE XREF: main+39Cj
		mov	ds:print_headers, 1

loc_8002093:				; CODE XREF: main+3A2j	main+3B0j
		movzx	eax, [ebp+count_lines]
		xor	eax, 1
		test	al, al
		jz	short loc_80020E3
		cmp	[ebp+elide_from_end], 0
		jz	short loc_80020E3
		mov	eax, dword ptr [ebp+n_units]
		mov	edx, dword ptr [ebp+n_units+4]
		test	edx, edx
		jns	short loc_80020E3
		sub	esp, 4
		lea	eax, [ebp+umax_buf]
		push	eax
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]
		call	umaxtostr
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSNumberOfBytes ; "%s: number of	bytes is too large"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80020E3:				; CODE XREF: main+3C2j	main+3C8j ...
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_80020FF
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		jmp	short loc_8002104
; ---------------------------------------------------------------------------

loc_80020FF:				; CODE XREF: main+410j
		mov	eax, offset default_file_list_5348

loc_8002104:				; CODE XREF: main+423j
		mov	[ebp+file_list], eax
		mov	[ebp+i], 0
		jmp	short loc_8002152
; ---------------------------------------------------------------------------

loc_8002110:				; CODE XREF: main+48Bj
		movzx	ecx, [ebp+elide_from_end]
		movzx	edx, [ebp+count_lines]
		mov	eax, [ebp+i]
		lea	ebx, ds:0[eax*4]
		mov	eax, [ebp+file_list]
		add	eax, ebx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	ecx		; elide_from_end
		push	edx		; count_lines
		push	dword ptr [ebp+n_units+4]
		push	dword ptr [ebp+n_units]	; n_units
		push	eax		; filename
		call	head_file
		add	esp, 20h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	[ebp+i], 1

loc_8002152:				; CODE XREF: main+434j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file_list]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8002110
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_800219D
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_800219D
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_8002986 ; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800219D:				; CODE XREF: main+496j	main+4A7j
		cmp	[ebp+ok], 0
		jz	short loc_80021AA
		mov	eax, 0
		jmp	short loc_80021AF
; ---------------------------------------------------------------------------

loc_80021AA:				; CODE XREF: main+4C7j
		mov	eax, 1

loc_80021AF:				; CODE XREF: main+4CEj
		sub	esp, 0Ch
		push	eax		; status

loc_80021B3:				; DATA XREF: .eh_frame:08002B38o
					; .eh_frame:08002B5Co ...
		call	exit
main		endp

_text		ends

; Function-local static	variable
; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
		assume cs:_data
		;org 80021B8h
; _Bool	first_file_5162
first_file_5162	db 1			; DATA XREF: write_header+6r
					; write_header+31w
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
		assume cs:_bss
		;org 80021B9h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; _Bool	presume_input_pipe
presume_input_pipe db ?			; DATA XREF: elide_tail_bytes_file+31r
					; elide_tail_lines_file+12r ...
; _Bool	print_headers
print_headers	db ?			; DATA XREF: head+1Er main+A6w ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: head_file+41w main+9Fw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80021C0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+72o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+31Do
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aBytes		db 'bytes',0            ; DATA XREF: .rodata:long_optionso
aLines		db 'lines',0            ; DATA XREF: .rodata:long_optionso
aPresumeInputPi	db '-presume-input-pipe',0 ; DATA XREF: .rodata:long_optionso
aQuiet		db 'quiet',0            ; DATA XREF: .rodata:long_optionso
aSilent		db 'silent',0           ; DATA XREF: .rodata:long_optionso
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[9]
long_options	option <offset aBytes, 1, 0, 63h> ; DATA XREF: main+374o
		option <offset aLines, 1, 0, 6Eh> ; "bytes"
		option <offset aPresumeInputPi,	0, 0, 80h>
		option <offset aQuiet, 0, 0, 71h>
		option <offset aSilent,	0, 0, 71h>
		option <offset aVerbose, 0, 0, 76h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aPrintTheFirst1[]
aPrintTheFirst1	db 'Print the first 10 lines of each FILE to standard output.',0Ah
					; DATA XREF: usage+69o
		db 'With more than one FILE, precede each with a header giving the fi'
		db 'le name.',0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aCBytesKPrintTh[]
aCBytesKPrintTh	db '  -c, --bytes=[-]K         print the first K bytes of each file;',0Ah
					; DATA XREF: usage+AFo
		db '                             with the leading `-',27h,', print all b'
		db 'ut the last',0Ah
		db '                             K bytes of each file',0Ah
		db '  -n, --lines=[-]K         print the first K lines instead of the'
		db ' first 10;',0Ah
		db '                             with the leading `-',27h,', print all b'
		db 'ut the last',0Ah
		db '                             K lines of each file',0Ah,0
		align 4
; char aQQuietSilentNe[]
aQQuietSilentNe	db '  -q, --quiet, --silent    never print headers giving file names',0Ah
					; DATA XREF: usage+D2o
		db '  -v, --verbose            always print headers giving file names'
		db 0Ah,0
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+F5o
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+118o
		align 4
; char aKMayHaveAMulti[]
aKMayHaveAMulti	db 0Ah			; DATA XREF: usage+13Bo
		db 'K may have a multiplier suffix:',0Ah
		db 'b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,',0Ah
		db 'GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.'
		db 0Ah,0
; char aErrorReadingS[]
aErrorReadingS	db 'error reading %s',0 ; DATA XREF: diagnose_copy_fd_failure+2Eo
					; elide_tail_bytes_pipe+11Do ...
; char aErrorWritingS[]
aErrorWritingS	db 'error writing %s',0 ; DATA XREF: diagnose_copy_fd_failure+66o
; char aSFileHasShrunk[]
aSFileHasShrunk	db '%s: file has shrunk too much',0
					; DATA XREF: diagnose_copy_fd_failure+9Eo
; char locale
locale		db 0			; DATA XREF: write_header+11o main+5Bo
asc_800288F	db 0Ah,0		; DATA XREF: write_header:loc_8000369o
; char format[]
format		db '%s==> %s <==',0Ah,0 ; DATA XREF: write_header+24o
		align 10h
; char aSNumberOfBytes[]
aSNumberOfBytes	db '%s: number of bytes is too large',0
					; DATA XREF: elide_tail_bytes_pipe+6Do
					; main+3EEo
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: elide_tail_bytes_pipe+1DAo
					; elide_tail_bytes_pipe+398o ...
; char aCannotLseekS[]
aCannotLseekS	db 'cannot lseek %s',0  ; DATA XREF: elide_tail_bytes_file+107o
		align 10h
; char aSCannotLseekBa[]
aSCannotLseekBa	db '%s: cannot lseek back to original position',0
					; DATA XREF: elide_tail_bytes_file+1D2o
; char aSCannotSeekToO[]
aSCannotSeekToO	db '%s: cannot seek to offset %s',0
					; DATA XREF: elide_tail_lines_seekable+16Do
					; elide_tail_lines_seekable+44Co
; char aSUnableToResto[]
aSUnableToResto	db '%s: unable to restore file pointer to initial offset',0
					; DATA XREF: elide_tail_lines_seekable+320o
		align 10h
; char aCannotRepositi[]
aCannotRepositi	db 'cannot reposition file pointer for %s',0 ; DATA XREF: head_lines+193o
; char asc_8002986[]
asc_8002986	db '-',0                ; DATA XREF: head_file+23o main+4B3o ...
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: head_file+52o
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: head_file+90o
; char aClosingS[]
aClosingS	db 'closing %s',0       ; DATA XREF: head_file+111o
aBkkmmgtpezy0	db 'bkKmMGTPEZY0',0     ; DATA XREF: string_to_integer+21o
; char aNumberOfLines[]
aNumberOfLines	db 'number of lines',0  ; DATA XREF: string_to_integer+4Bo
; char aNumberOfBytes[]
aNumberOfBytes	db 'number of bytes',0  ; DATA XREF: string_to_integer+5Fo
		align 4
; char aSSIsSoLargeTha[]
aSSIsSoLargeTha	db '%s: %s is so large that it is not representable',0
					; DATA XREF: string_to_integer+71o
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of lines',0 ; DATA XREF: string_to_integer+A1o
; char aInvalidNumbe_0[]
aInvalidNumbe_0	db 'invalid number of bytes',0 ; DATA XREF: string_to_integer+B3o
; char aSS_0[]
aSS_0		db '%s: %s',0           ; DATA XREF: string_to_integer+C7o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+6Do
; char aInvalidTrailin[]
aInvalidTrailin	db 'invalid trailing option -- %c',0 ; DATA XREF: main+174o
					; main+348o
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+312o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+317o
aHead		db 'head',0             ; DATA XREF: main+322o
; char shortopts[]
shortopts	db 'c:n:qv0123456789',0 ; DATA XREF: main+379o
off_8002ABC	dd offset loc_8001E1B	; DATA XREF: main+12Er
		dd offset loc_8001E11	; jump table for switch	statement
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E1B
		dd offset loc_8001E2A
		dd offset loc_8001E1B
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E30
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E42
		dd offset loc_8001E39
; Function-local static	variable
; const	char *const default_file_list_5348[2]
default_file_list_5348 dd offset asc_8002986 ; DATA XREF: main:loc_80020FFo
					; "-"
		align 8
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8002B18h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_80021B3-8004CEBh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset loc_80021B3-8004BF3h
		dd 165h, 80E4100h, 0D420285h, 3834405h,	24h, 5Ch
		dd offset loc_80021B3-8004AAAh
		dd 0D0h, 80E4100h, 0D420285h, 3864205h,	0C8020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 84h
		dd offset loc_80021B3-8004A02h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 20h, 0A4h
		dd offset loc_80021B3-80049E7h
		dd 12Fh, 80E4100h, 0D420285h, 3834705h,	0C5012403h, 4040CC3h
		dd 28h,	0C8h
		dd offset loc_80021B3-80048DCh
		dd 53Bh, 80E4100h, 0D420285h, 3864505h,	30030483h, 0C641C305h
		dd 40CC541h, 4,	28h, 0F4h
		dd offset loc_80021B3-80043CDh
		dd 26Ch, 80E4100h, 0D420285h, 3864805h,	5E030483h, 0C641C302h
		dd 40CC541h, 4,	28h, 120h
		dd offset loc_80021B3-800418Dh
		dd 411h, 80E4100h, 0D420285h, 3864505h,	6030483h, 0C641C304h
		dd 40CC541h, 4,	2Ch, 14Ch
		dd offset loc_80021B3-8003DA8h
		dd 513h, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3050303h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 17Ch
		dd offset loc_80021B3-80038C5h
		dd 0B2h, 80E4100h, 0D420285h, 0C5AE0205h, 4040Ch, 28h
		dd 19Ch
		dd offset loc_80021B3-8003833h
		dd 17Dh, 80E4100h, 0D420285h, 3864805h,	6F030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 1C8h
		dd offset loc_80021B3-80036E2h
		dd 24Ah, 80E4100h, 0D420285h, 3864805h,	3C030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 1F4h
		dd offset loc_80021B3-80034C4h
		dd 0A1h, 80E4100h, 0D420285h, 0C59D0205h, 4040Ch, 28h
		dd 214h
		dd offset loc_80021B3-8003443h
		dd 146h, 80E4100h, 0D420285h, 3864505h,	3B030483h, 0C641C301h
		dd 40CC541h, 4,	20h, 240h
		dd offset loc_80021B3-8003329h
		dd 0F4h, 80E4100h, 0D420285h, 3834405h,	0C3C5EC02h, 4040Ch
		dd 28h,	264h
		dd offset loc_80021B3-8003259h
		dd 4DEh, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+62p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+160p main+335p ...
		extrn quote:near	; CODE XREF: diagnose_copy_fd_failure+21p
					; diagnose_copy_fd_failure+59p	...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: diagnose_copy_fd_failure+3Dp
					; diagnose_copy_fd_failure+75p	...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: diagnose_copy_fd_failure+49p
					; diagnose_copy_fd_failure+81p	...
; void abort(void)
		extrn abort:near	; CODE XREF: diagnose_copy_fd_failure:loc_8000344p
		extrn safe_read:near	; CODE XREF: copy_fd+7Fp
					; elide_tail_lines_pipe+86p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	copy_fd+E9p
					; elide_tail_bytes_pipe+194p ...
		extrn __stack_chk_fail:near ; CODE XREF: copy_fd+125p
					; elide_tail_bytes_pipe+52Fp ...
		extrn umaxtostr:near	; CODE XREF: elide_tail_bytes_pipe+60p
					; main+3E1p
		extrn xnmalloc:near	; CODE XREF: elide_tail_bytes_pipe+B4p
		extrn full_read:near	; CODE XREF: elide_tail_bytes_pipe+E5p
					; elide_tail_bytes_pipe+2F3p
; void free(void *ptr)
		extrn free:near		; CODE XREF: elide_tail_bytes_pipe+231p
					; elide_tail_bytes_pipe+4FDp ...
; void *xcalloc(size_t,	size_t)
		extrn xcalloc:near	; CODE XREF: elide_tail_bytes_pipe+27Dp
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: elide_tail_bytes_pipe+2CCp
					; elide_tail_lines_pipe+27p ...
		extrn fstat64:near	; CODE XREF: elide_tail_bytes_file+46p
					; head_lines+15Fp
		extrn lseek64:near	; CODE XREF: elide_tail_bytes_file+8Cp
					; elide_tail_bytes_file+C3p ...
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: elide_tail_lines_pipe+10Ap
					; elide_tail_lines_pipe+3ADp
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: elide_tail_lines_pipe+162p
		extrn offtostr:near	; CODE XREF: elide_tail_lines_seekable+160p
					; elide_tail_lines_seekable+43Fp
		extrn memrchr:near	; CODE XREF: elide_tail_lines_seekable+25Fp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: head_file+2Bp
		extrn open64:near	; CODE XREF: head_file+6Cp
; int close(int	fd)
		extrn close:near	; CODE XREF: head_file+F2p main+49Dp
		extrn xstrtoumax:near	; CODE XREF: string_to_integer+31p
		extrn set_program_name:near ; CODE XREF: main+50p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+77p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+87p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+92o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+97p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+255r	main+26Br ...
		extrn Version:dword	; DATA XREF: main:loc_8001FDCr
		extrn version_etc:near	; CODE XREF: main+328p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+383p
; int optind
		extrn optind:dword	; DATA XREF: main+3A9r
					; main:loc_80020E3r ...


		end
