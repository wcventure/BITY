;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	91193E199406D1C32AEBFE1418FF9F8A
; Input	CRC32 :	B8708AC4

; File Name   :	D:\coreutils-o\kill.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'kill.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+160p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1B3p	main+1F4p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_800015B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000281
; ---------------------------------------------------------------------------

loc_800015B:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSSSignalS ; "Usage: %s [-s	SIGNAL | -SIGNAL] PID...\"...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSendSignalsToP ; "Send signals to processes, or	list sign"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSSignalSignalS ; "  -s,	--signal=SIGNAL, -SIGNAL\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSignalMayBeASi ; "\nSIGNAL may be a signal name	like `HUP"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aNoteYourShellM ; "\nNOTE: your shell may have its own ver"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aKill	; "kill"
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_8000281:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_table_row(unsigned	int num_width, int signum, unsigned int	name_width, const char *signame)
print_table_row	proc near		; CODE XREF: list_signals+E3p
					; list_signals+129p

description	= dword	ptr -0Ch
num_width	= dword	ptr  8
signum		= dword	ptr  0Ch
name_width	= dword	ptr  10h
signame		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	[ebp+signum]
		call	strsignal
		add	esp, 10h
		mov	[ebp+description], eax
		cmp	[ebp+description], 0
		jz	short loc_80002AE
		mov	eax, [ebp+description]
		jmp	short loc_80002B3
; ---------------------------------------------------------------------------

loc_80002AE:				; CODE XREF: print_table_row+1Bj
		mov	eax, offset a?	; "?"

loc_80002B3:				; CODE XREF: print_table_row+20j
		sub	esp, 8
		push	eax
		push	[ebp+signame]
		push	[ebp+name_width]
		push	[ebp+signum]
		push	[ebp+num_width]
		push	offset format	; "%*d %-*s %s\n"
		call	printf
		add	esp, 20h
		nop
		leave
		retn
print_table_row	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl list_signals(_Bool table,	char *const *argv)
list_signals	proc near		; CODE XREF: main+37Cp

argv		= dword	ptr -40h
table		= byte ptr -3Ch
signum		= dword	ptr -34h
status		= dword	ptr -30h
name_width	= dword	ptr -2Ch
num_width	= dword	ptr -28h
len		= dword	ptr -24h
signame		= byte ptr -1Fh
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	eax, [ebp+arg_0]
		mov	[ebp+table], al
		mov	eax, [ebp+arg_4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+status], 0
		cmp	[ebp+table], 0
		jz	loc_8000413
		mov	[ebp+name_width], 0
		mov	[ebp+num_width], 1
		mov	[ebp+signum], 1
		jmp	short loc_800032B
; ---------------------------------------------------------------------------

loc_8000318:				; CODE XREF: list_signals+5Cj
		add	[ebp+num_width], 1
		mov	edx, [ebp+signum]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	[ebp+signum], eax

loc_800032B:				; CODE XREF: list_signals+43j
		cmp	[ebp+signum], 6
		jle	short loc_8000318
		mov	[ebp+signum], 1
		jmp	short loc_8000374
; ---------------------------------------------------------------------------

loc_800033A:				; CODE XREF: list_signals+A5j
		sub	esp, 8
		lea	eax, [ebp+signame]
		push	eax
		push	[ebp+signum]
		call	sig2str
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000370
		sub	esp, 0Ch
		lea	eax, [ebp+signame]
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, [ebp+name_width]
		cmp	eax, [ebp+len]
		jnb	short loc_8000370
		mov	eax, [ebp+len]
		mov	[ebp+name_width], eax

loc_8000370:				; CODE XREF: list_signals+7Bj
					; list_signals+95j
		add	[ebp+signum], 1

loc_8000374:				; CODE XREF: list_signals+65j
		cmp	[ebp+signum], 40h
		jle	short loc_800033A
		cmp	[ebp+argv], 0
		jz	short loc_80003D0
		jmp	short loc_80003C2
; ---------------------------------------------------------------------------

loc_8000382:				; CODE XREF: list_signals+F6j
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+signame]
		push	edx
		push	eax
		call	operand2sig
		add	esp, 10h
		mov	[ebp+signum], eax
		cmp	[ebp+signum], 0
		jns	short loc_80003A9
		mov	[ebp+status], 1
		jmp	short loc_80003BE
; ---------------------------------------------------------------------------

loc_80003A9:				; CODE XREF: list_signals+CBj
		lea	eax, [ebp+signame]
		push	eax		; signame
		push	[ebp+name_width] ; name_width
		push	[ebp+signum]	; signum
		push	[ebp+num_width]	; num_width
		call	print_table_row
		add	esp, 10h

loc_80003BE:				; CODE XREF: list_signals+D4j
		add	[ebp+argv], 4

loc_80003C2:				; CODE XREF: list_signals+ADj
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8000382
		jmp	loc_80004C0
; ---------------------------------------------------------------------------

loc_80003D0:				; CODE XREF: list_signals+ABj
		mov	[ebp+signum], 1
		jmp	short loc_8000408
; ---------------------------------------------------------------------------

loc_80003D9:				; CODE XREF: list_signals+139j
		sub	esp, 8
		lea	eax, [ebp+signame]
		push	eax
		push	[ebp+signum]
		call	sig2str
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000404
		lea	eax, [ebp+signame]
		push	eax		; signame
		push	[ebp+name_width] ; name_width
		push	[ebp+signum]	; signum
		push	[ebp+num_width]	; num_width
		call	print_table_row
		add	esp, 10h

loc_8000404:				; CODE XREF: list_signals+11Aj
		add	[ebp+signum], 1

loc_8000408:				; CODE XREF: list_signals+104j
		cmp	[ebp+signum], 40h
		jle	short loc_80003D9
		jmp	loc_80004C0
; ---------------------------------------------------------------------------

loc_8000413:				; CODE XREF: list_signals+28j
		cmp	[ebp+argv], 0
		jz	short loc_8000488
		jmp	short loc_800047D
; ---------------------------------------------------------------------------

loc_800041B:				; CODE XREF: list_signals+1B1j
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+signame]
		push	edx
		push	eax
		call	operand2sig
		add	esp, 10h
		mov	[ebp+signum], eax
		cmp	[ebp+signum], 0
		jns	short loc_8000442
		mov	[ebp+status], 1
		jmp	short loc_8000479
; ---------------------------------------------------------------------------

loc_8000442:				; CODE XREF: list_signals+164j
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_8000466
		sub	esp, 0Ch
		lea	eax, [ebp+signame]
		push	eax		; s
		call	puts
		add	esp, 10h
		jmp	short loc_8000479
; ---------------------------------------------------------------------------

loc_8000466:				; CODE XREF: list_signals+180j
		sub	esp, 8
		push	[ebp+signum]
		push	offset aD	; "%d\n"
		call	printf
		add	esp, 10h

loc_8000479:				; CODE XREF: list_signals+16Dj
					; list_signals+191j
		add	[ebp+argv], 4

loc_800047D:				; CODE XREF: list_signals+146j
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_800041B
		jmp	short loc_80004C0
; ---------------------------------------------------------------------------

loc_8000488:				; CODE XREF: list_signals+144j
		mov	[ebp+signum], 1
		jmp	short loc_80004BA
; ---------------------------------------------------------------------------

loc_8000491:				; CODE XREF: list_signals+1EBj
		sub	esp, 8
		lea	eax, [ebp+signame]
		push	eax
		push	[ebp+signum]
		call	sig2str
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80004B6
		sub	esp, 0Ch
		lea	eax, [ebp+signame]
		push	eax		; s
		call	puts
		add	esp, 10h

loc_80004B6:				; CODE XREF: list_signals+1D2j
		add	[ebp+signum], 1

loc_80004BA:				; CODE XREF: list_signals+1BCj
		cmp	[ebp+signum], 40h
		jle	short loc_8000491

loc_80004C0:				; CODE XREF: list_signals+F8j
					; list_signals+13Bj ...
		mov	eax, [ebp+status]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80004D4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80004D4:				; CODE XREF: list_signals+1FAj
		leave
		retn
list_signals	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl send_signals(int signum, char *const *argv)
send_signals	proc near		; CODE XREF: main+39Ep

argv		= dword	ptr -2Ch
endp		= dword	ptr -28h
status		= dword	ptr -24h
arg		= dword	ptr -20h
pid		= dword	ptr -1Ch
n		= qword	ptr -18h
var_C		= dword	ptr -0Ch
signum		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+status], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		mov	[ebp+arg], eax

loc_80004FC:				; CODE XREF: send_signals+F0j
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	0Ah		; base
		lea	eax, [ebp+endp]
		push	eax		; endptr
		push	[ebp+arg]	; nptr
		call	strtoimax
		add	esp, 10h
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		mov	eax, dword ptr [ebp+n]
		mov	[ebp+pid], eax
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 22h
		jz	short loc_8000557
		mov	eax, [ebp+pid]
		cdq
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+n+4]
		xor	eax, dword ptr [ebp+n]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000557
		mov	eax, [ebp+endp]
		cmp	[ebp+arg], eax
		jz	short loc_8000557
		mov	eax, [ebp+endp]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000580

loc_8000557:				; CODE XREF: send_signals+5Bj
					; send_signals+6Dj ...
		sub	esp, 0Ch
		push	offset aSInvalidProces ; "%s: invalid process id"
		call	gettext
		add	esp, 10h
		push	[ebp+arg]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+status], 1
		jmp	short loc_80005B6
; ---------------------------------------------------------------------------

loc_8000580:				; CODE XREF: send_signals+7Fj
		sub	esp, 8
		push	[ebp+signum]	; sig
		push	[ebp+pid]	; pid
		call	kill
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005B6
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+arg]
		push	offset aS	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+status], 1

loc_80005B6:				; CODE XREF: send_signals+A8j
					; send_signals+BDj
		add	[ebp+argv], 4
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		mov	[ebp+arg], eax
		cmp	[ebp+arg], 0
		jnz	loc_80004FC
		mov	eax, [ebp+status]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_80005E0
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80005E0:				; CODE XREF: send_signals+103j
		leave
		retn
send_signals	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -4Ch
list		= byte ptr -3Ah
table		= byte ptr -39h
signum		= dword	ptr -38h
optc		= dword	ptr -34h
signame		= byte ptr -2Fh
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 4Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+list], 0
		mov	[ebp+table], 0
		mov	[ebp+signum], 0FFFFFFFFh
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	loc_8000888
; ---------------------------------------------------------------------------

loc_8000674:				; CODE XREF: main+2C9j
		mov	eax, [ebp+optc]
		cmp	eax, 5Ah
		jg	short loc_80006B1
		cmp	eax, 41h
		jge	short loc_8000700
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000841
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_80006A3
		cmp	eax, 0FFFFFF7Dh
		jz	loc_800084B
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_80006A3:				; CODE XREF: main+AFj
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_800087E
		jmp	short loc_80006E4
; ---------------------------------------------------------------------------

loc_80006B1:				; CODE XREF: main+98j
		cmp	eax, 6Eh
		jz	loc_80007A7
		cmp	eax, 6Eh
		jg	short loc_80006CD
		cmp	eax, 6Ch
		jz	loc_800080B
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_80006CD:				; CODE XREF: main+DBj
		cmp	eax, 73h
		jz	loc_80007A7
		cmp	eax, 74h
		jz	loc_8000807
		jmp	loc_800087E
; ---------------------------------------------------------------------------

loc_80006E4:				; CODE XREF: main+CDj
		mov	eax, ds:optind
		cmp	eax, 2
		jz	short loc_8000700
		mov	eax, ds:optind
		sub	eax, 1
		mov	ds:optind, eax
		jmp	no_more_options
; ---------------------------------------------------------------------------

loc_8000700:				; CODE XREF: main+9Dj main+10Aj
		mov	eax, ds:optarg
		test	eax, eax
		jnz	short loc_800074C
		mov	eax, ds:optind
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	esi, [eax]
		mov	eax, ds:optind
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		add	eax, esi
		mov	ds:optarg, eax

loc_800074C:				; CODE XREF: main+125j
		mov	eax, ds:optind
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		lea	edx, [eax+2]
		mov	eax, ds:optarg
		cmp	edx, eax
		jz	short loc_800079A
		sub	esp, 0Ch
		push	offset aInvalidOptionC ; "invalid option -- %c"
		call	gettext
		add	esp, 10h
		push	[ebp+optc]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800079A:				; CODE XREF: main+18Cj
		mov	eax, ds:optarg
		sub	eax, 1
		mov	ds:optarg, eax

loc_80007A7:				; CODE XREF: main+D2j main+EEj
		cmp	[ebp+signum], 0
		js	short loc_80007DB
		mov	ebx, ds:optarg
		sub	esp, 0Ch
		push	offset aSMultipleSigna ; "%s: multiple signals specified"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80007DB:				; CODE XREF: main+1C9j
		mov	eax, ds:optarg
		sub	esp, 8
		lea	edx, [ebp+signame]
		push	edx
		push	eax
		call	operand2sig
		add	esp, 10h
		mov	[ebp+signum], eax
		cmp	[ebp+signum], 0
		jns	loc_8000888
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000807:				; CODE XREF: main+F7j
		mov	[ebp+table], 1

loc_800080B:				; CODE XREF: main+E0j
		cmp	[ebp+list], 0
		jz	short loc_800083B
		sub	esp, 0Ch
		push	offset aMultipleLOrTOp ; "multiple -l or -t options specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800083B:				; CODE XREF: main+22Dj
		mov	[ebp+list], 1
		jmp	short loc_8000888
; ---------------------------------------------------------------------------

loc_8000841:				; CODE XREF: main+A4j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800084B:				; CODE XREF: main+B6j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aPaulEggert ; "Paul Eggert"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aKill	; "kill"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800087E:				; CODE XREF: main+BCj main+C7j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000888:				; CODE XREF: main+8Dj main+215j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset short_options ; "0::1::2::3::4::5::6::7::8::9::A::B::C::"...
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_8000674

no_more_options:			; CODE XREF: main+119j
		cmp	[ebp+signum], 0
		jns	short loc_80008C0
		mov	[ebp+signum], 0Fh
		jmp	short loc_80008F0
; ---------------------------------------------------------------------------

loc_80008C0:				; CODE XREF: main+2D3j
		cmp	[ebp+list], 0
		jz	short loc_80008F0
		sub	esp, 0Ch
		push	offset aCannotCombineS ; "cannot combine signal	with -l	or -t"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80008F0:				; CODE XREF: main+2DCj	main+2E2j
		movzx	eax, [ebp+list]
		xor	eax, 1
		test	al, al
		jz	short loc_800092E
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_800092E
		sub	esp, 0Ch
		push	offset aNoProcessIdSpe ; "no process ID	specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800092E:				; CODE XREF: main+317j	main+320j
		cmp	[ebp+list], 0
		jz	short loc_8000968
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_8000950
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	edx, eax
		jmp	short loc_8000955
; ---------------------------------------------------------------------------

loc_8000950:				; CODE XREF: main+359j
		mov	edx, 0

loc_8000955:				; CODE XREF: main+36Cj
		movzx	eax, [ebp+table]
		sub	esp, 8
		push	edx		; argv
		push	eax		; table
		call	list_signals
		add	esp, 10h
		jmp	short loc_8000988
; ---------------------------------------------------------------------------

loc_8000968:				; CODE XREF: main+350j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		sub	esp, 8
		push	eax		; argv
		push	[ebp+signum]	; signum
		call	send_signals
		add	esp, 10h

loc_8000988:				; CODE XREF: main+384j
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8000999
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000999:				; CODE XREF: main+3B0j
		lea	esp, [ebp-0Ch]
		pop	ecx
		pop	ebx
		pop	esi
		pop	ebp
		lea	esp, [ecx-4]

locret_80009A3:				; DATA XREF: .eh_frame:08001100o
					; .eh_frame:08001124o ...
		retn
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80009C0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+60o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+27Fo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 20h
; char short_options[115]
short_options	db '0::1::2::3::4::5::6::7::8::9::A::B::C::D::E::F::G::H::I::J::K::L:'
					; DATA XREF: main+2B0o
		db ':M::N::O::P::Q::R::S::T::U::V::W::X::Y::Z::ln:s:t',0
aList		db 'list',0             ; DATA XREF: .rodata:long_optionso
aSignal		db 'signal',0           ; DATA XREF: .rodata:long_optionso
aTable		db 'table',0            ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[6]
long_options	option <offset aList, 0, 0, 6Ch> ; DATA	XREF: main+2ABo
		option <offset aSignal,	1, 0, 73h> ; "list"
		option <offset aTable, 0, 0, 74h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSSSignalS[]
aUsageSSSignalS	db 'Usage: %s [-s SIGNAL | -SIGNAL] PID...',0Ah ; DATA XREF: usage+54o
		db '  or:  %s -l [SIGNAL]...',0Ah
		db '  or:  %s -t [SIGNAL]...',0Ah,0
		align 4
; char aSendSignalsToP[]
aSendSignalsToP	db 'Send signals to processes, or list signals.',0Ah ; DATA XREF: usage+76o
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+99o
		db 'ns too.',0Ah,0
		align 10h
; char aSSignalSignalS[]
aSSignalSignalS	db '  -s, --signal=SIGNAL, -SIGNAL',0Ah ; DATA XREF: usage+BCo
		db '                   specify the name or number of the signal to be'
		db ' sent',0Ah
		db '  -l, --list       list signal names, or convert signal names to/'
		db 'from numbers',0Ah
		db '  -t, --table      print a table of signal information',0Ah,0
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+DFo
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+102o
		align 4
; char aSignalMayBeASi[]
aSignalMayBeASi	db 0Ah			; DATA XREF: usage+125o
		db 'SIGNAL may be a signal name like `HUP',27h,', or a signal number lik'
		db 'e `1',27h,',',0Ah
		db 'or the exit status of a process terminated by a signal.',0Ah
		db 'PID is an integer; if negative it identifies a process group.',0Ah,0
		align 4
; char aNoteYourShellM[]
aNoteYourShellM	db 0Ah			; DATA XREF: usage+142o
		db 'NOTE: your shell may have its own version of %s, which usually su'
		db 'persedes',0Ah
		db 'the version described here.  Please refer to your shell',27h,'s docu'
		db 'mentation',0Ah
		db 'for details about the options it supports.',0Ah,0
aKill		db 'kill',0             ; DATA XREF: usage+152o main+284o
a?		db '?',0                ; DATA XREF: print_table_row:loc_80002AEo
; char format[]
format		db '%*d %-*s %s',0Ah,0  ; DATA XREF: print_table_row+37o
; char aD[]
aD		db '%d',0Ah,0           ; DATA XREF: list_signals+199o
; char aSInvalidProces[]
aSInvalidProces	db '%s: invalid process id',0 ; DATA XREF: send_signals+84o
; char aS[]
aS		db '%s',0               ; DATA XREF: send_signals+C9o
; char locale
locale		db 0			; DATA XREF: main+49o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+5Bo
; char aInvalidOptionC[]
aInvalidOptionC	db 'invalid option -- %c',0 ; DATA XREF: main+191o
		align 4
; char aSMultipleSigna[]
aSMultipleSigna	db '%s: multiple signals specified',0 ; DATA XREF: main+1D4o
		align 4
; char aMultipleLOrTOp[]
aMultipleLOrTOp	db 'multiple -l or -t options specified',0 ; DATA XREF: main+232o
aPaulEggert	db 'Paul Eggert',0      ; DATA XREF: main+279o
; char aCannotCombineS[]
aCannotCombineS	db 'cannot combine signal with -l or -t',0 ; DATA XREF: main+2E7o
; char aNoProcessIdSpe[]
aNoProcessIdSpe	db 'no process ID specified',0 ; DATA XREF: main+325o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80010E0h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset locret_80009A3-8001AA3h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset locret_80009A3-80019ABh
		dd 170h, 80E4100h, 0D420285h, 3874605h,	5830486h, 1Ch
		dd 60h
		dd offset locret_80009A3-800185Bh
		dd 47h,	80E4100h, 0D420285h, 0C5430205h, 4040Ch, 1Ch, 80h
		dd offset locret_80009A3-8001834h
		dd 203h, 80E4100h, 0D420285h, 1FF0305h,	4040CC5h, 1Ch
		dd 0A0h
		dd offset locret_80009A3-8001651h
		dd 10Ch, 80E4100h, 0D420285h, 1080305h,	4040CC5h, 38h
		dd 0C0h
		dd offset locret_80009A3-8001565h
		dd 3C2h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 3787502h, 0CC103ABh, 0C3410001h, 0C541C641h
		dd 4040C43h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+6Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+88p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+50p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+16Bp main+297p
		extrn strsignal:near	; CODE XREF: print_table_row+Cp
		extrn sig2str:near	; CODE XREF: list_signals+71p
					; list_signals+110p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: list_signals+84p
					; main+15Bp
		extrn operand2sig:near	; CODE XREF: list_signals+BCp
					; list_signals+155p ...
; int puts(const char *s)
		extrn puts:near		; CODE XREF: list_signals+189p
					; list_signals+1DBp
		extrn __stack_chk_fail:near ; CODE XREF: list_signals+1FCp
					; send_signals+105p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: send_signals:loc_80004FCp
					; send_signals+51p ...
; intmax_t strtoimax(const char	*nptr, char **endptr, int base)
		extrn strtoimax:near	; CODE XREF: send_signals+3Dp
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: send_signals+99p
					; send_signals+D1p ...
; int kill(__pid_t pid,	int sig)
		extrn kill:near		; CODE XREF: send_signals+B3p
		extrn set_program_name:near ; CODE XREF: main+3Ep
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+65p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+75p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+80o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+85p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_80006E4r
					; main+10Cr ...
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000700r
					; main+165w ...
		extrn Version:dword	; DATA XREF: main:loc_800084Br
		extrn version_etc:near	; CODE XREF: main+28Ap
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+2BAp


		end
