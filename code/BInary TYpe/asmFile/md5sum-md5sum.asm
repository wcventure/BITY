;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	CD42F57216872F293606922B071A4435
; Input	CRC32 :	9B77C5CB

; File Name   :	D:\coreutils-o\md5sum-md5sum.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'md5sum.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl select_plural(uintmax_t n)
select_plural	proc near		; CODE XREF: digest_check+4BFp
					; digest_check+51Ep

n		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n+4], eax
		cmp	dword ptr [ebp+n+4], 0
		jbe	short loc_8000036
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		push	0
		push	0F4240h
		push	edx
		push	eax
		call	__umoddi3
		add	esp, 10h
		add	eax, 0F4240h
		jmp	short locret_8000039
; ---------------------------------------------------------------------------

loc_8000036:				; CODE XREF: select_plural+16j
		mov	eax, dword ptr [ebp+n]

locret_8000039:				; CODE XREF: select_plural+34j
		leave
		retn
select_plural	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void *__cdecl	ptr_align(const	void *ptr, size_t alignment)
ptr_align	proc near		; CODE XREF: digest_check+4Bp main+2Cp

p0		= dword	ptr -8
p1		= dword	ptr -4
ptr		= dword	ptr  8
alignment	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+ptr]
		mov	[ebp+p0], eax
		mov	eax, [ebp+alignment]
		lea	edx, [eax-1]
		mov	eax, [ebp+p0]
		add	eax, edx
		mov	[ebp+p1], eax
		mov	eax, [ebp+p1]
		mov	edx, 0
		div	[ebp+alignment]
		mov	eax, edx
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+p1]
		add	eax, edx
		leave
		retn
ptr_align	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+158p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000153
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000153
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000153:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	bad_cast(const char *s)
bad_cast	proc near		; CODE XREF: main+328p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+s]
		pop	ebp
		retn
bad_cast	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+176p	main+1BAp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80001CE
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002EE
; ---------------------------------------------------------------------------

loc_80001CE:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\nPrint "...
		call	gettext
		add	esp, 10h
		push	80h
		push	offset aMd5	; "MD5"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBBinaryReadInB ; "  -b,	--binary	    read in binar"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aCCheckReadSSum ; "  -c,	--check		    read %s sums "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aMd5	; "MD5"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTTextReadInTex ; "  -t,	--text		    read in text "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTheFollowingTh ; "\nThe	following three	options	are usefu"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aTheSumsAreComp ; "\nThe	sums are computed as described in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aRfc1321	; "RFC 1321"
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_80002EE:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)
bsd_split_3	proc near		; CODE XREF: split_3+B9p

i		= dword	ptr -4
s		= dword	ptr  8
s_len		= dword	ptr  0Ch
hex_digest	= dword	ptr  10h
file_name	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		cmp	[ebp+s_len], 0
		jnz	short loc_800030F
		mov	eax, 0
		jmp	locret_80003D9
; ---------------------------------------------------------------------------

loc_800030F:				; CODE XREF: bsd_split_3+Aj
		mov	eax, [ebp+file_name]
		mov	edx, [ebp+s]
		mov	[eax], edx
		mov	eax, [ebp+s_len]
		sub	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_8000326
; ---------------------------------------------------------------------------

loc_8000322:				; CODE XREF: bsd_split_3+40j
		sub	[ebp+i], 1

loc_8000326:				; CODE XREF: bsd_split_3+27j
		cmp	[ebp+i], 0
		jz	short loc_800033B
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 29h
		jnz	short loc_8000322

loc_800033B:				; CODE XREF: bsd_split_3+31j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 29h
		jz	short loc_8000354
		mov	eax, 0
		jmp	locret_80003D9
; ---------------------------------------------------------------------------

loc_8000354:				; CODE XREF: bsd_split_3+4Fj
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		mov	edx, [ebp+s]
		add	eax, edx
		mov	byte ptr [eax],	0
		jmp	short loc_800036B
; ---------------------------------------------------------------------------

loc_8000367:				; CODE XREF: bsd_split_3+7Fj
					; bsd_split_3+8Ej
		add	[ebp+i], 1

loc_800036B:				; CODE XREF: bsd_split_3+6Cj
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_8000367
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 9
		jz	short loc_8000367
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 3Dh
		jz	short loc_800039F
		mov	eax, 0
		jmp	short locret_80003D9
; ---------------------------------------------------------------------------

loc_800039F:				; CODE XREF: bsd_split_3+9Dj
		add	[ebp+i], 1
		jmp	short loc_80003A9
; ---------------------------------------------------------------------------

loc_80003A5:				; CODE XREF: bsd_split_3+BDj
					; bsd_split_3+CCj
		add	[ebp+i], 1

loc_80003A9:				; CODE XREF: bsd_split_3+AAj
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_80003A5
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 9
		jz	short loc_80003A5
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	edx, eax
		mov	eax, [ebp+hex_digest]
		mov	[eax], edx
		mov	eax, 1

locret_80003D9:				; CODE XREF: bsd_split_3+11j
					; bsd_split_3+56j ...
		leave
		retn
bsd_split_3	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	split_3(char *s, size_t	s_len, unsigned	__int8 **hex_digest, int *binary, char **file_name)
split_3		proc near		; CODE XREF: digest_check+192p

escaped_filename= byte ptr -15h
i		= dword	ptr -14h
dst		= dword	ptr -10h
algo_name_len	= dword	ptr -0Ch
s		= dword	ptr  8
s_len		= dword	ptr  0Ch
hex_digest	= dword	ptr  10h
binary		= dword	ptr  14h
file_name	= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+escaped_filename],	0
		mov	[ebp+i], 0
		jmp	short loc_80003F2
; ---------------------------------------------------------------------------

loc_80003EE:				; CODE XREF: split_3+24j split_3+33j
		add	[ebp+i], 1

loc_80003F2:				; CODE XREF: split_3+11j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_80003EE
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 9
		jz	short loc_80003EE
		mov	[ebp+algo_name_len], 3
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		sub	esp, 4
		push	[ebp+algo_name_len] ; n
		push	offset aMd5	; "MD5"
		push	eax		; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80004A1
		mov	edx, [ebp+i]
		mov	eax, [ebp+algo_name_len]
		add	edx, eax
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jnz	short loc_800044F
		add	[ebp+i], 1

loc_800044F:				; CODE XREF: split_3+6Ej
		mov	edx, [ebp+i]
		mov	eax, [ebp+algo_name_len]
		add	edx, eax
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 28h
		jnz	short loc_80004A1
		mov	eax, [ebp+binary]
		mov	dword ptr [eax], 0
		mov	edx, [ebp+i]
		mov	eax, [ebp+algo_name_len]
		add	edx, eax
		mov	eax, [ebp+s_len]
		sub	eax, edx
		lea	edx, [eax-1]
		mov	ecx, [ebp+i]
		mov	eax, [ebp+algo_name_len]
		add	eax, ecx
		lea	ecx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, ecx
		push	[ebp+file_name]	; file_name
		push	[ebp+hex_digest] ; hex_digest
		push	edx		; s_len
		push	eax		; s
		call	bsd_split_3
		add	esp, 10h
		jmp	locret_8000651
; ---------------------------------------------------------------------------

loc_80004A1:				; CODE XREF: split_3+5Aj split_3+86j
		mov	eax, [ebp+s_len]
		sub	eax, [ebp+i]
		mov	ecx, [ebp+s]
		mov	edx, [ebp+i]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		cmp	dl, 5Ch
		setz	dl
		movzx	ecx, dl
		mov	edx, ds:min_digest_line_length
		add	edx, ecx
		cmp	eax, edx
		jnb	short loc_80004D1
		mov	eax, 0
		jmp	locret_8000651
; ---------------------------------------------------------------------------

loc_80004D1:				; CODE XREF: split_3+EAj
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 5Ch
		jnz	short loc_80004E8
		add	[ebp+i], 1
		mov	[ebp+escaped_filename],	1

loc_80004E8:				; CODE XREF: split_3+103j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	edx, eax
		mov	eax, [ebp+hex_digest]
		mov	[eax], edx
		mov	eax, ds:digest_hex_bytes
		add	[ebp+i], eax
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_8000525
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 9
		jz	short loc_8000525
		mov	eax, 0
		jmp	locret_8000651
; ---------------------------------------------------------------------------

loc_8000525:				; CODE XREF: split_3+12Fj split_3+13Ej
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		mov	edx, [ebp+s]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_800055E
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ah
		jz	short loc_800055E
		mov	eax, 0
		jmp	locret_8000651
; ---------------------------------------------------------------------------

loc_800055E:				; CODE XREF: split_3+168j split_3+177j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		mov	edx, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ah
		setz	al
		movzx	edx, al
		mov	eax, [ebp+binary]
		mov	[eax], edx
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	edx, eax
		mov	eax, [ebp+file_name]
		mov	[eax], edx
		cmp	[ebp+escaped_filename],	0
		jz	loc_800064C
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		mov	[ebp+dst], eax
		jmp	loc_800063A
; ---------------------------------------------------------------------------

loc_80005A3:				; CODE XREF: split_3+265j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		test	eax, eax
		jz	short loc_8000616
		cmp	eax, 5Ch
		jnz	short loc_800061D
		mov	eax, [ebp+s_len]
		sub	eax, 1
		cmp	eax, [ebp+i]
		jnz	short loc_80005CF
		mov	eax, 0
		jmp	locret_8000651
; ---------------------------------------------------------------------------

loc_80005CF:				; CODE XREF: split_3+1E8j
		add	[ebp+i], 1
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	[ebp+i], edx
		mov	edx, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 5Ch
		jz	short loc_80005FF
		cmp	eax, 6Eh
		jnz	short loc_800060D
		mov	eax, [ebp+dst]
		lea	edx, [eax+1]
		mov	[ebp+dst], edx
		mov	byte ptr [eax],	0Ah
		jmp	short loc_8000614
; ---------------------------------------------------------------------------

loc_80005FF:				; CODE XREF: split_3+20Fj
		mov	eax, [ebp+dst]
		lea	edx, [eax+1]
		mov	[ebp+dst], edx
		mov	byte ptr [eax],	5Ch
		jmp	short loc_8000614
; ---------------------------------------------------------------------------

loc_800060D:				; CODE XREF: split_3+214j
		mov	eax, 0
		jmp	short locret_8000651
; ---------------------------------------------------------------------------

loc_8000614:				; CODE XREF: split_3+222j split_3+230j
		jmp	short loc_800063A
; ---------------------------------------------------------------------------

loc_8000616:				; CODE XREF: split_3+1D8j
		mov	eax, 0
		jmp	short locret_8000651
; ---------------------------------------------------------------------------

loc_800061D:				; CODE XREF: split_3+1DDj
		mov	eax, [ebp+dst]
		lea	edx, [eax+1]
		mov	[ebp+dst], edx
		mov	edx, [ebp+i]
		lea	ecx, [edx+1]
		mov	[ebp+i], ecx
		mov	ecx, [ebp+s]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		mov	[eax], dl
		nop

loc_800063A:				; CODE XREF: split_3+1C3j
					; split_3:loc_8000614j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+s_len]
		jb	loc_80005A3
		mov	eax, [ebp+dst]
		mov	byte ptr [eax],	0

loc_800064C:				; CODE XREF: split_3+1B2j
		mov	eax, 1

locret_8000651:				; CODE XREF: split_3+C1j split_3+F1j ...
		leave
		retn
split_3		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	hex_digits(const unsigned __int8 *s)
hex_digits	proc near		; CODE XREF: digest_check+1C6p

i		= dword	ptr -0Ch
s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_8000694
; ---------------------------------------------------------------------------

loc_8000662:				; CODE XREF: hex_digits+49j
		call	__ctype_b_loc
		mov	edx, [eax]
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		add	eax, eax
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1000h
		test	eax, eax
		jnz	short loc_800068C
		mov	eax, 0
		jmp	short locret_80006A9
; ---------------------------------------------------------------------------

loc_800068C:				; CODE XREF: hex_digits+30j
		add	[ebp+s], 1
		add	[ebp+i], 1

loc_8000694:				; CODE XREF: hex_digits+Dj
		mov	eax, ds:digest_hex_bytes
		cmp	[ebp+i], eax
		jb	short loc_8000662
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		setz	al

locret_80006A9:				; CODE XREF: hex_digits+37j
		leave
		retn
hex_digits	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	digest_file(const char *filename, int *binary, unsigned	__int8 *bin_result)
digest_file	proc near		; CODE XREF: digest_check+22Dp
					; main+38Ap

is_stdin	= byte ptr -11h
fp		= dword	ptr -10h
err		= dword	ptr -0Ch
filename	= dword	ptr  8
binary		= dword	ptr  0Ch
bin_result	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	offset s	; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_80006E3
		mov	ds:have_read_stdin, 1
		mov	eax, ds:stdin
		mov	[ebp+fp], eax
		jmp	short loc_8000723
; ---------------------------------------------------------------------------

loc_80006E3:				; CODE XREF: digest_file+25j
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+filename]
		call	fopen_safer
		add	esp, 10h
		mov	[ebp+fp], eax
		cmp	[ebp+fp], 0
		jnz	short loc_8000723
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+filename]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	locret_80007B9
; ---------------------------------------------------------------------------

loc_8000723:				; CODE XREF: digest_file+36j
					; digest_file+52j
		sub	esp, 8
		push	[ebp+bin_result]
		push	[ebp+fp]
		call	md5_stream
		add	esp, 10h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jz	short loc_8000776
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+filename]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, ds:stdin
		cmp	[ebp+fp], eax
		jz	short loc_800076F
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h

loc_800076F:				; CODE XREF: digest_file+B4j
		mov	eax, 0
		jmp	short locret_80007B9
; ---------------------------------------------------------------------------

loc_8000776:				; CODE XREF: digest_file+90j
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_80007B4
		sub	esp, 0Ch
		push	[ebp+fp]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_80007B4
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+filename]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_80007B9
; ---------------------------------------------------------------------------

loc_80007B4:				; CODE XREF: digest_file+D4j
					; digest_file+E6j
		mov	eax, 1

locret_80007B9:				; CODE XREF: digest_file+73j
					; digest_file+C9j ...
		leave
		retn
digest_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	digest_check(const char	*checkfile_name)
digest_check	proc near		; CODE XREF: main+359p

checkfile_name	= dword	ptr -7Ch
is_stdin	= byte ptr -72h
ok		= byte ptr -71h
line		= dword	ptr -70h
line_chars_allocated= dword ptr	-6Ch
filename	= dword	ptr -68h
binary		= dword	ptr -64h
hex_digest	= dword	ptr -60h
checkfile_stream= dword	ptr -5Ch
line_length	= dword	ptr -58h
cnt		= dword	ptr -54h
bin_buffer	= dword	ptr -50h
digest_bin_bytes= dword	ptr -4Ch
n_properly_formatted_lines= qword ptr -48h
n_mismatched_checksums=	qword ptr -40h
n_open_or_read_failures= qword ptr -38h
line_number	= qword	ptr -30h
n_computed_checksums= qword ptr	-28h
bin_buffer_unaligned= byte ptr -20h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 84h
		mov	eax, [ebp+arg_0]
		mov	[ebp+checkfile_name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	dword ptr [ebp+n_properly_formatted_lines], 0
		mov	dword ptr [ebp+n_properly_formatted_lines+4], 0
		mov	dword ptr [ebp+n_mismatched_checksums],	0
		mov	dword ptr [ebp+n_mismatched_checksums+4], 0
		mov	dword ptr [ebp+n_open_or_read_failures], 0
		mov	dword ptr [ebp+n_open_or_read_failures+4], 0
		push	4		; alignment
		lea	eax, [ebp+bin_buffer_unaligned]
		push	eax		; ptr
		call	ptr_align
		add	esp, 8
		mov	[ebp+bin_buffer], eax
		sub	esp, 8
		push	offset s	; "-"
		push	[ebp+checkfile_name] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		cmp	[ebp+is_stdin],	0
		jz	short loc_8000856
		mov	ds:have_read_stdin, 1
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	[ebp+checkfile_name], eax
		mov	eax, ds:stdin
		mov	[ebp+checkfile_stream],	eax
		jmp	short loc_8000896
; ---------------------------------------------------------------------------

loc_8000856:				; CODE XREF: digest_check+75j
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+checkfile_name]
		call	fopen_safer
		add	esp, 10h
		mov	[ebp+checkfile_stream],	eax
		cmp	[ebp+checkfile_stream],	0
		jnz	short loc_8000896
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+checkfile_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D40
; ---------------------------------------------------------------------------

loc_8000896:				; CODE XREF: digest_check+99j
					; digest_check+B5j
		mov	dword ptr [ebp+line_number], 0
		mov	dword ptr [ebp+line_number+4], 0
		mov	[ebp+line], 0
		mov	[ebp+line_chars_allocated], 0

loc_80008B2:				; CODE XREF: digest_check+3CEj
		add	dword ptr [ebp+line_number], 1
		adc	dword ptr [ebp+line_number+4], 0
		mov	eax, dword ptr [ebp+line_number+4]
		or	eax, dword ptr [ebp+line_number]
		test	eax, eax
		jnz	short loc_80008E4
		sub	esp, 0Ch
		push	offset aSTooManyChecks ; "%s: too many checksum	lines"
		call	gettext
		add	esp, 10h
		push	[ebp+checkfile_name]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008E4:				; CODE XREF: digest_check+107j
		sub	esp, 4
		push	[ebp+checkfile_stream]
		lea	eax, [ebp+line_chars_allocated]
		push	eax
		lea	eax, [ebp+line]
		push	eax
		call	getline
		add	esp, 10h
		mov	[ebp+line_length], eax
		cmp	[ebp+line_length], 0
		jle	loc_8000B91
		mov	eax, [ebp+line]
		movzx	eax, byte ptr [eax]
		cmp	al, 23h
		jz	loc_8000B66
		mov	eax, [ebp+line]
		mov	edx, [ebp+line_length]
		sub	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 0Ah
		jnz	short loc_8000936
		mov	edx, [ebp+line]
		sub	[ebp+line_length], 1
		mov	eax, [ebp+line_length]
		add	eax, edx
		mov	byte ptr [eax],	0

loc_8000936:				; CODE XREF: digest_check+16Aj
		mov	edx, [ebp+line_length]
		mov	eax, [ebp+line]
		sub	esp, 0Ch
		lea	ecx, [ebp+filename]
		push	ecx		; file_name
		lea	ecx, [ebp+binary]
		push	ecx		; binary
		lea	ecx, [ebp+hex_digest]
		push	ecx		; hex_digest
		push	edx		; s_len
		push	eax		; s
		call	split_3
		add	esp, 20h
		xor	eax, 1
		test	al, al
		jnz	short loc_8000990
		cmp	[ebp+is_stdin],	0
		jz	short loc_800097A
		mov	eax, [ebp+filename]
		sub	esp, 8
		push	offset s	; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000990

loc_800097A:				; CODE XREF: digest_check+1A5j
		mov	eax, [ebp+hex_digest]
		sub	esp, 0Ch
		push	eax		; s
		call	hex_digits
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80009D2

loc_8000990:				; CODE XREF: digest_check+19Fj
					; digest_check+1BDj
		movzx	eax, ds:warn
		test	al, al
		jz	loc_8000B67
		sub	esp, 0Ch
		push	offset aSLluImproperly ; "%s: %llu: improperly formatted %s check"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aMd5	; "MD5"
		push	dword ptr [ebp+line_number+4]
		push	dword ptr [ebp+line_number]
		push	[ebp+checkfile_name]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	loc_8000B67
; ---------------------------------------------------------------------------

loc_80009D2:				; CODE XREF: digest_check+1D3j
		add	dword ptr [ebp+n_properly_formatted_lines], 1
		adc	dword ptr [ebp+n_properly_formatted_lines+4], 0
		mov	eax, [ebp+filename]
		sub	esp, 4
		push	[ebp+bin_buffer] ; bin_result
		lea	edx, [ebp+binary]
		push	edx		; binary
		push	eax		; filename
		call	digest_file
		add	esp, 10h
		mov	[ebp+ok], al
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_8000A3D
		add	dword ptr [ebp+n_open_or_read_failures], 1
		adc	dword ptr [ebp+n_open_or_read_failures+4], 0
		movzx	eax, ds:status_only
		xor	eax, 1
		test	al, al
		jz	loc_8000B67
		mov	ebx, [ebp+filename]
		sub	esp, 0Ch
		push	offset aSFailedOpenOrR ; "%s: FAILED open or read\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		jmp	loc_8000B67
; ---------------------------------------------------------------------------

loc_8000A3D:				; CODE XREF: digest_check+241j
		mov	eax, ds:digest_hex_bytes
		shr	eax, 1
		mov	[ebp+digest_bin_bytes],	eax
		mov	[ebp+cnt], 0
		jmp	loc_8000AD4
; ---------------------------------------------------------------------------

loc_8000A53:				; CODE XREF: digest_check+31Fj
		mov	eax, [ebp+hex_digest]
		mov	edx, [ebp+cnt]
		add	edx, edx
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	tolower
		add	esp, 10h
		mov	ecx, eax
		mov	edx, [ebp+bin_buffer]
		mov	eax, [ebp+cnt]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		shr	al, 4
		movzx	eax, al
		movzx	eax, ds:bin2hex_5204[eax]
		movsx	eax, al
		cmp	ecx, eax
		jnz	short loc_8000AE0
		mov	eax, [ebp+hex_digest]
		mov	edx, [ebp+cnt]
		add	edx, edx
		add	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	tolower
		add	esp, 10h
		mov	ecx, eax
		mov	edx, [ebp+bin_buffer]
		mov	eax, [ebp+cnt]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		and	eax, 0Fh
		movzx	eax, ds:bin2hex_5204[eax]
		movsx	eax, al
		cmp	ecx, eax
		jnz	short loc_8000AE0
		add	[ebp+cnt], 1

loc_8000AD4:				; CODE XREF: digest_check+293j
		mov	eax, [ebp+cnt]
		cmp	eax, [ebp+digest_bin_bytes]
		jb	loc_8000A53

loc_8000AE0:				; CODE XREF: digest_check+2D3j
					; digest_check+313j
		mov	eax, [ebp+cnt]
		cmp	eax, [ebp+digest_bin_bytes]
		jz	short loc_8000AF0
		add	dword ptr [ebp+n_mismatched_checksums],	1
		adc	dword ptr [ebp+n_mismatched_checksums+4], 0

loc_8000AF0:				; CODE XREF: digest_check+32Bj
		movzx	eax, ds:status_only
		xor	eax, 1
		test	al, al
		jz	short loc_8000B67
		mov	eax, [ebp+cnt]
		cmp	eax, [ebp+digest_bin_bytes]
		jz	short loc_8000B2F
		sub	esp, 0Ch
		push	offset aFailed	; "FAILED"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+filename]
		sub	esp, 4
		push	edx
		push	eax
		push	offset aSS	; "%s: %s\n"
		call	printf
		add	esp, 10h
		jmp	short loc_8000B67
; ---------------------------------------------------------------------------

loc_8000B2F:				; CODE XREF: digest_check+349j
		movzx	eax, ds:quiet
		xor	eax, 1
		test	al, al
		jz	short loc_8000B67
		sub	esp, 0Ch
		push	offset aOk	; "OK"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+filename]
		sub	esp, 4
		push	edx
		push	eax
		push	offset aSS	; "%s: %s\n"
		call	printf
		add	esp, 10h
		jmp	short loc_8000B67
; ---------------------------------------------------------------------------

loc_8000B66:				; CODE XREF: digest_check+154j
		nop

loc_8000B67:				; CODE XREF: digest_check+1DEj
					; digest_check+212j ...
		sub	esp, 0Ch
		push	[ebp+checkfile_stream] ; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000B92
		sub	esp, 0Ch
		push	[ebp+checkfile_stream] ; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	loc_80008B2
		jmp	short loc_8000B92
; ---------------------------------------------------------------------------

loc_8000B91:				; CODE XREF: digest_check+146j
		nop

loc_8000B92:				; CODE XREF: digest_check+3BCj
					; digest_check+3D4j
		mov	eax, [ebp+line]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+checkfile_stream] ; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000BDD
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		push	[ebp+checkfile_name]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D40
; ---------------------------------------------------------------------------

loc_8000BDD:				; CODE XREF: digest_check+3F6j
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_8000C1E
		sub	esp, 0Ch
		push	[ebp+checkfile_stream] ; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000C1E
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+checkfile_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D40
; ---------------------------------------------------------------------------

loc_8000C1E:				; CODE XREF: digest_check+42Bj
					; digest_check+43Dj
		mov	eax, dword ptr [ebp+n_properly_formatted_lines+4]
		or	eax, dword ptr [ebp+n_properly_formatted_lines]
		test	eax, eax
		jnz	short loc_8000C55
		sub	esp, 0Ch
		push	offset aSNoProperlyFor ; "%s: no properly formatted %s checksum	l"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aMd5	; "MD5"
		push	[ebp+checkfile_name]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		jmp	loc_8000D13
; ---------------------------------------------------------------------------

loc_8000C55:				; CODE XREF: digest_check+46Bj
		movzx	eax, ds:status_only
		xor	eax, 1
		test	al, al
		jz	loc_8000D13
		mov	eax, dword ptr [ebp+n_open_or_read_failures+4]
		or	eax, dword ptr [ebp+n_open_or_read_failures]
		test	eax, eax
		jz	short loc_8000CB4
		sub	esp, 8
		push	dword ptr [ebp+n_properly_formatted_lines+4]
		push	dword ptr [ebp+n_properly_formatted_lines] ; n
		call	select_plural
		add	esp, 10h
		sub	esp, 4
		push	eax		; n
		push	offset msgid2	; "WARNING: %llu of %llu listed	files coul"...
		push	offset msgid1	; "WARNING: %llu of %llu listed	file could"...
		call	ngettext
		add	esp, 10h
		sub	esp, 4
		push	dword ptr [ebp+n_properly_formatted_lines+4]
		push	dword ptr [ebp+n_properly_formatted_lines]
		push	dword ptr [ebp+n_open_or_read_failures+4]
		push	dword ptr [ebp+n_open_or_read_failures]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8000CB4:				; CODE XREF: digest_check+4B4j
		mov	eax, dword ptr [ebp+n_mismatched_checksums+4]
		or	eax, dword ptr [ebp+n_mismatched_checksums]
		test	eax, eax
		jz	short loc_8000D13
		mov	eax, dword ptr [ebp+n_properly_formatted_lines]
		mov	edx, dword ptr [ebp+n_properly_formatted_lines+4]
		sub	eax, dword ptr [ebp+n_open_or_read_failures]
		sbb	edx, dword ptr [ebp+n_open_or_read_failures+4]
		mov	dword ptr [ebp+n_computed_checksums], eax
		mov	dword ptr [ebp+n_computed_checksums+4],	edx
		sub	esp, 8
		push	dword ptr [ebp+n_computed_checksums+4]
		push	dword ptr [ebp+n_computed_checksums] ; n
		call	select_plural
		add	esp, 10h
		sub	esp, 4
		push	eax		; n
		push	offset aWarningLluOf_1 ; "WARNING: %llu	of %llu	computed checksum"...
		push	offset aWarningLluOf_2 ; "WARNING: %llu	of %llu	computed checksum"...
		call	ngettext
		add	esp, 10h
		sub	esp, 4
		push	dword ptr [ebp+n_computed_checksums+4]
		push	dword ptr [ebp+n_computed_checksums]
		push	dword ptr [ebp+n_mismatched_checksums+4]
		push	dword ptr [ebp+n_mismatched_checksums]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8000D13:				; CODE XREF: digest_check+495j
					; digest_check+4A6j ...
		mov	eax, dword ptr [ebp+n_properly_formatted_lines+4]
		or	eax, dword ptr [ebp+n_properly_formatted_lines]
		test	eax, eax
		jz	short loc_8000D38
		mov	eax, dword ptr [ebp+n_mismatched_checksums+4]
		or	eax, dword ptr [ebp+n_mismatched_checksums]
		test	eax, eax
		jnz	short loc_8000D38
		mov	eax, dword ptr [ebp+n_open_or_read_failures+4]
		or	eax, dword ptr [ebp+n_open_or_read_failures]
		test	eax, eax
		jnz	short loc_8000D38
		mov	eax, 1
		jmp	short loc_8000D3D
; ---------------------------------------------------------------------------

loc_8000D38:				; CODE XREF: digest_check+560j
					; digest_check+56Aj ...
		mov	eax, 0

loc_8000D3D:				; CODE XREF: digest_check+57Bj
		and	eax, 1

loc_8000D40:				; CODE XREF: digest_check+D6j
					; digest_check+41Dj ...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8000D51
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000D51:				; CODE XREF: digest_check+58Fj
		mov	ebx, [ebp+var_4]
		leave
		retn
digest_check	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -5Ch
do_check	= byte ptr -4Ah
ok		= byte ptr -49h
file_is_binary	= dword	ptr -48h
binary		= dword	ptr -44h
i		= dword	ptr -40h
bin_buffer	= dword	ptr -3Ch
opt		= dword	ptr -38h
file		= dword	ptr -34h
bin_buffer_unaligned= byte ptr -30h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 5Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		push	4		; alignment
		lea	eax, [ebp+bin_buffer_unaligned]
		push	eax		; ptr
		call	ptr_align
		add	esp, 8
		mov	[ebp+bin_buffer], eax
		mov	[ebp+do_check],	0
		mov	[ebp+ok], 1
		mov	[ebp+binary], 0FFFFFFFFh
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, ds:stdout
		push	0		; n
		push	1		; modes
		push	0		; buf
		push	eax		; stream
		call	setvbuf
		add	esp, 10h
		jmp	loc_8000F15
; ---------------------------------------------------------------------------

loc_8000E0D:				; CODE XREF: main+1E2j
		mov	eax, [ebp+opt]
		cmp	eax, 63h
		jz	short loc_8000E6D
		cmp	eax, 63h
		jg	short loc_8000E3A
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000EC7
		cmp	eax, 62h
		jz	short loc_8000E61
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000ED1
		jmp	loc_8000F0B
; ---------------------------------------------------------------------------

loc_8000E3A:				; CODE XREF: main+C2j
		cmp	eax, 77h
		jz	short loc_8000E99
		cmp	eax, 77h
		jg	short loc_8000E4E
		cmp	eax, 74h
		jz	short loc_8000E90
		jmp	loc_8000F0B
; ---------------------------------------------------------------------------

loc_8000E4E:				; CODE XREF: main+ECj
		cmp	eax, 80h
		jz	short loc_8000E76
		cmp	eax, 81h
		jz	short loc_8000EB0
		jmp	loc_8000F0B
; ---------------------------------------------------------------------------

loc_8000E61:				; CODE XREF: main+D2j
		mov	[ebp+binary], 1
		jmp	loc_8000F15
; ---------------------------------------------------------------------------

loc_8000E6D:				; CODE XREF: main+BDj
		mov	[ebp+do_check],	1
		jmp	loc_8000F15
; ---------------------------------------------------------------------------

loc_8000E76:				; CODE XREF: main+FDj
		mov	ds:status_only,	1
		mov	ds:warn, 0
		mov	ds:quiet, 0
		jmp	loc_8000F15
; ---------------------------------------------------------------------------

loc_8000E90:				; CODE XREF: main+F1j
		mov	[ebp+binary], 0
		jmp	short loc_8000F15
; ---------------------------------------------------------------------------

loc_8000E99:				; CODE XREF: main+E7j
		mov	ds:status_only,	0
		mov	ds:warn, 1
		mov	ds:quiet, 0
		jmp	short loc_8000F15
; ---------------------------------------------------------------------------

loc_8000EB0:				; CODE XREF: main+104j
		mov	ds:status_only,	0
		mov	ds:warn, 0
		mov	ds:quiet, 1
		jmp	short loc_8000F15
; ---------------------------------------------------------------------------

loc_8000EC7:				; CODE XREF: main+C9j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000ED1:				; CODE XREF: main+D9j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		push	0
		push	offset aDavidMadore ; "David Madore"
		push	offset aScottMiller ; "Scott Miller"
		push	offset aUlrichDrepper ;	"Ulrich	Drepper"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aMd5sum	; "md5sum"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000F0B:				; CODE XREF: main+DFj main+F3j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F15:				; CODE XREF: main+B2j main+112j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "bctw"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+opt], eax
		cmp	[ebp+opt], 0FFFFFFFFh
		jnz	loc_8000E0D
		mov	ds:min_digest_line_length, 23h
		mov	ds:digest_hex_bytes, 20h
		cmp	[ebp+binary], 0
		js	short loc_8000F88
		cmp	[ebp+do_check],	0
		jz	short loc_8000F88
		sub	esp, 0Ch
		push	offset aTheBinaryAndTe ; "the --binary and --text options are mea"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F88:				; CODE XREF: main+200j	main+206j
		movzx	eax, ds:status_only
		test	al, al
		jz	short loc_8000FC8
		movzx	eax, [ebp+do_check]
		xor	eax, 1
		test	al, al
		jz	short loc_8000FC8
		sub	esp, 0Ch
		push	offset aTheStatusOptio ; "the --status option is meaningful only "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000FC8:				; CODE XREF: main+23Bj	main+246j
		movzx	eax, ds:warn
		test	al, al
		jz	short loc_8001008
		movzx	eax, [ebp+do_check]
		xor	eax, 1
		test	al, al
		jz	short loc_8001008
		sub	esp, 0Ch
		push	offset aTheWarnOptionI ; "the --warn option is meaningful only wh"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001008:				; CODE XREF: main+27Bj	main+286j
		movzx	eax, ds:quiet
		test	al, al
		jz	short loc_8001048
		movzx	eax, [ebp+do_check]
		xor	eax, 1
		test	al, al
		jz	short loc_8001048
		sub	esp, 0Ch
		push	offset aTheQuietOption ; "the --quiet option is	meaningful only	w"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001048:				; CODE XREF: main+2BBj	main+2C6j
		cmp	[ebp+binary], 0
		jns	short loc_8001055
		mov	[ebp+binary], 0

loc_8001055:				; CODE XREF: main+2F6j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jnz	loc_8001236
		mov	eax, [ebx]
		lea	edx, [eax+1]
		mov	[ebx], edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		lea	esi, [edx+eax]
		sub	esp, 0Ch
		push	offset s	; "-"
		call	bad_cast
		add	esp, 10h
		mov	[esi], eax
		jmp	loc_8001236
; ---------------------------------------------------------------------------

loc_800108D:				; CODE XREF: main+4E7j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+file], eax
		cmp	[ebp+do_check],	0
		jz	short loc_80010CD
		sub	esp, 0Ch
		push	[ebp+file]	; checkfile_name
		call	digest_check
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		jmp	loc_8001229
; ---------------------------------------------------------------------------

loc_80010CD:				; CODE XREF: main+351j
		mov	eax, [ebp+binary]
		mov	[ebp+file_is_binary], eax
		sub	esp, 4
		push	[ebp+bin_buffer] ; bin_result
		lea	eax, [ebp+file_is_binary]
		push	eax		; binary
		push	[ebp+file]	; filename
		call	digest_file
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80010F8
		mov	[ebp+ok], 0
		jmp	loc_8001229
; ---------------------------------------------------------------------------

loc_80010F8:				; CODE XREF: main+397j
		sub	esp, 8
		push	0Ah		; c
		push	[ebp+file]	; s
		call	strchr
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001120
		sub	esp, 8
		push	5Ch		; c
		push	[ebp+file]	; s
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_800112D

loc_8001120:				; CODE XREF: main+3B4j
		sub	esp, 0Ch
		push	5Ch		; c
		call	putchar_unlocked
		add	esp, 10h

loc_800112D:				; CODE XREF: main+3C8j
		mov	[ebp+i], 0
		jmp	short loc_8001159
; ---------------------------------------------------------------------------

loc_8001136:				; CODE XREF: main+40Dj
		mov	edx, [ebp+bin_buffer]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 8
		push	eax
		push	offset a02x	; "%02x"
		call	printf
		add	esp, 10h
		add	[ebp+i], 1

loc_8001159:				; CODE XREF: main+3DEj
		mov	eax, ds:digest_hex_bytes
		shr	eax, 1
		cmp	eax, [ebp+i]
		ja	short loc_8001136
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, [ebp+file_is_binary]
		test	eax, eax
		jz	short loc_8001188
		sub	esp, 0Ch
		push	2Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_8001195
; ---------------------------------------------------------------------------

loc_8001188:				; CODE XREF: main+421j
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8001195:				; CODE XREF: main+430j
		mov	[ebp+i], 0
		jmp	short loc_8001209
; ---------------------------------------------------------------------------

loc_800119E:				; CODE XREF: main+4C4j
		mov	edx, [ebp+file]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 0Ah
		jz	short loc_80011B8
		cmp	eax, 5Ch
		jz	short loc_80011D1
		jmp	short loc_80011EA
; ---------------------------------------------------------------------------

loc_80011B8:				; CODE XREF: main+459j
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset aN	; "\\n"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8001205
; ---------------------------------------------------------------------------

loc_80011D1:				; CODE XREF: main+45Ej
		mov	eax, ds:stdout
		push	eax		; stream
		push	2		; n
		push	1		; size
		push	offset asc_8001BCF ; "\\\\"
		call	fwrite_unlocked
		add	esp, 10h
		jmp	short loc_8001205
; ---------------------------------------------------------------------------

loc_80011EA:				; CODE XREF: main+460j
		mov	edx, [ebp+file]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		nop

loc_8001205:				; CODE XREF: main+479j	main+492j
		add	[ebp+i], 1

loc_8001209:				; CODE XREF: main+446j
		sub	esp, 0Ch
		push	[ebp+file]	; s
		call	strlen
		add	esp, 10h
		cmp	eax, [ebp+i]
		ja	short loc_800119E
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8001229:				; CODE XREF: main+372j	main+39Dj
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax

loc_8001236:				; CODE XREF: main+306j	main+332j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	loc_800108D
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_800128C
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_800128C
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800128C:				; CODE XREF: main+4F6j	main+50Cj
		cmp	[ebp+ok], 0
		jz	short loc_8001299
		mov	eax, 0
		jmp	short loc_800129E
; ---------------------------------------------------------------------------

loc_8001299:				; CODE XREF: main+53Aj
		mov	eax, 1

loc_800129E:				; CODE XREF: main+541j
		sub	esp, 0Ch
		push	eax		; status

loc_80012A2:				; DATA XREF: .eh_frame:08001C04o
					; .eh_frame:08001C24o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 80012A8h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: digest_file+27w
					; digest_check+77w ...
		align 4
; size_t min_digest_line_length
min_digest_line_length dd ?		; DATA XREF: split_3+E0r main+1E8w
; size_t digest_hex_bytes
digest_hex_bytes dd ?			; DATA XREF: split_3+11Ar
					; hex_digits:loc_8000694r ...
; _Bool	status_only
status_only	db ?			; DATA XREF: digest_check+24Br
					; digest_check:loc_8000AF0r ...
; _Bool	warn
warn		db ?			; DATA XREF: digest_check:loc_8000990r
					; main+127w ...
; _Bool	quiet
quiet		db ?			; DATA XREF: digest_check:loc_8000B2Fr
					; main+12Ew ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80012C0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+71o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+198o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aBinary		db 'binary',0           ; DATA XREF: .rodata:long_optionso
aCheck		db 'check',0            ; DATA XREF: .rodata:long_optionso
aQuiet		db 'quiet',0            ; DATA XREF: .rodata:long_optionso
aStatus		db 'status',0           ; DATA XREF: .rodata:long_optionso
aText		db 'text',0             ; DATA XREF: .rodata:long_optionso
aWarn		db 'warn',0             ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[9]
long_options	option <offset aBinary,	0, 0, 62h> ; DATA XREF:	main+1C4o
		option <offset aCheck, 0, 0, 63h> ; "binary"
		option <offset aQuiet, 0, 0, 81h>
		option <offset aStatus,	0, 0, 80h>
		option <offset aText, 0, 0, 74h>
		option <offset aWarn, 0, 0, 77h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah ; DATA XREF: usage+46o
		db 'Print or check %s (%d-bit) checksums.',0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
; char aMd5[]
aMd5		db 'MD5',0              ; DATA XREF: usage+58o usage+9Do ...
		align 4
; char aBBinaryReadInB[]
aBBinaryReadInB	db '  -b, --binary            read in binary mode',0Ah,0
					; DATA XREF: usage+70o
		align 4
; char aCCheckReadSSum[]
aCCheckReadSSum	db '  -c, --check             read %s sums from the FILEs and check t'
					; DATA XREF: usage+8Do
		db 'hem',0Ah,0
		align 4
; char aTTextReadInTex[]
aTTextReadInTex	db '  -t, --text              read in text mode (default)',0Ah,0
					; DATA XREF: usage+B4o
		align 4
; char aTheFollowingTh[]
aTheFollowingTh	db 0Ah			; DATA XREF: usage+D7o
		db 'The following three options are useful only when verifying checks'
		db 'ums:',0Ah
		db '      --quiet             don',27h,'t print OK for each successfully'
		db ' verified file',0Ah
		db '      --status            don',27h,'t output anything, status code s'
		db 'hows success',0Ah
		db '  -w, --warn              warn about improperly formatted checksu'
		db 'm lines',0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+FAo
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+11Do
		align 10h
; char aTheSumsAreComp[]
aTheSumsAreComp	db 0Ah			; DATA XREF: usage+13Ao
		db 'The sums are computed as described in %s.  When checking, the inp'
		db 'ut',0Ah
		db 'should be a former output of this program.  The default mode is t'
		db 'o print',0Ah
		db 'a line with checksum, a character indicating type (`*',27h,' for bin'
		db 'ary, ` ',27h,' for',0Ah
		db 'text), and name for each FILE.',0Ah,0
aRfc1321	db 'RFC 1321',0         ; DATA XREF: usage+14Ao
; char s[]
s		db '-',0                ; DATA XREF: digest_file+9o
					; digest_check+59o ...
aR		db 'r',0                ; DATA XREF: digest_file+3Bo
					; digest_check+9Eo
; char format[]
format		db '%s',0               ; DATA XREF: digest_file+5Eo
					; digest_file+9Co ...
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: digest_check+81o
					; main+511o
; char aSTooManyChecks[]
aSTooManyChecks	db '%s: too many checksum lines',0 ; DATA XREF: digest_check+10Co
; char aSLluImproperly[]
aSLluImproperly	db '%s: %llu: improperly formatted %s checksum line',0
					; DATA XREF: digest_check+1E7o
; char aSFailedOpenOrR[]
aSFailedOpenOrR	db '%s: FAILED open or read',0Ah,0 ; DATA XREF: digest_check+263o
; char aFailed[]
aFailed		db 'FAILED',0           ; DATA XREF: digest_check+34Eo
; char aSS[]
aSS		db '%s: %s',0Ah,0       ; DATA XREF: digest_check+365o
					; digest_check+39Co
; char aOk[]
aOk		db 'OK',0               ; DATA XREF: digest_check+385o
; char aSReadError[]
aSReadError	db '%s: read error',0   ; DATA XREF: digest_check+3FBo
		align 10h
; char aSNoProperlyFor[]
aSNoProperlyFor	db '%s: no properly formatted %s checksum lines found',0
					; DATA XREF: digest_check+470o
		align 4
; char msgid2[]
msgid2		db 'WARNING: %llu of %llu listed files could not be read',0
					; DATA XREF: digest_check+4CBo
		align 4
; char msgid1[]
msgid1		db 'WARNING: %llu of %llu listed file could not be read',0
					; DATA XREF: digest_check+4D0o
; char aWarningLluOf_1[]
aWarningLluOf_1	db 'WARNING: %llu of %llu computed checksums did NOT match',0
					; DATA XREF: digest_check+52Ao
		align 4
; char aWarningLluOf_2[]
aWarningLluOf_2	db 'WARNING: %llu of %llu computed checksum did NOT match',0
					; DATA XREF: digest_check+52Fo
; char locale
locale		db 0			; DATA XREF: main+5Ao
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+6Co
aDavidMadore	db 'David Madore',0     ; DATA XREF: main+188o
aScottMiller	db 'Scott Miller',0     ; DATA XREF: main+18Do
aUlrichDrepper	db 'Ulrich Drepper',0   ; DATA XREF: main+192o
aMd5sum		db 'md5sum',0           ; DATA XREF: main+19Do
; char shortopts[]
shortopts	db 'bctw',0             ; DATA XREF: main+1C9o
; char aTheBinaryAndTe[]
aTheBinaryAndTe	db 'the --binary and --text options are meaningless when verifying ch'
					; DATA XREF: main+20Bo
		db 'ecksums',0
		align 4
; char aTheStatusOptio[]
aTheStatusOptio	db 'the --status option is meaningful only when verifying checksums',0
					; DATA XREF: main+24Bo
; char aTheWarnOptionI[]
aTheWarnOptionI	db 'the --warn option is meaningful only when verifying checksums',0
					; DATA XREF: main+28Bo
		align 4
; char aTheQuietOption[]
aTheQuietOption	db 'the --quiet option is meaningful only when verifying checksums',0
					; DATA XREF: main+2CBo
; char a02x[]
a02x		db '%02x',0             ; DATA XREF: main+3F2o
aN		db '\n',0               ; DATA XREF: main+46Co
asc_8001BCF	db '\\',0               ; DATA XREF: main+485o
		align 4
; Function-local static	variable
; const	char bin2hex_5204[16]
bin2hex_5204	db 30h			; DATA XREF: digest_check+2C7r
					; digest_check+307r
		db 31h,	32h, 33h
		dd 37363534h, 62613938h, 66656463h
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001BE4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80012A2-8002EA6h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 1Ch, 3Ch
		dd offset loc_80012A2-8002E8Bh
		dd 32h,	80E4100h, 0D420285h, 0CC56E05h,	404h, 20h, 5Ch
		dd offset loc_80012A2-8002E79h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	80h
		dd offset loc_80012A2-8002D81h
		dd 8, 80E4100h,	0D420285h, 0CC54405h, 404h, 18h, 0A0h
		dd offset loc_80012A2-8002D99h
		dd 168h, 80E4100h, 0D420285h, 3834405h,	1Ch, 0BCh
		dd offset loc_80012A2-8002C4Dh
		dd 0E2h, 80E4100h, 0D420285h, 0C5DE0205h, 4040Ch, 1Ch
		dd 0DCh
		dd offset loc_80012A2-8002B8Bh
		dd 278h, 80E4100h, 0D420285h, 2740305h,	4040CC5h, 1Ch
		dd 0FCh
		dd offset loc_80012A2-8002933h
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 1Ch, 11Ch
		dd offset loc_80012A2-80028FBh
		dd 110h, 80E4100h, 0D420285h, 10C0305h,	4040CC5h, 20h
		dd 13Ch
		dd offset loc_80012A2-800280Bh
		dd 59Bh, 80E4100h, 0D420285h, 3834705h,	0C5059003h, 4040CC3h
		dd 28h,	160h
		dd offset loc_80012A2-8002294h
		dd 551h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn __umoddi3:near	; CODE XREF: select_plural+27p
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+67r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+82p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+61p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
					; split_3+50p
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+163p main+1B0p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: hex_digits:loc_8000662p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: digest_file+11p
					; digest_check+61p ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: digest_file+2Er
					; digest_file+ACr ...
		extrn fopen_safer:near	; CODE XREF: digest_file+43p
					; digest_check+A6p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: digest_file+54p
					; digest_file+92p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: digest_file+66p
					; digest_file+A4p ...
		extrn md5_stream:near	; CODE XREF: digest_file+81p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: digest_file+BCp
					; digest_file+DCp ...
		extrn getline:near	; CODE XREF: digest_check+137p
; int tolower(int c)
		extrn tolower:near	; CODE XREF: digest_check+2ACp
					; digest_check+2ECp
; int feof_unlocked(FILE *stream)
		extrn feof_unlocked:near ; CODE	XREF: digest_check+3B2p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	digest_check+3C4p
					; digest_check+3ECp
; void free(void *ptr)
		extrn free:near		; CODE XREF: digest_check+3DEp
; char *ngettext(const char *msgid1, const char	*msgid2, unsigned __int32 n)
		extrn ngettext:near	; CODE XREF: digest_check+4D5p
					; digest_check+534p
		extrn __stack_chk_fail:near ; CODE XREF: digest_check+591p
		extrn set_program_name:near ; CODE XREF: main+4Fp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+76p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+86p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+91o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+96p
; int setvbuf(FILE *stream, char *buf, int modes, size_t n)
		extrn setvbuf:near	; CODE XREF: main+AAp
		extrn Version:dword	; DATA XREF: main:loc_8000ED1r
		extrn version_etc:near	; CODE XREF: main+1A3p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+1D3p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8001055r
					; main:loc_800108Dr ...
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: main+3AAp	main+3BEp
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: main+3CFp main+414p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	main+471p main+48Ap
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: main+4B9p


		end
