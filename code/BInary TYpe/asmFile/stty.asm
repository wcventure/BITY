;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	5F7066B263652F55B207FD19FBCDAD11
; Input	CRC32 :	58491D99

; File Name   :	D:\coreutils-o\stty.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'stty.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: set_control_char+79p
					; set_control_char+100p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+4CDp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void wrapf(const char	*message, ...)
wrapf		proc near		; CODE XREF: display_window_size+ABp
					; display_changed+30p ...

message		= dword	ptr -1Ch
args		= dword	ptr -18h
buf		= dword	ptr -14h
buflen		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= byte ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+message], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		lea	eax, [ebp+arg_4]
		mov	[ebp+args], eax
		mov	eax, [ebp+args]
		sub	esp, 4
		push	eax
		push	[ebp+message]
		lea	eax, [ebp+buf]
		push	eax
		call	rpl_vasprintf
		add	esp, 10h
		mov	[ebp+buflen], eax
		cmp	[ebp+buflen], 0
		jns	short loc_800016F
		call	xalloc_die

loc_800016F:				; CODE XREF: wrapf+3Aj
		mov	eax, ds:current_col
		test	eax, eax
		jle	short loc_80001BF
		mov	edx, ds:max_col
		mov	eax, ds:current_col
		sub	edx, eax
		mov	eax, edx
		cmp	eax, [ebp+buflen]
		jge	short loc_80001A5
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		jmp	short loc_80001BF
; ---------------------------------------------------------------------------

loc_80001A5:				; CODE XREF: wrapf+5Cj
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:current_col
		add	eax, 1
		mov	ds:current_col,	eax

loc_80001BF:				; CODE XREF: wrapf+48j	wrapf+75j
		mov	edx, ds:stdout
		mov	eax, [ebp+buf]
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	eax, [ebp+buf]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	edx, ds:current_col
		mov	eax, [ebp+buflen]
		add	eax, edx
		mov	ds:current_col,	eax
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000206
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000206:				; CODE XREF: wrapf+D1j
		leave
		retn
wrapf		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+185p	main+596p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_8000247
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80006DA
; ---------------------------------------------------------------------------

loc_8000247:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSFDeviceF ; "Usage: %s [-F	DEVICE | --file=DEVICE]	["...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintOrChangeT ; "Print	or change terminal characteristic"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOptionalBefore ; "\nOptional - before SETTING indicates	n"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSpecialCharact ; "\nSpecial characters:\n * dsusp CHAR	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEol2CharAltern ; " * eol2 CHAR	   alternate CHAR for end"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLnextCharCharW ; " * lnext CHAR	   CHAR	will enter the ne"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aStopCharCharWi ; "   stop CHAR	   CHAR	will stop the out"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSpecialSetting ; "\nSpecial settings:\n	  N		s"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIspeedNSetTheI ; "   ispeed N	   set the input speed to"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRowsNTellTheKe ; " * rows N	   tell	the kernel that	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aControlSetting ; "\nControl settings:\n	  [-]clocal	d"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCstopbUseTwoSt ; "   [-]cstopb	   use two stop	bits per "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aInputSettingsB ; "\nInput settings:\n	[-]brkint     bre"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIgnparIgnoreCh ; "   [-]ignpar	   ignore characters with"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIutf8AssumeInp ; " * [-]iutf8	   assume input	character"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIuclcTranslate ; " * [-]iuclc	   translate uppercase ch"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOutputSettings ; "\nOutput settings:\n * bsN	       ba"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOcrnlTranslate ; " * [-]ocrnl	   translate carriage ret"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOnocrDoNotPrin ; " * [-]onocr	   do not print	carriage "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLocalSettingsC ; "\nLocal settings:\n	[-]crterase   ech"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCtlechoEchoCon ; " * [-]ctlecho	   echo	control	character"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEchokeSameAsCr ; " * [-]echoke	   same	as [-]crtkill\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIsigEnableInte ; "   [-]isig	   enable interrupt, quit"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCombinationSet ; "\nCombination	settings:\n * [-]LCASE	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCookedSameAsBr ; "   cooked	   same	as brkint ignpar "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDecSameAsEchoe ; "   dec	   same	as echoe echoctl "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEvenpSameAsPar ; "   -evenp	   same	as -parenb cs8\n "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOddpSameAsPare ; "   oddp	   same	as parenb parodd "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRawSameAsIgnbr ; "   raw	   same	as -ignbrk -brkin"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSaneSameAsCrea ; "   sane	   same	as cread -ignbrk "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHandleTheTtyLi ; "\nHandle the tty line	connected to stan"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80006DA:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0CCh
require_set_attr= byte ptr -0C7h
speed_was_set	= byte ptr -0C6h
verbose_output	= byte ptr -0C5h
recoverable_output= byte ptr -0C4h
noargs		= byte ptr -0C3h
match_found	= byte ptr -0C2h
reversed	= byte ptr -0C1h
output_type	= dword	ptr -0C0h
argi		= dword	ptr -0BCh
opti		= dword	ptr -0B8h
k		= dword	ptr -0B4h
file_name	= dword	ptr -0B0h
device_name	= dword	ptr -0ACh
arg		= dword	ptr -0A8h
i		= dword	ptr -0A4h
optc		= dword	ptr -0A0h
fdflags		= dword	ptr -9Ch
value		= dword	ptr -98h
mode		= termios ptr -94h
new_mode	= termios ptr -58h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0C8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		lea	edx, [ebp+mode]
		mov	eax, 0
		mov	ecx, 0Fh
		mov	edi, edx
		rep stosd
		mov	[ebp+argi], 0
		mov	[ebp+opti], 1
		mov	[ebp+noargs], 1
		mov	[ebp+file_name], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	[ebp+output_type], 0
		mov	[ebp+verbose_output], 0
		mov	[ebp+recoverable_output], 0
		mov	ds:opterr, 0
		jmp	loc_8000905
; ---------------------------------------------------------------------------

loc_80007CD:				; CODE XREF: main+263j
		mov	eax, [ebp+optc]
		cmp	eax, 46h
		jz	short loc_800082F
		cmp	eax, 46h
		jg	short loc_80007F4
		cmp	eax, 0FFFFFF7Dh
		jz	loc_800086F
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8000865
		jmp	loc_80008A2
; ---------------------------------------------------------------------------

loc_80007F4:				; CODE XREF: main+F6j
		cmp	eax, 61h
		jz	short loc_8000803
		cmp	eax, 67h
		jz	short loc_8000819
		jmp	loc_80008A2
; ---------------------------------------------------------------------------

loc_8000803:				; CODE XREF: main+112j
		mov	[ebp+verbose_output], 1
		mov	[ebp+output_type], 1
		jmp	loc_80008CA
; ---------------------------------------------------------------------------

loc_8000819:				; CODE XREF: main+117j
		mov	[ebp+recoverable_output], 1
		mov	[ebp+output_type], 2
		jmp	loc_80008CA
; ---------------------------------------------------------------------------

loc_800082F:				; CODE XREF: main+F1j
		cmp	[ebp+file_name], 0
		jz	short loc_8000858
		sub	esp, 0Ch
		push	offset aOnlyOneDeviceM ; "only one device may be specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000858:				; CODE XREF: main+151j
		mov	eax, ds:optarg
		mov	[ebp+file_name], eax
		jmp	short loc_80008CA
; ---------------------------------------------------------------------------

loc_8000865:				; CODE XREF: main+108j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800086F:				; CODE XREF: main+FDj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aStty	; "stty"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80008A2:				; CODE XREF: main+10Aj	main+119j
		mov	[ebp+noargs], 0
		mov	eax, [ebp+opti]
		add	[ebp+argi], eax
		mov	[ebp+opti], 1
		mov	ds:optind, 0
		nop

loc_80008CA:				; CODE XREF: main+12Fj	main+145j ...
		jmp	short loc_80008F8
; ---------------------------------------------------------------------------

loc_80008CC:				; CODE XREF: main+21Ej
		mov	eax, [ebp+opti]
		lea	edx, [eax+1]
		mov	[ebp+opti], edx
		mov	edx, [ebp+argi]
		add	eax, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	dword ptr [eax], 0

loc_80008F8:				; CODE XREF: main:loc_80008CAj
		mov	eax, ds:optind
		cmp	[ebp+opti], eax
		jl	short loc_80008CC

loc_8000905:				; CODE XREF: main+E3j
		mov	eax, [ebp+argi]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	edx, eax
		mov	eax, [ebx]
		sub	eax, [ebp+argi]
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "-agF:"
		push	edx		; argv
		push	eax		; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80007CD
		cmp	[ebp+verbose_output], 0
		jz	short loc_8000980
		cmp	[ebp+recoverable_output], 0
		jz	short loc_8000980
		sub	esp, 0Ch
		push	offset aTheOptionsForV ; "the options for verbose and stty-readab"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000980:				; CODE XREF: main+270j	main+279j
		movzx	eax, [ebp+noargs]
		xor	eax, 1
		test	al, al
		jz	short loc_80009C0
		cmp	[ebp+verbose_output], 0
		jnz	short loc_80009A0
		cmp	[ebp+recoverable_output], 0
		jz	short loc_80009C0

loc_80009A0:				; CODE XREF: main+2B0j
		sub	esp, 0Ch
		push	offset aWhenSpecifying ; "when specifying an output style, modes "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009C0:				; CODE XREF: main+2A7j	main+2B9j
		cmp	[ebp+file_name], 0
		jz	loc_8000A79
		mov	eax, [ebp+file_name]
		mov	[ebp+device_name], eax
		push	0
		push	800h
		push	[ebp+device_name]
		push	0
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000A11
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000A11:				; CODE XREF: main+30Dj
		sub	esp, 8
		push	3
		push	0
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+fdflags], eax
		cmp	[ebp+fdflags], 0FFFFFFFFh
		jz	short loc_8000A4C
		mov	eax, [ebp+fdflags]
		and	ah, 0F7h
		sub	esp, 4
		push	eax
		push	4
		push	0
		call	rpl_fcntl
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000A8F

loc_8000A4C:				; CODE XREF: main+348j
		sub	esp, 0Ch
		push	offset aSCouldnTResetN ; "%s: couldn't reset non-blocking mode"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	esi		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000A8F
; ---------------------------------------------------------------------------

loc_8000A79:				; CODE XREF: main+2E2j
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	[ebp+device_name], eax

loc_8000A8F:				; CODE XREF: main+365j	main+392j
		sub	esp, 8
		lea	eax, [ebp+mode]
		push	eax		; termios_p
		push	0		; fd
		call	tcgetattr
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000AC4
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000AC4:				; CODE XREF: main+3C0j
		cmp	[ebp+verbose_output], 0
		jnz	short loc_8000ADF
		cmp	[ebp+recoverable_output], 0
		jnz	short loc_8000ADF
		cmp	[ebp+noargs], 0
		jz	short loc_8000B1B

loc_8000ADF:				; CODE XREF: main+3E6j	main+3EFj
		call	screen_columns
		mov	ds:max_col, eax
		mov	ds:current_col,	0
		sub	esp, 4
		push	[ebp+device_name] ; device_name
		lea	eax, [ebp+mode]
		push	eax		; mode
		push	[ebp+output_type] ; output_type
		call	display_settings
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000B1B:				; CODE XREF: main+3F8j
		mov	[ebp+speed_was_set], 0
		mov	[ebp+require_set_attr],	0
		mov	[ebp+k], 1
		jmp	loc_80012A8
; ---------------------------------------------------------------------------

loc_8000B38:				; CODE XREF: main+BCBj
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+arg], eax
		mov	[ebp+match_found], 0
		mov	[ebp+reversed],	0
		cmp	[ebp+arg], 0
		jz	loc_80012A0
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_8000B8B
		add	[ebp+arg], 1
		mov	[ebp+reversed],	1

loc_8000B8B:				; CODE XREF: main+496j
		mov	[ebp+i], 0
		jmp	short loc_8000C0B
; ---------------------------------------------------------------------------

loc_8000B97:				; CODE XREF: main+53Fj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000C04
		movzx	ecx, [ebp+reversed]
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		lea	edx, mode_info_0.name[eax]
		sub	esp, 4
		lea	eax, [ebp+mode]
		push	eax		; mode
		push	ecx		; reversed
		push	edx		; info
		call	set_mode
		add	esp, 10h
		mov	[ebp+match_found], al
		mov	[ebp+require_set_attr],	1
		jmp	short loc_8000C2A
; ---------------------------------------------------------------------------

loc_8000C04:				; CODE XREF: main+4DDj
		add	[ebp+i], 1

loc_8000C0B:				; CODE XREF: main+4B0j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_8000B97

loc_8000C2A:				; CODE XREF: main+51Dj
		movzx	eax, [ebp+match_found]
		xor	eax, 1
		test	al, al
		jz	short loc_8000C80
		cmp	[ebp+reversed],	0
		jz	short loc_8000C80
		mov	eax, [ebp+arg]
		sub	eax, 1
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidArgumen ; "invalid argument %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C80:				; CODE XREF: main+551j	main+55Aj
		movzx	eax, [ebp+match_found]
		xor	eax, 1
		test	al, al
		jz	loc_8000D95
		mov	[ebp+i], 0
		jmp	loc_8000D77
; ---------------------------------------------------------------------------

loc_8000CA1:				; CODE XREF: main+6AAj
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000D70
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_8000D19
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000D19:				; CODE XREF: main+5F7j
		mov	[ebp+match_found], 1
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, control_info_0.name[eax]
		sub	esp, 4
		lea	eax, [ebp+mode]
		push	eax		; mode
		push	ecx		; arg
		push	edx		; info
		call	set_control_char
		add	esp, 10h
		mov	[ebp+require_set_attr],	1
		jmp	short loc_8000D95
; ---------------------------------------------------------------------------

loc_8000D70:				; CODE XREF: main+5E6j
		add	[ebp+i], 1

loc_8000D77:				; CODE XREF: main+5B7j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_8000CA1

loc_8000D95:				; CODE XREF: main+5A7j	main+689j
		movzx	eax, [ebp+match_found]
		xor	eax, 1
		test	al, al
		jz	loc_80012A1
		sub	esp, 8
		push	offset aIspeed	; "ispeed"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000E53
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_8000E0D
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E0D:				; CODE XREF: main+6EBj
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		lea	edx, [ebp+mode]
		push	edx		; mode
		push	eax		; arg
		push	0		; type
		call	set_speed
		add	esp, 10h
		mov	[ebp+speed_was_set], 1
		mov	[ebp+require_set_attr],	1
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_8000E53:				; CODE XREF: main+6DAj
		sub	esp, 8
		push	offset aOspeed	; "ospeed"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000EFF
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_8000EB9
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000EB9:				; CODE XREF: main+797j
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		lea	edx, [ebp+mode]
		push	edx		; mode
		push	eax		; arg
		push	1		; type
		call	set_speed
		add	esp, 10h
		mov	[ebp+speed_was_set], 1
		mov	[ebp+require_set_attr],	1
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_8000EFF:				; CODE XREF: main+786j
		sub	esp, 8
		push	offset aRows	; "rows"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000FAD
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_8000F65
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F65:				; CODE XREF: main+843j
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	7FFFFFFFh	; maxval
		push	eax		; s
		call	integer_arg
		add	esp, 10h
		sub	esp, 4
		push	[ebp+device_name] ; device_name
		push	0FFFFFFFFh	; cols
		push	eax		; rows
		call	set_window_size
		add	esp, 10h
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_8000FAD:				; CODE XREF: main+832j
		sub	esp, 8
		push	offset aCols	; "cols"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000FE5
		sub	esp, 8
		push	offset aColumns_0 ; "columns"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8001075

loc_8000FE5:				; CODE XREF: main+8E0j
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_800102D
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800102D:				; CODE XREF: main+90Bj
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	7FFFFFFFh	; maxval
		push	eax		; s
		call	integer_arg
		add	esp, 10h
		sub	esp, 4
		push	[ebp+device_name] ; device_name
		push	eax		; cols
		push	0FFFFFFFFh	; rows
		call	set_window_size
		add	esp, 10h
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_8001075:				; CODE XREF: main+8FAj
		sub	esp, 8
		push	offset aSize	; "size"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80010BB
		call	screen_columns
		mov	ds:max_col, eax
		mov	ds:current_col,	0
		sub	esp, 8
		push	[ebp+device_name] ; device_name
		push	0		; fancy
		call	display_window_size
		add	esp, 10h
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_80010BB:				; CODE XREF: main+9A8j
		sub	esp, 8
		push	offset aLine	; "line"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_80011C0
		mov	eax, [ebx]
		sub	eax, 1
		cmp	eax, [ebp+k]
		jnz	short loc_8001121
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument to %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001121:				; CODE XREF: main+9FFj
		add	[ebp+k], 1
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	0FFFFFFFFh	; maxval
		push	eax		; s
		call	integer_arg
		add	esp, 10h
		mov	[ebp+value], eax
		mov	eax, [ebp+value]
		mov	[ebp+mode.c_line], al
		movzx	eax, [ebp+mode.c_line]
		movzx	eax, al
		cmp	eax, [ebp+value]
		jz	short loc_80011B4
		mov	eax, [ebp+k]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidLineDis ; "invalid line discipline %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80011B4:				; CODE XREF: main+A8Aj
		mov	[ebp+require_set_attr],	1
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_80011C0:				; CODE XREF: main+9EEj
		sub	esp, 8
		push	offset aSpeed	; "speed"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80011FD
		call	screen_columns
		mov	ds:max_col, eax
		sub	esp, 8
		push	0		; fancy
		lea	eax, [ebp+mode]
		push	eax		; mode
		call	display_speed
		add	esp, 10h
		jmp	loc_80012A1
; ---------------------------------------------------------------------------

loc_80011FD:				; CODE XREF: main+AF3j
		sub	esp, 0Ch
		push	[ebp+arg]	; arg
		call	string_to_baud
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_800123D
		sub	esp, 4
		lea	eax, [ebp+mode]
		push	eax		; mode
		push	[ebp+arg]	; arg
		push	2		; type
		call	set_speed
		add	esp, 10h
		mov	[ebp+speed_was_set], 1
		mov	[ebp+require_set_attr],	1
		jmp	short loc_80012A1
; ---------------------------------------------------------------------------

loc_800123D:				; CODE XREF: main+B2Cj
		sub	esp, 8
		lea	eax, [ebp+mode]
		push	eax		; mode
		push	[ebp+arg]	; arg
		call	recover_mode
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001297
		sub	esp, 0Ch
		push	[ebp+arg]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidArgumen ; "invalid argument %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001297:				; CODE XREF: main+B75j
		mov	[ebp+require_set_attr],	1
		jmp	short loc_80012A1
; ---------------------------------------------------------------------------

loc_80012A0:				; CODE XREF: main+485j
		nop

loc_80012A1:				; CODE XREF: main+6BCj	main+769j ...
		add	[ebp+k], 1

loc_80012A8:				; CODE XREF: main+44Ej
		mov	eax, [ebp+k]
		cmp	eax, [ebx]
		jl	loc_8000B38
		cmp	[ebp+require_set_attr],	0
		jz	loc_80013AC
		lea	edx, [ebp+new_mode]
		mov	eax, 0
		mov	ecx, 0Fh
		mov	edi, edx
		rep stosd
		sub	esp, 4
		lea	eax, [ebp+mode]
		push	eax		; termios_p
		push	1		; optional_actions
		push	0		; fd
		call	tcsetattr
		add	esp, 10h
		test	eax, eax
		jz	short loc_800130B
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800130B:				; CODE XREF: main+C07j
		sub	esp, 8
		lea	eax, [ebp+new_mode]
		push	eax		; termios_p
		push	0		; fd
		call	tcgetattr
		add	esp, 10h
		test	eax, eax
		jz	short loc_800133D
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800133D:				; CODE XREF: main+C39j
		sub	esp, 4
		push	3Ch		; n
		lea	eax, [ebp+new_mode]
		push	eax		; s2
		lea	eax, [ebp+mode]
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80013AC
		mov	eax, [ebp+new_mode.c_cflag]
		and	eax, 0EFF0FFFFh
		mov	[ebp+new_mode.c_cflag],	eax
		cmp	[ebp+speed_was_set], 0
		jnz	short loc_8001389
		sub	esp, 4
		push	3Ch		; n
		lea	eax, [ebp+new_mode]
		push	eax		; s2
		lea	eax, [ebp+mode]
		push	eax		; s1
		call	memcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80013AC

loc_8001389:				; CODE XREF: main+C86j
		sub	esp, 0Ch
		push	offset aSUnableToPerfo ; "%s: unable to	perform	all requested ope"...
		call	gettext
		add	esp, 10h
		push	[ebp+device_name]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80013AC:				; CODE XREF: main+BD8j	main+C72j ...
		sub	esp, 0Ch
		push	0		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	set_mode(const mode_info *info,	_Bool reversed,	termios	*mode)
set_mode	proc near		; CODE XREF: main+508p

reversed	= byte ptr -1Ch
bitsp		= dword	ptr -0Ch
info		= dword	ptr  8
arg_4		= dword	ptr  0Ch
mode		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+reversed],	al
		cmp	[ebp+reversed],	0
		jz	short loc_80013E3
		mov	eax, [ebp+info]
		movzx	eax, byte ptr [eax+8]
		movsx	eax, al
		and	eax, 4
		test	eax, eax
		jnz	short loc_80013E3
		mov	eax, 0
		jmp	locret_80019D2
; ---------------------------------------------------------------------------

loc_80013E3:				; CODE XREF: set_mode+10j set_mode+21j
		mov	eax, [ebp+info]
		mov	eax, [eax+4]
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	eax		; type
		call	mode_type_flag
		add	esp, 10h
		mov	[ebp+bitsp], eax
		cmp	[ebp+bitsp], 0
		jnz	loc_800198B
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aEvenp	; "evenp"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001439
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aParity	; "parity"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001477

loc_8001439:				; CODE XREF: set_mode+67j
		cmp	[ebp+reversed],	0
		jz	short loc_800145A
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800145A:				; CODE XREF: set_mode+87j
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFCCFh
		or	eax, 120h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001477:				; CODE XREF: set_mode+81j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aOddp	; "oddp"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80014CF
		cmp	[ebp+reversed],	0
		jz	short loc_80014B2
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80014B2:				; CODE XREF: set_mode+DFj
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFCCFh
		or	eax, 320h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80014CF:				; CODE XREF: set_mode+D9j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aNl	; "nl"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001541
		cmp	[ebp+reversed],	0
		jz	short loc_800151C
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	eax, 0FFFFFE3Fh
		or	ah, 1
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	eax, 0FFFFFFD3h
		or	eax, 4
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800151C:				; CODE XREF: set_mode+137j
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	ah, 0FEh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFBh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001541:				; CODE XREF: set_mode+131j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aEk	; "ek"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800156E
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+13h], 7Fh
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+14h], 15h
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800156E:				; CODE XREF: set_mode+1A3j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aSane	; "sane"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800159B
		sub	esp, 0Ch
		push	[ebp+mode]	; mode
		call	sane_mode
		add	esp, 10h
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800159B:				; CODE XREF: set_mode+1D0j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aCbreak	; "cbreak"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80015E7
		cmp	[ebp+reversed],	0
		jz	short loc_80015D1
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		or	eax, 2
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80015D1:				; CODE XREF: set_mode+203j
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		and	eax, 0FFFFFFFDh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80015E7:				; CODE XREF: set_mode+1FDj
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aPass8	; "pass8"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800165D
		cmp	[ebp+reversed],	0
		jz	short loc_8001633
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 120h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		or	eax, 20h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001633:				; CODE XREF: set_mode+24Fj
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	eax, 0FFFFFFDFh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800165D:				; CODE XREF: set_mode+249j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aLitout	; "litout"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80016F5
		cmp	[ebp+reversed],	0
		jz	short loc_80016BA
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 120h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		or	eax, 20h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		or	eax, 1
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80016BA:				; CODE XREF: set_mode+2C5j
		mov	eax, [ebp+mode]
		mov	eax, [eax+8]
		and	eax, 0FFFFFECFh
		or	eax, 30h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	eax, 0FFFFFFDFh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFEh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80016F5:				; CODE XREF: set_mode+2BFj
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aRaw	; "raw"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800172D
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aCooked	; "cooked"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_80017CC

loc_800172D:				; CODE XREF: set_mode+357j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 72h
		jnz	short loc_800173F
		cmp	[ebp+reversed],	0
		jnz	short loc_8001756

loc_800173F:				; CODE XREF: set_mode+381j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 63h
		jnz	short loc_800178E
		movzx	eax, [ebp+reversed]
		xor	eax, 1
		test	al, al
		jz	short loc_800178E

loc_8001756:				; CODE XREF: set_mode+387j
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		or	eax, 526h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		or	eax, 1
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		or	eax, 3
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800178E:				; CODE XREF: set_mode+393j
					; set_mode+39Ej
		mov	eax, [ebp+mode]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFEh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		and	eax, 0FFFFFFF8h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+17h], 1
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+16h], 0
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80017CC:				; CODE XREF: set_mode+371j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aDecctlq	; "decctlq"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001814
		cmp	[ebp+reversed],	0
		jz	short loc_8001800
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		or	ah, 8
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001800:				; CODE XREF: set_mode+434j
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	ah, 0F7h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001814:				; CODE XREF: set_mode+42Ej
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aTabs	; "tabs"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001860
		cmp	[ebp+reversed],	0
		jz	short loc_800184A
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		or	ah, 18h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_800184A:				; CODE XREF: set_mode+47Cj
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	ah, 0E7h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001860:				; CODE XREF: set_mode+476j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aLcase	; "lcase"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001894
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aLcase_0	; "LCASE"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001906

loc_8001894:				; CODE XREF: set_mode+4C2j
		cmp	[ebp+reversed],	0
		jz	short loc_80018D0
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		and	eax, 0FFFFFFFBh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	ah, 0FDh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		and	eax, 0FFFFFFFDh
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_80018D0:				; CODE XREF: set_mode+4E2j
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		or	eax, 4
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		or	ah, 2
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax+4]
		or	eax, 2
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001906:				; CODE XREF: set_mode+4DCj
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aCrt	; "crt"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001938
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		or	eax, 0A10h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		jmp	loc_80019CD
; ---------------------------------------------------------------------------

loc_8001938:				; CODE XREF: set_mode+568j
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aDec	; "dec"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80019CD
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+11h], 3
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+13h], 7Fh
		mov	eax, [ebp+mode]
		mov	byte ptr [eax+14h], 15h
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		or	eax, 0A10h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		and	ah, 0F7h
		mov	edx, eax
		mov	eax, [ebp+mode]
		mov	[eax], edx
		jmp	short loc_80019CD
; ---------------------------------------------------------------------------

loc_800198B:				; CODE XREF: set_mode+49j
		cmp	[ebp+reversed],	0
		jz	short loc_80019B1
		mov	eax, [ebp+bitsp]
		mov	edx, [eax]
		mov	eax, [ebp+info]
		mov	eax, [eax+10h]
		not	eax
		and	edx, eax
		mov	eax, [ebp+info]
		mov	eax, [eax+0Ch]
		not	eax
		and	edx, eax
		mov	eax, [ebp+bitsp]
		mov	[eax], edx
		jmp	short loc_80019CD
; ---------------------------------------------------------------------------

loc_80019B1:				; CODE XREF: set_mode+5D9j
		mov	eax, [ebp+bitsp]
		mov	edx, [eax]
		mov	eax, [ebp+info]
		mov	eax, [eax+10h]
		not	eax
		and	edx, eax
		mov	eax, [ebp+info]
		mov	eax, [eax+0Ch]
		or	edx, eax
		mov	eax, [ebp+bitsp]
		mov	[eax], edx

loc_80019CD:				; CODE XREF: set_mode+9Fj set_mode+BCj ...
		mov	eax, 1

locret_80019D2:				; CODE XREF: set_mode+28j
		leave
		retn
set_mode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_control_char(const control_info *info, const	char *arg, termios *mode)
set_control_char proc near		; CODE XREF: main+67Ap

value		= dword	ptr -0Ch
info		= dword	ptr  8
arg		= dword	ptr  0Ch
mode		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aMin	; "min"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001A0E
		mov	eax, [ebp+info]
		mov	eax, [eax]
		sub	esp, 8
		push	offset aTime	; "time"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A29

loc_8001A0E:				; CODE XREF: set_control_char+1Ej
		sub	esp, 8
		push	0FFh		; maxval
		push	[ebp+arg]	; s
		call	integer_arg
		add	esp, 10h
		mov	[ebp+value], eax
		jmp	loc_8001AFD
; ---------------------------------------------------------------------------

loc_8001A29:				; CODE XREF: set_control_char+38j
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001A40
		mov	eax, [ebp+arg]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8001A60

loc_8001A40:				; CODE XREF: set_control_char+5Dj
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		mov	[ebp+value], eax
		jmp	loc_8001AFD
; ---------------------------------------------------------------------------

loc_8001A60:				; CODE XREF: set_control_char+6Aj
		sub	esp, 8
		push	offset asc_800575F ; "^-"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001A8E
		sub	esp, 8
		push	offset aUndef	; "undef"
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A97

loc_8001A8E:				; CODE XREF: set_control_char+A1j
		mov	[ebp+value], 0
		jmp	short loc_8001AFD
; ---------------------------------------------------------------------------

loc_8001A97:				; CODE XREF: set_control_char+B8j
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		cmp	al, 5Eh
		jnz	short loc_8001AE7
		mov	eax, [ebp+arg]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001AE7
		mov	eax, [ebp+arg]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 3Fh
		jnz	short loc_8001AC4
		mov	[ebp+value], 7Fh
		jmp	short loc_8001AFD
; ---------------------------------------------------------------------------

loc_8001AC4:				; CODE XREF: set_control_char+E5j
		mov	eax, [ebp+arg]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		and	eax, 0FFFFFF9Fh
		mov	[ebp+value], eax
		jmp	short loc_8001AFD
; ---------------------------------------------------------------------------

loc_8001AE7:				; CODE XREF: set_control_char+CBj
					; set_control_char+D8j
		sub	esp, 8
		push	0FFh		; maxval
		push	[ebp+arg]	; s
		call	integer_arg
		add	esp, 10h
		mov	[ebp+value], eax

loc_8001AFD:				; CODE XREF: set_control_char+50j
					; set_control_char+87j	...
		mov	eax, [ebp+info]
		mov	eax, [eax+8]
		mov	edx, [ebp+value]
		mov	ecx, edx
		mov	edx, [ebp+mode]
		mov	[edx+eax+11h], cl
		nop
		leave
		retn
set_control_char endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_speed(speed_setting type, const char	*arg, termios *mode)
set_speed	proc near		; CODE XREF: main+753p	main+7FFp ...

baud		= dword	ptr -0Ch
type		= dword	ptr  8
arg		= dword	ptr  0Ch
mode		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	[ebp+arg]	; arg
		call	string_to_baud
		add	esp, 10h
		mov	[ebp+baud], eax
		cmp	[ebp+type], 0
		jz	short loc_8001B35
		cmp	[ebp+type], 2
		jnz	short loc_8001B46

loc_8001B35:				; CODE XREF: set_speed+1Bj
		sub	esp, 8
		push	[ebp+baud]	; speed
		push	[ebp+mode]	; termios_p
		call	cfsetispeed
		add	esp, 10h

loc_8001B46:				; CODE XREF: set_speed+21j
		cmp	[ebp+type], 1
		jz	short loc_8001B52
		cmp	[ebp+type], 2
		jnz	short loc_8001B63

loc_8001B52:				; CODE XREF: set_speed+38j
		sub	esp, 8
		push	[ebp+baud]	; speed
		push	[ebp+mode]	; termios_p
		call	cfsetospeed
		add	esp, 10h

loc_8001B63:				; CODE XREF: set_speed+3Ej
		nop
		leave
		retn
set_speed	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl get_win_size(int fd, winsize *win)
get_win_size	proc near		; CODE XREF: set_window_size+20p
					; display_window_size+26p ...

err		= dword	ptr -0Ch
fd		= dword	ptr  8
win		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 4
		push	[ebp+win]
		push	5413h		; request
		push	[ebp+fd]	; fd
		call	ioctl
		add	esp, 10h
		mov	[ebp+err], eax
		mov	eax, [ebp+err]
		leave
		retn
get_win_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_window_size(int rows, int cols, const char *device_name)
set_window_size	proc near		; CODE XREF: main+8BBp	main+983p

device_name	= dword	ptr -1Ch
win		= winsize ptr -14h
var_C		= dword	ptr -0Ch
rows		= dword	ptr  8
cols		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_8]
		mov	[ebp+device_name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+win]
		push	eax		; win
		push	0		; fd
		call	get_win_size
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001BEF
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jz	short loc_8001BDC
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001BDC:				; CODE XREF: set_window_size+36j
		sub	esp, 4
		push	8		; n
		push	0		; c
		lea	eax, [ebp+win]
		push	eax		; s
		call	memset
		add	esp, 10h

loc_8001BEF:				; CODE XREF: set_window_size+2Aj
		cmp	[ebp+rows], 0
		js	short loc_8001BFC
		mov	eax, [ebp+rows]
		mov	[ebp+win.ws_row], ax

loc_8001BFC:				; CODE XREF: set_window_size+69j
		cmp	[ebp+cols], 0
		js	short loc_8001C09
		mov	eax, [ebp+cols]
		mov	[ebp+win.ws_col], ax

loc_8001C09:				; CODE XREF: set_window_size+76j
		sub	esp, 4
		lea	eax, [ebp+win]
		push	eax
		push	5414h		; request
		push	0		; fd
		call	ioctl
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001C3D
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001C3D:				; CODE XREF: set_window_size+97j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8001C4F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001C4F:				; CODE XREF: set_window_size+BEj
		leave
		retn
set_window_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_window_size(_Bool fancy,	const char *device_name)
display_window_size proc near		; CODE XREF: main+9C9p	display_all+25p

device_name	= dword	ptr -20h
fancy		= byte ptr -1Ch
win		= winsize ptr -14h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fancy], al
		mov	eax, [ebp+arg_4]
		mov	[ebp+device_name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+win]
		push	eax		; win
		push	0		; fd
		call	get_win_size
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001CD6
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jz	short loc_8001CA9
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+device_name]
		push	offset format	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001CA9:				; CODE XREF: display_window_size+3Cj
		movzx	eax, [ebp+fancy]
		xor	eax, 1
		test	al, al
		jz	short loc_8001D19
		sub	esp, 0Ch
		push	offset aSNoSizeInforma ; "%s: no size information for this device"
		call	gettext
		add	esp, 10h
		push	[ebp+device_name]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001D19
; ---------------------------------------------------------------------------

loc_8001CD6:				; CODE XREF: display_window_size+30j
		movzx	eax, [ebp+win.ws_col]
		movzx	edx, ax
		movzx	eax, [ebp+win.ws_row]
		movzx	eax, ax
		cmp	[ebp+fancy], 0
		jz	short loc_8001CF1
		mov	ecx, offset message ; "rows %d;	columns	%d;"
		jmp	short loc_8001CF6
; ---------------------------------------------------------------------------

loc_8001CF1:				; CODE XREF: display_window_size+97j
		mov	ecx, offset aDD	; "%d %d\n"

loc_8001CF6:				; CODE XREF: display_window_size+9Ej
		sub	esp, 4
		push	edx
		push	eax
		push	ecx		; message
		call	wrapf
		add	esp, 10h
		movzx	eax, [ebp+fancy]
		xor	eax, 1
		test	al, al
		jz	short loc_8001D19
		mov	ds:current_col,	0

loc_8001D19:				; CODE XREF: display_window_size+61j
					; display_window_size+83j ...
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8001D2B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001D2B:				; CODE XREF: display_window_size+D3j
		leave
		retn
display_window_size endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int screen_columns()
screen_columns	proc near		; CODE XREF: main:loc_8000ADFp
					; main+9AAp ...

n_columns	= dword	ptr -1Ch
col_string	= dword	ptr -18h
win		= winsize ptr -14h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+win]
		push	eax		; win
		push	1		; fd
		call	get_win_size
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001D65
		movzx	eax, [ebp+win.ws_col]
		test	ax, ax
		jz	short loc_8001D65
		movzx	eax, [ebp+win.ws_col]
		movzx	eax, ax
		jmp	short loc_8001DAE
; ---------------------------------------------------------------------------

loc_8001D65:				; CODE XREF: screen_columns+24j
					; screen_columns+2Dj
		sub	esp, 0Ch
		push	offset name	; "COLUMNS"
		call	getenv
		add	esp, 10h
		mov	[ebp+col_string], eax
		cmp	[ebp+col_string], 0
		jz	short loc_8001DA4
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+n_columns]
		push	eax
		push	0
		push	0
		push	[ebp+col_string]
		call	xstrtol
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8001DA4
		mov	eax, [ebp+n_columns]
		test	eax, eax
		jg	short loc_8001DAB

loc_8001DA4:				; CODE XREF: screen_columns+4Fj
					; screen_columns+6Ej
		mov	[ebp+n_columns], 50h

loc_8001DAB:				; CODE XREF: screen_columns+75j
		mov	eax, [ebp+n_columns]

loc_8001DAE:				; CODE XREF: screen_columns+36j
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8001DBF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001DBF:				; CODE XREF: screen_columns+8Bj
		leave
		retn
screen_columns	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; tcflag_t *__cdecl mode_type_flag(mode_type type, termios *mode)
mode_type_flag	proc near		; CODE XREF: set_mode+3Ap
					; display_changed+215p	...

type		= dword	ptr  8
mode		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+type], 4	; switch 5 cases
		ja	short loc_8001E00 ; jumptable 08001DDA default case
		mov	eax, [ebp+type]
		shl	eax, 2
		add	eax, offset off_80057B4
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001DDC:				; CODE XREF: mode_type_flag+19j
					; DATA XREF: .rodata:off_80057B4o
		mov	eax, [ebp+mode]	; jumptable 08001DDA case 0
		add	eax, 8
		jmp	short locret_8001E05
; ---------------------------------------------------------------------------

loc_8001DE4:				; CODE XREF: mode_type_flag+19j
					; DATA XREF: .rodata:off_80057B4o
		mov	eax, [ebp+mode]	; jumptable 08001DDA case 1
		jmp	short locret_8001E05
; ---------------------------------------------------------------------------

loc_8001DE9:				; CODE XREF: mode_type_flag+19j
					; DATA XREF: .rodata:off_80057B4o
		mov	eax, [ebp+mode]	; jumptable 08001DDA case 2
		add	eax, 4
		jmp	short locret_8001E05
; ---------------------------------------------------------------------------

loc_8001DF1:				; CODE XREF: mode_type_flag+19j
					; DATA XREF: .rodata:off_80057B4o
		mov	eax, [ebp+mode]	; jumptable 08001DDA case 3
		add	eax, 0Ch
		jmp	short locret_8001E05
; ---------------------------------------------------------------------------

loc_8001DF9:				; CODE XREF: mode_type_flag+19j
					; DATA XREF: .rodata:off_80057B4o
		mov	eax, 0		; jumptable 08001DDA case 4
		jmp	short locret_8001E05
; ---------------------------------------------------------------------------

loc_8001E00:				; CODE XREF: mode_type_flag+Aj
		call	abort		; jumptable 08001DDA default case
; ---------------------------------------------------------------------------

locret_8001E05:				; CODE XREF: mode_type_flag+21j
					; mode_type_flag+26j ...
		leave
		retn
mode_type_flag	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_settings(output_type output_type, termios *mode,	const char *device_name)
display_settings proc near		; CODE XREF: main+424p

output_type	= dword	ptr  8
mode		= dword	ptr  0Ch
device_name	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+output_type]
		cmp	eax, 1
		jz	short loc_8001E31
		cmp	eax, 1
		jb	short loc_8001E21
		cmp	eax, 2
		jz	short loc_8001E44
		jmp	short loc_8001E53
; ---------------------------------------------------------------------------

loc_8001E21:				; CODE XREF: display_settings+11j
		sub	esp, 0Ch
		push	[ebp+mode]	; mode
		call	display_changed
		add	esp, 10h
		jmp	short loc_8001E53
; ---------------------------------------------------------------------------

loc_8001E31:				; CODE XREF: display_settings+Cj
		sub	esp, 8
		push	[ebp+device_name] ; device_name
		push	[ebp+mode]	; mode
		call	display_all
		add	esp, 10h
		jmp	short loc_8001E53
; ---------------------------------------------------------------------------

loc_8001E44:				; CODE XREF: display_settings+16j
		sub	esp, 0Ch
		push	[ebp+mode]	; mode
		call	display_recoverable
		add	esp, 10h
		nop

loc_8001E53:				; CODE XREF: display_settings+18j
					; display_settings+28j	...
		nop
		leave
		retn
display_settings endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_changed(termios *mode)
display_changed	proc near		; CODE XREF: display_settings+20p

empty_line	= byte ptr -19h
i		= dword	ptr -18h
prev_type	= dword	ptr -14h
bitsp		= dword	ptr -10h
mask		= dword	ptr -0Ch
mode		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+prev_type], 0
		sub	esp, 8
		push	1		; fancy
		push	[ebp+mode]	; mode
		call	display_speed
		add	esp, 10h
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+10h]
		movzx	eax, al
		sub	esp, 8
		push	eax
		push	offset aLineD	; "line	= %d;"
		call	wrapf
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		mov	[ebp+empty_line], 1
		mov	[ebp+i], 0
		jmp	loc_8001F44
; ---------------------------------------------------------------------------

loc_8001EB5:				; CODE XREF: display_changed+114j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.offset
		mov	eax, [eax]
		mov	edx, [ebp+mode]
		movzx	ecx, byte ptr [edx+eax+11h]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.saneval
		movzx	eax, byte ptr [eax]
		cmp	cl, al
		jz	short loc_8001F3F
		mov	[ebp+empty_line], 0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.offset
		mov	eax, [eax]
		mov	edx, [ebp+mode]
		movzx	eax, byte ptr [edx+eax+11h]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	visible
		add	esp, 10h
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		sub	esp, 4
		push	ecx
		push	eax
		push	offset aSS	; "%s =	%s;"
		call	wrapf
		add	esp, 10h
		jmp	short loc_8001F40
; ---------------------------------------------------------------------------

loc_8001F3F:				; CODE XREF: display_changed+90j
		nop

loc_8001F40:				; CODE XREF: display_changed+E7j
		add	[ebp+i], 1

loc_8001F44:				; CODE XREF: display_changed+5Aj
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	offset aMin	; "min"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8001EB5
		mov	eax, [ebp+mode]
		mov	eax, [eax+0Ch]
		and	eax, 2
		test	eax, eax
		jnz	short loc_8001FA5
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+16h]
		movzx	edx, al
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+17h]
		movzx	eax, al
		sub	esp, 4
		push	edx
		push	eax
		push	offset aMinLuTimeLu ; "min = %lu; time = %lu;\n"
		call	wrapf
		add	esp, 10h
		jmp	short loc_8001FBD
; ---------------------------------------------------------------------------

loc_8001FA5:				; CODE XREF: display_changed+125j
		movzx	eax, [ebp+empty_line]
		xor	eax, 1
		test	al, al
		jz	short loc_8001FBD
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8001FBD:				; CODE XREF: display_changed+14Dj
					; display_changed+158j
		mov	ds:current_col,	0
		mov	[ebp+empty_line], 1
		mov	[ebp+i], 0
		jmp	loc_8002177
; ---------------------------------------------------------------------------

loc_8001FD7:				; CODE XREF: display_changed+337j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 8
		test	eax, eax
		jnz	loc_8002172
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		cmp	eax, [ebp+prev_type]
		jz	short loc_8002050
		movzx	eax, [ebp+empty_line]
		xor	eax, 1
		test	al, al
		jz	short loc_8002039
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		mov	[ebp+empty_line], 1

loc_8002039:				; CODE XREF: display_changed+1C6j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		mov	[ebp+prev_type], eax

loc_8002050:				; CODE XREF: display_changed+1BBj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	eax		; type
		call	mode_type_flag
		add	esp, 10h
		mov	[ebp+bitsp], eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_80020A4
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		jmp	short loc_80020B8
; ---------------------------------------------------------------------------

loc_80020A4:				; CODE XREF: display_changed+236j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]

loc_80020B8:				; CODE XREF: display_changed+24Cj
		mov	[ebp+mask], eax
		mov	eax, [ebp+bitsp]
		mov	eax, [eax]
		and	eax, [ebp+mask]
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]
		cmp	ecx, eax
		jnz	short loc_8002127
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 2
		test	eax, eax
		jz	short loc_8002173
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	offset format	; "%s"
		call	wrapf
		add	esp, 10h
		mov	[ebp+empty_line], 0
		jmp	short loc_8002173
; ---------------------------------------------------------------------------

loc_8002127:				; CODE XREF: display_changed+285j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 5
		cmp	eax, 5
		jnz	short loc_8002173
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	offset aS_0	; "-%s"
		call	wrapf
		add	esp, 10h
		mov	[ebp+empty_line], 0
		jmp	short loc_8002173
; ---------------------------------------------------------------------------

loc_8002172:				; CODE XREF: display_changed+19Ej
		nop

loc_8002173:				; CODE XREF: display_changed+2A4j
					; display_changed+2CFj	...
		add	[ebp+i], 1

loc_8002177:				; CODE XREF: display_changed+17Cj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_8001FD7
		movzx	eax, [ebp+empty_line]
		xor	eax, 1
		test	al, al
		jz	short loc_80021AB
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_80021AB:				; CODE XREF: display_changed+346j
		mov	ds:current_col,	0
		nop
		leave
		retn
display_changed	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_all(termios *mode, const	char *device_name)
display_all	proc near		; CODE XREF: display_settings+33p

i		= dword	ptr -18h
prev_type	= dword	ptr -14h
bitsp		= dword	ptr -10h
mask		= dword	ptr -0Ch
mode		= dword	ptr  8
device_name	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+prev_type], 0
		sub	esp, 8
		push	1		; fancy
		push	[ebp+mode]	; mode
		call	display_speed
		add	esp, 10h
		sub	esp, 8
		push	[ebp+device_name] ; device_name
		push	1		; fancy
		call	display_window_size
		add	esp, 10h
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+10h]
		movzx	eax, al
		sub	esp, 8
		push	eax
		push	offset aLineD	; "line	= %d;"
		call	wrapf
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		mov	[ebp+i], 0
		jmp	short loc_8002275
; ---------------------------------------------------------------------------

loc_8002220:				; CODE XREF: display_all+E3j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.offset
		mov	eax, [eax]
		mov	edx, [ebp+mode]
		movzx	eax, byte ptr [edx+eax+11h]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	visible
		add	esp, 10h
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		sub	esp, 4
		push	ecx
		push	eax
		push	offset aSS	; "%s =	%s;"
		call	wrapf
		add	esp, 10h
		add	[ebp+i], 1

loc_8002275:				; CODE XREF: display_all+66j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	offset aMin	; "min"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002220
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+16h]
		movzx	edx, al
		mov	eax, [ebp+mode]
		movzx	eax, byte ptr [eax+17h]
		movzx	eax, al
		sub	esp, 4
		push	edx
		push	eax
		push	offset aMinLuTimeLu_0 ;	"min = %lu; time = %lu;"
		call	wrapf
		add	esp, 10h
		mov	eax, ds:current_col
		test	eax, eax
		jz	short loc_80022D9
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_80022D9:				; CODE XREF: display_all+112j
		mov	ds:current_col,	0
		mov	[ebp+i], 0
		jmp	loc_8002458
; ---------------------------------------------------------------------------

loc_80022EF:				; CODE XREF: display_all+2B6j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 8
		test	eax, eax
		jnz	loc_8002453
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		cmp	eax, [ebp+prev_type]
		jz	short loc_8002359
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		mov	[ebp+prev_type], eax

loc_8002359:				; CODE XREF: display_all+171j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	eax		; type
		call	mode_type_flag
		add	esp, 10h
		mov	[ebp+bitsp], eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_80023AD
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		jmp	short loc_80023C1
; ---------------------------------------------------------------------------

loc_80023AD:				; CODE XREF: display_all+1DDj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]

loc_80023C1:				; CODE XREF: display_all+1F3j
		mov	[ebp+mask], eax
		mov	eax, [ebp+bitsp]
		mov	eax, [eax]
		and	eax, [ebp+mask]
		mov	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]
		cmp	ecx, eax
		jnz	short loc_800240D
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	offset format	; "%s"
		call	wrapf
		add	esp, 10h
		jmp	short loc_8002454
; ---------------------------------------------------------------------------

loc_800240D:				; CODE XREF: display_all+22Cj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 4
		test	eax, eax
		jz	short loc_8002454
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	offset aS_0	; "-%s"
		call	wrapf
		add	esp, 10h
		jmp	short loc_8002454
; ---------------------------------------------------------------------------

loc_8002453:				; CODE XREF: display_all+154j
		nop

loc_8002454:				; CODE XREF: display_all+253j
					; display_all+272j ...
		add	[ebp+i], 1

loc_8002458:				; CODE XREF: display_all+132j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_80022EF
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ds:current_col,	0
		nop
		leave
		retn
display_all	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_speed(termios *mode, _Bool fancy)
display_speed	proc near		; CODE XREF: main+B0Bp
					; display_changed+15p ...

fancy		= byte ptr -0Ch
var_4		= dword	ptr -4
mode		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+arg_4]
		mov	[ebp+fancy], al
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetispeed
		add	esp, 10h
		test	eax, eax
		jz	short loc_80024CF
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetispeed
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetospeed
		add	esp, 10h
		cmp	ebx, eax
		jnz	short loc_800250C

loc_80024CF:				; CODE XREF: display_speed+1Dj
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetospeed
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; speed
		call	baud_to_value
		add	esp, 10h
		mov	edx, eax
		cmp	[ebp+fancy], 0
		jz	short loc_80024F8
		mov	eax, offset aSpeedLuBaud ; "speed %lu baud;"
		jmp	short loc_80024FD
; ---------------------------------------------------------------------------

loc_80024F8:				; CODE XREF: display_speed+61j
		mov	eax, offset aLu	; "%lu\n"

loc_80024FD:				; CODE XREF: display_speed+68j
		sub	esp, 8
		push	edx
		push	eax		; message
		call	wrapf
		add	esp, 10h
		jmp	short loc_8002564
; ---------------------------------------------------------------------------

loc_800250C:				; CODE XREF: display_speed+3Fj
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetospeed
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; speed
		call	baud_to_value
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+mode]	; termios_p
		call	cfgetispeed
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; speed
		call	baud_to_value
		add	esp, 10h
		mov	edx, eax
		cmp	[ebp+fancy], 0
		jz	short loc_8002551
		mov	eax, offset aIspeedLuBaudOs ; "ispeed %lu baud;	ospeed %lu baud;"
		jmp	short loc_8002556
; ---------------------------------------------------------------------------

loc_8002551:				; CODE XREF: display_speed+BAj
		mov	eax, offset aLuLu ; "%lu %lu\n"

loc_8002556:				; CODE XREF: display_speed+C1j
		sub	esp, 4
		push	ebx
		push	edx
		push	eax		; message
		call	wrapf
		add	esp, 10h

loc_8002564:				; CODE XREF: display_speed+7Cj
		movzx	eax, [ebp+fancy]
		xor	eax, 1
		test	al, al
		jz	short loc_8002579
		mov	ds:current_col,	0

loc_8002579:				; CODE XREF: display_speed+DFj
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
display_speed	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl display_recoverable(termios *mode)
display_recoverable proc near		; CODE XREF: display_settings+43p

i		= dword	ptr -0Ch
var_4		= dword	ptr -4
mode		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+mode]
		mov	ebx, [eax+0Ch]
		mov	eax, [ebp+mode]
		mov	ecx, [eax+8]
		mov	eax, [ebp+mode]
		mov	edx, [eax+4]
		mov	eax, [ebp+mode]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	ebx
		push	ecx
		push	edx
		push	eax
		push	offset aLxLxLxLx ; "%lx:%lx:%lx:%lx"
		call	printf
		add	esp, 20h
		mov	[ebp+i], 0
		jmp	short loc_80025E0
; ---------------------------------------------------------------------------

loc_80025BA:				; CODE XREF: display_recoverable+65j
		mov	edx, [ebp+mode]
		mov	eax, [ebp+i]
		add	eax, edx
		add	eax, 11h
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 8
		push	eax
		push	offset aLx	; ":%lx"
		call	printf
		add	esp, 10h
		add	[ebp+i], 1

loc_80025E0:				; CODE XREF: display_recoverable+39j
		cmp	[ebp+i], 1Fh
		jbe	short loc_80025BA
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
display_recoverable endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strtoul_tcflag_t(const char *s, int base,	char **p, tcflag_t *result, char delim)
strtoul_tcflag_t proc near		; CODE XREF: recover_mode+4Ap

delim		= byte ptr -1Ch
ul		= dword	ptr -0Ch
s		= dword	ptr  8
base		= dword	ptr  0Ch
p		= dword	ptr  10h
result		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_10]
		mov	[ebp+delim], al
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	[ebp+base]	; base
		push	[ebp+p]		; endptr
		push	[ebp+s]		; nptr
		call	strtoul
		add	esp, 10h
		mov	[ebp+ul], eax
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8002649
		mov	eax, [ebp+p]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+delim]
		jnz	short loc_8002649
		mov	eax, [ebp+p]
		mov	eax, [eax]
		cmp	eax, [ebp+s]
		jnz	short loc_8002650

loc_8002649:				; CODE XREF: strtoul_tcflag_t+37j
					; strtoul_tcflag_t+44j
		mov	eax, 0FFFFFFFFh
		jmp	short locret_800265D
; ---------------------------------------------------------------------------

loc_8002650:				; CODE XREF: strtoul_tcflag_t+4Ej
		mov	eax, [ebp+result]
		mov	edx, [ebp+ul]
		mov	[eax], edx
		mov	eax, 0

locret_800265D:				; CODE XREF: strtoul_tcflag_t+55j
		leave
		retn
strtoul_tcflag_t endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl strtoul_cc_t(const char *s, int base, char **p, cc_t *result, char delim)
strtoul_cc_t	proc near		; CODE XREF: recover_mode+D1p

delim		= byte ptr -1Ch
ul		= dword	ptr -0Ch
s		= dword	ptr  8
base		= dword	ptr  0Ch
p		= dword	ptr  10h
result		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_10]
		mov	[ebp+delim], al
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	[ebp+base]	; base
		push	[ebp+p]		; endptr
		push	[ebp+s]		; nptr
		call	strtoul
		add	esp, 10h
		mov	[ebp+ul], eax
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80026BA
		mov	eax, [ebp+p]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+delim]
		jnz	short loc_80026BA
		mov	eax, [ebp+p]
		mov	eax, [eax]
		cmp	eax, [ebp+s]
		jz	short loc_80026BA
		mov	eax, [ebp+ul]
		movzx	eax, al
		cmp	eax, [ebp+ul]
		jz	short loc_80026C1

loc_80026BA:				; CODE XREF: strtoul_cc_t+37j
					; strtoul_cc_t+44j ...
		mov	eax, 0FFFFFFFFh
		jmp	short locret_80026D0
; ---------------------------------------------------------------------------

loc_80026C1:				; CODE XREF: strtoul_cc_t+59j
		mov	eax, [ebp+ul]
		mov	edx, eax
		mov	eax, [ebp+result]
		mov	[eax], dl
		mov	eax, 0

locret_80026D0:				; CODE XREF: strtoul_cc_t+60j
		leave
		retn
strtoul_cc_t	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	recover_mode(const char	*arg, termios *mode)
recover_mode	proc near		; CODE XREF: main+B68p

mode		= dword	ptr -40h
arg		= dword	ptr -3Ch
delim		= byte ptr -29h
p		= dword	ptr -28h
s		= dword	ptr -24h
i		= dword	ptr -20h
flag		= dword	ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	eax, [ebp+arg_0]
		mov	[ebp+arg], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+mode], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+arg]
		mov	[ebp+s], eax
		mov	[ebp+i], 0
		jmp	short loc_800273F
; ---------------------------------------------------------------------------

loc_80026FE:				; CODE XREF: recover_mode+71j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		lea	eax, [ebp+flag]
		add	eax, edx
		sub	esp, 0Ch
		push	3Ah		; delim
		push	eax		; result
		lea	eax, [ebp+p]
		push	eax		; p
		push	10h		; base
		push	[ebp+s]		; s
		call	strtoul_tcflag_t
		add	esp, 20h
		test	eax, eax
		jz	short loc_8002732
		mov	eax, 0
		jmp	loc_80027CE
; ---------------------------------------------------------------------------

loc_8002732:				; CODE XREF: recover_mode+54j
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+s], eax
		add	[ebp+i], 1

loc_800273F:				; CODE XREF: recover_mode+2Aj
		cmp	[ebp+i], 3
		jbe	short loc_80026FE
		mov	edx, [ebp+flag]
		mov	eax, [ebp+mode]
		mov	[eax], edx
		mov	edx, [ebp+flag+4]
		mov	eax, [ebp+mode]
		mov	[eax+4], edx
		mov	edx, [ebp+flag+8]
		mov	eax, [ebp+mode]
		mov	[eax+8], edx
		mov	edx, [ebp+flag+0Ch]
		mov	eax, [ebp+mode]
		mov	[eax+0Ch], edx
		mov	[ebp+i], 0
		jmp	short loc_80027C3
; ---------------------------------------------------------------------------

loc_8002771:				; CODE XREF: recover_mode+F5j
		cmp	[ebp+i], 1Eh
		ja	short loc_800277E
		mov	eax, 3Ah
		jmp	short loc_8002783
; ---------------------------------------------------------------------------

loc_800277E:				; CODE XREF: recover_mode+A3j
		mov	eax, 0

loc_8002783:				; CODE XREF: recover_mode+AAj
		mov	[ebp+delim], al
		movsx	eax, [ebp+delim]
		mov	edx, [ebp+mode]
		lea	ecx, [edx+11h]
		mov	edx, [ebp+i]
		add	edx, ecx
		sub	esp, 0Ch
		push	eax		; delim
		push	edx		; result
		lea	eax, [ebp+p]
		push	eax		; p
		push	10h		; base
		push	[ebp+s]		; s
		call	strtoul_cc_t
		add	esp, 20h
		test	eax, eax
		jz	short loc_80027B6
		mov	eax, 0
		jmp	short loc_80027CE
; ---------------------------------------------------------------------------

loc_80027B6:				; CODE XREF: recover_mode+DBj
		mov	eax, [ebp+p]
		add	eax, 1
		mov	[ebp+s], eax
		add	[ebp+i], 1

loc_80027C3:				; CODE XREF: recover_mode+9Dj
		cmp	[ebp+i], 1Fh
		jbe	short loc_8002771
		mov	eax, 1

loc_80027CE:				; CODE XREF: recover_mode+5Bj
					; recover_mode+E2j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80027DF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80027DF:				; CODE XREF: recover_mode+106j
		leave
		retn
recover_mode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; speed_t __cdecl string_to_baud(const char *arg)
string_to_baud	proc near		; CODE XREF: main+B21p	set_speed+Cp

i		= dword	ptr -0Ch
arg		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_800282F
; ---------------------------------------------------------------------------

loc_80027F0:				; CODE XREF: string_to_baud+63j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+arg]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800282B
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds.speed
		mov	eax, [eax]
		jmp	short locret_800284B
; ---------------------------------------------------------------------------

loc_800282B:				; CODE XREF: string_to_baud+33j
		add	[ebp+i], 1

loc_800282F:				; CODE XREF: string_to_baud+Dj
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80027F0
		mov	eax, 0FFFFFFFFh

locret_800284B:				; CODE XREF: string_to_baud+48j
		leave
		retn
string_to_baud	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl baud_to_value(speed_t speed)
baud_to_value	proc near		; CODE XREF: display_speed+53p
					; display_speed+90p ...

i		= dword	ptr -4
speed		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_800288D
; ---------------------------------------------------------------------------

loc_800285C:				; CODE XREF: baud_to_value+55j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds.speed
		mov	eax, [eax]
		cmp	eax, [ebp+speed]
		jnz	short loc_8002889
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds.value
		mov	eax, [eax]
		jmp	short locret_80028A9
; ---------------------------------------------------------------------------

loc_8002889:				; CODE XREF: baud_to_value+25j
		add	[ebp+i], 1

loc_800288D:				; CODE XREF: baud_to_value+Dj
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset speeds
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_800285C
		mov	eax, 0

locret_80028A9:				; CODE XREF: baud_to_value+3Aj
		leave
		retn
baud_to_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl sane_mode(termios *mode)
sane_mode	proc near		; CODE XREF: set_mode+1D8p

i		= dword	ptr -10h
bitsp		= dword	ptr -0Ch
mode		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_80028EC
; ---------------------------------------------------------------------------

loc_80028BA:				; CODE XREF: sane_mode+56j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.offset
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0.saneval
		movzx	edx, byte ptr [eax]
		mov	eax, [ebp+mode]
		mov	[eax+ecx+11h], dl
		add	[ebp+i], 1

loc_80028EC:				; CODE XREF: sane_mode+Dj
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset control_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80028BA
		mov	[ebp+i], 0
		jmp	loc_8002A18
; ---------------------------------------------------------------------------

loc_800290F:				; CODE XREF: sane_mode+183j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 1
		test	eax, eax
		jz	short loc_8002993
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	eax		; type
		call	mode_type_flag
		add	esp, 10h
		mov	[ebp+bitsp], eax
		mov	eax, [ebp+bitsp]
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		not	eax
		and	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]
		or	ecx, eax
		mov	edx, ecx
		mov	eax, [ebp+bitsp]
		mov	[eax], edx
		jmp	loc_8002A14
; ---------------------------------------------------------------------------

loc_8002993:				; CODE XREF: sane_mode+81j
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.flags
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		and	eax, 2
		test	eax, eax
		jz	short loc_8002A14
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.type
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+mode]	; mode
		push	eax		; type
		call	mode_type_flag
		add	esp, 10h
		mov	[ebp+bitsp], eax
		mov	eax, [ebp+bitsp]
		mov	ecx, [eax]
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.mask
		mov	eax, [eax]
		not	eax
		and	ecx, eax
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0.bits
		mov	eax, [eax]
		not	eax
		and	ecx, eax
		mov	edx, ecx
		mov	eax, [ebp+bitsp]
		mov	[eax], edx

loc_8002A14:				; CODE XREF: sane_mode+E3j
					; sane_mode+105j
		add	[ebp+i], 1

loc_8002A18:				; CODE XREF: sane_mode+5Fj
		mov	edx, [ebp+i]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		shl	eax, 2
		add	eax, offset mode_info_0
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_800290F
		nop
		leave
		retn
sane_mode	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl visible(cc_t ch_0)
visible		proc near		; CODE XREF: display_changed+B8p
					; display_all+8Ap

ch_0		= byte ptr -14h
bpout		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		mov	[ebp+bpout], offset buf_5556
		cmp	[ebp+ch_0], 0
		jnz	short loc_8002A5A
		mov	eax, offset aUndef_0 ; "<undef>"
		jmp	locret_8002B3C
; ---------------------------------------------------------------------------

loc_8002A5A:				; CODE XREF: visible+17j
		cmp	[ebp+ch_0], 1Fh
		jbe	loc_8002B13
		cmp	[ebp+ch_0], 7Eh
		ja	short loc_8002A7E
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		movzx	edx, [ebp+ch_0]
		mov	[eax], dl
		jmp	loc_8002B31
; ---------------------------------------------------------------------------

loc_8002A7E:				; CODE XREF: visible+31j
		cmp	[ebp+ch_0], 7Fh
		jnz	short loc_8002AA1
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	5Eh
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	3Fh
		jmp	loc_8002B31
; ---------------------------------------------------------------------------

loc_8002AA1:				; CODE XREF: visible+4Bj
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	4Dh
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	2Dh
		cmp	[ebp+ch_0], 9Fh
		jbe	short loc_8002AF3
		cmp	[ebp+ch_0], 0FFh
		jz	short loc_8002AD9
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		movzx	edx, [ebp+ch_0]
		add	edx, 0FFFFFF80h
		mov	[eax], dl
		jmp	short loc_8002B31
; ---------------------------------------------------------------------------

loc_8002AD9:				; CODE XREF: visible+8Cj
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	5Eh
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	3Fh
		jmp	short loc_8002B31
; ---------------------------------------------------------------------------

loc_8002AF3:				; CODE XREF: visible+86j
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	5Eh
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		movzx	edx, [ebp+ch_0]
		sub	edx, 40h
		mov	[eax], dl
		jmp	short loc_8002B31
; ---------------------------------------------------------------------------

loc_8002B13:				; CODE XREF: visible+27j
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		mov	byte ptr [eax],	5Eh
		mov	eax, [ebp+bpout]
		lea	edx, [eax+1]
		mov	[ebp+bpout], edx
		movzx	edx, [ebp+ch_0]
		add	edx, 40h
		mov	[eax], dl

loc_8002B31:				; CODE XREF: visible+42j visible+65j ...
		mov	eax, [ebp+bpout]
		mov	byte ptr [eax],	0
		mov	eax, offset buf_5556

locret_8002B3C:				; CODE XREF: visible+1Ej
		leave
		retn
visible		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl integer_arg(const char *s, unsigned int maxval)
integer_arg	proc near		; CODE XREF: main+8A7p	main+96Fp ...

s		= dword	ptr -1Ch
value		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
maxval		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aBb	; "bB"
		lea	eax, [ebp+value]
		push	eax
		push	0
		push	0
		push	[ebp+s]
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8002B7D
		mov	eax, [ebp+value]
		cmp	[ebp+maxval], eax
		jnb	short loc_8002BB5

loc_8002B7D:				; CODE XREF: integer_arg+35j
		sub	esp, 0Ch
		push	[ebp+s]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidInteger ; "invalid integer argument %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002BB5:				; CODE XREF: integer_arg+3Dj
		mov	eax, [ebp+value]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8002BC9
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002BC9:				; CODE XREF: integer_arg+84j
		mov	ebx, [ebp+var_4]
		leave

locret_8002BCD:				; DATA XREF: .eh_frame:08005B2Co
					; .eh_frame:08005B4Co ...
		retn
integer_arg	endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8002BD0h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; int max_col
max_col		dd ?			; DATA XREF: wrapf+4Ar	main+3FFw ...
; int current_col
current_col	dd ?			; DATA XREF: wrapf:loc_800016Fr
					; wrapf+50r ...
; Function-local static	variable
; char buf_5556[10]
buf_5556	db 0Ah dup(?)		; DATA XREF: visible+Co visible+100o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8002C00h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+94o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+1A0o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aParenb		db 'parenb',0           ; DATA XREF: .rodata:mode_info_0o
aParodd		db 'parodd',0           ; DATA XREF: .rodata:mode_info_0o
aCs5		db 'cs5',0              ; DATA XREF: .rodata:mode_info_0o
aCs6		db 'cs6',0              ; DATA XREF: .rodata:mode_info_0o
aCs7		db 'cs7',0              ; DATA XREF: .rodata:mode_info_0o
aCs8		db 'cs8',0              ; DATA XREF: .rodata:mode_info_0o
aHupcl		db 'hupcl',0            ; DATA XREF: .rodata:mode_info_0o
aHup		db 'hup',0              ; DATA XREF: .rodata:mode_info_0o
aCstopb		db 'cstopb',0           ; DATA XREF: .rodata:mode_info_0o
aCread		db 'cread',0            ; DATA XREF: .rodata:mode_info_0o
aClocal		db 'clocal',0           ; DATA XREF: .rodata:mode_info_0o
aCrtscts	db 'crtscts',0          ; DATA XREF: .rodata:mode_info_0o
aIgnbrk		db 'ignbrk',0           ; DATA XREF: .rodata:mode_info_0o
aBrkint		db 'brkint',0           ; DATA XREF: .rodata:mode_info_0o
aIgnpar		db 'ignpar',0           ; DATA XREF: .rodata:mode_info_0o
aParmrk		db 'parmrk',0           ; DATA XREF: .rodata:mode_info_0o
aInpck		db 'inpck',0            ; DATA XREF: .rodata:mode_info_0o
aIstrip		db 'istrip',0           ; DATA XREF: .rodata:mode_info_0o
aInlcr		db 'inlcr',0            ; DATA XREF: .rodata:mode_info_0o
aIgncr		db 'igncr',0            ; DATA XREF: .rodata:mode_info_0o
aIcrnl		db 'icrnl',0            ; DATA XREF: .rodata:mode_info_0o
aIxon		db 'ixon',0             ; DATA XREF: .rodata:mode_info_0o
aIxoff		db 'ixoff',0            ; DATA XREF: .rodata:mode_info_0o
aTandem		db 'tandem',0           ; DATA XREF: .rodata:mode_info_0o
aIuclc		db 'iuclc',0            ; DATA XREF: .rodata:mode_info_0o
aIxany		db 'ixany',0            ; DATA XREF: .rodata:mode_info_0o
aImaxbel	db 'imaxbel',0          ; DATA XREF: .rodata:mode_info_0o
aIutf8		db 'iutf8',0            ; DATA XREF: .rodata:mode_info_0o
aOpost		db 'opost',0            ; DATA XREF: .rodata:mode_info_0o
aOlcuc		db 'olcuc',0            ; DATA XREF: .rodata:mode_info_0o
aOcrnl		db 'ocrnl',0            ; DATA XREF: .rodata:mode_info_0o
aOnlcr		db 'onlcr',0            ; DATA XREF: .rodata:mode_info_0o
aOnocr		db 'onocr',0            ; DATA XREF: .rodata:mode_info_0o
aOnlret		db 'onlret',0           ; DATA XREF: .rodata:mode_info_0o
aOfill		db 'ofill',0            ; DATA XREF: .rodata:mode_info_0o
aOfdel		db 'ofdel',0            ; DATA XREF: .rodata:mode_info_0o
aNl1		db 'nl1',0              ; DATA XREF: .rodata:mode_info_0o
aNl0		db 'nl0',0              ; DATA XREF: .rodata:mode_info_0o
aCr3		db 'cr3',0              ; DATA XREF: .rodata:mode_info_0o
aCr2		db 'cr2',0              ; DATA XREF: .rodata:mode_info_0o
aCr1		db 'cr1',0              ; DATA XREF: .rodata:mode_info_0o
aCr0		db 'cr0',0              ; DATA XREF: .rodata:mode_info_0o
aTab3		db 'tab3',0             ; DATA XREF: .rodata:mode_info_0o
aTab2		db 'tab2',0             ; DATA XREF: .rodata:mode_info_0o
aTab1		db 'tab1',0             ; DATA XREF: .rodata:mode_info_0o
aTab0		db 'tab0',0             ; DATA XREF: .rodata:mode_info_0o
aBs1		db 'bs1',0              ; DATA XREF: .rodata:mode_info_0o
aBs0		db 'bs0',0              ; DATA XREF: .rodata:mode_info_0o
aVt1		db 'vt1',0              ; DATA XREF: .rodata:mode_info_0o
aVt0		db 'vt0',0              ; DATA XREF: .rodata:mode_info_0o
aFf1		db 'ff1',0              ; DATA XREF: .rodata:mode_info_0o
aFf0		db 'ff0',0              ; DATA XREF: .rodata:mode_info_0o
aIsig		db 'isig',0             ; DATA XREF: .rodata:mode_info_0o
aIcanon		db 'icanon',0           ; DATA XREF: .rodata:mode_info_0o
aIexten		db 'iexten',0           ; DATA XREF: .rodata:mode_info_0o
aEcho		db 'echo',0             ; DATA XREF: .rodata:mode_info_0o
aEchoe		db 'echoe',0            ; DATA XREF: .rodata:mode_info_0o
aCrterase	db 'crterase',0         ; DATA XREF: .rodata:mode_info_0o
aEchok		db 'echok',0            ; DATA XREF: .rodata:mode_info_0o
aEchonl		db 'echonl',0           ; DATA XREF: .rodata:mode_info_0o
aNoflsh		db 'noflsh',0           ; DATA XREF: .rodata:mode_info_0o
aXcase		db 'xcase',0            ; DATA XREF: .rodata:mode_info_0o
aTostop		db 'tostop',0           ; DATA XREF: .rodata:mode_info_0o
aEchoprt	db 'echoprt',0          ; DATA XREF: .rodata:mode_info_0o
aPrterase	db 'prterase',0         ; DATA XREF: .rodata:mode_info_0o
aEchoctl	db 'echoctl',0          ; DATA XREF: .rodata:mode_info_0o
aCtlecho	db 'ctlecho',0          ; DATA XREF: .rodata:mode_info_0o
aEchoke		db 'echoke',0           ; DATA XREF: .rodata:mode_info_0o
aCrtkill	db 'crtkill',0          ; DATA XREF: .rodata:mode_info_0o
; char aEvenp[]
aEvenp		db 'evenp',0            ; DATA XREF: set_mode+57o
					; .rodata:mode_info_0o
; char aParity[]
aParity		db 'parity',0           ; DATA XREF: set_mode+71o
					; .rodata:mode_info_0o
; char aOddp[]
aOddp		db 'oddp',0             ; DATA XREF: set_mode+C9o
					; .rodata:mode_info_0o
; char aNl[]
aNl		db 'nl',0               ; DATA XREF: set_mode+121o
					; .rodata:mode_info_0o
; char aEk[]
aEk		db 'ek',0               ; DATA XREF: set_mode+193o
					; .rodata:mode_info_0o
; char aSane[]
aSane		db 'sane',0             ; DATA XREF: set_mode+1C0o
					; .rodata:mode_info_0o
; char aCooked[]
aCooked		db 'cooked',0           ; DATA XREF: set_mode+361o
					; .rodata:mode_info_0o
; char aRaw[]
aRaw		db 'raw',0              ; DATA XREF: set_mode+347o
					; .rodata:mode_info_0o
; char aPass8[]
aPass8		db 'pass8',0            ; DATA XREF: set_mode+239o
					; .rodata:mode_info_0o
; char aLitout[]
aLitout		db 'litout',0           ; DATA XREF: set_mode+2AFo
					; .rodata:mode_info_0o
; char aCbreak[]
aCbreak		db 'cbreak',0           ; DATA XREF: set_mode+1EDo
					; .rodata:mode_info_0o
; char aDecctlq[]
aDecctlq	db 'decctlq',0          ; DATA XREF: set_mode+41Eo
					; .rodata:mode_info_0o
; char aTabs[]
aTabs		db 'tabs',0             ; DATA XREF: set_mode+466o
					; .rodata:mode_info_0o
; char aLcase[]
aLcase		db 'lcase',0            ; DATA XREF: set_mode+4B2o
					; .rodata:mode_info_0o
; char aLcase_0[]
aLcase_0	db 'LCASE',0            ; DATA XREF: set_mode+4CCo
					; .rodata:mode_info_0o
; char aCrt[]
aCrt		db 'crt',0              ; DATA XREF: set_mode+558o
					; .rodata:mode_info_0o
; char aDec[]
aDec		db 'dec',0              ; DATA XREF: set_mode+58Ao
					; .rodata:mode_info_0o
		align 10h
; const	mode_info mode_info_0[87]
mode_info_0	dd offset aParenb	; name ; DATA XREF: main+4C2o
					; main+4F6o ...
		dd control		; type ; "parenb"
		db 4			; flags
		db 3 dup(0)
		dd 100h			; bits
		dd 0			; mask
		dd offset aParodd	; name
		dd control		; type
		db 4			; flags
		db 3 dup(0)
		dd 200h			; bits
		dd 0			; mask
		dd offset aCs5		; name
		dd control		; type
		db 0			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 30h			; mask
		dd offset aCs6		; name
		dd control		; type
		db 0			; flags
		db 3 dup(0)
		dd 10h			; bits
		dd 30h			; mask
		dd offset aCs7		; name
		dd control		; type
		db 0			; flags
		db 3 dup(0)
		dd 20h			; bits
		dd 30h			; mask
		dd offset aCs8		; name
		dd control		; type
		db 0			; flags
		db 3 dup(0)
		dd 30h			; bits
		dd 30h			; mask
		dd offset aHupcl	; name
		dd control		; type
		db 4			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 0			; mask
		dd offset aHup		; name
		dd control		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 0			; mask
		dd offset aCstopb	; name
		dd control		; type
		db 4			; flags
		db 3 dup(0)
		dd 40h			; bits
		dd 0			; mask
		dd offset aCread	; name
		dd control		; type
		db 5			; flags
		db 3 dup(0)
		dd 80h			; bits
		dd 0			; mask
		dd offset aClocal	; name
		dd control		; type
		db 4			; flags
		db 3 dup(0)
		dd 800h			; bits
		dd 0			; mask
		dd offset aCrtscts	; name
		dd control		; type
		db 4			; flags
		db 3 dup(0)
		dd 80000000h		; bits
		dd 0			; mask
		dd offset aIgnbrk	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 1			; bits
		dd 0			; mask
		dd offset aBrkint	; name
		dd input		; type
		db 5			; flags
		db 3 dup(0)
		dd 2			; bits
		dd 0			; mask
		dd offset aIgnpar	; name
		dd input		; type
		db 4			; flags
		db 3 dup(0)
		dd 4			; bits
		dd 0			; mask
		dd offset aParmrk	; name
		dd input		; type
		db 4			; flags
		db 3 dup(0)
		dd 8			; bits
		dd 0			; mask
		dd offset aInpck	; name
		dd input		; type
		db 4			; flags
		db 3 dup(0)
		dd 10h			; bits
		dd 0			; mask
		dd offset aIstrip	; name
		dd input		; type
		db 4			; flags
		db 3 dup(0)
		dd 20h			; bits
		dd 0			; mask
		dd offset aInlcr	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 40h			; bits
		dd 0			; mask
		dd offset aIgncr	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 80h			; bits
		dd 0			; mask
		dd offset aIcrnl	; name
		dd input		; type
		db 5			; flags
		db 3 dup(0)
		dd 100h			; bits
		dd 0			; mask
		dd offset aIxon		; name
		dd input		; type
		db 4			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 0			; mask
		dd offset aIxoff	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 1000h		; bits
		dd 0			; mask
		dd offset aTandem	; name
		dd input		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 1000h		; bits
		dd 0			; mask
		dd offset aIuclc	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 200h			; bits
		dd 0			; mask
		dd offset aIxany	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 800h			; bits
		dd 0			; mask
		dd offset aImaxbel	; name
		dd input		; type
		db 5			; flags
		db 3 dup(0)
		dd 2000h		; bits
		dd 0			; mask
		dd offset aIutf8	; name
		dd input		; type
		db 6			; flags
		db 3 dup(0)
		dd 4000h		; bits
		dd 0			; mask
		dd offset aOpost	; name
		dd output		; type
		db 5			; flags
		db 3 dup(0)
		dd 1			; bits
		dd 0			; mask
		dd offset aOlcuc	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 2			; bits
		dd 0			; mask
		dd offset aOcrnl	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 8			; bits
		dd 0			; mask
		dd offset aOnlcr	; name
		dd output		; type
		db 5			; flags
		db 3 dup(0)
		dd 4			; bits
		dd 0			; mask
		dd offset aOnocr	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 10h			; bits
		dd 0			; mask
		dd offset aOnlret	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 20h			; bits
		dd 0			; mask
		dd offset aOfill	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 40h			; bits
		dd 0			; mask
		dd offset aOfdel	; name
		dd output		; type
		db 6			; flags
		db 3 dup(0)
		dd 80h			; bits
		dd 0			; mask
		dd offset aNl1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 100h			; bits
		dd 100h			; mask
		dd offset aNl0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 100h			; mask
		dd offset aCr3		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 600h			; bits
		dd 600h			; mask
		dd offset aCr2		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 600h			; mask
		dd offset aCr1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 200h			; bits
		dd 600h			; mask
		dd offset aCr0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 600h			; mask
		dd offset aTab3		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 1800h		; bits
		dd 1800h		; mask
		dd offset aTab2		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 1000h		; bits
		dd 1800h		; mask
		dd offset aTab1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 800h			; bits
		dd 1800h		; mask
		dd offset aTab0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 1800h		; mask
		dd offset aBs1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 2000h		; bits
		dd 2000h		; mask
		dd offset aBs0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 2000h		; mask
		dd offset aVt1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 4000h		; bits
		dd 4000h		; mask
		dd offset aVt0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 4000h		; mask
		dd offset aFf1		; name
		dd output		; type
		db 2			; flags
		db 3 dup(0)
		dd 8000h		; bits
		dd 8000h		; mask
		dd offset aFf0		; name
		dd output		; type
		db 1			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 8000h		; mask
		dd offset aIsig		; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 1			; bits
		dd 0			; mask
		dd offset aIcanon	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 2			; bits
		dd 0			; mask
		dd offset aIexten	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 8000h		; bits
		dd 0			; mask
		dd offset aEcho		; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 8			; bits
		dd 0			; mask
		dd offset aEchoe	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 10h			; bits
		dd 0			; mask
		dd offset aCrterase	; name
		dd local		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 10h			; bits
		dd 0			; mask
		dd offset aEchok	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 20h			; bits
		dd 0			; mask
		dd offset aEchonl	; name
		dd local		; type
		db 6			; flags
		db 3 dup(0)
		dd 40h			; bits
		dd 0			; mask
		dd offset aNoflsh	; name
		dd local		; type
		db 6			; flags
		db 3 dup(0)
		dd 80h			; bits
		dd 0			; mask
		dd offset aXcase	; name
		dd local		; type
		db 6			; flags
		db 3 dup(0)
		dd 4			; bits
		dd 0			; mask
		dd offset aTostop	; name
		dd local		; type
		db 6			; flags
		db 3 dup(0)
		dd 100h			; bits
		dd 0			; mask
		dd offset aEchoprt	; name
		dd local		; type
		db 6			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 0			; mask
		dd offset aPrterase	; name
		dd local		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 400h			; bits
		dd 0			; mask
		dd offset aEchoctl	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 200h			; bits
		dd 0			; mask
		dd offset aCtlecho	; name
		dd local		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 200h			; bits
		dd 0			; mask
		dd offset aEchoke	; name
		dd local		; type
		db 5			; flags
		db 3 dup(0)
		dd 800h			; bits
		dd 0			; mask
		dd offset aCrtkill	; name
		dd local		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 800h			; bits
		dd 0			; mask
		dd offset aEvenp	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aParity	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aOddp		; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aNl		; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aEk		; name
		dd combination		; type
		db 8			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aSane		; name
		dd combination		; type
		db 8			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aCooked	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aRaw		; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aPass8	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aLitout	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aCbreak	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aDecctlq	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aTabs		; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aLcase	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aLcase_0	; name
		dd combination		; type
		db 0Ch			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aCrt		; name
		dd combination		; type
		db 8			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd offset aDec		; name
		dd combination		; type
		db 8			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
		dd 0			; name
		dd control		; type
		db 0			; flags
		db 3 dup(0)
		dd 0			; bits
		dd 0			; mask
aIntr		db 'intr',0             ; DATA XREF: .rodata:control_info_0o
aQuit		db 'quit',0             ; DATA XREF: .rodata:control_info_0o
aErase		db 'erase',0            ; DATA XREF: .rodata:control_info_0o
aKill		db 'kill',0             ; DATA XREF: .rodata:control_info_0o
aEof		db 'eof',0              ; DATA XREF: .rodata:control_info_0o
aEol		db 'eol',0              ; DATA XREF: .rodata:control_info_0o
aEol2		db 'eol2',0             ; DATA XREF: .rodata:control_info_0o
aSwtch		db 'swtch',0            ; DATA XREF: .rodata:control_info_0o
aStart		db 'start',0            ; DATA XREF: .rodata:control_info_0o
aStop		db 'stop',0             ; DATA XREF: .rodata:control_info_0o
aSusp		db 'susp',0             ; DATA XREF: .rodata:control_info_0o
aRprnt		db 'rprnt',0            ; DATA XREF: .rodata:control_info_0o
aWerase		db 'werase',0           ; DATA XREF: .rodata:control_info_0o
aLnext		db 'lnext',0            ; DATA XREF: .rodata:control_info_0o
aFlush		db 'flush',0            ; DATA XREF: .rodata:control_info_0o
; char aMin[]
aMin		db 'min',0              ; DATA XREF: set_control_char+Eo
					; display_changed+104o	...
; char aTime[]
aTime		db 'time',0             ; DATA XREF: set_control_char+28o
					; .rodata:control_info_0o
		align 20h
; const	control_info control_info_0[18]
control_info_0	dd offset aIntr		; name ; DATA XREF: main+5CBo
					; main+668o ...
		db 3			; saneval ; "intr"
		db 3 dup(0)
		dd 0			; offset
		dd offset aQuit		; name
		db 1Ch			; saneval
		db 3 dup(0)
		dd 1			; offset
		dd offset aErase	; name
		db 7Fh			; saneval
		db 3 dup(0)
		dd 2			; offset
		dd offset aKill		; name
		db 15h			; saneval
		db 3 dup(0)
		dd 3			; offset
		dd offset aEof		; name
		db 4			; saneval
		db 3 dup(0)
		dd 4			; offset
		dd offset aEol		; name
		db 0			; saneval
		db 3 dup(0)
		dd 0Bh			; offset
		dd offset aEol2		; name
		db 0			; saneval
		db 3 dup(0)
		dd 10h			; offset
		dd offset aSwtch	; name
		db 0			; saneval
		db 3 dup(0)
		dd 7			; offset
		dd offset aStart	; name
		db 11h			; saneval
		db 3 dup(0)
		dd 8			; offset
		dd offset aStop		; name
		db 13h			; saneval
		db 3 dup(0)
		dd 9			; offset
		dd offset aSusp		; name
		db 1Ah			; saneval
		db 3 dup(0)
		dd 0Ah			; offset
		dd offset aRprnt	; name
		db 12h			; saneval
		db 3 dup(0)
		dd 0Ch			; offset
		dd offset aWerase	; name
		db 17h			; saneval
		db 3 dup(0)
		dd 0Eh			; offset
		dd offset aLnext	; name
		db 16h			; saneval
		db 3 dup(0)
		dd 0Fh			; offset
		dd offset aFlush	; name
		db 0Fh			; saneval
		db 3 dup(0)
		dd 0Dh			; offset
		dd offset aMin		; name
		db 1			; saneval
		db 3 dup(0)
		dd 6			; offset
		dd offset aTime		; name
		db 0			; saneval
		db 3 dup(0)
		dd 5			; offset
		dd 0			; name
		db 0			; saneval
		db 3 dup(0)
		dd 0			; offset
dword_8003758	dd 6C6C61h		; DATA XREF: .rodata:longoptso
aSave		db 'save',0             ; DATA XREF: .rodata:longoptso
aFile		db 'file',0             ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 10h
; const	option longopts[6]
longopts	option <offset dword_8003758, 0, 0, 61h> ; DATA	XREF: main+242o
		option <offset aSave, 0, 0, 67h> ; "save"
		option <offset aFile, 1, 0, 46h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSFDeviceF[]
aUsageSFDeviceF	db 'Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...',0Ah
					; DATA XREF: usage+54o
		db '  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]',0Ah
		db '  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]',0Ah,0
		align 10h
; char aPrintOrChangeT[]
aPrintOrChangeT	db 'Print or change terminal characteristics.',0Ah ; DATA XREF: usage+76o
		db 0Ah
		db '  -a, --all          print all current settings in human-readable'
		db ' form',0Ah
		db '  -g, --save         print all current settings in a stty-readabl'
		db 'e form',0Ah
		db '  -F, --file=DEVICE  open and use the specified DEVICE instead of'
		db ' stdin',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+99o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+BCo
		align 4
; char aOptionalBefore[]
aOptionalBefore	db 0Ah			; DATA XREF: usage+DFo
		db 'Optional - before SETTING indicates negation.  An * marks non-POS'
		db 'IX',0Ah
		db 'settings.  The underlying system defines which settings are avail'
		db 'able.',0Ah,0
		align 4
; char aSpecialCharact[]
aSpecialCharact	db 0Ah			; DATA XREF: usage+102o
		db 'Special characters:',0Ah
		db ' * dsusp CHAR    CHAR will send a terminal stop signal once input'
		db ' flushed',0Ah
		db '   eof CHAR      CHAR will send an end of file (terminate the inp'
		db 'ut)',0Ah
		db '   eol CHAR      CHAR will end the line',0Ah,0
		align 4
; char aEol2CharAltern[]
aEol2CharAltern	db ' * eol2 CHAR     alternate CHAR for ending the line',0Ah
					; DATA XREF: usage+125o
		db '   erase CHAR    CHAR will erase the last character typed',0Ah
		db '   intr CHAR     CHAR will send an interrupt signal',0Ah
		db '   kill CHAR     CHAR will erase the current line',0Ah,0
		align 4
; char aLnextCharCharW[]
aLnextCharCharW	db ' * lnext CHAR    CHAR will enter the next character quoted',0Ah
					; DATA XREF: usage+148o
		db '   quit CHAR     CHAR will send a quit signal',0Ah
		db ' * rprnt CHAR    CHAR will redraw the current line',0Ah
		db '   start CHAR    CHAR will restart the output after stopping it',0Ah
		db 0
		align 4
; char aStopCharCharWi[]
aStopCharCharWi	db '   stop CHAR     CHAR will stop the output',0Ah ; DATA XREF: usage+16Bo
		db '   susp CHAR     CHAR will send a terminal stop signal',0Ah
		db ' * swtch CHAR    CHAR will switch to a different shell layer',0Ah
		db ' * werase CHAR   CHAR will erase the last word typed',0Ah,0
		align 4
; char aSpecialSetting[]
aSpecialSetting	db 0Ah			; DATA XREF: usage+18Eo
		db 'Special settings:',0Ah
		db '   N             set the input and output speeds to N bauds',0Ah
		db ' * cols N        tell the kernel that the terminal has N columns',0Ah
		db ' * columns N     same as cols N',0Ah,0
		align 10h
; char aIspeedNSetTheI[]
aIspeedNSetTheI	db '   ispeed N      set the input speed to N',0Ah ; DATA XREF: usage+1B1o
		db ' * line N        use line discipline N',0Ah
		db '   min N         with -icanon, set N characters minimum for a com'
		db 'pleted read',0Ah
		db '   ospeed N      set the output speed to N',0Ah,0
		align 4
; char aRowsNTellTheKe[]
aRowsNTellTheKe	db ' * rows N        tell the kernel that the terminal has N rows',0Ah
					; DATA XREF: usage+1D4o
		db ' * size          print the number of rows and columns according t'
		db 'o the kernel',0Ah
		db '   speed         print the terminal speed',0Ah
		db '   time N        with -icanon, set read timeout of N tenths of a '
		db 'second',0Ah,0
		align 4
; char aControlSetting[]
aControlSetting	db 0Ah			; DATA XREF: usage+1F7o
		db 'Control settings:',0Ah
		db '   [-]clocal     disable modem control signals',0Ah
		db '   [-]cread      allow input to be received',0Ah
		db ' * [-]crtscts    enable RTS/CTS handshaking',0Ah
		db '   csN           set character size to N bits, N in [5..8]',0Ah,0
		align 4
; char aCstopbUseTwoSt[]
aCstopbUseTwoSt	db '   [-]cstopb     use two stop bits per character (one with `-',27h,')'
					; DATA XREF: usage+21Ao
		db 0Ah
		db '   [-]hup        send a hangup signal when the last process close'
		db 's the tty',0Ah
		db '   [-]hupcl      same as [-]hup',0Ah
		db '   [-]parenb     generate parity bit in output and expect parity '
		db 'bit in input',0Ah
		db '   [-]parodd     set odd parity (even with `-',27h,')',0Ah,0
		align 10h
; char aInputSettingsB[]
aInputSettingsB	db 0Ah			; DATA XREF: usage+23Do
		db 'Input settings:',0Ah
		db '   [-]brkint     breaks cause an interrupt signal',0Ah
		db '   [-]icrnl      translate carriage return to newline',0Ah
		db '   [-]ignbrk     ignore break characters',0Ah
		db '   [-]igncr      ignore carriage return',0Ah,0
		align 4
; char aIgnparIgnoreCh[]
aIgnparIgnoreCh	db '   [-]ignpar     ignore characters with parity errors',0Ah
					; DATA XREF: usage+260o
		db ' * [-]imaxbel    beep and do not flush a full input buffer on a c'
		db 'haracter',0Ah
		db '   [-]inlcr      translate newline to carriage return',0Ah
		db '   [-]inpck      enable input parity checking',0Ah
		db '   [-]istrip     clear high (8th) bit of input characters',0Ah,0
		align 4
; char aIutf8AssumeInp[]
aIutf8AssumeInp	db ' * [-]iutf8      assume input characters are UTF-8 encoded',0Ah,0
					; DATA XREF: usage+283o
; char aIuclcTranslate[]
aIuclcTranslate	db ' * [-]iuclc      translate uppercase characters to lowercase',0Ah
					; DATA XREF: usage+2A6o
		db ' * [-]ixany      let any character restart output, not only start'
		db ' character',0Ah
		db '   [-]ixoff      enable sending of start/stop characters',0Ah
		db '   [-]ixon       enable XON/XOFF flow control',0Ah
		db '   [-]parmrk     mark parity errors (with a 255-0-character seque'
		db 'nce)',0Ah
		db '   [-]tandem     same as [-]ixoff',0Ah,0
		align 4
; char aOutputSettings[]
aOutputSettings	db 0Ah			; DATA XREF: usage+2C9o
		db 'Output settings:',0Ah
		db ' * bsN           backspace delay style, N in [0..1]',0Ah
		db ' * crN           carriage return delay style, N in [0..3]',0Ah
		db ' * ffN           form feed delay style, N in [0..1]',0Ah
		db ' * nlN           newline delay style, N in [0..1]',0Ah,0
		align 4
; char aOcrnlTranslate[]
aOcrnlTranslate	db ' * [-]ocrnl      translate carriage return to newline',0Ah
					; DATA XREF: usage+2ECo
		db ' * [-]ofdel      use delete characters for fill instead of null c'
		db 'haracters',0Ah
		db ' * [-]ofill      use fill (padding) characters instead of timing '
		db 'for delays',0Ah
		db ' * [-]olcuc      translate lowercase characters to uppercase',0Ah
		db ' * [-]onlcr      translate newline to carriage return-newline',0Ah
		db ' * [-]onlret     newline performs a carriage return',0Ah,0
		align 4
; char aOnocrDoNotPrin[]
aOnocrDoNotPrin	db ' * [-]onocr      do not print carriage returns in the first colum'
					; DATA XREF: usage+30Fo
		db 'n',0Ah
		db '   [-]opost      postprocess output',0Ah
		db ' * tabN          horizontal tab delay style, N in [0..3]',0Ah
		db ' * tabs          same as tab0',0Ah
		db ' * -tabs         same as tab3',0Ah
		db ' * vtN           vertical tab delay style, N in [0..1]',0Ah,0
; char aLocalSettingsC[]
aLocalSettingsC	db 0Ah			; DATA XREF: usage+332o
		db 'Local settings:',0Ah
		db '   [-]crterase   echo erase characters as backspace-space-backspa'
		db 'ce',0Ah
		db ' * crtkill       kill all line by obeying the echoprt and echoe s'
		db 'ettings',0Ah
		db ' * -crtkill      kill all line by obeying the echoctl and echok s'
		db 'ettings',0Ah,0
; char aCtlechoEchoCon[]
aCtlechoEchoCon	db ' * [-]ctlecho    echo control characters in hat notation (`^c',27h,')'
					; DATA XREF: usage+355o
		db 0Ah
		db '   [-]echo       echo input characters',0Ah
		db ' * [-]echoctl    same as [-]ctlecho',0Ah
		db '   [-]echoe      same as [-]crterase',0Ah
		db '   [-]echok      echo a newline after a kill character',0Ah,0
; char aEchokeSameAsCr[]
aEchokeSameAsCr	db ' * [-]echoke     same as [-]crtkill',0Ah ; DATA XREF: usage+378o
		db '   [-]echonl     echo newline even if not echoing other character'
		db 's',0Ah
		db ' * [-]echoprt    echo erased characters backward, between `\',27h,' '
		db 'and ',27h,'/',27h,0Ah
		db '   [-]icanon     enable erase, kill, werase, and rprnt special ch'
		db 'aracters',0Ah
		db '   [-]iexten     enable non-POSIX special characters',0Ah,0
		align 10h
; char aIsigEnableInte[]
aIsigEnableInte	db '   [-]isig       enable interrupt, quit, and suspend special char'
					; DATA XREF: usage+39Bo
		db 'acters',0Ah
		db '   [-]noflsh     disable flushing after interrupt and quit specia'
		db 'l characters',0Ah
		db ' * [-]prterase   same as [-]echoprt',0Ah
		db ' * [-]tostop     stop background jobs that try to write to the te'
		db 'rminal',0Ah
		db ' * [-]xcase      with icanon, escape with `\',27h,' for uppercase ch'
		db 'aracters',0Ah,0
		align 4
; char aCombinationSet[]
aCombinationSet	db 0Ah			; DATA XREF: usage+3BEo
		db 'Combination settings:',0Ah
		db ' * [-]LCASE      same as [-]lcase',0Ah
		db '   cbreak        same as -icanon',0Ah
		db '   -cbreak       same as icanon',0Ah,0
		align 4
; char aCookedSameAsBr[]
aCookedSameAsBr	db '   cooked        same as brkint ignpar istrip icrnl ixon opost is'
					; DATA XREF: usage+3E1o
		db 'ig',0Ah
		db '                 icanon, eof and eol characters to their default '
		db 'values',0Ah
		db '   -cooked       same as raw',0Ah
		db '   crt           same as echoe echoctl echoke',0Ah,0
; char aDecSameAsEchoe[]
aDecSameAsEchoe	db '   dec           same as echoe echoctl echoke -ixany intr ^c eras'
					; DATA XREF: usage+404o
		db 'e 0177',0Ah
		db '                 kill ^u',0Ah
		db ' * [-]decctlq    same as [-]ixany',0Ah
		db '   ek            erase and kill characters to their default value'
		db 's',0Ah
		db '   evenp         same as parenb -parodd cs7',0Ah,0
		align 4
; char aEvenpSameAsPar[]
aEvenpSameAsPar	db '   -evenp        same as -parenb cs8',0Ah ; DATA XREF: usage+427o
		db ' * [-]lcase      same as xcase iuclc olcuc',0Ah
		db '   litout        same as -parenb -istrip -opost cs8',0Ah
		db '   -litout       same as parenb istrip opost cs7',0Ah
		db '   nl            same as -icrnl -onlcr',0Ah
		db '   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret'
		db 0Ah,0
		align 4
; char aOddpSameAsPare[]
aOddpSameAsPare	db '   oddp          same as parenb parodd cs7',0Ah ; DATA XREF: usage+44Ao
		db '   -oddp         same as -parenb cs8',0Ah
		db '   [-]parity     same as [-]evenp',0Ah
		db '   pass8         same as -parenb -istrip cs8',0Ah
		db '   -pass8        same as parenb istrip cs7',0Ah,0
		align 10h
; char aRawSameAsIgnbr[]
aRawSameAsIgnbr	db '   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -'
					; DATA XREF: usage+46Do
		db 'istrip',0Ah
		db '                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ix'
		db 'any',0Ah
		db '                 -imaxbel -opost -isig -icanon -xcase min 1 time '
		db '0',0Ah
		db '   -raw          same as cooked',0Ah,0
		align 4
; char aSaneSameAsCrea[]
aSaneSameAsCrea	db '   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl'
					; DATA XREF: usage+490o
		db ' -iutf8',0Ah
		db '                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl'
		db ' onlcr',0Ah
		db '                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt'
		db '0 ff0',0Ah
		db '                 isig icanon iexten echo echoe echok -echonl -nof'
		db 'lsh',0Ah
		db '                 -xcase -tostop -echoprt echoctl echoke, all spec'
		db 'ial',0Ah
		db '                 characters to their default values',0Ah,0
		align 4
; char aHandleTheTtyLi[]
aHandleTheTtyLi	db 0Ah			; DATA XREF: usage+4B3o
		db 'Handle the tty line connected to standard input.  Without argumen'
		db 'ts,',0Ah
		db 'prints baud rate, line discipline, and deviations from stty sane.'
		db '  In',0Ah
		db 'settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 '
		db 'or',0Ah
		db '127; special values ^- or undef used to disable special character'
		db 's.',0Ah,0
; char locale
locale		db 0			; DATA XREF: main+7Do
					; screen_columns+54o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+8Fo
		align 4
; char aOnlyOneDeviceM[]
aOnlyOneDeviceM	db 'only one device may be specified',0 ; DATA XREF: main+156o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+19Ao
aStty		db 'stty',0             ; DATA XREF: main+1A5o
; char shortopts[]
shortopts	db '-agF:',0            ; DATA XREF: main+247o
; char aTheOptionsForV[]
aTheOptionsForV	db 'the options for verbose and stty-readable output styles are',0Ah
					; DATA XREF: main+27Eo
		db 'mutually exclusive',0
		align 4
; char aWhenSpecifying[]
aWhenSpecifying	db 'when specifying an output style, modes may not be set',0
					; DATA XREF: main+2BEo
; char format[]
format		db '%s',0               ; DATA XREF: main+31Co main+3CFo ...
		align 4
; char aSCouldnTResetN[]
aSCouldnTResetN	db '%s: couldn',27h,'t reset non-blocking mode',0 ; DATA XREF: main+36Ao
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: main+397o
; char aInvalidArgumen[]
aInvalidArgumen	db 'invalid argument %s',0 ; DATA XREF: main+576o main+B8Do
; char aMissingArgumen[]
aMissingArgumen	db 'missing argument to %s',0 ; DATA XREF: main+60Fo main+703o ...
; char aIspeed[]
aIspeed		db 'ispeed',0           ; DATA XREF: main+6C5o
; char aOspeed[]
aOspeed		db 'ospeed',0           ; DATA XREF: main+771o
; char aRows[]
aRows		db 'rows',0             ; DATA XREF: main+81Do
; char aCols[]
aCols		db 'cols',0             ; DATA XREF: main+8CBo
; char aColumns_0[]
aColumns_0	db 'columns',0          ; DATA XREF: main+8E5o
; char aSize[]
aSize		db 'size',0             ; DATA XREF: main+993o
; char aLine[]
aLine		db 'line',0             ; DATA XREF: main+9D9o
; char aInvalidLineDis[]
aInvalidLineDis	db 'invalid line discipline %s',0 ; DATA XREF: main+AB4o
; char aSpeed[]
aSpeed		db 'speed',0            ; DATA XREF: main+ADEo
		align 10h
; char aSUnableToPerfo[]
aSUnableToPerfo	db '%s: unable to perform all requested operations',0 ; DATA XREF: main+CA7o
; char asc_800575F[]
asc_800575F	db '^-',0               ; DATA XREF: set_control_char+8Fo
; char aUndef[]
aUndef		db 'undef',0            ; DATA XREF: set_control_char+A6o
; char aSNoSizeInforma[]
aSNoSizeInforma	db '%s: no size information for this device',0
					; DATA XREF: display_window_size+66o
; char message[]
message		db 'rows %d; columns %d;',0 ; DATA XREF: display_window_size+99o
aDD		db '%d %d',0Ah,0        ; DATA XREF: display_window_size:loc_8001CF1o
; char name[]
name		db 'COLUMNS',0          ; DATA XREF: screen_columns+3Bo
off_80057B4	dd offset loc_8001DDC	; DATA XREF: mode_type_flag+12o
		dd offset loc_8001DE4	; jump table for switch	statement
		dd offset loc_8001DE9
		dd offset loc_8001DF1
		dd offset loc_8001DF9
; char aLineD[]
aLineD		db 'line = %d;',0       ; DATA XREF: display_changed+2Bo
					; display_all+3Bo
; char aSS[]
aSS		db '%s = %s;',0         ; DATA XREF: display_changed+DAo
					; display_all+ACo
; char aMinLuTimeLu[]
aMinLuTimeLu	db 'min = %lu; time = %lu;',0Ah,0 ; DATA XREF: display_changed+140o
; char aS_0[]
aS_0		db '-%s',0              ; DATA XREF: display_changed+309o
					; display_all+28Co
; char aMinLuTimeLu_0[]
aMinLuTimeLu_0	db 'min = %lu; time = %lu;',0 ; DATA XREF: display_all+FEo
; char aSpeedLuBaud[]
aSpeedLuBaud	db 'speed %lu baud;',0  ; DATA XREF: display_speed+63o
aLu		db '%lu',0Ah,0          ; DATA XREF: display_speed:loc_80024F8o
; char aIspeedLuBaudOs[]
aIspeedLuBaudOs	db 'ispeed %lu baud; ospeed %lu baud;',0 ; DATA XREF: display_speed+BCo
aLuLu		db '%lu %lu',0Ah,0      ; DATA XREF: display_speed:loc_8002551o
; char aLxLxLxLx[]
aLxLxLxLx	db '%lx:%lx:%lx:%lx',0  ; DATA XREF: display_recoverable+25o
; char aLx[]
aLx		db ':%lx',0             ; DATA XREF: display_recoverable+50o
a0		db '0',0                ; DATA XREF: .rodata:speedso
a50		db '50',0               ; DATA XREF: .rodata:speedso
a75		db '75',0               ; DATA XREF: .rodata:speedso
a110		db '110',0              ; DATA XREF: .rodata:speedso
a134		db '134',0              ; DATA XREF: .rodata:speedso
a134_5		db '134.5',0            ; DATA XREF: .rodata:speedso
a150		db '150',0              ; DATA XREF: .rodata:speedso
a200		db '200',0              ; DATA XREF: .rodata:speedso
a300		db '300',0              ; DATA XREF: .rodata:speedso
a600		db '600',0              ; DATA XREF: .rodata:speedso
a1200		db '1200',0             ; DATA XREF: .rodata:speedso
a1800		db '1800',0             ; DATA XREF: .rodata:speedso
a2400		db '2400',0             ; DATA XREF: .rodata:speedso
a4800		db '4800',0             ; DATA XREF: .rodata:speedso
a9600		db '9600',0             ; DATA XREF: .rodata:speedso
a19200		db '19200',0            ; DATA XREF: .rodata:speedso
a38400		db '38400',0            ; DATA XREF: .rodata:speedso
aExta		db 'exta',0             ; DATA XREF: .rodata:speedso
aExtb		db 'extb',0             ; DATA XREF: .rodata:speedso
a57600		db '57600',0            ; DATA XREF: .rodata:speedso
a115200		db '115200',0           ; DATA XREF: .rodata:speedso
a230400		db '230400',0           ; DATA XREF: .rodata:speedso
a460800		db '460800',0           ; DATA XREF: .rodata:speedso
a500000		db '500000',0           ; DATA XREF: .rodata:speedso
a576000		db '576000',0           ; DATA XREF: .rodata:speedso
a921600		db '921600',0           ; DATA XREF: .rodata:speedso
a1000000	db '1000000',0          ; DATA XREF: .rodata:speedso
a1152000	db '1152000',0          ; DATA XREF: .rodata:speedso
a1500000	db '1500000',0          ; DATA XREF: .rodata:speedso
a2000000	db '2000000',0          ; DATA XREF: .rodata:speedso
a2500000	db '2500000',0          ; DATA XREF: .rodata:speedso
a3000000	db '3000000',0          ; DATA XREF: .rodata:speedso
a3500000	db '3500000',0          ; DATA XREF: .rodata:speedso
a4000000	db '4000000',0          ; DATA XREF: .rodata:speedso
		align 20h
; const	speed_map speeds[35]
speeds		speed_map <offset a0, 0, 0> ; DATA XREF: string_to_baud+1Bo
					; string_to_baud+5Ao ...
		speed_map <offset a50, 1, 32h> ; "0"
		speed_map <offset a75, 2, 4Bh>
		speed_map <offset a110,	3, 6Eh>
		speed_map <offset a134,	4, 86h>
		speed_map <offset a134_5, 4, 86h>
		speed_map <offset a150,	5, 96h>
		speed_map <offset a200,	6, 0C8h>
		speed_map <offset a300,	7, 12Ch>
		speed_map <offset a600,	8, 258h>
		speed_map <offset a1200, 9, 4B0h>
		speed_map <offset a1800, 0Ah, 708h>
		speed_map <offset a2400, 0Bh, 960h>
		speed_map <offset a4800, 0Ch, 12C0h>
		speed_map <offset a9600, 0Dh, 2580h>
		speed_map <offset a19200, 0Eh, 4B00h>
		speed_map <offset a38400, 0Fh, 9600h>
		speed_map <offset aExta, 0Eh, 4B00h>
		speed_map <offset aExtb, 0Fh, 9600h>
		speed_map <offset a57600, 1001h, 0E100h>
		speed_map <offset a115200, 1002h, 1C200h>
		speed_map <offset a230400, 1003h, 38400h>
		speed_map <offset a460800, 1004h, 70800h>
		speed_map <offset a500000, 1005h, 7A120h>
		speed_map <offset a576000, 1006h, 8CA00h>
		speed_map <offset a921600, 1007h, 0E1000h>
		speed_map <offset a1000000, 1008h, 0F4240h>
		speed_map <offset a1152000, 1009h, 119400h>
		speed_map <offset a1500000, 100Ah, 16E360h>
		speed_map <offset a2000000, 100Bh, 1E8480h>
		speed_map <offset a2500000, 100Ch, 2625A0h>
		speed_map <offset a3000000, 100Dh, 2DC6C0h>
		speed_map <offset a3500000, 100Eh, 3567E0h>
		speed_map <offset a4000000, 100Fh, 3D0900h>
		speed_map  <0>
aUndef_0	db '<undef>',0          ; DATA XREF: visible+19o
aBb		db 'bB',0               ; DATA XREF: integer_arg+1Bo
; char aInvalidInteger[]
aInvalidInteger	db 'invalid integer argument %s',0 ; DATA XREF: integer_arg+52o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8005B0Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_8002BCD-80086F9h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset locret_8002BCD-8008707h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset locret_8002BCD-800860Fh
		dd 0DAh, 80E4100h, 0D420285h, 0C5D60205h, 4040Ch, 1Ch
		dd 80h
		dd offset locret_8002BCD-8008555h
		dd 4DDh, 80E4100h, 0D420285h, 3874605h,	5830486h, 2Ch
		dd 0A0h
		dd offset locret_8002BCD-8008098h
		dd 0CD1h, 10C4400h, 5104700h, 46007502h, 7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h, 1Ch,	0D0h
		dd offset locret_8002BCD-80073F7h
		dd 61Eh, 80E4100h, 0D420285h, 61A0305h,	4040CC5h, 1Ch
		dd 0F0h
		dd offset locret_8002BCD-8006DF9h
		dd 13Eh, 80E4100h, 0D420285h, 13A0305h,	4040CC5h, 1Ch
		dd 110h
		dd offset locret_8002BCD-8006CDBh
		dd 54h,	80E4100h, 0D420285h, 0C5500205h, 4040Ch, 1Ch, 130h
		dd offset locret_8002BCD-8006CA7h
		dd 24h,	80E4100h, 0D420285h, 0CC56005h,	404h, 1Ch, 150h
		dd offset locret_8002BCD-8006CA3h
		dd 0C7h, 80E4100h, 0D420285h, 0C5C30205h, 4040Ch, 1Ch
		dd 170h
		dd offset locret_8002BCD-8006BFCh
		dd 0DCh, 80E4100h, 0D420285h, 0C5D80205h, 4040Ch, 1Ch
		dd 190h
		dd offset locret_8002BCD-8006B40h
		dd 94h,	80E4100h, 0D420285h, 0C5900205h, 4040Ch, 1Ch, 1B0h
		dd offset locret_8002BCD-8006ACCh
		dd 46h,	80E4100h, 0D420285h, 0C5420205h, 4040Ch, 1Ch, 1D0h
		dd offset locret_8002BCD-8006AA6h
		dd 4Fh,	80E4100h, 0D420285h, 0C54B0205h, 4040Ch, 1Ch, 1F0h
		dd offset locret_8002BCD-8006A77h
		dd 362h, 80E4100h, 0D420285h, 35E0305h,	4040CC5h, 1Ch
		dd 210h
		dd offset locret_8002BCD-8006735h
		dd 2D6h, 80E4100h, 0D420285h, 2D20305h,	4040CC5h, 20h
		dd 230h
		dd offset locret_8002BCD-800647Fh
		dd 0F1h, 80E4100h, 0D420285h, 3834405h,	0C3C5E902h, 4040Ch
		dd 20h,	254h
		dd offset locret_8002BCD-80063B2h
		dd 7Ah,	80E4100h, 0D420285h, 3834405h, 0C3C57202h, 4040Ch
		dd 1Ch,	278h
		dd offset locret_8002BCD-800635Ch
		dd 66h,	80E4100h, 0D420285h, 0C5620205h, 4040Ch, 1Ch, 298h
		dd offset locret_8002BCD-8006316h
		dd 73h,	80E4100h, 0D420285h, 0C56F0205h, 4040Ch, 1Ch, 2B8h
		dd offset locret_8002BCD-80062C3h
		dd 10Fh, 80E4100h, 0D420285h, 10B0305h,	4040CC5h, 1Ch
		dd 2D8h
		dd offset locret_8002BCD-80061D4h
		dd 6Ch,	80E4100h, 0D420285h, 0C5680205h, 4040Ch, 1Ch, 2F8h
		dd offset locret_8002BCD-8006188h
		dd 5Eh,	80E4100h, 0D420285h, 0C55A0205h, 4040Ch, 1Ch, 318h
		dd offset locret_8002BCD-800614Ah
		dd 18Ch, 80E4100h, 0D420285h, 1880305h,	4040CC5h, 1Ch
		dd 338h
		dd offset locret_8002BCD-8005FDEh
		dd 107h, 80E4100h, 0D420285h, 1030305h,	4040CC5h, 20h
		dd 358h
		dd offset locret_8002BCD-8005EF7h
		dd 90h,	80E4100h, 0D420285h, 3834405h, 0C3C58802h, 4040Ch
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; wrapf:loc_80001BFr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; wrapf+9Fp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+84p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn rpl_vasprintf:near ; CODE	XREF: wrapf+2Bp
		extrn xalloc_die:near	; CODE XREF: wrapf+3Cp
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: wrapf+63p wrapf+7Cp ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: wrapf+AEp
		extrn __stack_chk_fail:near ; CODE XREF: wrapf+D3p
					; set_window_size+C0p ...
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+4D8p main+1B8p ...
		extrn set_program_name:near ; CODE XREF: main+72p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+99p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+A9p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+B4o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+B9p
; int opterr
		extrn opterr:dword	; DATA XREF: main+D9w
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+16Bp	main+293p ...
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000858r
		extrn Version:dword	; DATA XREF: main:loc_800086Fr
		extrn version_etc:near	; CODE XREF: main+1ABp
; int optind
		extrn optind:dword	; DATA XREF: main+1DAw
					; main:loc_80008F8r
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+24Ep
		extrn fd_reopen:near	; CODE XREF: main+303p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: main+30Fp main+379p ...
		extrn rpl_fcntl:near	; CODE XREF: main+333p	main+35Bp
; int tcgetattr(int fd,	struct termios *termios_p)
		extrn tcgetattr:near	; CODE XREF: main+3B6p	main+C2Fp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+4D3p	main+5DCp ...
		extrn quote:near	; CODE XREF: main+569p	main+602p ...
; int tcsetattr(int fd,	int optional_actions, const struct termios *termios_p)
		extrn tcsetattr:near	; CODE XREF: main+BFDp
; int memcmp(const void	*s1, const void	*s2, size_t n)
		extrn memcmp:near	; CODE XREF: main+C68p	main+C98p
; int cfsetispeed(struct termios *termios_p, speed_t speed)
		extrn cfsetispeed:near	; CODE XREF: set_speed+2Cp
; int cfsetospeed(struct termios *termios_p, speed_t speed)
		extrn cfsetospeed:near	; CODE XREF: set_speed+49p
; int ioctl(int	fd, unsigned __int32 request, ...)
		extrn ioctl:near	; CODE XREF: get_win_size+14p
					; set_window_size+8Dp
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: set_window_size+5Dp
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: screen_columns+40p
		extrn xstrtol:near	; CODE XREF: screen_columns+64p
; void abort(void)
		extrn abort:near	; CODE XREF: mode_type_flag:loc_8001E00p
; speed_t cfgetispeed(const struct termios *termios_p)
		extrn cfgetispeed:near	; CODE XREF: display_speed+13p
					; display_speed+25p ...
; speed_t cfgetospeed(const struct termios *termios_p)
		extrn cfgetospeed:near	; CODE XREF: display_speed+35p
					; display_speed+47p ...
; unsigned __int32 strtoul(const char *nptr, char **endptr, int	base)
		extrn strtoul:near	; CODE XREF: strtoul_tcflag_t+23p
					; strtoul_cc_t+23p
		extrn xstrtoul:near	; CODE XREF: integer_arg+2Bp


		end
