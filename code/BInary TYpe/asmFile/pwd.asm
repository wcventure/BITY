;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4882664FB66E0B344AB59B9AFC2D8185
; Input	CRC32 :	6DC9FA1B

; File Name   :	D:\coreutils-o\pwd.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'pwd.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	dot_or_dotdot(const char *file_name)
dot_or_dotdot	proc near		; CODE XREF: readdir_ignoring_dot_and_dotdot+27p

sep		= byte ptr -1
file_name	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+file_name]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8000051
		mov	eax, [ebp+file_name]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8000024
		mov	edx, 2
		jmp	short loc_8000029
; ---------------------------------------------------------------------------

loc_8000024:				; CODE XREF: dot_or_dotdot+1Bj
		mov	edx, 1

loc_8000029:				; CODE XREF: dot_or_dotdot+22j
		mov	eax, [ebp+file_name]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+sep], al
		cmp	[ebp+sep], 0
		jz	short loc_8000040
		cmp	[ebp+sep], 2Fh
		jnz	short loc_8000047

loc_8000040:				; CODE XREF: dot_or_dotdot+38j
		mov	eax, 1
		jmp	short loc_800004C
; ---------------------------------------------------------------------------

loc_8000047:				; CODE XREF: dot_or_dotdot+3Ej
		mov	eax, 0

loc_800004C:				; CODE XREF: dot_or_dotdot+45j
		and	eax, 1
		jmp	short locret_8000056
; ---------------------------------------------------------------------------

loc_8000051:				; CODE XREF: dot_or_dotdot+Ej
		mov	eax, 0

locret_8000056:				; CODE XREF: dot_or_dotdot+4Fj
		leave
		retn
dot_or_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	dirent *__cdecl	readdir_ignoring_dot_and_dotdot(DIR *dirp)
readdir_ignoring_dot_and_dotdot	proc near ; CODE XREF: find_dir_entry+21Bp

dp		= dword	ptr -0Ch
dirp		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h

loc_800005E:				; CODE XREF: readdir_ignoring_dot_and_dotdot+34j
		sub	esp, 0Ch
		push	[ebp+dirp]
		call	readdir64
		add	esp, 10h
		mov	[ebp+dp], eax
		cmp	[ebp+dp], 0
		jz	short loc_800008E
		mov	eax, [ebp+dp]
		add	eax, 13h
		sub	esp, 0Ch
		push	eax		; file_name
		call	dot_or_dotdot
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_800005E

loc_800008E:				; CODE XREF: readdir_ignoring_dot_and_dotdot+1Bj
		mov	eax, [ebp+dp]
		leave
		retn
readdir_ignoring_dot_and_dotdot	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+10Dp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000179
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000179
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000179:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+E0p main+11Dp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80001EC
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002C1
; ---------------------------------------------------------------------------

loc_80001EC:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintTheFullFi ; "Print	the full filename of the current "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLLogicalUsePwd ; "  -L,	--logical   use	PWD from environm"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aNoteYourShellM ; "\nNOTE: your shell may have its own ver"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aPwd	; "pwd"
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_80002C1:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl file_name_free(file_name	*p)
file_name_free	proc near		; CODE XREF: main+1D7p

p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+p]		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
file_name_free	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; file_name *file_name_init()
file_name_init	proc near		; CODE XREF: main:loc_8000D73p

p		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	dword ptr [eax+4], 2000h
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	[eax], edx
		mov	eax, [ebp+p]
		mov	edx, [eax]
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		sub	eax, 1
		add	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	byte ptr [eax],	0
		mov	eax, [ebp+p]
		leave
		retn
file_name_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl file_name_prepend(file_name *p, const char *s, size_t s_len)
file_name_prepend proc near		; CODE XREF: find_dir_entry+35Ap
					; robust_getcwd+146p

n_free		= dword	ptr -18h
half		= dword	ptr -14h
q		= dword	ptr -10h
n_used		= dword	ptr -0Ch
p		= dword	ptr  8
s		= dword	ptr  0Ch
s_len		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	edx, eax
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n_free], eax
		mov	eax, [ebp+s_len]
		add	eax, 1
		cmp	eax, [ebp+n_free]
		jbe	loc_8000404
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s_len]
		add	eax, edx
		add	eax, 1
		mov	[ebp+half], eax
		sub	esp, 8
		push	[ebp+half]
		push	2
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+q], eax
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		sub	eax, [ebp+n_free]
		mov	[ebp+n_used], eax
		mov	eax, [ebp+half]
		add	eax, eax
		sub	eax, [ebp+n_used]
		mov	edx, eax
		mov	eax, [ebp+q]
		add	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	edx, [eax]
		mov	eax, [ebp+n_free]
		add	edx, eax
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 4
		push	[ebp+n_used]	; n
		push	edx		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+p]
		mov	edx, [ebp+q]
		mov	[eax], edx
		mov	eax, [ebp+half]
		lea	edx, [eax+eax]
		mov	eax, [ebp+p]
		mov	[eax+4], edx

loc_8000404:				; CODE XREF: file_name_prepend+23j
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	edx, [ebp+s_len]
		not	edx
		add	edx, eax
		mov	eax, [ebp+p]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	byte ptr [eax],	2Fh
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		add	eax, 1
		sub	esp, 4
		push	[ebp+s_len]	; n
		push	[ebp+s]		; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		nop
		leave
		retn
file_name_prepend endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	nth_parent(size_t n)
nth_parent	proc near		; CODE XREF: find_dir_entry+4Ep
					; find_dir_entry+E6p ...

p		= dword	ptr -14h
i		= dword	ptr -10h
buf		= dword	ptr -0Ch
n		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	[ebp+n]
		push	3
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		mov	eax, [ebp+buf]
		mov	[ebp+p], eax
		mov	[ebp+i], 0
		jmp	short loc_8000483
; ---------------------------------------------------------------------------

loc_8000466:				; CODE XREF: nth_parent+4Bj
		sub	esp, 4
		push	3		; n
		push	offset a__	; "../"
		push	[ebp+p]		; dest
		call	memcpy
		add	esp, 10h
		add	[ebp+p], 3
		add	[ebp+i], 1

loc_8000483:				; CODE XREF: nth_parent+26j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n]
		jb	short loc_8000466
		mov	eax, [ebp+p]
		sub	eax, 1
		mov	byte ptr [eax],	0
		mov	eax, [ebp+buf]
		leave
		retn
nth_parent	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl find_dir_entry(stat *dot_sb, file_name *file_name, size_t parent_height)
find_dir_entry	proc near		; CODE XREF: robust_getcwd+11Bp

var_118		= dword	ptr -118h
var_114		= dword	ptr -114h
file_name	= dword	ptr -110h
dot_sb		= dword	ptr -10Ch
found		= byte ptr -0FAh
use_lstat	= byte ptr -0F9h
dirp		= dword	ptr -0F8h
fd		= dword	ptr -0F4h
dp		= dword	ptr -0F0h
e		= dword	ptr -0ECh
ino		= qword	ptr -0E8h
parent_sb	= stat ptr -0DCh
ent_sb		= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
parent_height	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 10Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+dot_sb], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+file_name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset path	; ".."
		call	opendir
		add	esp, 10h
		mov	[ebp+dirp], eax
		cmp	[ebp+dirp], 0
		jnz	short loc_800052C
		sub	esp, 0Ch
		push	[ebp+parent_height] ; n
		call	nth_parent
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	[ebp+var_118], eax
		sub	esp, 0Ch
		push	offset aCannotOpenDire ; "cannot open directory	%s"
		call	gettext
		add	esp, 10h
		mov	edi, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+var_118]
		push	edi		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800052C:				; CODE XREF: find_dir_entry+46j
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	dirfd
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0
		js	short loc_8000562
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	fchdir
		add	esp, 10h
		shr	eax, 1Fh
		jmp	short loc_8000575
; ---------------------------------------------------------------------------

loc_8000562:				; CODE XREF: find_dir_entry+B1j
		sub	esp, 0Ch
		push	offset path	; ".."
		call	chdir
		add	esp, 10h
		shr	eax, 1Fh

loc_8000575:				; CODE XREF: find_dir_entry+C7j
		test	al, al
		jz	short loc_80005C4
		sub	esp, 0Ch
		push	[ebp+parent_height] ; n
		call	nth_parent
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	[ebp+var_118], eax
		sub	esp, 0Ch
		push	offset aFailedToChdirT ; "failed to chdir to %s"
		call	gettext
		add	esp, 10h
		mov	edi, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+var_118]
		push	edi		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80005C4:				; CODE XREF: find_dir_entry+DEj
		cmp	[ebp+fd], 0
		js	short loc_80005EA
		sub	esp, 8
		lea	eax, [ebp+parent_sb]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		shr	eax, 1Fh
		jmp	short loc_8000604
; ---------------------------------------------------------------------------

loc_80005EA:				; CODE XREF: find_dir_entry+132j
		sub	esp, 8
		lea	eax, [ebp+parent_sb]
		push	eax
		push	offset a_	; "."
		call	stat64
		add	esp, 10h
		shr	eax, 1Fh

loc_8000604:				; CODE XREF: find_dir_entry+14Fj
		test	al, al
		jz	short loc_8000653
		sub	esp, 0Ch
		push	[ebp+parent_height] ; n
		call	nth_parent
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	[ebp+var_118], eax
		sub	esp, 0Ch
		push	offset aFailedToStatS ;	"failed	to stat	%s"
		call	gettext
		add	esp, 10h
		mov	edi, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+var_118]
		push	edi		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000653:				; CODE XREF: find_dir_entry+16Dj
		mov	eax, dword ptr [ebp+parent_sb.st_dev]
		mov	edx, dword ptr [ebp+parent_sb.st_dev+4]
		mov	[ebp+var_118], eax
		mov	[ebp+var_114], edx
		mov	eax, [ebp+dot_sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, [ebp+var_118]
		xor	ecx, eax
		mov	ebx, ecx
		mov	edi, [ebp+var_114]
		xor	edi, edx
		mov	esi, edi
		mov	eax, ebx
		or	eax, esi
		test	eax, eax
		setnz	al
		mov	[ebp+use_lstat], al
		mov	[ebp+found], 0

loc_80006A0:				; CODE XREF: find_dir_entry+329j
					; find_dir_entry+378j ...
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	readdir_ignoring_dot_and_dotdot
		add	esp, 10h
		mov	[ebp+dp], eax
		cmp	[ebp+dp], 0
		jnz	short loc_8000716
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8000804
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+e], eax
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		call	__errno_location
		mov	edx, eax
		mov	eax, [ebp+e]
		mov	[edx], eax
		mov	[ebp+dirp], 0
		jmp	loc_8000804
; ---------------------------------------------------------------------------

loc_8000716:				; CODE XREF: find_dir_entry+230j
		mov	eax, [ebp+dp]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+ino], eax
		mov	dword ptr [ebp+ino+4], edx
		mov	eax, dword ptr [ebp+ino+4]
		or	eax, dword ptr [ebp+ino]
		test	eax, eax
		jz	short loc_8000746
		cmp	[ebp+use_lstat], 0
		jz	short loc_8000779

loc_8000746:				; CODE XREF: find_dir_entry+2A2j
		mov	eax, [ebp+dp]
		lea	edx, [eax+13h]
		sub	esp, 8
		lea	eax, [ebp+ent_sb]
		push	eax
		push	edx
		call	lstat64
		add	esp, 10h
		test	eax, eax
		js	loc_8000810
		mov	eax, dword ptr [ebp+ent_sb.st_ino]
		mov	edx, dword ptr [ebp+ent_sb.st_ino+4]
		mov	dword ptr [ebp+ino], eax
		mov	dword ptr [ebp+ino+4], edx

loc_8000779:				; CODE XREF: find_dir_entry+2ABj
		mov	eax, [ebp+dot_sb]
		mov	edx, [eax+5Ch]
		mov	eax, [eax+58h]
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+ino+4]
		xor	eax, dword ptr [ebp+ino]
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8000816
		movzx	eax, [ebp+use_lstat]
		xor	eax, 1
		test	al, al
		jnz	short loc_80007C8
		mov	ecx, dword ptr [ebp+ent_sb.st_dev]
		mov	ebx, dword ptr [ebp+ent_sb.st_dev+4]
		mov	eax, [ebp+dot_sb]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	loc_80006A0

loc_80007C8:				; CODE XREF: find_dir_entry+30Cj
		mov	eax, [ebp+dp]
		add	eax, 13h
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+dp]
		add	eax, 13h
		sub	esp, 4
		push	edx		; s_len
		push	eax		; s
		push	[ebp+file_name]	; p
		call	file_name_prepend
		add	esp, 10h
		mov	[ebp+found], 1
		jmp	short loc_8000805
; ---------------------------------------------------------------------------

loc_8000804:				; CODE XREF: find_dir_entry+23Bj
					; find_dir_entry+278j
		nop

loc_8000805:				; CODE XREF: find_dir_entry+369j
		cmp	[ebp+dirp], 0
		jz	short loc_8000831
		jmp	short loc_800081C
; ---------------------------------------------------------------------------

loc_8000810:				; CODE XREF: find_dir_entry+2C8j
		nop
		jmp	loc_80006A0
; ---------------------------------------------------------------------------

loc_8000816:				; CODE XREF: find_dir_entry+2FEj
		nop
		jmp	loc_80006A0
; ---------------------------------------------------------------------------

loc_800081C:				; CODE XREF: find_dir_entry+375j
		sub	esp, 0Ch
		push	[ebp+dirp]	; dirp
		call	closedir
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000873

loc_8000831:				; CODE XREF: find_dir_entry+373j
		sub	esp, 0Ch
		push	[ebp+parent_height] ; n
		call	nth_parent
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aReadingDirecto ; "reading directory %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000873:				; CODE XREF: find_dir_entry+396j
		movzx	eax, [ebp+found]
		xor	eax, 1
		test	al, al
		jz	short loc_80008BB
		sub	esp, 0Ch
		push	[ebp+parent_height] ; n
		call	nth_parent
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCouldnTFindDir ; "couldn't find directory entry in %s wit"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008BB:				; CODE XREF: find_dir_entry+3E6j
		mov	eax, [ebp+dot_sb]
		mov	ebx, eax
		lea	eax, [ebp+parent_sb]
		mov	edx, 18h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_80008E8
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80008E8:				; CODE XREF: find_dir_entry+448j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
find_dir_entry	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl robust_getcwd(file_name *file_name)
robust_getcwd	proc near		; CODE XREF: main+1B7p

file_name	= dword	ptr -8Ch
height		= dword	ptr -84h
root_dev_ino	= dword	ptr -80h
dev_ino_buf	= dev_ino ptr -7Ch
dot_sb		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, [ebp+arg_0]
		mov	[ebp+file_name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+height], 1
		sub	esp, 0Ch
		lea	eax, [ebp+dev_ino_buf]
		push	eax
		call	get_root_dev_ino
		add	esp, 10h
		mov	[ebp+root_dev_ino], eax
		cmp	[ebp+root_dev_ino], 0
		jnz	short loc_8000969
		sub	esp, 0Ch
		push	offset asc_8001241 ; "/"
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToGetAtt ; "failed to get	attributes of %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000969:				; CODE XREF: robust_getcwd+3Fj
		sub	esp, 8
		lea	eax, [ebp+dot_sb]
		push	eax
		push	offset a_	; "."
		call	stat64
		add	esp, 10h
		test	eax, eax
		jns	short loc_80009B9
		sub	esp, 0Ch
		push	offset a_	; "."
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToStatS ;	"failed	to stat	%s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009B9:				; CODE XREF: robust_getcwd+8Fj
					; robust_getcwd+123j
		mov	ecx, dword ptr [ebp+dot_sb.st_ino]
		mov	ebx, dword ptr [ebp+dot_sb.st_ino+4]
		mov	eax, [ebp+root_dev_ino]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_80009EE
		mov	ecx, dword ptr [ebp+dot_sb.st_dev]
		mov	ebx, dword ptr [ebp+dot_sb.st_dev+4]
		mov	eax, [ebp+root_dev_ino]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8000A15

loc_80009EE:				; CODE XREF: robust_getcwd+E1j
		mov	eax, [ebp+height]
		lea	edx, [eax+1]
		mov	[ebp+height], edx
		sub	esp, 4
		push	eax		; parent_height
		push	[ebp+file_name]	; file_name
		lea	eax, [ebp+dot_sb]
		push	eax		; dot_sb
		call	find_dir_entry
		add	esp, 10h
		jmp	short loc_80009B9
; ---------------------------------------------------------------------------

loc_8000A15:				; CODE XREF: robust_getcwd+FCj
		nop
		mov	eax, [ebp+file_name]
		mov	eax, [eax+8]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000A3E
		sub	esp, 4
		push	0		; s_len
		push	offset locale	; s
		push	[ebp+file_name]	; p
		call	file_name_prepend
		add	esp, 10h

loc_8000A3E:				; CODE XREF: robust_getcwd+134j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8000A50
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000A50:				; CODE XREF: robust_getcwd+159j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
robust_getcwd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *logical_getcwd()
logical_getcwd	proc near		; CODE XREF: main+157p

p		= dword	ptr -0D4h
wd		= dword	ptr -0D0h
st1_0		= stat ptr -0CCh
st2_0		= stat ptr -6Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0D0h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset name	; "PWD"
		call	getenv
		add	esp, 10h
		mov	[ebp+wd], eax
		cmp	[ebp+wd], 0
		jz	short loc_8000A99
		mov	eax, [ebp+wd]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_8000AA3

loc_8000A99:				; CODE XREF: logical_getcwd+33j
		mov	eax, 0
		jmp	loc_8000BB2
; ---------------------------------------------------------------------------

loc_8000AA3:				; CODE XREF: logical_getcwd+40j
		mov	eax, [ebp+wd]
		mov	[ebp+p], eax
		jmp	short loc_8000B12
; ---------------------------------------------------------------------------

loc_8000AB1:				; CODE XREF: logical_getcwd+DEj
		mov	eax, [ebp+p]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000B01
		mov	eax, [ebp+p]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_8000B01
		mov	eax, [ebp+p]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_8000B0B
		mov	eax, [ebp+p]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000B01
		mov	eax, [ebp+p]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jnz	short loc_8000B0B

loc_8000B01:				; CODE XREF: logical_getcwd+68j
					; logical_getcwd+78j ...
		mov	eax, 0
		jmp	loc_8000BB2
; ---------------------------------------------------------------------------

loc_8000B0B:				; CODE XREF: logical_getcwd+88j
					; logical_getcwd+A8j
		add	[ebp+p], 1

loc_8000B12:				; CODE XREF: logical_getcwd+58j
		sub	esp, 8
		push	offset needle	; "/."
		push	[ebp+p]		; haystack
		call	strstr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	loc_8000AB1
		sub	esp, 8
		lea	eax, [ebp+st1_0]
		push	eax
		push	[ebp+wd]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000BAD
		sub	esp, 8
		lea	eax, [ebp+st2_0]
		push	eax
		push	offset a_	; "."
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000BAD
		mov	ecx, dword ptr [ebp+st1_0.st_ino]
		mov	ebx, dword ptr [ebp+st1_0.st_ino+4]
		mov	eax, dword ptr [ebp+st2_0.st_ino]
		mov	edx, dword ptr [ebp+st2_0.st_ino+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8000BAD
		mov	ecx, dword ptr [ebp+st1_0.st_dev]
		mov	ebx, dword ptr [ebp+st1_0.st_dev+4]
		mov	eax, dword ptr [ebp+st2_0.st_dev]
		mov	edx, dword ptr [ebp+st2_0.st_dev+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8000BAD
		mov	eax, [ebp+wd]
		jmp	short loc_8000BB2
; ---------------------------------------------------------------------------

loc_8000BAD:				; CODE XREF: logical_getcwd+FEj
					; logical_getcwd+116j ...
		mov	eax, 0

loc_8000BB2:				; CODE XREF: logical_getcwd+47j
					; logical_getcwd+AFj ...
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short loc_8000BC3
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000BC3:				; CODE XREF: logical_getcwd+165j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
logical_getcwd	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

logical		= byte ptr -15h
c		= dword	ptr -14h
wd		= dword	ptr -10h
file_name	= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		sub	esp, 0Ch
		push	offset aPosixly_correc ; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+logical], al
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h

loc_8000C4E:				; CODE XREF: main:loc_8000CECj
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "LP"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000CF1
		mov	eax, [ebp+c]
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8000CA5
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_8000C8D
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_8000CAF
		jmp	short loc_8000CE2
; ---------------------------------------------------------------------------

loc_8000C8D:				; CODE XREF: main+B8j
		cmp	eax, 4Ch
		jz	short loc_8000C99
		cmp	eax, 50h
		jz	short loc_8000C9F
		jmp	short loc_8000CE2
; ---------------------------------------------------------------------------

loc_8000C99:				; CODE XREF: main+C6j
		mov	[ebp+logical], 1
		jmp	short loc_8000CEC
; ---------------------------------------------------------------------------

loc_8000C9F:				; CODE XREF: main+CBj
		mov	[ebp+logical], 0
		jmp	short loc_8000CEC
; ---------------------------------------------------------------------------

loc_8000CA5:				; CODE XREF: main+B1j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CAF:				; CODE XREF: main+BFj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aPwd	; "pwd"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000CE2:				; CODE XREF: main+C1j main+CDj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CEC:				; CODE XREF: main+D3j main+D9j
		jmp	loc_8000C4E
; ---------------------------------------------------------------------------

loc_8000CF1:				; CODE XREF: main+A7j
		nop
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_8000D1B
		sub	esp, 0Ch
		push	offset aIgnoringNonOpt ; "ignoring non-option arguments"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000D1B:				; CODE XREF: main+12Fj
		cmp	[ebp+logical], 0
		jz	short loc_8000D47
		call	logical_getcwd
		mov	[ebp+wd], eax
		cmp	[ebp+wd], 0
		jz	short loc_8000D47
		sub	esp, 0Ch
		push	[ebp+wd]	; s
		call	puts
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000D47:				; CODE XREF: main+155j	main+163j
		call	xgetcwd
		mov	[ebp+wd], eax
		cmp	[ebp+wd], 0
		jz	short loc_8000D73
		sub	esp, 0Ch
		push	[ebp+wd]	; s
		call	puts
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+wd]	; ptr
		call	free
		add	esp, 10h
		jmp	short loc_8000DA9
; ---------------------------------------------------------------------------

loc_8000D73:				; CODE XREF: main+189j
		call	file_name_init
		mov	[ebp+file_name], eax
		sub	esp, 0Ch
		push	[ebp+file_name]	; file_name
		call	robust_getcwd
		add	esp, 10h
		mov	eax, [ebp+file_name]
		mov	eax, [eax+8]
		sub	esp, 0Ch
		push	eax		; s
		call	puts
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+file_name]	; p
		call	file_name_free
		add	esp, 10h

loc_8000DA9:				; CODE XREF: main+1A7j
		sub	esp, 0Ch
		push	0		; status

loc_8000DAE:				; DATA XREF: .eh_frame:080012E4o
					; .eh_frame:08001304o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000DC0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+57o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+FBo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aLogical	db 'logical',0          ; DATA XREF: .rodata:longoptso
aPhysical	db 'physical',0         ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[5]
longopts	option <offset aLogical, 0, 0, 4Ch> ; DATA XREF: main+89o
		option <offset aPhysical, 0, 0,	50h> ; "logical"
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]...',0Ah,0 ; DATA XREF: usage+46o
		align 10h
; char aPrintTheFullFi[]
aPrintTheFullFi	db 'Print the full filename of the current working directory.',0Ah
					; DATA XREF: usage+69o
		db 0Ah,0
; char aLLogicalUsePwd[]
aLLogicalUsePwd	db '  -L, --logical   use PWD from environment, even if it contains s'
					; DATA XREF: usage+8Co
		db 'ymlinks',0Ah
		db '  -P, --physical  avoid all symlinks',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+AFo
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 4
; char aNoteYourShellM[]
aNoteYourShellM	db 0Ah			; DATA XREF: usage+EFo
		db 'NOTE: your shell may have its own version of %s, which usually su'
		db 'persedes',0Ah
		db 'the version described here.  Please refer to your shell',27h,'s docu'
		db 'mentation',0Ah
		db 'for details about the options it supports.',0Ah,0
aPwd		db 'pwd',0              ; DATA XREF: usage+FFo main+100o
a__		db '../',0              ; DATA XREF: nth_parent+2Do
; char path[]
path		db '..',0               ; DATA XREF: find_dir_entry+2Co
					; find_dir_entry+CCo
; char aCannotOpenDire[]
aCannotOpenDire	db 'cannot open directory %s',0 ; DATA XREF: find_dir_entry+6Bo
; char aFailedToChdirT[]
aFailedToChdirT	db 'failed to chdir to %s',0 ; DATA XREF: find_dir_entry+103o
a_		db '.',0                ; DATA XREF: find_dir_entry+15Bo
					; robust_getcwd+80o ...
; char aFailedToStatS[]
aFailedToStatS	db 'failed to stat %s',0 ; DATA XREF: find_dir_entry+192o
					; robust_getcwd+A6o
; char aReadingDirecto[]
aReadingDirecto	db 'reading directory %s',0 ; DATA XREF: find_dir_entry+3B7o
		align 4
; char aCouldnTFindDir[]
aCouldnTFindDir	db 'couldn',27h,'t find directory entry in %s with matching i-node',0
					; DATA XREF: find_dir_entry+407o
asc_8001241	db '/',0                ; DATA XREF: robust_getcwd+44o
		align 4
; char aFailedToGetAtt[]
aFailedToGetAtt	db 'failed to get attributes of %s',0 ; DATA XREF: robust_getcwd+56o
; char locale
locale		db 0			; DATA XREF: robust_getcwd+13Bo
					; main+40o
; char name[]
name		db 'PWD',0              ; DATA XREF: logical_getcwd+19o
; char needle[]
needle		db '/.',0               ; DATA XREF: logical_getcwd+BEo
; char aPosixly_correc[]
aPosixly_correc	db 'POSIXLY_CORRECT',0  ; DATA XREF: main+17o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+52o
; char shortopts[]
shortopts	db 'LP',0               ; DATA XREF: main+8Eo
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+F5o
; char aIgnoringNonOpt[]
aIgnoringNonOpt	db 'ignoring non-option arguments',0 ; DATA XREF: main+134o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80012C4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000DAE-8002092h
		dd 58h,	80E4100h, 0D420285h, 0C5540205h, 4040Ch, 1Ch, 3Ch
		dd offset loc_8000DAE-800205Ah
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 20h, 5Ch
		dd offset loc_8000DAE-800203Fh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	80h
		dd offset loc_8000DAE-8001F47h
		dd 11Dh, 80E4100h, 0D420285h, 3834405h,	1Ch, 9Ch
		dd offset loc_8000DAE-8001E46h
		dd 28h,	80E4100h, 0D420285h, 0CC56405h,	404h, 1Ch, 0BCh
		dd offset loc_8000DAE-8001E3Eh
		dd 5Dh,	80E4100h, 0D420285h, 0C5590205h, 4040Ch, 1Ch, 0DCh
		dd offset loc_8000DAE-8001E01h
		dd 0EDh, 80E4100h, 0D420285h, 0C5E90205h, 4040Ch, 1Ch
		dd 0FCh
		dd offset loc_8000DAE-8001D34h
		dd 5Bh,	80E4100h, 0D420285h, 0C5570205h, 4040Ch, 2Ch, 11Ch
		dd offset loc_8000DAE-8001CF9h
		dd 457h, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3044703h
		dd 0C741C641h, 40CC541h, 4, 28h, 14Ch
		dd offset loc_8000DAE-80018D2h
		dd 167h, 80E4100h, 0D420285h, 3864805h,	59030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 178h
		dd offset loc_8000DAE-8001797h
		dd 173h, 80E4100h, 0D420285h, 3864805h,	65030483h, 0C641C301h
		dd 40CC541h, 4,	24h, 1A4h
		dd offset loc_8000DAE-8001650h
		dd 1E9h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn readdir64:near	; CODE XREF: readdir_ignoring_dot_and_dotdot+Cp
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+47p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+118p main+113p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: file_name_free+Fp
					; file_name_free+1Dp ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: file_name_init+Bp
					; file_name_init+2Ap
		extrn xnmalloc:near	; CODE XREF: file_name_prepend+42p
					; nth_parent+Ep
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: file_name_prepend+86p
					; file_name_prepend+E2p ...
; DIR *opendir(const char *name)
		extrn opendir:near	; CODE XREF: find_dir_entry+31p
		extrn quote:near	; CODE XREF: find_dir_entry+5Ap
					; find_dir_entry+F2p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: find_dir_entry+7Ap
					; find_dir_entry+112p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: find_dir_entry+8Bp
					; find_dir_entry+123p ...
; int dirfd(DIR	*dirp)
		extrn dirfd:near	; CODE XREF: find_dir_entry+9Cp
; int fchdir(int fd)
		extrn fchdir:near	; CODE XREF: find_dir_entry+BCp
; int chdir(const char *path)
		extrn chdir:near	; CODE XREF: find_dir_entry+D1p
		extrn fstat64:near	; CODE XREF: find_dir_entry+144p
		extrn stat64:near	; CODE XREF: find_dir_entry+160p
					; robust_getcwd+85p ...
; int closedir(DIR *dirp)
		extrn closedir:near	; CODE XREF: find_dir_entry+257p
					; find_dir_entry+38Cp
		extrn lstat64:near	; CODE XREF: find_dir_entry+2BEp
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: find_dir_entry+33Cp
		extrn __stack_chk_fail:near ; CODE XREF: find_dir_entry+44Ap
					; robust_getcwd+15Bp ...
		extrn get_root_dev_ino:near ; CODE XREF: robust_getcwd+30p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: logical_getcwd+1Ep
					; main+1Cp
; char *strstr(const char *haystack, const char	*needle)
		extrn strstr:near	; CODE XREF: logical_getcwd+C9p
		extrn set_program_name:near ; CODE XREF: main+35p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+5Cp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+6Cp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+77o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+7Cp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+98p
		extrn Version:dword	; DATA XREF: main:loc_8000CAFr
		extrn version_etc:near	; CODE XREF: main+106p
; int optind
		extrn optind:dword	; DATA XREF: main+128r
; int puts(const char *s)
		extrn puts:near		; CODE XREF: main+16Bp	main+191p ...
		extrn xgetcwd:near	; CODE XREF: main:loc_8000D47p


		end
