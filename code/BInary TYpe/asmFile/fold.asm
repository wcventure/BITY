;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	CCC0F5019BA93C27B5CF3EF71624E57E
; Input	CRC32 :	9E7DA8D9

; File Name   :	D:\coreutils-o\fold.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'fold.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: fold_file+152p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+10Fp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+195p	main+1D2p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000242
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWrapInputLines ; "Wrap input lines in each FILE	(standard"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBBytesCountByt ; "  -b,	--bytes		count bytes rathe"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000242:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl adjust_column(size_t column, char c)
adjust_column	proc near		; CODE XREF: fold_file+100p
					; fold_file+202p

c		= byte ptr -4
column		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		movzx	eax, ds:count_bytes
		xor	eax, 1
		test	al, al
		jz	short loc_80002A2
		cmp	[ebp+c], 8
		jnz	short loc_8000279
		cmp	[ebp+column], 0
		jz	short loc_80002A6
		sub	[ebp+column], 1
		jmp	short loc_80002A6
; ---------------------------------------------------------------------------

loc_8000279:				; CODE XREF: adjust_column+1Ej
		cmp	[ebp+c], 0Dh
		jnz	short loc_8000288
		mov	[ebp+column], 0
		jmp	short loc_80002A6
; ---------------------------------------------------------------------------

loc_8000288:				; CODE XREF: adjust_column+30j
		cmp	[ebp+c], 9
		jnz	short loc_800029C
		mov	eax, [ebp+column]
		and	eax, 0FFFFFFF8h
		add	eax, 8
		mov	[ebp+column], eax
		jmp	short loc_80002A6
; ---------------------------------------------------------------------------

loc_800029C:				; CODE XREF: adjust_column+3Fj
		add	[ebp+column], 1
		jmp	short loc_80002A6
; ---------------------------------------------------------------------------

loc_80002A2:				; CODE XREF: adjust_column+18j
		add	[ebp+column], 1

loc_80002A6:				; CODE XREF: adjust_column+24j
					; adjust_column+2Aj ...
		mov	eax, [ebp+column]
		leave
		retn
adjust_column	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	fold_file(const	char *filename,	size_t width)
fold_file	proc near		; CODE XREF: main+214p	main+247p

found_blank	= byte ptr -25h
istream		= dword	ptr -24h
column		= dword	ptr -20h
offset_out	= dword	ptr -1Ch
logical_end	= dword	ptr -18h
i		= dword	ptr -14h
c		= dword	ptr -10h
saved_errno	= dword	ptr -0Ch
var_4		= dword	ptr -4
filename	= dword	ptr  8
width		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+column], 0
		mov	[ebp+offset_out], 0
		sub	esp, 8
		push	offset filename	; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80002E8
		mov	eax, ds:stdin
		mov	[ebp+istream], eax
		mov	ds:have_read_stdin, 1
		jmp	short loc_80002FE
; ---------------------------------------------------------------------------

loc_80002E8:				; CODE XREF: fold_file+2Aj
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+filename]
		call	fopen64
		add	esp, 10h
		mov	[ebp+istream], eax

loc_80002FE:				; CODE XREF: fold_file+3Bj
		cmp	[ebp+istream], 0
		jnz	loc_800053D
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+filename]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000625
; ---------------------------------------------------------------------------

loc_800032C:				; CODE XREF: fold_file+2A7j
		mov	eax, [ebp+offset_out]
		lea	edx, [eax+1]
		mov	eax, ds:allocated_out_5137
		cmp	edx, eax
		jb	short loc_8000356
		mov	eax, ds:line_out_5136
		sub	esp, 8
		push	offset allocated_out_5137
		push	eax
		call	x2realloc
		add	esp, 10h
		mov	ds:line_out_5136, eax

loc_8000356:				; CODE XREF: fold_file+8Ej
		cmp	[ebp+c], 0Ah
		jnz	short rescan
		mov	ecx, ds:line_out_5136
		mov	eax, [ebp+offset_out]
		lea	edx, [eax+1]
		mov	[ebp+offset_out], edx
		add	eax, ecx
		mov	edx, [ebp+c]
		mov	[eax], dl
		mov	edx, ds:stdout
		mov	eax, ds:line_out_5136
		push	edx		; stream
		push	[ebp+offset_out] ; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	[ebp+offset_out], 0
		mov	eax, [ebp+offset_out]
		mov	[ebp+column], eax
		jmp	loc_800053D
; ---------------------------------------------------------------------------

rescan:					; CODE XREF: fold_file+AFj
					; fold_file+219j ...
		mov	eax, [ebp+c]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	[ebp+column]	; column
		call	adjust_column
		add	esp, 10h
		mov	[ebp+column], eax
		mov	eax, [ebp+column]
		cmp	eax, [ebp+width]
		jbe	loc_8000527
		movzx	eax, ds:break_spaces
		test	al, al
		jz	loc_80004C9
		mov	[ebp+found_blank], 0
		mov	eax, [ebp+offset_out]
		mov	[ebp+logical_end], eax
		jmp	short loc_800041F
; ---------------------------------------------------------------------------

loc_80003DD:				; CODE XREF: fold_file+178j
		sub	[ebp+logical_end], 1
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	edx, ds:line_out_5136
		mov	eax, [ebp+logical_end]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jz	short loc_800041F
		mov	[ebp+found_blank], 1
		jmp	short loc_8000425
; ---------------------------------------------------------------------------

loc_800041F:				; CODE XREF: fold_file+130j
					; fold_file+16Cj
		cmp	[ebp+logical_end], 0
		jnz	short loc_80003DD

loc_8000425:				; CODE XREF: fold_file+172j
		cmp	[ebp+found_blank], 0
		jz	loc_80004C9
		add	[ebp+logical_end], 1
		mov	edx, ds:stdout
		mov	eax, ds:line_out_5136
		push	edx		; stream
		push	[ebp+logical_end] ; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, [ebp+offset_out]
		sub	eax, [ebp+logical_end]
		mov	edx, eax
		mov	ecx, ds:line_out_5136
		mov	eax, [ebp+logical_end]
		add	ecx, eax
		mov	eax, ds:line_out_5136
		sub	esp, 4
		push	edx		; n
		push	ecx		; src
		push	eax		; dest
		call	memmove
		add	esp, 10h
		mov	eax, [ebp+logical_end]
		sub	[ebp+offset_out], eax
		mov	[ebp+i], 0
		mov	eax, [ebp+i]
		mov	[ebp+column], eax
		jmp	short loc_80004BC
; ---------------------------------------------------------------------------

loc_8000495:				; CODE XREF: fold_file+217j
		mov	edx, ds:line_out_5136
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	[ebp+column]	; column
		call	adjust_column
		add	esp, 10h
		mov	[ebp+column], eax
		add	[ebp+i], 1

loc_80004BC:				; CODE XREF: fold_file+1E8j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+offset_out]
		jb	short loc_8000495
		jmp	rescan
; ---------------------------------------------------------------------------

loc_80004C9:				; CODE XREF: fold_file+120j
					; fold_file+17Ej
		cmp	[ebp+offset_out], 0
		jnz	short loc_80004E7
		mov	ecx, ds:line_out_5136
		mov	eax, [ebp+offset_out]
		lea	edx, [eax+1]
		mov	[ebp+offset_out], edx
		add	eax, ecx
		mov	edx, [ebp+c]
		mov	[eax], dl
		jmp	short loc_800053D
; ---------------------------------------------------------------------------

loc_80004E7:				; CODE XREF: fold_file+222j
		mov	ecx, ds:line_out_5136
		mov	eax, [ebp+offset_out]
		lea	edx, [eax+1]
		mov	[ebp+offset_out], edx
		add	eax, ecx
		mov	byte ptr [eax],	0Ah
		mov	edx, ds:stdout
		mov	eax, ds:line_out_5136
		push	edx		; stream
		push	[ebp+offset_out] ; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	[ebp+offset_out], 0
		mov	eax, [ebp+offset_out]
		mov	[ebp+column], eax
		jmp	rescan
; ---------------------------------------------------------------------------

loc_8000527:				; CODE XREF: fold_file+111j
		mov	ecx, ds:line_out_5136
		mov	eax, [ebp+offset_out]
		lea	edx, [eax+1]
		mov	[ebp+offset_out], edx
		add	eax, ecx
		mov	edx, [ebp+c]
		mov	[eax], dl

loc_800053D:				; CODE XREF: fold_file+57j
					; fold_file+EEj ...
		sub	esp, 0Ch
		push	[ebp+istream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_800032C
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		cmp	[ebp+offset_out], 0
		jz	short loc_8000582
		mov	edx, ds:stdout
		mov	eax, ds:line_out_5136
		push	edx		; stream
		push	[ebp+offset_out] ; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h

loc_8000582:				; CODE XREF: fold_file+2BBj
		sub	esp, 0Ch
		push	[ebp+istream]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005D5
		push	[ebp+filename]
		push	offset format	; "%s"
		push	[ebp+saved_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 8
		push	offset filename	; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005CE
		sub	esp, 0Ch
		push	[ebp+istream]	; stream
		call	fclose
		add	esp, 10h

loc_80005CE:				; CODE XREF: fold_file+313j
		mov	eax, 0
		jmp	short loc_8000625
; ---------------------------------------------------------------------------

loc_80005D5:				; CODE XREF: fold_file+2E7j
		sub	esp, 8
		push	offset filename	; "-"
		push	[ebp+filename]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000620
		sub	esp, 0Ch
		push	[ebp+istream]	; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000620
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+filename]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8000625
; ---------------------------------------------------------------------------

loc_8000620:				; CODE XREF: fold_file+33Fj
					; fold_file+352j
		mov	eax, 1

loc_8000625:				; CODE XREF: fold_file+7Cj
					; fold_file+328j ...
		mov	ebx, [ebp+var_4]
		leave
		retn
fold_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -3Ch
ok		= byte ptr -31h
tmp_ulong	= dword	ptr -30h
width		= dword	ptr -2Ch
i		= dword	ptr -28h
optc		= dword	ptr -24h
optargbuf	= byte ptr -1Eh
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 3Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+width], 50h
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:have_read_stdin, 0
		movzx	eax, ds:have_read_stdin
		mov	ds:count_bytes,	al
		movzx	eax, ds:count_bytes
		mov	ds:break_spaces, al
		jmp	loc_8000801
; ---------------------------------------------------------------------------

loc_80006D3:				; CODE XREF: main+1FAj
		mov	eax, [ebp+optc]
		cmp	eax, 39h
		jg	short loc_80006FB
		cmp	eax, 30h
		jge	short loc_8000726
		cmp	eax, 0FFFFFF7Dh
		jz	loc_80007C4
		cmp	eax, 0FFFFFF7Eh
		jz	loc_80007BA
		jmp	loc_80007F7
; ---------------------------------------------------------------------------

loc_80006FB:				; CODE XREF: main+AFj
		cmp	eax, 73h
		jz	short loc_800071A
		cmp	eax, 77h
		jz	short loc_8000750
		cmp	eax, 62h
		jnz	loc_80007F7
		mov	ds:count_bytes,	1
		jmp	loc_8000801
; ---------------------------------------------------------------------------

loc_800071A:				; CODE XREF: main+D4j
		mov	ds:break_spaces, 1
		jmp	loc_8000801
; ---------------------------------------------------------------------------

loc_8000726:				; CODE XREF: main+B4j
		mov	eax, ds:optarg
		test	eax, eax
		jz	short loc_800073E
		mov	eax, ds:optarg
		sub	eax, 1
		mov	ds:optarg, eax
		jmp	short loc_8000750
; ---------------------------------------------------------------------------

loc_800073E:				; CODE XREF: main+103j
		mov	eax, [ebp+optc]
		mov	[ebp+optargbuf], al
		mov	[ebp+optargbuf+1], 0
		lea	eax, [ebp+optargbuf]
		mov	ds:optarg, eax

loc_8000750:				; CODE XREF: main+D9j main+112j
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	offset locale
		lea	edx, [ebp+tmp_ulong]
		push	edx
		push	0Ah
		push	0
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000781
		mov	eax, [ebp+tmp_ulong]
		test	eax, eax
		jz	short loc_8000781
		mov	eax, [ebp+tmp_ulong]
		cmp	eax, 0FFFFFFF6h
		jbe	short loc_80007B2

loc_8000781:				; CODE XREF: main+146j	main+14Dj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidNumberO ; "invalid number of columns: %s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007B2:				; CODE XREF: main+155j
		mov	eax, [ebp+tmp_ulong]
		mov	[ebp+width], eax
		jmp	short loc_8000801
; ---------------------------------------------------------------------------

loc_80007BA:				; CODE XREF: main+C6j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80007C4:				; CODE XREF: main+BBj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aFold	; "fold"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80007F7:				; CODE XREF: main+CCj main+DEj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000801:				; CODE XREF: main+A4j main+EBj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "bsw:0::1::2::3::4::5::6::7::8::9::"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80006D3
		mov	eax, ds:optind
		cmp	[ebx], eax
		jnz	short loc_800084B
		sub	esp, 8
		push	[ebp+width]	; width
		push	offset filename	; "-"
		call	fold_file
		add	esp, 10h
		mov	[ebp+ok], al
		jmp	short loc_8000895
; ---------------------------------------------------------------------------

loc_800084B:				; CODE XREF: main+207j
		mov	[ebp+ok], 1
		mov	eax, ds:optind
		mov	[ebp+i], eax
		jmp	short loc_800088E
; ---------------------------------------------------------------------------

loc_8000859:				; CODE XREF: main+269j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+width]	; width
		push	eax		; filename
		call	fold_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		add	[ebp+i], 1

loc_800088E:				; CODE XREF: main+22Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebx]
		jl	short loc_8000859

loc_8000895:				; CODE XREF: main+21Fj
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_80008D0
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80008D0
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset filename	; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008D0:				; CODE XREF: main+274j	main+28Aj
		cmp	[ebp+ok], 0
		jz	short loc_80008DD
		mov	eax, 0
		jmp	short loc_80008E2
; ---------------------------------------------------------------------------

loc_80008DD:				; CODE XREF: main+2AAj
		mov	eax, 1

loc_80008E2:				; CODE XREF: main+2B1j
		sub	esp, 0Ch
		push	eax		; status

loc_80008E6:				; DATA XREF: .eh_frame:08000D84o
					; .eh_frame:08000DA4o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 80008ECh
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	break_spaces
break_spaces	db ?			; DATA XREF: fold_file+117r main+9Fw ...
; _Bool	count_bytes
count_bytes	db ?			; DATA XREF: adjust_column+Cr main+93w ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: fold_file+34w main+85w ...
		align 10h
; Function-local static	variable
; size_t allocated_out_5137
allocated_out_5137 dd ?			; DATA XREF: fold_file+87r
					; fold_file+98o
; Function-local static	variable
; char *line_out_5136
line_out_5136	dd ?			; DATA XREF: fold_file+90r
					; fold_file+A6w ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000900h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+58o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+1B0o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 20h
; char shortopts[35]
shortopts	db 'bsw:0::1::2::3::4::5::6::7::8::9::',0 ; DATA XREF: main+1E1o
aBytes		db 'bytes',0            ; DATA XREF: .rodata:longoptso
aSpaces		db 'spaces',0           ; DATA XREF: .rodata:longoptso
aWidth		db 'width',0            ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[6]
longopts	option <offset aBytes, 0, 0, 62h> ; DATA XREF: main+1DCo
		option <offset aSpaces,	0, 0, 73h> ; "bytes"
		option <offset aWidth, 1, 0, 77h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aWrapInputLines[]
aWrapInputLines	db 'Wrap input lines in each FILE (standard input by default), writin'
					; DATA XREF: usage+69o
		db 'g to',0Ah
		db 'standard output.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aBBytesCountByt[]
aBBytesCountByt	db '  -b, --bytes         count bytes rather than columns',0Ah
					; DATA XREF: usage+AFo
		db '  -s, --spaces        break at spaces',0Ah
		db '  -w, --width=WIDTH   use WIDTH columns instead of 80',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+F5o
; char filename[]
filename	db '-',0                ; DATA XREF: fold_file+18o
					; fold_file+301o ...
aR		db 'r',0                ; DATA XREF: fold_file+40o
; char format[]
format		db '%s',0               ; DATA XREF: fold_file+67o
					; fold_file+2ECo ...
; char locale
locale		db 0			; DATA XREF: main+41o main+12Eo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+53o
; char aInvalidNumberO[]
aInvalidNumberO	db 'invalid number of columns: %s',0 ; DATA XREF: main+16Do
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+1AAo
aFold		db 'fold',0             ; DATA XREF: main+1B5o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8000D64h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80008E6-800166Ah
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_80008E6-8001678h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	60h
		dd offset loc_80008E6-8001580h
		dd 11Fh, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_80008E6-800147Dh
		dd 5Eh,	80E4100h, 0D420285h, 0C55A0205h, 4040Ch, 20h, 9Ch
		dd offset loc_80008E6-800143Fh
		dd 37Fh, 80E4100h, 0D420285h, 3834405h,	0C5037703h, 4040CC3h
		dd 28h,	0C0h
		dd offset loc_80008E6-80010E4h
		dd 2C1h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+48p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+11Ap main+1C8p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: fold_file+20p
					; fold_file+309p ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: fold_file+2Cr main+276r
		extrn fopen64:near	; CODE XREF: fold_file+48p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: fold_file+5Dp
					; fold_file+2ADp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: fold_file+6Fp
					; fold_file+2F6p ...
		extrn x2realloc:near	; CODE XREF: fold_file+9Ep
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	fold_file+D9p
					; fold_file+19Ap ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: fold_file+136p
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: fold_file+1A7p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: fold_file+1CDp
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: fold_file+298p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	fold_file+2DDp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: fold_file+31Bp
					; fold_file+347p ...
		extrn set_program_name:near ; CODE XREF: main+36p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+5Dp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+6Dp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+78o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+7Dp
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000726r
					; main+105r ...
		extrn xstrtoul:near	; CODE XREF: main+13Cp
		extrn quote:near	; CODE XREF: main+160p
		extrn Version:dword	; DATA XREF: main:loc_80007C4r
		extrn version_etc:near	; CODE XREF: main+1BBp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+1EBp
; int optind
		extrn optind:dword	; DATA XREF: main+200r	main+225r


		end
