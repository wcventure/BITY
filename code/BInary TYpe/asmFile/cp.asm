;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	CA03478A6CCCE74033A5CD58816C9930
; Input	CRC32 :	9C0EA6E9

; File Name   :	D:\coreutils-o\cp.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'cp.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+2E3p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl ignore_value(int	i)
ignore_value	proc near		; CODE XREF: re_protect+1EBp

i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
ignore_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_atime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_atime	proc near		; CODE XREF: re_protect+C3p

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+44h]
		mov	eax, [eax+40h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_atime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: re_protect+E2p

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: do_copy+BAp do_copy+137p	...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_8000197
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000440
; ---------------------------------------------------------------------------

loc_8000197:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[-T] SOURCE DEST\"...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCopySourceToDe ; "Copy SOURCE to DEST, or multiple SOURCE"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAArchiveSameAs ; "  -a,	--archive		 same as "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFForceIfAnExis ; "  -f,	--force			 if an ex"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLLinkLinkFiles ; "  -l,	--link			 link fil"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNNoClobberDoNo ; "  -n,	--no-clobber		 do not	o"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPSameAsPreserv ; "  -p				 same as "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoPreserveAttr ; "	--no-preserve=ATTR_LIST	 don't pr"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRRRecursiveCop ; "  -R,	-r, --recursive		 copy dir"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSparseWhenCont ; "	--sparse=WHEN		 control "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSSymbolicLinkM ; "  -s,	--symbolic-link		 make sym"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUUpdateCopyOnl ; "  -u,	--update		 copy onl"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aByDefaultSpars ; "\nBy default,	sparse SOURCE files are	d"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTheBackupSuffi ; "\nThe	backup suffix is `~', unless set "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoneOffNeverMa ; "  none, off	    never make backups (e"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAsASpecialCase ; "\nAs a special case, cp makes	a backup "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000440:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	re_protect(const char *const_dst_name, size_t src_offset, dir_attr *attr_list, const cp_options	*x)
re_protect	proc near		; CODE XREF: do_copy+511p

var_50		= timespec ptr -50h
x		= dword	ptr -44h
attr_list	= dword	ptr -40h
const_dst_name	= dword	ptr -3Ch
p		= dword	ptr -34h
__old		= dword	ptr -30h
__len		= dword	ptr -2Ch
__new		= dword	ptr -28h
dst_name	= dword	ptr -24h
src_name	= dword	ptr -20h
timespec	= timespec ptr -1Ch
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
src_offset	= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 50h
		mov	eax, [ebp+arg_0]
		mov	[ebp+const_dst_name], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+attr_list], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+x], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+const_dst_name]
		mov	[ebp+__old], eax
		sub	esp, 0Ch
		push	[ebp+__old]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		mov	[ebp+__len], eax
		mov	eax, [ebp+__len]
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ecx, 10h
		mov	edx, 0
		div	ecx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+__new], eax
		sub	esp, 4
		push	[ebp+__len]	; n
		push	[ebp+__old]	; src
		push	[ebp+__new]	; dest
		call	memcpy
		add	esp, 10h
		mov	[ebp+dst_name],	eax
		mov	edx, [ebp+dst_name]
		mov	eax, [ebp+src_offset]
		add	eax, edx
		mov	[ebp+src_name],	eax
		mov	eax, [ebp+attr_list]
		mov	[ebp+p], eax
		jmp	loc_80006EB
; ---------------------------------------------------------------------------

loc_80004E6:				; CODE XREF: re_protect+2A4j
		mov	eax, [ebp+p]
		mov	edx, [eax+64h]
		mov	eax, [ebp+dst_name]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	loc_8000597
		mov	edx, [ebp+p]
		lea	eax, [ebp+var_50]
		sub	esp, 8
		push	edx		; st
		push	eax		; retstr
		call	get_stat_atime
		add	esp, 0Ch
		mov	eax, [ebp+var_50.tv_sec]
		mov	edx, [ebp+var_50.tv_nsec]
		mov	[ebp+timespec.tv_sec], eax
		mov	[ebp+timespec.tv_nsec],	edx
		mov	edx, [ebp+p]
		lea	eax, [ebp+var_50]
		sub	esp, 8
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_50.tv_sec]
		mov	edx, [ebp+var_50.tv_nsec]
		mov	[ebp+timespec.tv_sec+8], eax
		mov	[ebp+timespec.tv_nsec+8], edx
		sub	esp, 8
		lea	eax, [ebp+timespec]
		push	eax
		push	[ebp+dst_name]
		call	utimens
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000597
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToPreser ; "failed to preserve times for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80006FA
; ---------------------------------------------------------------------------

loc_8000597:				; CODE XREF: re_protect+B2j
					; re_protect+10Aj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jz	loc_800063E
		mov	eax, [ebp+p]
		mov	edx, [eax+1Ch]
		mov	eax, [ebp+p]
		mov	eax, [eax+18h]
		sub	esp, 4
		push	edx		; group
		push	eax		; owner
		push	[ebp+dst_name]	; file
		call	lchown
		add	esp, 10h
		test	eax, eax
		jz	short loc_800063E
		sub	esp, 0Ch
		push	[ebp+x]
		call	chown_failure_ok
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_800061B
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToPres_0 ; "failed to preserve ownership for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80006FA
; ---------------------------------------------------------------------------

loc_800061B:				; CODE XREF: re_protect+18Ej
		mov	eax, [ebp+p]
		mov	eax, [eax+1Ch]
		sub	esp, 4
		push	eax		; group
		push	0FFFFFFFFh	; owner
		push	[ebp+dst_name]	; file
		call	lchown
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; i
		call	ignore_value
		add	esp, 10h

loc_800063E:				; CODE XREF: re_protect+155j
					; re_protect+179j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jz	short loc_8000673
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		sub	esp, 0Ch
		push	eax
		push	0FFFFFFFFh
		push	[ebp+dst_name]
		push	0FFFFFFFFh
		push	[ebp+src_name]
		call	copy_acl
		add	esp, 20h
		test	eax, eax
		jz	short loc_80006D4
		mov	eax, 0
		jmp	loc_80006FA
; ---------------------------------------------------------------------------

loc_8000673:				; CODE XREF: re_protect+1FCj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+60h]
		test	al, al
		jz	short loc_80006D4
		mov	eax, [ebp+p]
		mov	eax, [eax+10h]
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dst_name]	; file
		call	chmod
		add	esp, 10h
		test	eax, eax
		jz	short loc_80006D4
		sub	esp, 0Ch
		push	[ebp+dst_name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToPres_1 ; "failed to preserve permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_80006FA
; ---------------------------------------------------------------------------

loc_80006D4:				; CODE XREF: re_protect+21Cj
					; re_protect+231j ...
		mov	eax, [ebp+p]
		mov	edx, [eax+64h]
		mov	eax, [ebp+dst_name]
		add	eax, edx
		mov	byte ptr [eax],	2Fh
		mov	eax, [ebp+p]
		mov	eax, [eax+68h]
		mov	[ebp+p], eax

loc_80006EB:				; CODE XREF: re_protect+96j
		cmp	[ebp+p], 0
		jnz	loc_80004E6
		mov	eax, 1

loc_80006FA:				; CODE XREF: re_protect+147j
					; re_protect+1CBj ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800070B
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800070B:				; CODE XREF: re_protect+2B9j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
re_protect	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	make_dir_parents_private(const char *const_dir,	size_t src_offset, const char *verbose_fmt_string, dir_attr **attr_list, _Bool *new_dst, const cp_options *x)
make_dir_parents_private proc near	; CODE XREF: do_copy+38Bp

x		= dword	ptr -12Ch
new_dst		= dword	ptr -128h
attr_list	= dword	ptr -124h
verbose_fmt_string= dword ptr -120h
const_dir	= dword	ptr -11Ch
missing_dir	= byte ptr -111h
slash		= dword	ptr -110h
new		= dword	ptr -10Ch
omitted_permissions= dword ptr -108h
__old		= dword	ptr -104h
__len		= dword	ptr -100h
__new		= dword	ptr -0FCh
dir		= dword	ptr -0F8h
src		= dword	ptr -0F4h
dirlen		= dword	ptr -0F0h
dst_dir		= dword	ptr -0ECh
src_mode	= dword	ptr -0E8h
mkdir_mode	= dword	ptr -0E4h
src_errno	= dword	ptr -0E0h
stats		= stat ptr -0DCh
src_st		= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
arg_0		= dword	ptr  8
src_offset	= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 12Ch
		mov	eax, [ebp+arg_0]
		mov	[ebp+const_dir], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+verbose_fmt_string], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+attr_list], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+new_dst], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+x], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+const_dir]
		mov	[ebp+__old], eax
		sub	esp, 0Ch
		push	[ebp+__old]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		mov	[ebp+__len], eax
		mov	eax, [ebp+__len]
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	edi, 10h
		mov	edx, 0
		div	edi
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+__new], eax
		sub	esp, 4
		push	[ebp+__len]	; n
		push	[ebp+__old]	; src
		push	[ebp+__new]	; dest
		call	memcpy
		add	esp, 10h
		mov	[ebp+dir], eax
		mov	edx, [ebp+dir]
		mov	eax, [ebp+src_offset]
		add	eax, edx
		mov	[ebp+src], eax
		sub	esp, 0Ch
		push	[ebp+dir]
		call	dir_len
		add	esp, 10h
		mov	[ebp+dirlen], eax
		mov	eax, [ebp+dirlen]
		add	eax, 1
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ecx, 10h
		mov	edx, 0
		div	ecx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+dst_dir], eax
		sub	esp, 4
		push	[ebp+dirlen]	; n
		push	[ebp+dir]	; src
		push	[ebp+dst_dir]	; dest
		call	memcpy
		add	esp, 10h
		mov	edx, [ebp+dst_dir]
		mov	eax, [ebp+dirlen]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	eax, [ebp+attr_list]
		mov	dword ptr [eax], 0
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+dst_dir]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	loc_8000D0A
		mov	eax, [ebp+src]
		mov	[ebp+slash], eax
		jmp	short loc_80008A3
; ---------------------------------------------------------------------------

loc_800089C:				; CODE XREF: make_dir_parents_private+19Cj
		add	[ebp+slash], 1

loc_80008A3:				; CODE XREF: make_dir_parents_private+188j
		mov	eax, [ebp+slash]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_800089C
		jmp	loc_8000CE2
; ---------------------------------------------------------------------------

loc_80008B5:				; CODE XREF: make_dir_parents_private+5F0j
		mov	eax, [ebp+slash]
		mov	byte ptr [eax],	0
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+dir]
		call	stat64
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+missing_dir], al
		cmp	[ebp+missing_dir], 0
		jnz	short loc_8000918
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		test	al, al
		jnz	short loc_8000918
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jnz	short loc_8000918
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Eh]
		test	al, al
		jz	loc_8000A12

loc_8000918:				; CODE XREF: make_dir_parents_private+1D6j
					; make_dir_parents_private+1E4j ...
		sub	esp, 8
		lea	eax, [ebp+src_st]
		push	eax
		push	[ebp+src]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_800093A
		call	__errno_location
		mov	eax, [eax]
		jmp	short loc_8000955
; ---------------------------------------------------------------------------

loc_800093A:				; CODE XREF: make_dir_parents_private+21Dj
		mov	eax, [ebp+src_st.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_8000950
		mov	eax, 0
		jmp	short loc_8000955
; ---------------------------------------------------------------------------

loc_8000950:				; CODE XREF: make_dir_parents_private+235j
		mov	eax, 14h

loc_8000955:				; CODE XREF: make_dir_parents_private+226j
					; make_dir_parents_private+23Cj
		mov	[ebp+src_errno], eax
		cmp	[ebp+src_errno], 0
		jz	short loc_80009A3
		sub	esp, 0Ch
		push	[ebp+src]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFailedToGetAtt ; "failed to get	attributes of %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+src_errno]	; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D62
; ---------------------------------------------------------------------------

loc_80009A3:				; CODE XREF: make_dir_parents_private+250j
		sub	esp, 0Ch
		push	6Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	ebx, eax
		lea	eax, [ebp+src_st]
		mov	edx, 18h
		mov	edi, ebx
		mov	esi, eax
		mov	ecx, edx
		rep movsd
		mov	edx, [ebp+slash]
		mov	eax, [ebp+dir]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+new]
		mov	[eax+64h], edx
		mov	eax, [ebp+new]
		mov	byte ptr [eax+60h], 0
		mov	eax, [ebp+attr_list]
		mov	edx, [eax]
		mov	eax, [ebp+new]
		mov	[eax+68h], edx
		mov	eax, [ebp+attr_list]
		mov	edx, [ebp+new]
		mov	[eax], edx

loc_8000A12:				; CODE XREF: make_dir_parents_private+200j
		cmp	[ebp+missing_dir], 0
		jz	loc_8000C64
		mov	eax, [ebp+new_dst]
		mov	byte ptr [eax],	1
		mov	eax, [ebp+new]
		mov	eax, [eax+10h]
		mov	[ebp+src_mode],	eax
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Ch]
		xor	eax, 1
		test	al, al
		jz	short loc_8000A64
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		test	al, al
		jz	short loc_8000A5D
		mov	eax, 12h
		jmp	short loc_8000A69
; ---------------------------------------------------------------------------

loc_8000A5D:				; CODE XREF: make_dir_parents_private+342j
		mov	eax, 0
		jmp	short loc_8000A69
; ---------------------------------------------------------------------------

loc_8000A64:				; CODE XREF: make_dir_parents_private+334j
		mov	eax, 3Fh

loc_8000A69:				; CODE XREF: make_dir_parents_private+349j
					; make_dir_parents_private+350j
		and	eax, [ebp+src_mode]
		mov	[ebp+omitted_permissions], eax
		mov	eax, [ebp+omitted_permissions]
		not	eax
		and	eax, [ebp+src_mode]
		and	eax, 0FFFh
		mov	[ebp+mkdir_mode], eax
		sub	esp, 8
		push	[ebp+mkdir_mode] ; mode
		push	[ebp+dir]	; path
		call	mkdir
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000AEC
		sub	esp, 0Ch
		push	[ebp+dir]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotMakeDire ; "cannot make directory	%s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D62
; ---------------------------------------------------------------------------

loc_8000AEC:				; CODE XREF: make_dir_parents_private+395j
		cmp	[ebp+verbose_fmt_string], 0
		jz	short loc_8000B12
		sub	esp, 4
		push	[ebp+dir]
		push	[ebp+src]
		push	[ebp+verbose_fmt_string] ; format
		call	printf
		add	esp, 10h

loc_8000B12:				; CODE XREF: make_dir_parents_private+3E1j
		sub	esp, 8
		lea	eax, [ebp+stats]
		push	eax
		push	[ebp+dir]
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B71
		sub	esp, 0Ch
		push	[ebp+dir]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToGetAtt ; "failed to get	attributes of %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D62
; ---------------------------------------------------------------------------

loc_8000B71:				; CODE XREF: make_dir_parents_private+41Aj
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+1Dh]
		xor	eax, 1
		test	al, al
		jz	short loc_8000BE6
		mov	eax, [ebp+stats.st_mode]
		not	eax
		and	eax, [ebp+omitted_permissions]
		test	eax, eax
		jz	short loc_8000BA1
		call	cached_umask
		not	eax
		and	[ebp+omitted_permissions], eax

loc_8000BA1:				; CODE XREF: make_dir_parents_private+480j
		mov	eax, [ebp+stats.st_mode]
		not	eax
		and	eax, [ebp+omitted_permissions]
		test	eax, eax
		jnz	short loc_8000BC5
		mov	eax, [ebp+stats.st_mode]
		and	eax, 1C0h
		cmp	eax, 1C0h
		jz	short loc_8000BE6

loc_8000BC5:				; CODE XREF: make_dir_parents_private+49Fj
		mov	eax, [ebp+stats.st_mode]
		or	eax, [ebp+omitted_permissions]
		mov	edx, eax
		mov	eax, [ebp+new]
		mov	[eax+10h], edx
		mov	eax, [ebp+new]
		mov	byte ptr [eax+60h], 1

loc_8000BE6:				; CODE XREF: make_dir_parents_private+46Ej
					; make_dir_parents_private+4B1j
		mov	eax, [ebp+stats.st_mode]
		and	eax, 1C0h
		cmp	eax, 1C0h
		jz	loc_8000CBA
		mov	eax, [ebp+stats.st_mode]
		or	eax, 1C0h
		sub	esp, 8
		push	eax		; mode
		push	[ebp+dir]	; file
		call	chmod
		add	esp, 10h
		test	eax, eax
		jz	loc_8000CBA
		sub	esp, 0Ch
		push	[ebp+dir]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSettingPermiss ; "setting permissions for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D62
; ---------------------------------------------------------------------------

loc_8000C64:				; CODE XREF: make_dir_parents_private+307j
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8000CB1
		sub	esp, 0Ch
		push	[ebp+dir]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSExistsButIsNo ; "%s exists but	is not a directory"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_8000D62
; ---------------------------------------------------------------------------

loc_8000CB1:				; CODE XREF: make_dir_parents_private+562j
		mov	eax, [ebp+new_dst]
		mov	byte ptr [eax],	0

loc_8000CBA:				; CODE XREF: make_dir_parents_private+4E4j
					; make_dir_parents_private+509j
		mov	eax, [ebp+slash]
		lea	edx, [eax+1]
		mov	[ebp+slash], edx
		mov	byte ptr [eax],	2Fh
		jmp	short loc_8000CD5
; ---------------------------------------------------------------------------

loc_8000CCE:				; CODE XREF: make_dir_parents_private+5CEj
		add	[ebp+slash], 1

loc_8000CD5:				; CODE XREF: make_dir_parents_private+5BAj
		mov	eax, [ebp+slash]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jz	short loc_8000CCE

loc_8000CE2:				; CODE XREF: make_dir_parents_private+19Ej
		sub	esp, 8
		push	2Fh		; c
		push	[ebp+slash]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+slash], eax
		cmp	[ebp+slash], 0
		jnz	loc_80008B5
		jmp	short loc_8000D5D
; ---------------------------------------------------------------------------

loc_8000D0A:				; CODE XREF: make_dir_parents_private+176j
		mov	eax, [ebp+stats.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8000D54
		sub	esp, 0Ch
		push	[ebp+dst_dir]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSExistsButIsNo ; "%s exists but	is not a directory"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short loc_8000D62
; ---------------------------------------------------------------------------

loc_8000D54:				; CODE XREF: make_dir_parents_private+608j
		mov	eax, [ebp+new_dst]
		mov	byte ptr [eax],	0

loc_8000D5D:				; CODE XREF: make_dir_parents_private+5F6j
		mov	eax, 1

loc_8000D62:				; CODE XREF: make_dir_parents_private+28Cj
					; make_dir_parents_private+3D5j ...
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_8000D73
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000D73:				; CODE XREF: make_dir_parents_private+65Aj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
make_dir_parents_private endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	target_directory_operand(const char *file, stat	*st, _Bool *new_dst)
target_directory_operand proc near	; CODE XREF: do_copy+177p

is_a_dir	= byte ptr -0Dh
err		= dword	ptr -0Ch
var_4		= dword	ptr -4
file		= dword	ptr  8
st		= dword	ptr  0Ch
new_dst		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 8
		push	[ebp+st]
		push	[ebp+file]
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000DA0
		call	__errno_location
		mov	eax, [eax]
		jmp	short loc_8000DA5
; ---------------------------------------------------------------------------

loc_8000DA0:				; CODE XREF: target_directory_operand+1Aj
		mov	eax, 0

loc_8000DA5:				; CODE XREF: target_directory_operand+23j
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jnz	short loc_8000DC7
		mov	eax, [ebp+st]
		mov	eax, [eax+10h]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_8000DC7
		mov	eax, 1
		jmp	short loc_8000DCC
; ---------------------------------------------------------------------------

loc_8000DC7:				; CODE XREF: target_directory_operand+31j
					; target_directory_operand+43j
		mov	eax, 0

loc_8000DCC:				; CODE XREF: target_directory_operand+4Aj
		mov	[ebp+is_a_dir],	al
		and	[ebp+is_a_dir],	1
		cmp	[ebp+err], 0
		jz	short loc_8000E14
		cmp	[ebp+err], 2
		jz	short loc_8000E0E
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aAccessingS ; "accessing	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+err]	; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000E0E:				; CODE XREF: target_directory_operand+62j
		mov	eax, [ebp+new_dst]
		mov	byte ptr [eax],	1

loc_8000E14:				; CODE XREF: target_directory_operand+5Cj
		movzx	eax, [ebp+is_a_dir]
		mov	ebx, [ebp+var_4]
		leave
		retn
target_directory_operand endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	do_copy(int n_files, char **file, const	char *target_directory,	_Bool no_target_directory, cp_options *x)
do_copy		proc near		; CODE XREF: main+704p

x		= dword	ptr -0C8h
no_target_directory= byte ptr -0C4h
target_directory= dword	ptr -0C0h
file		= dword	ptr -0BCh
new_dst		= byte ptr -0B8h
copy_into_self	= byte ptr -0B7h
ok		= byte ptr -0B6h
parent_exists	= byte ptr -0B5h
attr_list	= dword	ptr -0B4h
unused		= dword	ptr -0B0h
i		= dword	ptr -0ACh
dst_name	= dword	ptr -0A8h
new_dest	= dword	ptr -0A4h
arg		= dword	ptr -0A0h
__old		= dword	ptr -9Ch
__len		= dword	ptr -98h
__new		= dword	ptr -94h
arg_no_trailing_slash= dword ptr -90h
__old_0		= dword	ptr -8Ch
__len_0		= dword	ptr -88h
__new_0		= dword	ptr -84h
tmp_abns_	= dword	ptr -80h
s1		= dword	ptr -7Ch
p		= dword	ptr -78h
source		= dword	ptr -74h
dest		= dword	ptr -70h
sb		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
n_files		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0C4h
		mov	eax, [ebp+arg_C]
		mov	edx, [ebp+arg_4]
		mov	[ebp+file], edx
		mov	edx, [ebp+arg_8]
		mov	[ebp+target_directory],	edx
		mov	[ebp+no_target_directory], al
		mov	eax, [ebp+arg_10]
		mov	[ebp+x], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+new_dst], 0
		mov	[ebp+ok], 1
		cmp	[ebp+target_directory],	0
		setz	al
		movzx	eax, al
		cmp	eax, [ebp+n_files]
		jl	short loc_8000EDC
		cmp	[ebp+n_files], 0
		jg	short loc_8000E9E
		sub	esp, 0Ch
		push	offset aMissingFileOpe ; "missing file operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000ED2
; ---------------------------------------------------------------------------

loc_8000E9E:				; CODE XREF: do_copy+5Dj
		mov	eax, [ebp+file]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingDestina ; "missing destination file operand after "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000ED2:				; CODE XREF: do_copy+7Fj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000EDC:				; CODE XREF: do_copy+57j
		cmp	[ebp+no_target_directory], 0
		jz	short loc_8000F59
		cmp	[ebp+target_directory],	0
		jz	short loc_8000F0E
		sub	esp, 0Ch
		push	offset aCannotCombineT ; "cannot combine --target-directory (-t) "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000F0E:				; CODE XREF: do_copy+CFj
		cmp	[ebp+n_files], 2
		jle	loc_800100B
		mov	eax, [ebp+file]
		add	eax, 8
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F59:				; CODE XREF: do_copy+C6j
		cmp	[ebp+target_directory],	0
		jnz	loc_800100B
		cmp	[ebp+n_files], 1
		jle	short loc_8000FC0
		mov	eax, [ebp+n_files]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 4
		lea	edx, [ebp+new_dst]
		push	edx		; new_dst
		lea	edx, [ebp+sb]
		push	edx		; st
		push	eax		; file
		call	target_directory_operand
		add	esp, 10h
		test	al, al
		jz	short loc_8000FC0
		sub	[ebp+n_files], 1
		mov	eax, [ebp+n_files]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+target_directory],	eax
		jmp	short loc_800100B
; ---------------------------------------------------------------------------

loc_8000FC0:				; CODE XREF: do_copy+14Dj do_copy+181j
		cmp	[ebp+n_files], 2
		jle	short loc_800100B
		mov	eax, [ebp+n_files]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aTargetSIsNotAD ; "target %s is not a directory"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800100B:				; CODE XREF: do_copy+F5j do_copy+143j	...
		cmp	[ebp+target_directory],	0
		jz	loc_80013B6
		cmp	[ebp+n_files], 1
		jle	short loc_8001040
		sub	esp, 0Ch
		push	[ebp+x]
		call	dest_info_init
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+x]
		call	src_info_init
		add	esp, 10h

loc_8001040:				; CODE XREF: do_copy+1FFj
		mov	[ebp+i], 0
		jmp	loc_80013A2
; ---------------------------------------------------------------------------

loc_800104F:				; CODE XREF: do_copy+58Ej
		mov	[ebp+parent_exists], 1
		mov	[ebp+unused], 0
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+arg], eax
		movzx	eax, ds:remove_trailing_slashes
		test	al, al
		jz	short loc_8001099
		sub	esp, 0Ch
		push	[ebp+arg]
		call	strip_trailing_slashes
		add	esp, 10h

loc_8001099:				; CODE XREF: do_copy+269j
		movzx	eax, ds:parents_option
		test	al, al
		jz	loc_80011BB
		mov	eax, [ebp+arg]
		mov	[ebp+__old], eax
		sub	esp, 0Ch
		push	[ebp+__old]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		mov	[ebp+__len], eax
		mov	eax, [ebp+__len]
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ebx, 10h
		mov	edx, 0
		div	ebx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+__new], eax
		sub	esp, 4
		push	[ebp+__len]	; n
		push	[ebp+__old]	; src
		push	[ebp+__new]	; dest
		call	memcpy
		add	esp, 10h
		mov	[ebp+arg_no_trailing_slash], eax
		sub	esp, 0Ch
		push	[ebp+arg_no_trailing_slash]
		call	strip_trailing_slashes
		add	esp, 10h
		sub	esp, 4
		lea	eax, [ebp+unused]
		push	eax
		push	[ebp+arg_no_trailing_slash]
		push	[ebp+target_directory]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+dst_name],	eax
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+2Ah]
		test	al, al
		jz	short loc_8001170
		mov	edx, offset verbose_fmt_string ; "%s ->	%s\n"
		jmp	short loc_8001175
; ---------------------------------------------------------------------------

loc_8001170:				; CODE XREF: do_copy+34Aj
		mov	edx, 0

loc_8001175:				; CODE XREF: do_copy+351j
		mov	eax, [ebp+unused]
		mov	ecx, eax
		mov	eax, [ebp+dst_name]
		sub	ecx, eax
		mov	eax, ecx
		mov	ecx, eax
		sub	esp, 8
		push	[ebp+x]		; x
		lea	eax, [ebp+new_dst]
		push	eax		; new_dst
		lea	eax, [ebp+attr_list]
		push	eax		; attr_list
		push	edx		; verbose_fmt_string
		push	ecx		; src_offset
		push	[ebp+dst_name]	; const_dir
		call	make_dir_parents_private
		add	esp, 20h
		mov	[ebp+parent_exists], al
		jmp	loc_800129B
; ---------------------------------------------------------------------------

loc_80011BB:				; CODE XREF: do_copy+285j
		mov	eax, [ebp+arg]
		mov	[ebp+__old_0], eax
		sub	esp, 0Ch
		push	[ebp+__old_0]	; s
		call	strlen
		add	esp, 10h
		add	eax, 1
		mov	[ebp+__len_0], eax
		mov	eax, [ebp+__len_0]
		lea	edx, [eax+0Fh]
		mov	eax, 10h
		sub	eax, 1
		add	eax, edx
		mov	ebx, 10h
		mov	edx, 0
		div	ebx
		imul	eax, 10h
		sub	esp, eax
		mov	eax, esp
		add	eax, 0Fh
		shr	eax, 4
		shl	eax, 4
		mov	[ebp+__new_0], eax
		sub	esp, 4
		push	[ebp+__len_0]	; n
		push	[ebp+__old_0]	; src
		push	[ebp+__new_0]	; dest
		call	memcpy
		add	esp, 10h
		mov	[ebp+tmp_abns_], eax
		sub	esp, 0Ch
		push	[ebp+tmp_abns_]
		call	last_component
		add	esp, 10h
		mov	[ebp+s1], eax
		sub	esp, 0Ch
		push	[ebp+s1]
		call	strip_trailing_slashes
		add	esp, 10h
		sub	esp, 8
		push	offset a__	; ".."
		push	[ebp+s1]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800127F
		sub	esp, 0Ch
		push	[ebp+target_directory] ; char *
		call	xstrdup
		add	esp, 10h
		jmp	short loc_8001295
; ---------------------------------------------------------------------------

loc_800127F:				; CODE XREF: do_copy+44Dj
		sub	esp, 4
		push	0
		push	[ebp+s1]
		push	[ebp+target_directory]
		call	file_name_concat
		add	esp, 10h

loc_8001295:				; CODE XREF: do_copy+460j
		mov	[ebp+dst_name],	eax

loc_800129B:				; CODE XREF: do_copy+399j
		movzx	eax, [ebp+parent_exists]
		xor	eax, 1
		test	al, al
		jz	short loc_80012B5
		mov	[ebp+ok], 0
		jmp	loc_800134D
; ---------------------------------------------------------------------------

loc_80012B5:				; CODE XREF: do_copy+48Aj
		movzx	eax, [ebp+new_dst]
		movzx	eax, al
		sub	esp, 8
		push	0
		lea	edx, [ebp+copy_into_self]
		push	edx
		push	[ebp+x]
		push	eax
		push	[ebp+dst_name]
		push	[ebp+arg]
		call	copy
		add	esp, 20h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		movzx	eax, ds:parents_option
		test	al, al
		jz	short loc_800134D
		mov	eax, [ebp+attr_list]
		mov	edx, [ebp+unused]
		mov	ecx, edx
		mov	edx, [ebp+dst_name]
		sub	ecx, edx
		mov	edx, ecx
		push	[ebp+x]		; x
		push	eax		; attr_list
		push	edx		; src_offset
		push	[ebp+dst_name]	; const_dst_name
		call	re_protect
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_800134D:				; CODE XREF: do_copy+493j do_copy+4E9j
		movzx	eax, ds:parents_option
		test	al, al
		jz	short loc_800138A
		jmp	short loc_8001380
; ---------------------------------------------------------------------------

loc_800135A:				; CODE XREF: do_copy+56Bj
		mov	eax, [ebp+attr_list]
		mov	[ebp+p], eax
		mov	eax, [ebp+attr_list]
		mov	eax, [eax+68h]
		mov	[ebp+attr_list], eax
		sub	esp, 0Ch
		push	[ebp+p]		; ptr
		call	free
		add	esp, 10h

loc_8001380:				; CODE XREF: do_copy+53Bj
		mov	eax, [ebp+attr_list]
		test	eax, eax
		jnz	short loc_800135A

loc_800138A:				; CODE XREF: do_copy+539j
		sub	esp, 0Ch
		push	[ebp+dst_name]	; ptr
		call	free
		add	esp, 10h
		add	[ebp+i], 1

loc_80013A2:				; CODE XREF: do_copy+22Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_files]
		jl	loc_800104F
		jmp	loc_8001554
; ---------------------------------------------------------------------------

loc_80013B6:				; CODE XREF: do_copy+1F5j
		mov	eax, [ebp+file]
		mov	eax, [eax]
		mov	[ebp+source], eax
		mov	eax, [ebp+file]
		mov	eax, [eax+4]
		mov	[ebp+dest], eax
		movzx	eax, ds:parents_option
		test	al, al
		jz	short loc_8001402
		sub	esp, 0Ch
		push	offset aWithParentsThe ; "with --parents, the destination must be"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001402:				; CODE XREF: do_copy+5B9j
		mov	eax, [ebp+x]
		movzx	eax, byte ptr [eax+16h]
		test	al, al
		jz	loc_8001520
		mov	eax, [ebp+x]
		mov	eax, [eax]
		test	eax, eax
		jz	loc_8001520
		sub	esp, 8
		push	[ebp+dest]	; s2
		push	[ebp+source]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	loc_8001520
		movzx	eax, [ebp+new_dst]
		xor	eax, 1
		test	al, al
		jz	loc_8001520
		mov	eax, [ebp+sb.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8001520
		mov	eax, [ebp+x]
		mov	eax, [eax]
		sub	esp, 8
		push	eax
		push	[ebp+dest]
		call	find_backup_file_name
		add	esp, 10h
		mov	[ebp+new_dest],	eax
		mov	eax, [ebp+x]
		mov	edx, [eax]
		mov	ds:x_tmp_5550.backup_type, edx
		mov	edx, [eax+4]
		mov	ds:x_tmp_5550.dereference, edx
		mov	edx, [eax+8]
		mov	ds:x_tmp_5550.interactive, edx
		mov	edx, [eax+0Ch]
		mov	ds:x_tmp_5550.sparse_mode, edx
		mov	edx, [eax+10h]
		mov	ds:x_tmp_5550.mode, edx
		mov	edx, [eax+14h]
		mov	dword ptr ds:x_tmp_5550.copy_as_regular, edx
		mov	edx, [eax+18h]
		mov	dword ptr ds:x_tmp_5550.move_mode, edx
		mov	edx, [eax+1Ch]
		mov	dword ptr ds:x_tmp_5550.preserve_ownership, edx
		mov	edx, [eax+20h]
		mov	dword ptr ds:x_tmp_5550.require_preserve, edx
		mov	edx, [eax+24h]
		mov	dword ptr ds:x_tmp_5550.require_preserve_xattr,	edx
		mov	edx, [eax+28h]
		mov	dword ptr ds:x_tmp_5550.symbolic_link, edx
		mov	edx, [eax+2Ch]
		mov	dword ptr ds:x_tmp_5550.open_dangling_dest_symlink, edx
		mov	edx, [eax+30h]
		mov	ds:x_tmp_5550.reflink_mode, edx
		mov	edx, [eax+34h]
		mov	ds:x_tmp_5550.dest_info, edx
		mov	eax, [eax+38h]
		mov	ds:x_tmp_5550.src_info,	eax
		mov	ds:x_tmp_5550.backup_type, 0
		mov	[ebp+x], offset	x_tmp_5550
		jmp	short loc_8001529
; ---------------------------------------------------------------------------

loc_8001520:				; CODE XREF: do_copy+5F1j do_copy+601j ...
		mov	eax, [ebp+dest]
		mov	[ebp+new_dest],	eax

loc_8001529:				; CODE XREF: do_copy+701j
		sub	esp, 8
		push	0
		lea	eax, [ebp+unused]
		push	eax
		push	[ebp+x]
		push	0
		push	[ebp+new_dest]
		push	[ebp+source]
		call	copy
		add	esp, 20h
		mov	[ebp+ok], al

loc_8001554:				; CODE XREF: do_copy+594j
		movzx	eax, [ebp+ok]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_800156C
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800156C:				; CODE XREF: do_copy+748j
		mov	ebx, [ebp+var_4]
		leave
		retn
do_copy		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cp_option_init(cp_options *x)
cp_option_init	proc near		; CODE XREF: main+C2p

x		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+x]
		call	cp_options_default
		add	esp, 10h
		mov	eax, [ebp+x]
		mov	byte ptr [eax+14h], 1
		mov	eax, [ebp+x]
		mov	dword ptr [eax+4], 1
		mov	eax, [ebp+x]
		mov	byte ptr [eax+15h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+16h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+17h], 0
		mov	eax, [ebp+x]
		mov	dword ptr [eax+8], 4
		mov	eax, [ebp+x]
		mov	byte ptr [eax+18h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+1Bh], 0
		mov	eax, [ebp+x]
		mov	dword ptr [eax+30h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+1Ch], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+1Fh], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+1Dh], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+1Eh], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+21h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+22h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+23h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+25h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+24h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+20h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+26h], 0
		mov	eax, [ebp+x]
		mov	dword ptr [eax+0Ch], 2
		mov	eax, [ebp+x]
		mov	byte ptr [eax+28h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+27h], 0
		mov	eax, [ebp+x]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+2Bh], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+29h], 0
		mov	eax, [ebp+x]
		mov	byte ptr [eax+2Ah], 0
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+x]
		mov	[eax+2Ch], dl
		mov	eax, [ebp+x]
		mov	dword ptr [eax+34h], 0
		mov	eax, [ebp+x]
		mov	dword ptr [eax+38h], 0
		nop
		leave
		retn
cp_option_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl decode_preserve_arg(const char *arg, cp_options *x, _Bool on_off)
decode_preserve_arg proc near		; CODE XREF: main+2A6p	main+2CEp

on_off		= byte ptr -1Ch
s		= dword	ptr -18h
comma		= dword	ptr -14h
arg_writable	= dword	ptr -10h
val		= dword	ptr -0Ch
arg		= dword	ptr  8
x		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_8]
		mov	[ebp+on_off], al
		sub	esp, 0Ch
		push	[ebp+arg]	; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+arg_writable], eax
		mov	eax, [ebp+arg_writable]
		mov	[ebp+s], eax

loc_80016A6:				; CODE XREF: decode_preserve_arg+14Dj
		sub	esp, 8
		push	2Ch		; c
		push	[ebp+s]		; s
		call	strchr
		add	esp, 10h
		mov	[ebp+comma], eax
		cmp	[ebp+comma], 0
		jz	short loc_80016CB
		mov	eax, [ebp+comma]
		lea	edx, [eax+1]
		mov	[ebp+comma], edx
		mov	byte ptr [eax],	0

loc_80016CB:				; CODE XREF: decode_preserve_arg+3Aj
		mov	eax, ds:argmatch_die
		sub	esp, 8
		push	eax
		push	4
		push	offset preserve_vals_5567
		push	offset preserve_args_5568
		push	[ebp+s]
		push	offset aPreserve ; "--preserve"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:preserve_vals_5567[eax*4]
		mov	[ebp+val], eax
		cmp	[ebp+val], 6	; switch 7 cases
		ja	loc_80017C1	; jumptable 08001711 default case
		mov	eax, [ebp+val]
		shl	eax, 2
		add	eax, offset off_80036BC
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001713:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 0
		movzx	edx, [ebp+on_off]
		mov	[eax+1Dh], dl
		jmp	loc_80017C6
; ---------------------------------------------------------------------------

loc_8001722:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 1
		movzx	edx, [ebp+on_off]
		mov	[eax+1Eh], dl
		jmp	loc_80017C6
; ---------------------------------------------------------------------------

loc_8001731:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 2
		movzx	edx, [ebp+on_off]
		mov	[eax+1Ch], dl
		jmp	loc_80017C6
; ---------------------------------------------------------------------------

loc_8001740:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 3
		movzx	edx, [ebp+on_off]
		mov	[eax+1Fh], dl
		jmp	short loc_80017C6
; ---------------------------------------------------------------------------

loc_800174C:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 4
		movzx	edx, [ebp+on_off]
		mov	[eax+21h], dl
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+22h], dl
		jmp	short loc_80017C6
; ---------------------------------------------------------------------------

loc_8001762:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 5
		movzx	edx, [ebp+on_off]
		mov	[eax+23h], dl
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+24h], dl
		jmp	short loc_80017C6
; ---------------------------------------------------------------------------

loc_8001778:				; CODE XREF: decode_preserve_arg+8Ej
					; DATA XREF: .rodata:off_80036BCo
		mov	eax, [ebp+x]	; jumptable 08001711 case 6
		movzx	edx, [ebp+on_off]
		mov	[eax+1Dh], dl
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+1Eh], dl
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+1Ch], dl
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+1Fh], dl
		movzx	eax, ds:selinux_enabled
		test	al, al
		jz	short loc_80017B5
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+21h], dl

loc_80017B5:				; CODE XREF: decode_preserve_arg+126j
		mov	eax, [ebp+x]
		movzx	edx, [ebp+on_off]
		mov	[eax+23h], dl
		jmp	short loc_80017C6
; ---------------------------------------------------------------------------

loc_80017C1:				; CODE XREF: decode_preserve_arg+7Bj
		call	abort		; jumptable 08001711 default case
; ---------------------------------------------------------------------------

loc_80017C6:				; CODE XREF: decode_preserve_arg+9Aj
					; decode_preserve_arg+A9j ...
		mov	eax, [ebp+comma]
		mov	[ebp+s], eax
		cmp	[ebp+s], 0
		jnz	loc_80016A6
		sub	esp, 0Ch
		push	[ebp+arg_writable] ; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
decode_preserve_arg endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0DCh
make_backups	= byte ptr -0CCh
copy_contents	= byte ptr -0CBh
no_target_directory= byte ptr -0CAh
ok		= byte ptr -0C9h
backup_suffix_string= dword ptr	-0C8h
version_control_string=	dword ptr -0C4h
target_directory= dword	ptr -0C0h
c		= dword	ptr -0BCh
x		= cp_options ptr -0B8h
st		= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0D8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+make_backups], 0
		mov	[ebp+version_control_string], 0
		mov	[ebp+copy_contents], 0
		mov	[ebp+target_directory],	0
		mov	[ebp+no_target_directory], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdin ; func
		call	atexit
		add	esp, 10h
		mov	ds:selinux_enabled, 0
		sub	esp, 0Ch
		lea	eax, [ebp+x]
		push	eax		; x
		call	cp_option_init
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSimple_backup_ ; "SIMPLE_BACKUP_SUFFIX"
		call	getenv
		add	esp, 10h
		mov	[ebp+backup_suffix_string], eax
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_80018CC:				; CODE XREF: main+4DAj
		mov	eax, [ebp+c]
		add	eax, 83h	; switch 267 cases
		cmp	eax, 10Ah
		ja	loc_8001C8B	; jumptable 080018E9 default case
		mov	eax, ds:off_80038D0[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80018EB:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	edx, ds:argmatch_die ; jumptable 080018E9 case 133
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset sparse_type
		push	offset sparse_type_string
		push	eax
		push	offset aSparse	; "--sparse"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:sparse_type[eax*4]
		mov	[ebp+x.sparse_mode], eax
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001926:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	eax, ds:optarg	; jumptable 080018E9 case 132
		test	eax, eax
		jnz	short loc_800193E
		mov	[ebp+x.reflink_mode], 2
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_800193E:				; CODE XREF: main+146j
		mov	edx, ds:argmatch_die
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx
		push	4
		push	offset reflink_type
		push	offset reflink_type_string
		push	eax
		push	offset aReflink	; "--reflink"
		call	__xargmatch_internal
		add	esp, 20h
		mov	eax, ds:reflink_type[eax*4]
		mov	[ebp+x.reflink_mode], eax
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001979:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.dereference], 2 ; jumptable 080018E9 case 97
		mov	[ebp+x.preserve_links],	1
		mov	[ebp+x.preserve_ownership], 1
		mov	[ebp+x.preserve_mode], 1
		mov	[ebp+x.preserve_timestamps], 1
		mov	[ebp+x.require_preserve], 1
		movzx	eax, ds:selinux_enabled
		test	al, al
		jz	short loc_80019B8
		mov	[ebp+x.preserve_security_context], 1

loc_80019B8:				; CODE XREF: main+1C8j
		mov	[ebp+x.preserve_xattr],	1
		mov	[ebp+x.reduce_diagnostics], 1
		mov	[ebp+x.recursive], 1
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_80019D2:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+make_backups], 1 ;	jumptable 080018E9 case	98
		mov	eax, ds:optarg
		test	eax, eax
		jz	loc_8001C95
		mov	eax, ds:optarg
		mov	[ebp+version_control_string], eax
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_80019F6:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+copy_contents], 1 ; jumptable 080018E9 case 128
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A02:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.preserve_links],	1 ; jumptable 080018E9 case 100
		mov	[ebp+x.dereference], 2
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A18:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.unlink_dest_after_failed_open], 1 ; jumptable 080018E9 case 102
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A24:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.dereference], 3 ; jumptable 080018E9 case 72
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A33:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.interactive], 3 ; jumptable 080018E9 case 105
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A42:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.hard_link], 1 ; jumptable 080018E9 case 108
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A4E:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.dereference], 4 ; jumptable 080018E9 case 76
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A5D:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.interactive], 2 ; jumptable 080018E9 case 110
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A6C:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.dereference], 2 ; jumptable 080018E9 case 80
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A7B:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	eax, ds:optarg	; jumptable 080018E9 case 129
		sub	esp, 4
		push	0		; on_off
		lea	edx, [ebp+x]
		push	edx		; x
		push	eax		; arg
		call	decode_preserve_arg
		add	esp, 10h
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001A9A:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	eax, ds:optarg	; jumptable 080018E9 case 131
		test	eax, eax
		jz	short loc_8001AC9 ; jumptable 080018E9 case 112
		mov	eax, ds:optarg
		sub	esp, 4
		push	1		; on_off
		lea	edx, [ebp+x]
		push	edx		; x
		push	eax		; arg
		call	decode_preserve_arg
		add	esp, 10h
		mov	[ebp+x.require_preserve], 1
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001AC9:				; CODE XREF: main+102j	main+2BAj
					; DATA XREF: ...
		mov	[ebp+x.preserve_ownership], 1 ;	jumptable 080018E9 case	112
		mov	[ebp+x.preserve_mode], 1
		mov	[ebp+x.preserve_timestamps], 1
		mov	[ebp+x.require_preserve], 1
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001AEA:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	ds:parents_option, 1 ; jumptable 080018E9 case 130
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001AF6:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.recursive], 1 ; jumptable 080018E9 cases	82,114
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001B02:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.unlink_dest_before_opening], 1 ;	jumptable 080018E9 case	135
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001B0E:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	ds:remove_trailing_slashes, 1 ;	jumptable 080018E9 case	134
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001B1A:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.symbolic_link], 1 ; jumptable 080018E9 case 115
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001B26:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		cmp	[ebp+target_directory],	0 ; jumptable 080018E9 case 116
		jz	short loc_8001B54
		sub	esp, 0Ch
		push	offset aMultipleTarget ; "multiple target directories specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8001BE6
; ---------------------------------------------------------------------------

loc_8001B54:				; CODE XREF: main+346j
		mov	eax, ds:optarg
		sub	esp, 8
		lea	edx, [ebp+st]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001BA6
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	edi, eax
		sub	esp, 0Ch
		push	offset aAccessingS ; "accessing	%s"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	edi
		push	esi		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001BA6:				; CODE XREF: main+384j
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8001BE6
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aTargetSIsNotAD ; "target %s is not a directory"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001BE6:				; CODE XREF: main+368j	main+3CCj
		mov	eax, ds:optarg
		mov	[ebp+target_directory],	eax
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001BF6:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+no_target_directory], 1 ; jumptable 080018E9 case 84
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001C02:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.update],	1 ; jumptable 080018E9 case 117
		jmp	loc_8001C95
; ---------------------------------------------------------------------------

loc_8001C0E:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.verbose], 1 ; jumptable 080018E9	case 118
		jmp	short loc_8001C95
; ---------------------------------------------------------------------------

loc_8001C17:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+x.one_file_system], 1 ; jumptable 080018E9	case 120
		jmp	short loc_8001C95
; ---------------------------------------------------------------------------

loc_8001C20:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		mov	[ebp+make_backups], 1 ;	jumptable 080018E9 case	83
		mov	eax, ds:optarg
		mov	[ebp+backup_suffix_string], eax
		jmp	short loc_8001C95
; ---------------------------------------------------------------------------

loc_8001C34:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		sub	esp, 0Ch	; jumptable 080018E9 case -130
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001C3E:				; CODE XREF: main+102j
					; DATA XREF: .rodata:off_80038D0o
		sub	esp, 8		; jumptable 080018E9 case -131
		push	offset aTorbjRnGranlun ; "Torbjörn Granlund"
		push	offset aTorbjornGranlu ; "Torbjorn Granlund"
		call	proper_name_utf8
		add	esp, 10h
		mov	ecx, eax
		mov	edx, ds:Version
		mov	eax, ds:stdout
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	ecx
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aCp	; "cp"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001C8B:				; CODE XREF: main+F5j main+102j
					; DATA XREF: ...
		sub	esp, 0Ch	; jumptable 080018E9 default case
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001C95:				; CODE XREF: main+E0j main+13Aj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_opts ; longopts
		push	offset shortopts ; "abdfHilLnprst:uvxPRS:T"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_80018CC
		movzx	eax, [ebp+x.hard_link]
		test	al, al
		jz	short loc_8001D07
		movzx	eax, [ebp+x.symbolic_link]
		test	al, al
		jz	short loc_8001D07
		sub	esp, 0Ch
		push	offset aCannotMakeBoth ; "cannot make both hard	and symbolic link"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001D07:				; CODE XREF: main+4E9j	main+4F4j
		cmp	[ebp+make_backups], 0
		jz	short loc_8001D45
		mov	eax, [ebp+x.interactive]
		cmp	eax, 2
		jnz	short loc_8001D45
		sub	esp, 0Ch
		push	offset aOptionsBackupA ; "options --backup and --no-clobber are	m"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001D45:				; CODE XREF: main+527j	main+532j
		mov	eax, [ebp+x.reflink_mode]
		cmp	eax, 2
		jnz	short loc_8001D85
		mov	eax, [ebp+x.sparse_mode]
		cmp	eax, 2
		jz	short loc_8001D85
		sub	esp, 0Ch
		push	offset aReflinkCanBeUs ; "--reflink can	be used	only with --spars"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001D85:				; CODE XREF: main+567j	main+572j
		cmp	[ebp+backup_suffix_string], 0
		jz	short loc_8001DA4
		sub	esp, 0Ch
		push	[ebp+backup_suffix_string] ; char *
		call	xstrdup
		add	esp, 10h
		mov	ds:simple_backup_suffix, eax

loc_8001DA4:				; CODE XREF: main+5A5j
		cmp	[ebp+make_backups], 0
		jz	short loc_8001DD1
		sub	esp, 0Ch
		push	offset aBackupType ; "backup type"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+version_control_string]
		push	eax
		call	xget_version
		add	esp, 10h
		jmp	short loc_8001DD6
; ---------------------------------------------------------------------------

loc_8001DD1:				; CODE XREF: main+5C4j
		mov	eax, 0

loc_8001DD6:				; CODE XREF: main+5E8j
		mov	[ebp+x.backup_type], eax
		mov	eax, [ebp+x.dereference]
		cmp	eax, 1
		jnz	short loc_8001E08
		movzx	eax, [ebp+x.recursive]
		test	al, al
		jz	short loc_8001DFE
		mov	[ebp+x.dereference], 2
		jmp	short loc_8001E08
; ---------------------------------------------------------------------------

loc_8001DFE:				; CODE XREF: main+609j
		mov	[ebp+x.dereference], 4

loc_8001E08:				; CODE XREF: main+5FEj	main+615j
		movzx	eax, [ebp+x.recursive]
		test	al, al
		jz	short loc_8001E20
		movzx	eax, [ebp+copy_contents]
		mov	[ebp+x.copy_as_regular], al

loc_8001E20:				; CODE XREF: main+62Aj
		movzx	eax, [ebp+x.unlink_dest_after_failed_open]
		test	al, al
		jz	short loc_8001E48
		movzx	eax, [ebp+x.hard_link]
		test	al, al
		jnz	short loc_8001E41
		movzx	eax, [ebp+x.symbolic_link]
		test	al, al
		jz	short loc_8001E48

loc_8001E41:				; CODE XREF: main+64Dj
		mov	[ebp+x.unlink_dest_before_opening], 1

loc_8001E48:				; CODE XREF: main+642j	main+658j
		movzx	eax, [ebp+x.preserve_security_context]
		test	al, al
		jz	short loc_8001E81
		movzx	eax, ds:selinux_enabled
		xor	eax, 1
		test	al, al
		jz	short loc_8001E81
		sub	esp, 0Ch
		push	offset aCannotPreserve ; "cannot preserve security context withou"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001E81:				; CODE XREF: main+66Aj	main+678j
		movzx	eax, [ebp+x.require_preserve_xattr]
		test	al, al
		jz	short loc_8001EAC
		sub	esp, 0Ch
		push	offset aCannotPreser_0 ; "cannot preserve extended attributes, cp"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001EAC:				; CODE XREF: main+6A3j
		call	hash_init
		movzx	eax, [ebp+no_target_directory]
		mov	edx, ds:optind
		lea	ecx, ds:0[edx*4]
		mov	edx, [ebp+argv]
		lea	esi, [ecx+edx]
		mov	edx, ds:optind
		mov	ecx, [ebx]
		sub	ecx, edx
		sub	esp, 0Ch
		lea	edx, [ebp+x]
		push	edx		; x
		push	eax		; no_target_directory
		push	[ebp+target_directory] ; target_directory
		push	esi		; file
		push	ecx		; n_files
		call	do_copy
		add	esp, 20h
		mov	[ebp+ok], al
		call	forget_all
		cmp	[ebp+ok], 0
		jz	short loc_8001F0E
		mov	eax, 0
		jmp	short loc_8001F13
; ---------------------------------------------------------------------------

loc_8001F0E:				; CODE XREF: main+71Ej
		mov	eax, 1

loc_8001F13:				; CODE XREF: main+725j
		sub	esp, 0Ch
		push	eax		; status

loc_8001F17:				; DATA XREF: .eh_frame:08003D9Co
					; .eh_frame:08003DC0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8001F20h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	selinux_enabled
selinux_enabled	db ?			; DATA XREF: decode_preserve_arg+11Dr
					; main+B1w ...
; _Bool	parents_option
parents_option	db ?			; DATA XREF: do_copy:loc_8001099r
					; do_copy+4E0r	...
; _Bool	remove_trailing_slashes
remove_trailing_slashes	db ?		; DATA XREF: do_copy+260r
					; main:loc_8001B0Ew
		align 20h
; Function-local static	variable
; cp_options x_tmp_5550
x_tmp_5550	cp_options <?>		; DATA XREF: do_copy+66Aw do_copy+6EDw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8001F80h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+84o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+487o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aNever		db 'never',0            ; DATA XREF: .rodata:sparse_type_stringo
aAuto		db 'auto',0             ; DATA XREF: .rodata:sparse_type_stringo
					; .rodata:reflink_type_stringo
aAlways		db 'always',0           ; DATA XREF: .rodata:sparse_type_stringo
					; .rodata:reflink_type_stringo
		align 4
; const	char *const sparse_type_string[4]
sparse_type_string dd offset aNever, offset aAuto, offset aAlways, 0 ; DATA XREF: main+11Ao
					; "never"
; const	Sparse_type sparse_type[3]
sparse_type	dd SPARSE_NEVER, SPARSE_AUTO, SPARSE_ALWAYS ; DATA XREF: main+115o
					; main+12Dr
; const	char *const reflink_type_string[3]
reflink_type_string dd offset aAuto, offset aAlways, 0 ; DATA XREF: main+16Do
					; "auto"
; const	Reflink_type reflink_type[2]
reflink_type	dd REFLINK_AUTO, REFLINK_ALWAYS	; DATA XREF: main+168o
					; main+180r
aArchive	db 'archive',0          ; DATA XREF: .rodata:long_optso
aBackup		db 'backup',0           ; DATA XREF: .rodata:long_optso
aCopyContents	db 'copy-contents',0    ; DATA XREF: .rodata:long_optso
aDereference	db 'dereference',0      ; DATA XREF: .rodata:long_optso
aForce		db 'force',0            ; DATA XREF: .rodata:long_optso
aInteractive	db 'interactive',0      ; DATA XREF: .rodata:long_optso
aLink		db 'link',0             ; DATA XREF: .rodata:long_optso
aNoClobber	db 'no-clobber',0       ; DATA XREF: .rodata:long_optso
aNoDereference	db 'no-dereference',0   ; DATA XREF: .rodata:long_optso
aNoPreserve	db 'no-preserve',0      ; DATA XREF: .rodata:long_optso
aNoTargetDirect	db 'no-target-directory',0 ; DATA XREF: .rodata:long_optso
aOneFileSystem	db 'one-file-system',0  ; DATA XREF: .rodata:long_optso
aParents	db 'parents',0          ; DATA XREF: .rodata:long_optso
aPath		db 'path',0             ; DATA XREF: .rodata:long_optso
aPreserve_0	db 'preserve',0         ; DATA XREF: .rodata:long_optso
aRecursive	db 'recursive',0        ; DATA XREF: .rodata:long_optso
aRemoveDestinat	db 'remove-destination',0 ; DATA XREF: .rodata:long_optso
aSparse_0	db 'sparse',0           ; DATA XREF: .rodata:long_optso
aReflink_0	db 'reflink',0          ; DATA XREF: .rodata:long_optso
aStripTrailingS	db 'strip-trailing-slashes',0 ; DATA XREF: .rodata:long_optso
aSuffix		db 'suffix',0           ; DATA XREF: .rodata:long_optso
aSymbolicLink	db 'symbolic-link',0    ; DATA XREF: .rodata:long_optso
aTargetDirector	db 'target-directory',0 ; DATA XREF: .rodata:long_optso
aUpdate		db 'update',0           ; DATA XREF: .rodata:long_optso
aVerbose	db 'verbose',0          ; DATA XREF: .rodata:long_optso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optso
		align 10h
; const	option long_opts[28]
long_opts	option <offset aArchive, 0, 0, 61h> ; DATA XREF: main+4B3o
		option <offset aBackup,	2, 0, 62h> ; "archive"
		option <offset aCopyContents, 0, 0, 80h>
		option <offset aDereference, 0,	0, 4Ch>
		option <offset aForce, 0, 0, 66h>
		option <offset aInteractive, 0,	0, 69h>
		option <offset aLink, 0, 0, 6Ch>
		option <offset aNoClobber, 0, 0, 6Eh>
		option <offset aNoDereference, 0, 0, 50h>
		option <offset aNoPreserve, 1, 0, 81h>
		option <offset aNoTargetDirect,	0, 0, 54h>
		option <offset aOneFileSystem, 0, 0, 78h>
		option <offset aParents, 0, 0, 82h>
		option <offset aPath, 0, 0, 82h>
		option <offset aPreserve_0, 2, 0, 83h>
		option <offset aRecursive, 0, 0, 52h>
		option <offset aRemoveDestinat,	0, 0, 87h>
		option <offset aSparse_0, 1, 0,	85h>
		option <offset aReflink_0, 2, 0, 84h>
		option <offset aStripTrailingS,	0, 0, 86h>
		option <offset aSuffix,	1, 0, 53h>
		option <offset aSymbolicLink, 0, 0, 73h>
		option <offset aTargetDirector,	1, 0, 74h>
		option <offset aUpdate,	0, 0, 75h>
		option <offset aVerbose, 0, 0, 76h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [-T] SOURCE DEST',0Ah ; DATA XREF: usage+54o
		db '  or:  %s [OPTION]... SOURCE... DIRECTORY',0Ah
		db '  or:  %s [OPTION]... -t DIRECTORY SOURCE...',0Ah,0
		align 4
; char aCopySourceToDe[]
aCopySourceToDe	db 'Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.',0Ah
					; DATA XREF: usage+76o
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+99o
		db 'ns too.',0Ah,0
		align 10h
; char aAArchiveSameAs[]
aAArchiveSameAs	db '  -a, --archive                same as -dR --preserve=all',0Ah
					; DATA XREF: usage+BCo
		db '      --backup[=CONTROL]       make a backup of each existing des'
		db 'tination file',0Ah
		db '  -b                           like --backup but does not accept '
		db 'an argument',0Ah
		db '      --copy-contents          copy contents of special files whe'
		db 'n recursive',0Ah
		db '  -d                           same as --no-dereference --preserv'
		db 'e=links',0Ah,0
		align 10h
; char aFForceIfAnExis[]
aFForceIfAnExis	db '  -f, --force                  if an existing destination file ca'
					; DATA XREF: usage+DFo
		db 'nnot be',0Ah
		db '                                 opened, remove it and try again '
		db '(redundant if',0Ah
		db '                                 the -n option is used)',0Ah
		db '  -i, --interactive            prompt before overwrite (overrides'
		db ' a previous -n',0Ah
		db '                                  option)',0Ah
		db '  -H                           follow command-line symbolic links'
		db ' in SOURCE',0Ah,0
		align 4
; char aLLinkLinkFiles[]
aLLinkLinkFiles	db '  -l, --link                   link files instead of copying',0Ah
					; DATA XREF: usage+102o
		db '  -L, --dereference            always follow symbolic links in SO'
		db 'URCE',0Ah,0
; char aNNoClobberDoNo[]
aNNoClobberDoNo	db '  -n, --no-clobber             do not overwrite an existing file '
					; DATA XREF: usage+125o
		db '(overrides',0Ah
		db '                                 a previous -i option)',0Ah
		db '  -P, --no-dereference         never follow symbolic links in SOU'
		db 'RCE',0Ah,0
		align 4
; char aPSameAsPreserv[]
aPSameAsPreserv	db '  -p                           same as --preserve=mode,ownership,'
					; DATA XREF: usage+148o
		db 'timestamps',0Ah
		db '      --preserve[=ATTR_LIST]   preserve the specified attributes '
		db '(default:',0Ah
		db '                                 mode,ownership,timestamps), if p'
		db 'ossible',0Ah
		db '                                 additional attributes: context, '
		db 'links, xattr,',0Ah
		db '                                 all',0Ah,0
		align 10h
; char aNoPreserveAttr[]
aNoPreserveAttr	db '      --no-preserve=ATTR_LIST  don',27h,'t preserve the specified at'
					; DATA XREF: usage+16Bo
		db 'tributes',0Ah
		db '      --parents                use full source file name under DI'
		db 'RECTORY',0Ah,0
		align 4
; char aRRRecursiveCop[]
aRRRecursiveCop	db '  -R, -r, --recursive          copy directories recursively',0Ah
					; DATA XREF: usage+18Eo
		db '      --reflink[=WHEN]         control clone/CoW copies. See belo'
		db 'w.',0Ah
		db '      --remove-destination     remove each existing destination f'
		db 'ile before',0Ah
		db '                                 attempting to open it (contrast '
		db 'with --force)',0Ah,0
; char aSparseWhenCont[]
aSparseWhenCont	db '      --sparse=WHEN            control creation of sparse files. '
					; DATA XREF: usage+1B1o
		db 'See below.',0Ah
		db '      --strip-trailing-slashes  remove any trailing slashes from '
		db 'each SOURCE',0Ah
		db '                                 argument',0Ah,0
; char aSSymbolicLinkM[]
aSSymbolicLinkM	db '  -s, --symbolic-link          make symbolic links instead of cop'
					; DATA XREF: usage+1D4o
		db 'ying',0Ah
		db '  -S, --suffix=SUFFIX          override the usual backup suffix',0Ah
		db '  -t, --target-directory=DIRECTORY  copy all SOURCE arguments int'
		db 'o DIRECTORY',0Ah
		db '  -T, --no-target-directory    treat DEST as a normal file',0Ah,0
		align 4
; char aUUpdateCopyOnl[]
aUUpdateCopyOnl	db '  -u, --update                 copy only when the SOURCE file is '
					; DATA XREF: usage+1F7o
		db 'newer',0Ah
		db '                                 than the destination file or whe'
		db 'n the',0Ah
		db '                                 destination file is missing',0Ah
		db '  -v, --verbose                explain what is being done',0Ah
		db '  -x, --one-file-system        stay on this file system',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+21Ao
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+23Do
		align 4
; char aByDefaultSpars[]
aByDefaultSpars	db 0Ah			; DATA XREF: usage+260o
		db 'By default, sparse SOURCE files are detected by a crude heuristic'
		db ' and the',0Ah
		db 'corresponding DEST file is made sparse as well.  That is the beha'
		db 'vior',0Ah
		db 'selected by --sparse=auto.  Specify --sparse=always to create a s'
		db 'parse DEST',0Ah
		db 'file whenever the SOURCE file contains a long enough sequence of '
		db 'zero bytes.',0Ah
		db 'Use --sparse=never to inhibit creation of sparse files.',0Ah
		db 0Ah
		db 'When --reflink[=always] is specified, perform a lightweight copy,'
		db ' where the',0Ah
		db 'data blocks are copied only when modified.  If this is not possib'
		db 'le the copy',0Ah
		db 'fails, or if --reflink=auto is specified, fall back to a standard'
		db ' copy.',0Ah,0
		align 4
; char aTheBackupSuffi[]
aTheBackupSuffi	db 0Ah			; DATA XREF: usage+283o
		db 'The backup suffix is `~',27h,', unless set with --suffix or SIMPLE_B'
		db 'ACKUP_SUFFIX.',0Ah
		db 'The version control method may be selected via the --backup optio'
		db 'n or through',0Ah
		db 'the VERSION_CONTROL environment variable.  Here are the values:',0Ah
		db 0Ah,0
		align 4
; char aNoneOffNeverMa[]
aNoneOffNeverMa	db '  none, off       never make backups (even if --backup is given)',0Ah
					; DATA XREF: usage+2A6o
		db '  numbered, t     make numbered backups',0Ah
		db '  existing, nil   numbered if numbered backups exist, simple othe'
		db 'rwise',0Ah
		db '  simple, never   always make simple backups',0Ah,0
		align 4
; char aAsASpecialCase[]
aAsASpecialCase	db 0Ah			; DATA XREF: usage+2C9o
		db 'As a special case, cp makes a backup of SOURCE when the force and'
		db ' backup',0Ah
		db 'options are given and SOURCE and DEST are the same name for an ex'
		db 'isting,',0Ah
		db 'regular file.',0Ah,0
		align 4
; char aFailedToPreser[]
aFailedToPreser	db 'failed to preserve times for %s',0 ; DATA XREF: re_protect+11Fo
; char aFailedToPres_0[]
aFailedToPres_0	db 'failed to preserve ownership for %s',0 ; DATA XREF: re_protect+1A3o
; char aFailedToPres_1[]
aFailedToPres_1	db 'failed to preserve permissions for %s',0 ; DATA XREF: re_protect+25Fo
		align 4
; char aFailedToGetAtt[]
aFailedToGetAtt	db 'failed to get attributes of %s',0
					; DATA XREF: make_dir_parents_private+268o
					; make_dir_parents_private+432o
; char aCannotMakeDire[]
aCannotMakeDire	db 'cannot make directory %s',0 ; DATA XREF: make_dir_parents_private+3ADo
; char aSettingPermiss[]
aSettingPermiss	db 'setting permissions for %s',0 ; DATA XREF: make_dir_parents_private+525o
		align 4
; char aSExistsButIsNo[]
aSExistsButIsNo	db '%s exists but is not a directory',0
					; DATA XREF: make_dir_parents_private+57Ao
					; make_dir_parents_private+620o
; char aAccessingS[]
aAccessingS	db 'accessing %s',0     ; DATA XREF: target_directory_operand+77o
					; main+39Co
; char aMissingFileOpe[]
aMissingFileOpe	db 'missing file operand',0 ; DATA XREF: do_copy+62o
		align 4
; char aMissingDestina[]
aMissingDestina	db 'missing destination file operand after %s',0 ; DATA XREF: do_copy+9Ao
		align 4
; char aCannotCombineT[]
aCannotCombineT	db 'cannot combine --target-directory (-t) and --no-target-directory '
					; DATA XREF: do_copy+D4o
		db '(-T)',0
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: do_copy+117o
; char aTargetSIsNotAD[]
aTargetSIsNotAD	db 'target %s is not a directory',0 ; DATA XREF: do_copy+1D3o
					; main+3E4o
; char verbose_fmt_string[]
verbose_fmt_string db '%s -> %s',0Ah,0  ; DATA XREF: do_copy+34Co
; char a__[]
a__		db '..',0               ; DATA XREF: do_copy+43Bo
		align 4
; char aWithParentsThe[]
aWithParentsThe	db 'with --parents, the destination must be a directory',0
					; DATA XREF: do_copy+5BEo
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: cp_option_init+E3o
aPreserve	db '--preserve',0       ; DATA XREF: decode_preserve_arg+60o
		align 4
off_80036BC	dd offset loc_8001713	; DATA XREF: decode_preserve_arg+87o
		dd offset loc_8001722	; jump table for switch	statement
		dd offset loc_8001731
		dd offset loc_8001740
		dd offset loc_800174C
		dd offset loc_8001762
		dd offset loc_8001778
; char locale
locale		db 0			; DATA XREF: main+6Do
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+7Fo
; char aSimple_backup_[]
aSimple_backup_	db 'SIMPLE_BACKUP_SUFFIX',0 ; DATA XREF: main+CDo
aSparse		db '--sparse',0         ; DATA XREF: main+120o
aReflink	db '--reflink',0        ; DATA XREF: main+173o
		align 4
; char aMultipleTarget[]
aMultipleTarget	db 'multiple target directories specified',0 ; DATA XREF: main+34Bo
aTorbjRnGranlun	db 'Torbjörn Granlund',0 ; DATA XREF: main+45Ao
aTorbjornGranlu	db 'Torbjorn Granlund',0 ; DATA XREF: main+45Fo
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+47Bo
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+480o
aCp		db 'cp',0               ; DATA XREF: main+48Co
; char shortopts[]
shortopts	db 'abdfHilLnprst:uvxPRS:T',0 ; DATA XREF: main+4B8o
		align 10h
; char aCannotMakeBoth[]
aCannotMakeBoth	db 'cannot make both hard and symbolic links',0 ; DATA XREF: main+4F9o
		align 4
; char aOptionsBackupA[]
aOptionsBackupA	db 'options --backup and --no-clobber are mutually exclusive',0
					; DATA XREF: main+537o
		align 4
; char aReflinkCanBeUs[]
aReflinkCanBeUs	db '--reflink can be used only with --sparse=auto',0 ; DATA XREF: main+577o
; char aBackupType[]
aBackupType	db 'backup type',0      ; DATA XREF: main+5C9o
		align 4
; char aCannotPreserve[]
aCannotPreserve	db 'cannot preserve security context without an SELinux-enabled kerne'
					; DATA XREF: main+67Do
		db 'l',0
		align 4
; char aCannotPreser_0[]
aCannotPreser_0	db 'cannot preserve extended attributes, cp is built without xattr su'
					; DATA XREF: main+6A8o
		db 'pport',0
		align 10h
off_80038D0	dd offset loc_8001C3E, offset loc_8001C34, offset loc_8001C8B
					; DATA XREF: main+FBr
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B ;	jump table for switch statement
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001A24
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001A4E, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001A6C, offset loc_8001C8B
		dd offset loc_8001AF6, offset loc_8001C20, offset loc_8001BF6
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001979, offset loc_80019D2, offset loc_8001C8B
		dd offset loc_8001A02, offset loc_8001C8B, offset loc_8001A18
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001A33
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001A42
		dd offset loc_8001C8B, offset loc_8001A5D, offset loc_8001C8B
		dd offset loc_8001AC9, offset loc_8001C8B, offset loc_8001AF6
		dd offset loc_8001B1A, offset loc_8001B26, offset loc_8001C02
		dd offset loc_8001C0E, offset loc_8001C8B, offset loc_8001C17
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_8001C8B, offset loc_8001C8B
		dd offset loc_8001C8B, offset loc_80019F6, offset loc_8001A7B
		dd offset loc_8001AEA, offset loc_8001A9A, offset loc_8001926
		dd offset loc_80018EB, offset loc_8001B0E, offset loc_8001B02
aMode		db 'mode',0             ; DATA XREF: .rodata:preserve_args_5568o
aTimestamps	db 'timestamps',0       ; DATA XREF: .rodata:08003D44o
aOwnership	db 'ownership',0        ; DATA XREF: .rodata:08003D48o
aLinks		db 'links',0            ; DATA XREF: .rodata:08003D4Co
aContext	db 'context',0          ; DATA XREF: .rodata:08003D50o
aXattr		db 'xattr',0            ; DATA XREF: .rodata:08003D54o
aAll		db 'all',0              ; DATA XREF: .rodata:08003D58o
		align 20h
; Function-local static	variable
; const	char *const preserve_args_5568[8]
preserve_args_5568 dd offset aMode	; DATA XREF: decode_preserve_arg+58o
					; "mode"
		dd offset aTimestamps	; "timestamps"
		dd offset aOwnership	; "ownership"
		dd offset aLinks	; "links"
		dd offset aContext	; "context"
		dd offset aXattr	; "xattr"
		dd offset aAll		; "all"
		align 10h
; Function-local static	variable
; const	decode_preserve_arg::File_attribute preserve_vals_5567[7]
preserve_vals_5567 dd 0			; DATA XREF: decode_preserve_arg+53o
					; decode_preserve_arg+6Dr
		dd 1, 2, 3, 4, 5, 6
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8003D7Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8001F17-8005CB3h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	40h
		dd offset loc_8001F17-8005BBBh
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 60h
		dd offset loc_8001F17-8005BD5h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 80h
		dd offset loc_8001F17-8005BDAh
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 1Ch, 0A0h
		dd offset loc_8001F17-8005BDFh
		dd 2F3h, 80E4100h, 0D420285h, 3874605h,	5830486h, 28h
		dd 0C0h
		dd offset loc_8001F17-800590Ch
		dd 2C7h, 80E4100h, 0D420285h, 3864505h,	0BC030483h, 0C641C302h
		dd 40CC541h, 4,	2Ch, 0ECh
		dd offset loc_8001F17-8005671h
		dd 669h, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3065903h
		dd 0C741C641h, 40CC541h, 4, 20h, 11Ch
		dd offset loc_8001F17-8005038h
		dd 0A2h, 80E4100h, 0D420285h, 3834405h,	0C3C59A02h, 4040Ch
		dd 20h,	140h
		dd offset loc_8001F17-8004FBAh
		dd 754h, 80E4100h, 0D420285h, 3834705h,	0C5074903h, 4040CC3h
		dd 1Ch,	164h
		dd offset loc_8001F17-800488Ah
		dd 112h, 80E4100h, 0D420285h, 10E0305h,	4040CC5h, 1Ch
		dd 184h
		dd offset loc_8001F17-8004798h
		dd 164h, 80E4100h, 0D420285h, 1600305h,	4040CC5h, 2Ch
		dd 1A4h
		dd offset loc_8001F17-8004654h
		dd 735h, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+6Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+88p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+74p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+2EEp main+49Fp ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: re_protect+31p
					; make_dir_parents_private+59p	...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: re_protect+7Ap
					; make_dir_parents_private+B4p	...
		extrn utimens:near	; CODE XREF: re_protect+100p
		extrn quote:near	; CODE XREF: re_protect+112p
					; re_protect+196p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: re_protect+12Ep
					; re_protect+1B2p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: re_protect+13Ap
					; re_protect+1BEp ...
; int lchown(const char	*file, __uid_t owner, __gid_t group)
		extrn lchown:near	; CODE XREF: re_protect+16Fp
					; re_protect+1DFp
		extrn chown_failure_ok:near ; CODE XREF: re_protect+181p
		extrn copy_acl:near	; CODE XREF: re_protect+212p
; int chmod(const char *file, __mode_t mode)
		extrn chmod:near	; CODE XREF: re_protect+240p
					; make_dir_parents_private+4FFp
		extrn __stack_chk_fail:near ; CODE XREF: re_protect+2BBp
					; make_dir_parents_private+65Cp ...
		extrn dir_len:near	; CODE XREF: make_dir_parents_private+DCp
		extrn stat64:near	; CODE XREF: make_dir_parents_private+16Cp
					; make_dir_parents_private+1BCp ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: make_dir_parents_private+296p
; int mkdir(const char *path, __mode_t mode)
		extrn mkdir:near	; CODE XREF: make_dir_parents_private+38Bp
		extrn lstat64:near	; CODE XREF: make_dir_parents_private+410p
		extrn cached_umask:near	; CODE XREF: make_dir_parents_private+482p
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: make_dir_parents_private+5DBp
					; decode_preserve_arg+2Bp
		extrn dest_info_init:near ; CODE XREF: do_copy+20Ap
		extrn src_info_init:near ; CODE	XREF: do_copy+21Bp
		extrn strip_trailing_slashes:near ; CODE XREF: do_copy+274p
					; do_copy+312p	...
		extrn file_name_concat:near ; CODE XREF: do_copy+330p
					; do_copy+470p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: do_copy+443p do_copy+610p
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: do_copy+458p
					; decode_preserve_arg+12p ...
		extrn copy:near		; CODE XREF: do_copy+4C1p do_copy+729p
; void free(void *ptr)
		extrn free:near		; CODE XREF: do_copy+55Bp do_copy+576p ...
		extrn find_backup_file_name:near ; CODE	XREF: do_copy+654p
		extrn cp_options_default:near ;	CODE XREF: cp_option_init+Cp
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: cp_option_init+E8p
					; main+D2p
		extrn argmatch_die:dword ; DATA	XREF: decode_preserve_arg:loc_80016CBr
					; main:loc_80018EBr ...
		extrn __xargmatch_internal:near	; CODE XREF: decode_preserve_arg+65p
					; main+125p ...
; void abort(void)
		extrn abort:near	; CODE XREF: decode_preserve_arg:loc_80017C1p
		extrn set_program_name:near ; CODE XREF: main+62p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+89p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+99p
; void close_stdin(void)
		extrn close_stdin	; DATA XREF: main+A4o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+A9p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+10Ar
					; main:loc_8001926r ...
		extrn proper_name_utf8:near ; CODE XREF: main+464p
		extrn Version:dword	; DATA XREF: main+46Er
		extrn version_etc:near	; CODE XREF: main+492p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+4C5p
		extrn simple_backup_suffix:dword ; DATA	XREF: main+5B8w
		extrn xget_version:near	; CODE XREF: main+5E0p
		extrn hash_init:near	; CODE XREF: main:loc_8001EACp
; int optind
		extrn optind:dword	; DATA XREF: main+6D1r	main+6E7r
		extrn forget_all:near	; CODE XREF: main+712p


		end
