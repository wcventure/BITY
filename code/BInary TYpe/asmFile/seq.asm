;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6F5AA0450EA1B2216EE1D88E6D1E08A3
; Input	CRC32 :	7CB25E7D

; File Name   :	D:\coreutils-o\seq.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'seq.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: scan_arg+7Dp

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+11Cp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: scan_arg+60p main+199p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0Ch
		cmp	[ebp+status], 0
		jz	short loc_800016D
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800024F
; ---------------------------------------------------------------------------

loc_800016D:				; CODE XREF: usage+Dj
		mov	edi, ds:program_name
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	LAST\n	or:  %s	["...
		call	gettext
		add	esp, 10h
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintNumbersFr ; "Print	numbers	from FIRST to LAST, in st"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfFirstOrIncre ; "\nIf FIRST or	INCREMENT is omitted, it "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFormatMustBeSu ; "FORMAT must be suitable for printing on"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800024F:				; CODE XREF: usage+3Aj
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; operand_0 *scan_arg(operand_0	*__return_ptr __struct_ptr retstr, const char *arg)
scan_arg	proc near		; CODE XREF: main+2BFp	main+319p ...

arg		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
e		= dword	ptr -38h
decimal_point	= dword	ptr -34h
fraction_len	= dword	ptr -30h
exponent	= dword	ptr -2Ch
ret		= operand_0 ptr	-28h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
retstr		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+retstr]
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+arg], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		push	offset c_strtold
		lea	eax, [ebp+ret]
		push	eax
		push	0
		push	[ebp+arg]
		call	xstrtold
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80002C3
		sub	esp, 0Ch
		push	offset aInvalidFloatin ; "invalid floating point argument: %s"
		call	gettext
		add	esp, 10h
		push	[ebp+arg]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80002BF:				; CODE XREF: scan_arg+99j scan_arg+A3j
		add	[ebp+arg], 1

loc_80002C3:				; CODE XREF: scan_arg+39j
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 2000h
		test	eax, eax
		jnz	short loc_80002BF
		mov	eax, [ebp+arg]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jz	short loc_80002BF
		sub	esp, 0Ch
		push	[ebp+arg]	; s
		call	strlen
		add	esp, 10h
		mov	[ebp+ret.width], eax
		mov	[ebp+ret.precision], 7FFFFFFFh
		sub	esp, 8
		push	offset reject	; "xX"
		push	[ebp+arg]	; s
		call	strcspn
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+arg]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000448
		fld	[ebp+ret.value.value]
		fldz
		fmulp	st(1), st
		fldz
		fucomip	st, st(1)
		jp	loc_8000446
		fldz
		fucomip	st, st(1)
		fstp	st
		jnz	loc_8000448
		sub	esp, 8
		push	2Eh		; c
		push	[ebp+arg]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+decimal_point], eax
		cmp	[ebp+decimal_point], 0
		jnz	short loc_800037B
		mov	[ebp+ret.precision], 0
		jmp	short loc_80003DF
; ---------------------------------------------------------------------------

loc_800037B:				; CODE XREF: scan_arg+116j
		mov	eax, [ebp+decimal_point]
		add	eax, 1
		sub	esp, 8
		push	offset aEe	; "eE"
		push	eax		; s
		call	strcspn
		add	esp, 10h
		mov	[ebp+fraction_len], eax
		mov	eax, [ebp+fraction_len]
		test	eax, eax
		js	short loc_80003A2
		mov	eax, [ebp+fraction_len]
		mov	[ebp+ret.precision], eax

loc_80003A2:				; CODE XREF: scan_arg+140j
		mov	edx, [ebp+ret.width]
		cmp	[ebp+fraction_len], 0
		jz	short loc_80003D5
		mov	eax, [ebp+decimal_point]
		cmp	eax, [ebp+arg]
		jz	short loc_80003C7
		mov	eax, [ebp+decimal_point]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_80003CE

loc_80003C7:				; CODE XREF: scan_arg+157j
		mov	eax, 1
		jmp	short loc_80003DA
; ---------------------------------------------------------------------------

loc_80003CE:				; CODE XREF: scan_arg+16Bj
		mov	eax, 0
		jmp	short loc_80003DA
; ---------------------------------------------------------------------------

loc_80003D5:				; CODE XREF: scan_arg+14Fj
		mov	eax, 0FFFFFFFFh

loc_80003DA:				; CODE XREF: scan_arg+172j
					; scan_arg+179j
		add	eax, edx
		mov	[ebp+ret.width], eax

loc_80003DF:				; CODE XREF: scan_arg+11Fj
		sub	esp, 8
		push	65h		; c
		push	[ebp+arg]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+e], eax
		cmp	[ebp+e], 0
		jnz	short loc_800040B
		sub	esp, 8
		push	45h		; c
		push	[ebp+arg]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+e], eax

loc_800040B:				; CODE XREF: scan_arg+19Cj
		cmp	[ebp+e], 0
		jz	short loc_8000448
		mov	eax, [ebp+e]
		add	eax, 1
		sub	esp, 4
		push	0Ah		; base
		push	0		; endptr
		push	eax		; nptr
		call	strtol
		add	esp, 10h
		mov	[ebp+exponent],	eax
		mov	edx, [ebp+ret.precision]
		cmp	[ebp+exponent],	0
		jns	short loc_800043A
		mov	eax, [ebp+exponent]
		neg	eax
		jmp	short loc_800043F
; ---------------------------------------------------------------------------

loc_800043A:				; CODE XREF: scan_arg+1D7j
		mov	eax, 0

loc_800043F:				; CODE XREF: scan_arg+1DEj
		add	eax, edx
		mov	[ebp+ret.precision], eax
		jmp	short loc_8000448
; ---------------------------------------------------------------------------

loc_8000446:				; CODE XREF: scan_arg+EDj
		fstp	st

loc_8000448:				; CODE XREF: scan_arg+DCj scan_arg+F9j ...
		mov	eax, [ebp+var_3C]
		mov	edx, dword ptr [ebp+ret.value.value]
		mov	[eax], edx
		mov	edx, dword ptr [ebp+ret.value.value+4]
		mov	[eax+4], edx
		mov	edx, dword ptr [ebp+ret.value.value+8]
		mov	[eax+8], edx
		mov	edx, [ebp+ret.width]
		mov	[eax+0Ch], edx
		mov	edx, [ebp+ret.precision]
		mov	[eax+10h], edx
		mov	eax, [ebp+var_3C]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800047C
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800047C:				; CODE XREF: scan_arg+21Bj
		mov	ebx, [ebp+var_4]
		leave
		retn	4
scan_arg	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl long_double_format(const char *fmt, layout *layout)
long_double_format proc	near		; CODE XREF: main+290p

has_L		= byte ptr -21h
i		= dword	ptr -20h
prefix_len	= dword	ptr -1Ch
suffix_len	= dword	ptr -18h
length_modifier_offset=	dword ptr -14h
format_size	= dword	ptr -10h
ldfmt		= dword	ptr -0Ch
fmt		= dword	ptr  8
layout		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	[ebp+prefix_len], 0
		mov	[ebp+suffix_len], 0
		mov	[ebp+i], 0
		jmp	short loc_8000501
; ---------------------------------------------------------------------------

loc_80004A2:				; CODE XREF: long_double_format+8Bj
					; long_double_format+9Dj
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80004DF
		sub	esp, 0Ch
		push	[ebp+fmt]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFormatSHasNoDi ; "format %s has	no %% directive"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80004DF:				; CODE XREF: long_double_format+2Cj
		add	[ebp+prefix_len], 1
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_80004F9
		mov	eax, 2
		jmp	short loc_80004FE
; ---------------------------------------------------------------------------

loc_80004F9:				; CODE XREF: long_double_format+6Dj
		mov	eax, 1

loc_80004FE:				; CODE XREF: long_double_format+74j
		add	[ebp+i], eax

loc_8000501:				; CODE XREF: long_double_format+1Dj
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_80004A2
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+fmt]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jz	short loc_80004A2
		add	[ebp+i], 1
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		sub	esp, 8
		push	offset accept	; "-+#0	'"
		push	eax		; s
		call	strspn
		add	esp, 10h
		add	[ebp+i], eax
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		sub	esp, 8
		push	offset a0123456789 ; "0123456789"
		push	eax		; s
		call	strspn
		add	esp, 10h
		add	[ebp+i], eax
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	short loc_800058D
		add	[ebp+i], 1
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		sub	esp, 8
		push	offset a0123456789 ; "0123456789"
		push	eax		; s
		call	strspn
		add	esp, 10h
		add	[ebp+i], eax

loc_800058D:				; CODE XREF: long_double_format+E8j
		mov	eax, [ebp+i]
		mov	[ebp+length_modifier_offset], eax
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 4Ch
		setz	al
		mov	[ebp+has_L], al
		movzx	eax, [ebp+has_L]
		add	[ebp+i], eax
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80005EA
		sub	esp, 0Ch
		push	[ebp+fmt]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFormatSEndsIn ;	"format	%s ends	in %%"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80005EA:				; CODE XREF: long_double_format+137j
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset s	; "efgaEFGA"
		call	strchr
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800064D
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	ebx, al
		sub	esp, 0Ch
		push	[ebp+fmt]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFormatSHasUnkn ; "format %s has	unknown	%%%c directive"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_800064D:				; CODE XREF: long_double_format+188j
		add	[ebp+i], 1

loc_8000651:				; CODE XREF: long_double_format+2CEj
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_80006A5
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+fmt]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jz	short loc_80006A5
		sub	esp, 0Ch
		push	[ebp+fmt]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFormatSHasTooM ; "format %s has	too many %% directives"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000733
; ---------------------------------------------------------------------------

loc_80006A5:				; CODE XREF: long_double_format+1DBj
					; long_double_format+1EDj
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80006BA
		add	[ebp+suffix_len], 1
		jmp	short loc_8000733
; ---------------------------------------------------------------------------

loc_80006BA:				; CODE XREF: long_double_format+22Fj
		mov	eax, [ebp+i]
		add	eax, 1
		mov	[ebp+format_size], eax
		mov	eax, [ebp+format_size]
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+ldfmt], eax
		sub	esp, 4
		push	[ebp+length_modifier_offset] ; n
		push	[ebp+fmt]	; src
		push	[ebp+ldfmt]	; dest
		call	memcpy
		add	esp, 10h
		mov	edx, [ebp+ldfmt]
		mov	eax, [ebp+length_modifier_offset]
		add	eax, edx
		mov	byte ptr [eax],	4Ch
		movzx	edx, [ebp+has_L]
		mov	eax, [ebp+length_modifier_offset]
		add	edx, eax
		mov	eax, [ebp+fmt]
		add	edx, eax
		mov	eax, [ebp+length_modifier_offset]
		lea	ecx, [eax+1]
		mov	eax, [ebp+ldfmt]
		add	eax, ecx
		sub	esp, 8
		push	edx		; src
		push	eax		; dest
		call	strcpy
		add	esp, 10h
		mov	eax, [ebp+layout]
		mov	edx, [ebp+prefix_len]
		mov	[eax], edx
		mov	eax, [ebp+layout]
		mov	edx, [ebp+suffix_len]
		mov	[eax+4], edx
		mov	eax, [ebp+ldfmt]
		jmp	short loc_8000756
; ---------------------------------------------------------------------------

loc_8000733:				; CODE XREF: long_double_format+21Dj
					; long_double_format+235j
		mov	edx, [ebp+fmt]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_8000749
		mov	eax, 2
		jmp	short loc_800074E
; ---------------------------------------------------------------------------

loc_8000749:				; CODE XREF: long_double_format+2BDj
		mov	eax, 1

loc_800074E:				; CODE XREF: long_double_format+2C4j
		add	[ebp+i], eax
		jmp	loc_8000651
; ---------------------------------------------------------------------------

loc_8000756:				; CODE XREF: long_double_format+2AEj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
long_double_format endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_numbers(const char	*fmt, layout layout, long double first,	long double step, long double last)
print_numbers	proc near		; CODE XREF: main+476p

fmt		= dword	ptr -5Ch
out_of_range	= byte ptr -56h
print_extra_number= byte ptr -55h
x_str		= dword	ptr -54h
x0_str		= dword	ptr -50h
x_strlen	= dword	ptr -4Ch
x_val		= LONG_DOUBLE_12 ptr -48h
x		= LONG_DOUBLE_12 ptr -38h
i		= LONG_DOUBLE_12 ptr -28h
x0		= LONG_DOUBLE_12 ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
layout		= layout ptr  0Ch
first		= LONG_DOUBLE_12 ptr  14h
step		= LONG_DOUBLE_12 ptr  20h
last		= LONG_DOUBLE_12 ptr  2Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 68h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fmt], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		fldz
		fld	[ebp+step.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_8000792
		fld	[ebp+last.value]
		fld	[ebp+first.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		setnbe	al
		jmp	short loc_80007A1
; ---------------------------------------------------------------------------

loc_8000792:				; CODE XREF: print_numbers+22j
		fld	[ebp+first.value]
		fld	[ebp+last.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		setnbe	al

loc_80007A1:				; CODE XREF: print_numbers+33j
		mov	[ebp+out_of_range], al
		movzx	eax, [ebp+out_of_range]
		xor	eax, 1
		test	al, al
		jz	loc_8000973
		fld	[ebp+first.value]
		fstp	[ebp+x.value]
		fld1
		fstp	[ebp+i.value]

loc_80007BE:				; CODE XREF: print_numbers+1FAj
		fld	[ebp+x.value]
		fstp	[ebp+x0.value]
		push	dword ptr [ebp+x.value+8]
		push	dword ptr [ebp+x.value+4]
		push	dword ptr [ebp+x.value]
		push	[ebp+fmt]	; format
		call	printf
		add	esp, 10h
		cmp	[ebp+out_of_range], 0
		jnz	loc_800095C
		fld	[ebp+i.value]
		fld	[ebp+step.value]
		fmulp	st(1), st
		fld	[ebp+first.value]
		faddp	st(1), st
		fstp	[ebp+x.value]
		fldz
		fld	[ebp+step.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_8000810
		fld	[ebp+last.value]
		fld	[ebp+x.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		setnbe	al
		jmp	short loc_800081F
; ---------------------------------------------------------------------------

loc_8000810:				; CODE XREF: print_numbers+A0j
		fld	[ebp+x.value]
		fld	[ebp+last.value]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		setnbe	al

loc_800081F:				; CODE XREF: print_numbers+B1j
		mov	[ebp+out_of_range], al
		cmp	[ebp+out_of_range], 0
		jz	loc_8000935
		mov	[ebp+print_extra_number], 0
		sub	esp, 8
		push	offset locale	; "C"
		push	1		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 0Ch
		push	dword ptr [ebp+x.value+8]
		push	dword ptr [ebp+x.value+4]
		push	dword ptr [ebp+x.value]
		push	[ebp+fmt]
		lea	eax, [ebp+x_str]
		push	eax
		call	rpl_asprintf
		add	esp, 20h
		mov	[ebp+x_strlen],	eax
		sub	esp, 8
		push	offset byte_80015EB ; locale
		push	1		; category
		call	setlocale
		add	esp, 10h
		cmp	[ebp+x_strlen],	0
		jns	short loc_800087D
		call	xalloc_die

loc_800087D:				; CODE XREF: print_numbers+119j
		mov	eax, [ebp+x_str]
		mov	ecx, [ebp+x_strlen]
		mov	edx, [ebp+layout.suffix_len]
		sub	ecx, edx
		mov	edx, ecx
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	edx, [ebp+x_str]
		mov	eax, [ebp+layout.prefix_len]
		add	edx, eax
		push	offset c_strtold
		lea	eax, [ebp+x_val]
		push	eax
		push	0
		push	edx
		call	xstrtold
		add	esp, 10h
		test	al, al
		jz	short loc_800091B
		fld	[ebp+x_val.value]
		fld	[ebp+last.value]
		fucomip	st, st(1)
		jp	short loc_8000919
		fld	[ebp+last.value]
		fucomip	st, st(1)
		fstp	st
		jnz	short loc_800091B
		mov	[ebp+x0_str], 0
		sub	esp, 0Ch
		push	dword ptr [ebp+x0.value+8]
		push	dword ptr [ebp+x0.value+4]
		push	dword ptr [ebp+x0.value]
		push	[ebp+fmt]
		lea	eax, [ebp+x0_str]
		push	eax
		call	rpl_asprintf
		add	esp, 20h
		test	eax, eax
		jns	short loc_80008ED
		call	xalloc_die

loc_80008ED:				; CODE XREF: print_numbers+189j
		mov	edx, [ebp+x_str]
		mov	eax, [ebp+x0_str]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+print_extra_number], al
		mov	eax, [ebp+x0_str]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		jmp	short loc_800091B
; ---------------------------------------------------------------------------

loc_8000919:				; CODE XREF: print_numbers+15Aj
		fstp	st

loc_800091B:				; CODE XREF: print_numbers+150j
					; print_numbers+163j ...
		mov	eax, [ebp+x_str]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+print_extra_number]
		xor	eax, 1
		test	al, al
		jnz	short loc_800095F

loc_8000935:				; CODE XREF: print_numbers+C9j
		mov	edx, ds:stdout
		mov	eax, ds:separator
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		fld	[ebp+i.value]
		fld1
		faddp	st(1), st
		fstp	[ebp+i.value]
		jmp	loc_80007BE
; ---------------------------------------------------------------------------

loc_800095C:				; CODE XREF: print_numbers+7Fj
		nop
		jmp	short loc_8000960
; ---------------------------------------------------------------------------

loc_800095F:				; CODE XREF: print_numbers+1D6j
		nop

loc_8000960:				; CODE XREF: print_numbers+200j
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax		; stream
		push	0Ah		; c
		call	fputc_unlocked
		add	esp, 10h

loc_8000973:				; CODE XREF: print_numbers+50j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000985
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000985:				; CODE XREF: print_numbers+221j
		leave
		retn
print_numbers	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl get_default_format(operand_0 first, operand_0 step, operand_0 last)
get_default_format proc	near		; CODE XREF: main+442p

last_width	= dword	ptr -1Ch
prec		= dword	ptr -18h
first_width	= dword	ptr -14h
width		= dword	ptr -10h
w		= dword	ptr -0Ch
first		= operand_0 ptr	 8
step		= operand_0 ptr	 1Ch
last		= operand_0 ptr	 30h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, [ebp+step.precision]
		mov	eax, [ebp+first.precision]
		cmp	edx, eax
		cmovge	eax, edx
		mov	[ebp+prec], eax
		cmp	[ebp+prec], 7FFFFFFFh
		jz	loc_8000A5F
		mov	eax, [ebp+last.precision]
		cmp	eax, 7FFFFFFFh
		jz	loc_8000A5F
		movzx	eax, ds:equal_width
		test	al, al
		jz	short loc_8000A40
		mov	eax, [ebp+first.width]
		mov	edx, [ebp+first.precision]
		mov	ecx, [ebp+prec]
		sub	ecx, edx
		mov	edx, ecx
		add	eax, edx
		mov	[ebp+first_width], eax
		mov	eax, [ebp+last.width]
		mov	edx, [ebp+last.precision]
		mov	ecx, [ebp+prec]
		sub	ecx, edx
		mov	edx, ecx
		add	eax, edx
		mov	[ebp+last_width], eax
		mov	eax, [ebp+last.precision]
		test	eax, eax
		jz	short loc_80009F6
		cmp	[ebp+prec], 0
		jnz	short loc_80009F6
		sub	[ebp+last_width], 1

loc_80009F6:				; CODE XREF: get_default_format+63j
					; get_default_format+69j
		mov	eax, [ebp+last.precision]
		test	eax, eax
		jnz	short loc_8000A07
		cmp	[ebp+prec], 0
		jz	short loc_8000A07
		add	[ebp+last_width], 1

loc_8000A07:				; CODE XREF: get_default_format+74j
					; get_default_format+7Aj
		mov	eax, [ebp+first_width]
		cmp	[ebp+last_width], eax
		cmovnb	eax, [ebp+last_width]
		mov	[ebp+width], eax
		mov	eax, [ebp+width]
		test	eax, eax
		js	short loc_8000A5F
		mov	eax, [ebp+width]
		mov	[ebp+w], eax
		push	[ebp+prec]
		push	[ebp+w]
		push	offset format	; "%%0%d.%dLf"
		push	offset format_buf_5163 ; s
		call	sprintf
		add	esp, 10h
		mov	eax, offset format_buf_5163
		jmp	short locret_8000A64
; ---------------------------------------------------------------------------

loc_8000A40:				; CODE XREF: get_default_format+38j
		sub	esp, 4
		push	[ebp+prec]
		push	offset a_Dlf	; "%%.%dLf"
		push	offset format_buf_5163 ; s
		call	sprintf
		add	esp, 10h
		mov	eax, offset format_buf_5163
		jmp	short locret_8000A64
; ---------------------------------------------------------------------------

loc_8000A5F:				; CODE XREF: get_default_format+1Bj
					; get_default_format+29j ...
		mov	eax, offset aLg	; "%Lg"

locret_8000A64:				; CODE XREF: get_default_format+B7j
					; get_default_format+D6j
		leave
		retn
get_default_format endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

var_A8		= operand_0 ptr	-0A8h
argv		= dword	ptr -7Ch
format_str	= dword	ptr -78h
optc		= dword	ptr -74h
layout		= layout ptr -70h
first		= operand_0 ptr	-68h
step		= operand_0 ptr	-48h
last		= operand_0 ptr	-28h
var_C		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 0A0h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		fld1
		fstp	[ebp+first.value.value]
		mov	[ebp+first.width], 1
		mov	[ebp+first.precision], 0
		fld1
		fstp	[ebp+step.value.value]
		mov	[ebp+step.width], 1
		mov	[ebp+step.precision], 0
		mov	[ebp+layout.prefix_len], 0
		mov	[ebp+layout.suffix_len], 0
		mov	[ebp+format_str], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset byte_80015EB ; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:equal_width,	0
		mov	ds:separator, offset asc_800161B ; "\n"
		jmp	loc_8000C41
; ---------------------------------------------------------------------------

loc_8000B37:				; CODE XREF: main+1E2j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_8000B89
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 2Eh
		jz	loc_8000C51
		mov	eax, [ebp+optc]
		sub	eax, 30h
		cmp	eax, 9
		jbe	loc_8000C51

loc_8000B89:				; CODE XREF: main+E9j
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "+f:s:w"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jz	loc_8000C50
		mov	eax, [ebp+optc]
		cmp	eax, 66h
		jz	short loc_8000BDB
		cmp	eax, 66h
		jg	short loc_8000BCF
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_8000C04
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8000BFA
		jmp	short loc_8000C37
; ---------------------------------------------------------------------------

loc_8000BCF:				; CODE XREF: main+157j
		cmp	eax, 73h
		jz	short loc_8000BE5
		cmp	eax, 77h
		jz	short loc_8000BF1
		jmp	short loc_8000C37
; ---------------------------------------------------------------------------

loc_8000BDB:				; CODE XREF: main+152j
		mov	eax, ds:optarg
		mov	[ebp+format_str], eax
		jmp	short loc_8000C41
; ---------------------------------------------------------------------------

loc_8000BE5:				; CODE XREF: main+16Cj
		mov	eax, ds:optarg
		mov	ds:separator, eax
		jmp	short loc_8000C41
; ---------------------------------------------------------------------------

loc_8000BF1:				; CODE XREF: main+171j
		mov	ds:equal_width,	1
		jmp	short loc_8000C41
; ---------------------------------------------------------------------------

loc_8000BFA:				; CODE XREF: main+165j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C04:				; CODE XREF: main+15Ej
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aUlrichDrepper ;	"Ulrich	Drepper"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aSeq	; "seq"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000C37:				; CODE XREF: main+167j	main+173j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C41:				; CODE XREF: main+CCj main+17Dj ...
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	loc_8000B37
		jmp	short loc_8000C51
; ---------------------------------------------------------------------------

loc_8000C50:				; CODE XREF: main+146j
		nop

loc_8000C51:				; CODE XREF: main+10Ej	main+11Dj ...
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		test	eax, eax
		jg	short loc_8000C8A
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C8A:				; CODE XREF: main+1F8j
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 3
		jle	short loc_8000CE6
		mov	eax, ds:optind
		add	eax, 3
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000CE6:				; CODE XREF: main+232j
		cmp	[ebp+format_str], 0
		jz	short loc_8000D01
		sub	esp, 8
		lea	eax, [ebp+layout]
		push	eax		; layout
		push	[ebp+format_str] ; fmt
		call	long_double_format
		add	esp, 10h
		mov	[ebp+format_str], eax

loc_8000D01:				; CODE XREF: main+284j
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	edx, [eax]
		lea	eax, [ebp+last]
		sub	esp, 8
		push	edx		; arg
		push	eax		; retstr
		call	scan_arg
		add	esp, 0Ch
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	loc_8000E37
		mov	eax, dword ptr [ebp+last.value.value]
		mov	dword ptr [ebp+first.value.value], eax
		mov	eax, dword ptr [ebp+last.value.value+4]
		mov	dword ptr [ebp+first.value.value+4], eax
		mov	eax, dword ptr [ebp+last.value.value+8]
		mov	dword ptr [ebp+first.value.value+8], eax
		mov	eax, [ebp+last.width]
		mov	[ebp+first.width], eax
		mov	eax, [ebp+last.precision]
		mov	[ebp+first.precision], eax
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	edx, [eax]
		lea	eax, [ebp+var_A8]
		sub	esp, 8
		push	edx		; arg
		push	eax		; retstr
		call	scan_arg
		add	esp, 0Ch
		mov	eax, dword ptr [ebp+var_A8.value.value]
		mov	dword ptr [ebp+last.value.value], eax
		mov	eax, dword ptr [ebp+var_A8.value.value+4]
		mov	dword ptr [ebp+last.value.value+4], eax
		mov	eax, dword ptr [ebp+var_A8.value.value+8]
		mov	dword ptr [ebp+last.value.value+8], eax
		mov	eax, [ebp+var_A8.width]
		mov	[ebp+last.width], eax
		mov	eax, [ebp+var_A8.precision]
		mov	[ebp+last.precision], eax
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_8000E37
		mov	eax, dword ptr [ebp+last.value.value]
		mov	dword ptr [ebp+step.value.value], eax
		mov	eax, dword ptr [ebp+last.value.value+4]
		mov	dword ptr [ebp+step.value.value+4], eax
		mov	eax, dword ptr [ebp+last.value.value+8]
		mov	dword ptr [ebp+step.value.value+8], eax
		mov	eax, [ebp+last.width]
		mov	[ebp+step.width], eax
		mov	eax, [ebp+last.precision]
		mov	[ebp+step.precision], eax
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	edx, [eax]
		lea	eax, [ebp+var_A8]
		sub	esp, 8
		push	edx		; arg
		push	eax		; retstr
		call	scan_arg
		add	esp, 0Ch
		mov	eax, dword ptr [ebp+var_A8.value.value]
		mov	dword ptr [ebp+last.value.value], eax
		mov	eax, dword ptr [ebp+var_A8.value.value+4]
		mov	dword ptr [ebp+last.value.value+4], eax
		mov	eax, dword ptr [ebp+var_A8.value.value+8]
		mov	dword ptr [ebp+last.value.value+8], eax
		mov	eax, [ebp+var_A8.width]
		mov	[ebp+last.width], eax
		mov	eax, [ebp+var_A8.precision]
		mov	[ebp+last.precision], eax

loc_8000E37:				; CODE XREF: main+2CEj	main+355j
		cmp	[ebp+format_str], 0
		jz	short loc_8000E72
		movzx	eax, ds:equal_width
		test	al, al
		jz	short loc_8000E72
		sub	esp, 0Ch
		push	offset aFormatStringMa ; "format string	may not	be specified when"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000E72:				; CODE XREF: main+3D5j	main+3E0j
		cmp	[ebp+format_str], 0
		jnz	short loc_8000EB3
		sub	esp, 4
		push	[ebp+last.precision]
		push	[ebp+last.width]
		push	dword ptr [ebp+last.value.value+8]
		push	dword ptr [ebp+last.value.value+4]
		push	dword ptr [ebp+last.value.value] ; last
		push	[ebp+step.precision]
		push	[ebp+step.width]
		push	dword ptr [ebp+step.value.value+8]
		push	dword ptr [ebp+step.value.value+4]
		push	dword ptr [ebp+step.value.value] ; step
		push	[ebp+first.precision]
		push	[ebp+first.width]
		push	dword ptr [ebp+first.value.value+8]
		push	dword ptr [ebp+first.value.value+4]
		push	dword ptr [ebp+first.value.value] ; first
		call	get_default_format
		add	esp, 40h
		mov	[ebp+format_str], eax

loc_8000EB3:				; CODE XREF: main+410j
		fld	[ebp+last.value.value]
		fld	[ebp+step.value.value]
		fld	[ebp+first.value.value]
		fxch	st(2)
		lea	esp, [esp-0Ch]
		fstp	tbyte ptr [esp]	; last
		lea	esp, [esp-0Ch]
		fstp	tbyte ptr [esp]	; step
		lea	esp, [esp-0Ch]
		fstp	tbyte ptr [esp]	; first
		push	[ebp+layout.suffix_len]
		push	[ebp+layout.prefix_len]	; layout
		push	[ebp+format_str] ; fmt
		call	print_numbers
		add	esp, 30h
		sub	esp, 0Ch
		push	0		; status

loc_8000EE9:				; DATA XREF: .eh_frame:080016C0o
					; .eh_frame:080016E0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8000EF0h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	equal_width
equal_width	db ?			; DATA XREF: get_default_format+2Fr
					; main+BBw ...
		align 4
; const	char *separator
separator	dd ?			; DATA XREF: print_numbers+1DEr
					; main+C2w ...
; Function-local static	variable
; char format_buf_5163[28]
format_buf_5163	db 1Ch dup(?)		; DATA XREF: get_default_format+A5o
					; get_default_format+B2o ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000F20h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+8Eo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+1B4o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
; char terminator[2]
terminator	db 0Ah,0
aEqualWidth	db 'equal-width',0      ; DATA XREF: .rodata:long_optionso
aFormat		db 'format',0           ; DATA XREF: .rodata:long_optionso
aSeparator	db 'separator',0        ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[6]
long_options	option <offset aEqualWidth, 0, 0, 77h> ; DATA XREF: main+128o
		option <offset aFormat,	1, 0, 66h> ; "equal-width"
		option <offset aSeparator, 1, 0, 73h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+18o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... LAST',0Ah ; DATA XREF: usage+54o
		db '  or:  %s [OPTION]... FIRST LAST',0Ah
		db '  or:  %s [OPTION]... FIRST INCREMENT LAST',0Ah,0
; char aPrintNumbersFr[]
aPrintNumbersFr	db 'Print numbers from FIRST to LAST, in steps of INCREMENT.',0Ah
					; DATA XREF: usage+76o
		db 0Ah
		db '  -f, --format=FORMAT      use printf style floating-point FORMAT'
		db 0Ah
		db '  -s, --separator=STRING   use STRING to separate numbers (defaul'
		db 't: \n)',0Ah
		db '  -w, --equal-width        equalize width by padding with leading'
		db ' zeroes',0Ah,0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+99o
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+BCo
		align 4
; char aIfFirstOrIncre[]
aIfFirstOrIncre	db 0Ah			; DATA XREF: usage+DFo
		db 'If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an',0Ah
		db 'omitted INCREMENT defaults to 1 even when LAST is smaller than FI'
		db 'RST.',0Ah
		db 'FIRST, INCREMENT, and LAST are interpreted as floating point valu'
		db 'es.',0Ah
		db 'INCREMENT is usually positive if FIRST is smaller than LAST, and',0Ah
		db 'INCREMENT is usually negative if FIRST is greater than LAST.',0Ah,0
; char aFormatMustBeSu[]
aFormatMustBeSu	db 'FORMAT must be suitable for printing one argument of type `double'
					; DATA XREF: usage+102o
		db 27h,';',0Ah
		db 'it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixe'
		db 'd point',0Ah
		db 'decimal numbers with maximum precision PREC, and to %g otherwise.'
		db 0Ah,0
; char aInvalidFloatin[]
aInvalidFloatin	db 'invalid floating point argument: %s',0 ; DATA XREF: scan_arg+3Eo
; char reject[]
reject		db 'xX',0               ; DATA XREF: scan_arg+C0o
; char aEe[]
aEe		db 'eE',0               ; DATA XREF: scan_arg+12Ao
; char aFormatSHasNoDi[]
aFormatSHasNoDi	db 'format %s has no %% directive',0 ; DATA XREF: long_double_format+41o
; char accept[]
accept		db '-+#0 ',27h,0        ; DATA XREF: long_double_format+AEo
; char a0123456789[]
a0123456789	db '0123456789',0       ; DATA XREF: long_double_format+CAo
					; long_double_format+F9o
; char aFormatSEndsIn[]
aFormatSEndsIn	db 'format %s ends in %%',0 ; DATA XREF: long_double_format+14Co
; char s[]
s		db 'efgaEFGA',0         ; DATA XREF: long_double_format+179o
; char aFormatSHasUnkn[]
aFormatSHasUnkn	db 'format %s has unknown %%%c directive',0
					; DATA XREF: long_double_format+1ABo
		align 4
; char aFormatSHasTooM[]
aFormatSHasTooM	db 'format %s has too many %% directives',0
					; DATA XREF: long_double_format+202o
; char locale[]
locale		db 'C',0                ; DATA XREF: print_numbers+D6o
; char byte_80015EB
byte_80015EB	db 0			; DATA XREF: print_numbers+106o
					; main+77o
; char format[]
format		db '%%0%d.%dLf',0       ; DATA XREF: get_default_format+A0o
; char a_Dlf[]
a_Dlf		db '%%.%dLf',0          ; DATA XREF: get_default_format+BFo
aLg		db '%Lg',0              ; DATA XREF: get_default_format:loc_8000A5Fo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+89o
asc_800161B	db 0Ah,0		; DATA XREF: main+C2o
; char shortopts[]
shortopts	db '+f:s:w',0           ; DATA XREF: main+12Do
aUlrichDrepper	db 'Ulrich Drepper',0   ; DATA XREF: main+1AEo
aSeq		db 'seq',0              ; DATA XREF: main+1B9o
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+1FDo
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+25Bo
; char aFormatStringMa[]
aFormatStringMa	db 'format string may not be specified when printing equal width stri'
					; DATA XREF: main+3E5o
		db 'ngs',0
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80016A0h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000EE9-80025A9h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8000EE9-80025B7h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8000EE9-80024BFh
		dd 12Ch, 80E4100h, 0D420285h, 3874605h,	5830486h, 20h
		dd 80h
		dd offset loc_8000EE9-80023B3h
		dd 229h, 80E4100h, 0D420285h, 3834405h,	0C5021F03h, 4040CC3h
		dd 28h,	0A4h
		dd offset loc_8000EE9-80021AEh
		dd 2DAh, 80E4100h, 0D420285h, 3864505h,	0CF030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 0D0h
		dd offset loc_8000EE9-8001F00h
		dd 22Ah, 80E4100h, 0D420285h, 2260305h,	4040CC5h, 1Ch
		dd 0F0h
		dd offset loc_8000EE9-8001CF6h
		dd 0DFh, 80E4100h, 0D420285h, 0C5DB0205h, 4040Ch, 24h
		dd 110h
		dd offset loc_8000EE9-8001C37h
		dd 488h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+6Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+88p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; print_numbers+DDp ...
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+27r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+32p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+127p main+1CCp ...
		extrn c_strtold		; DATA XREF: scan_arg+1Eo
					; print_numbers+13Ao
		extrn xstrtold:near	; CODE XREF: scan_arg+2Cp
					; print_numbers+146p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: scan_arg+53p
					; long_double_format+54p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: scan_arg:loc_80002C3p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: scan_arg+ABp
; size_t strcspn(const char *s,	const char *reject)
		extrn strcspn:near	; CODE XREF: scan_arg+C8p
					; scan_arg+130p
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: scan_arg+107p
					; scan_arg+18Dp ...
; __int32 strtol(const char *nptr, char	**endptr, int base)
		extrn strtol:near	; CODE XREF: scan_arg+1C5p
		extrn __stack_chk_fail:near ; CODE XREF: scan_arg+21Dp
					; print_numbers+223p
		extrn quote:near	; CODE XREF: long_double_format+34p
					; long_double_format+13Fp ...
; size_t strspn(const char *s, const char *accept)
		extrn strspn:near	; CODE XREF: long_double_format+B4p
					; long_double_format+D0p ...
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: long_double_format+24Ap
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: long_double_format+261p
; char *strcpy(char *dest, const char *src)
		extrn strcpy:near	; CODE XREF: long_double_format+292p
		extrn rpl_asprintf:near	; CODE XREF: print_numbers+F8p
					; print_numbers+17Fp
		extrn xalloc_die:near	; CODE XREF: print_numbers+11Bp
					; print_numbers+18Bp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: print_numbers+19Bp
; void free(void *ptr)
		extrn free:near		; CODE XREF: print_numbers+1B2p
					; print_numbers+1C5p
; int fputc_unlocked(int c, FILE *stream)
		extrn fputc_unlocked:near ; CODE XREF: print_numbers+20Ep
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: get_default_format+AAp
					; get_default_format+C9p
		extrn set_program_name:near ; CODE XREF: main+6Cp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+93p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+A3p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+AEo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+B3p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000B37r
					; main+EBr ...
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+137p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000BDBr
					; main:loc_8000BE5r
		extrn Version:dword	; DATA XREF: main:loc_8000C04r
		extrn version_etc:near	; CODE XREF: main+1BFp


		end
