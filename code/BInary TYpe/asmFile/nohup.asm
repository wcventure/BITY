;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	275B29F5A9839EB894EB60B7069B88CA
; Input	CRC32 :	430BB9A0

; File Name   :	D:\coreutils-o\nohup.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'nohup.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+94p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+112p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000FA
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000FA
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000FA:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+F9p main+12Dp
					; DATA XREF: ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000247
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSCommandA ; "Usage: %s COMMAND [ARG]...\n	or:  %s	O"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRunCommandIgno ; "Run COMMAND, ignoring	hangup signals.\n"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aIfStandardInpu ; "\nIf standard	input is a terminal, redi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aNoteYourShellM ; "\nNOTE: your shell may have its own ver"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aNohup	; "nohup"
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_8000247:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ignoring_input	= byte ptr -54h
redirecting_stdout= byte ptr -53h
stdout_is_closed= byte ptr -52h
redirecting_stderr= byte ptr -51h
out_fd		= dword	ptr -50h
saved_stderr_fd	= dword	ptr -4Ch
in_home		= dword	ptr -48h
file		= dword	ptr -44h
exit_internal_failure= dword ptr -40h
flags		= dword	ptr -3Ch
mode		= dword	ptr -38h
umask_value	= dword	ptr -34h
saved_errno	= dword	ptr -30h
home		= dword	ptr -2Ch
saved_errno2	= dword	ptr -28h
cmd		= dword	ptr -24h
exit_status	= dword	ptr -20h
saved_errno_0	= dword	ptr -1Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 4Ch
		mov	ebx, ecx
		mov	[ebp+out_fd], 1
		mov	[ebp+saved_stderr_fd], 2
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		jz	short loc_80002D8
		mov	eax, 7Fh
		jmp	short loc_80002DD
; ---------------------------------------------------------------------------

loc_80002D8:				; CODE XREF: main+7Dj
		mov	eax, 7Dh

loc_80002DD:				; CODE XREF: main+84j
		mov	[ebp+exit_internal_failure], eax
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, ds:Version
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	offset usage
		push	eax
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aNohup	; "nohup"
		push	dword ptr [ebx+4]
		push	dword ptr [ebx]
		call	parse_long_options
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; longind
		push	0		; longopts
		push	offset shortopts ; "+"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8000350
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000350:				; CODE XREF: main+F1j
		mov	eax, ds:optind
		cmp	[ebx], eax
		jg	short loc_8000384
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000384:				; CODE XREF: main+105j
		sub	esp, 0Ch
		push	0		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+ignoring_input], al
		sub	esp, 0Ch
		push	1		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+redirecting_stdout], al
		movzx	eax, [ebp+redirecting_stdout]
		xor	eax, 1
		test	al, al
		jz	short loc_80003CC
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 9
		jnz	short loc_80003CC
		mov	eax, 1
		jmp	short loc_80003D1
; ---------------------------------------------------------------------------

loc_80003CC:				; CODE XREF: main+165j	main+171j
		mov	eax, 0

loc_80003D1:				; CODE XREF: main+178j
		mov	[ebp+stdout_is_closed],	al
		and	[ebp+stdout_is_closed],	1
		sub	esp, 0Ch
		push	2		; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+redirecting_stderr], al
		cmp	[ebp+ignoring_input], 0
		jz	loc_8000477
		push	0
		push	1
		push	offset aDevNull	; "/dev/null"
		push	0
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000441
		sub	esp, 0Ch
		push	offset aFailedToRender ; "failed to render standard input unusabl"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000441:				; CODE XREF: main+1BAj
		movzx	eax, [ebp+redirecting_stdout]
		xor	eax, 1
		test	al, al
		jz	short loc_8000477
		movzx	eax, [ebp+redirecting_stderr]
		xor	eax, 1
		test	al, al
		jz	short loc_8000477
		sub	esp, 0Ch
		push	offset aIgnoringInput ;	"ignoring input"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000477:				; CODE XREF: main+19Fj	main+1F8j ...
		cmp	[ebp+redirecting_stdout], 0
		jnz	short loc_8000491
		cmp	[ebp+redirecting_stderr], 0
		jz	loc_8000645
		cmp	[ebp+stdout_is_closed],	0
		jz	loc_8000645

loc_8000491:				; CODE XREF: main+229j
		mov	[ebp+in_home], 0
		mov	[ebp+file], offset aNohup_out ;	"nohup.out"
		mov	[ebp+flags], 441h
		mov	[ebp+mode], 180h
		mov	eax, [ebp+mode]
		not	eax
		sub	esp, 0Ch
		push	eax		; mask
		call	umask
		add	esp, 10h
		mov	[ebp+umask_value], eax
		cmp	[ebp+redirecting_stdout], 0
		jz	short loc_80004DC
		push	[ebp+mode]
		push	[ebp+flags]
		push	[ebp+file]
		push	1
		call	fd_reopen
		add	esp, 10h
		jmp	short loc_80004F0
; ---------------------------------------------------------------------------

loc_80004DC:				; CODE XREF: main+273j
		sub	esp, 4
		push	[ebp+mode]
		push	[ebp+flags]
		push	[ebp+file]
		call	open64
		add	esp, 10h

loc_80004F0:				; CODE XREF: main+288j
		mov	[ebp+out_fd], eax
		cmp	[ebp+out_fd], 0
		jns	loc_80005ED
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno], eax
		sub	esp, 0Ch
		push	offset aHome	; "HOME"
		call	getenv
		add	esp, 10h
		mov	[ebp+home], eax
		cmp	[ebp+home], 0
		jz	short loc_8000568
		sub	esp, 4
		push	0
		push	[ebp+file]
		push	[ebp+home]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+in_home], eax
		cmp	[ebp+redirecting_stdout], 0
		jz	short loc_8000551
		push	[ebp+mode]
		push	[ebp+flags]
		push	[ebp+in_home]
		push	1
		call	fd_reopen
		add	esp, 10h
		jmp	short loc_8000565
; ---------------------------------------------------------------------------

loc_8000551:				; CODE XREF: main+2E8j
		sub	esp, 4
		push	[ebp+mode]
		push	[ebp+flags]
		push	[ebp+in_home]
		call	open64
		add	esp, 10h

loc_8000565:				; CODE XREF: main+2FDj
		mov	[ebp+out_fd], eax

loc_8000568:				; CODE XREF: main+2CCj
		cmp	[ebp+out_fd], 0
		jns	short loc_80005E7
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno2], eax
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFailedToOpenS ;	"failed	to open	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+saved_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		cmp	[ebp+in_home], 0
		jz	short loc_80005DC
		sub	esp, 0Ch
		push	[ebp+in_home]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFailedToOpenS ;	"failed	to open	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+saved_errno2] ; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80005DC:				; CODE XREF: main+359j
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	exit
; ---------------------------------------------------------------------------

loc_80005E7:				; CODE XREF: main+31Aj
		mov	eax, [ebp+in_home]
		mov	[ebp+file], eax

loc_80005ED:				; CODE XREF: main+2A5j
		sub	esp, 0Ch
		push	[ebp+umask_value] ; mask
		call	umask
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	esi, eax
		cmp	[ebp+ignoring_input], 0
		jz	short loc_8000618
		mov	eax, offset aIgnoringInputA ; "ignoring	input and appending output to "...
		jmp	short loc_800061D
; ---------------------------------------------------------------------------

loc_8000618:				; CODE XREF: main+3BDj
		mov	eax, offset aAppendingOutpu ; "appending output	to %s"

loc_800061D:				; CODE XREF: main+3C4j
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+in_home]	; ptr
		call	free
		add	esp, 10h

loc_8000645:				; CODE XREF: main+22Fj	main+239j
		cmp	[ebp+redirecting_stderr], 0
		jz	loc_800072C
		sub	esp, 0Ch
		push	2
		call	dup_safer
		add	esp, 10h
		mov	[ebp+saved_stderr_fd], eax
		cmp	[ebp+saved_stderr_fd], 0
		js	short loc_80006A2
		sub	esp, 8
		push	1
		push	[ebp+saved_stderr_fd]
		call	set_cloexec_flag
		add	esp, 10h
		test	eax, eax
		jz	short loc_80006A2
		sub	esp, 0Ch
		push	offset aFailedToSetThe ; "failed to set	the copy of stderr to clo"...
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	esi		; format
		push	eax		; errnum
		push	[ebp+exit_internal_failure] ; status
		call	error
		add	esp, 10h

loc_80006A2:				; CODE XREF: main+411j	main+425j
		movzx	eax, [ebp+redirecting_stdout]
		xor	eax, 1
		test	al, al
		jz	short loc_80006DB
		cmp	[ebp+ignoring_input], 0
		jz	short loc_80006BA
		mov	eax, offset aIgnoringInpu_0 ; "ignoring	input and redirecting stderr t"...
		jmp	short loc_80006BF
; ---------------------------------------------------------------------------

loc_80006BA:				; CODE XREF: main+45Fj
		mov	eax, offset aRedirectingStd ; "redirecting stderr to stdout"

loc_80006BF:				; CODE XREF: main+466j
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80006DB:				; CODE XREF: main+459j
		sub	esp, 8
		push	2		; fd2
		push	[ebp+out_fd]	; fd
		call	dup2
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000718
		sub	esp, 0Ch
		push	offset aFailedToRedire ; "failed to redirect standard error"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	esi		; format
		push	eax		; errnum
		push	[ebp+exit_internal_failure] ; status
		call	error
		add	esp, 10h

loc_8000718:				; CODE XREF: main+49Bj
		cmp	[ebp+stdout_is_closed],	0
		jz	short loc_800072C
		sub	esp, 0Ch
		push	[ebp+out_fd]	; fd
		call	close
		add	esp, 10h

loc_800072C:				; CODE XREF: main+3F7j	main+4CAj
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	eax		; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_800074C
		sub	esp, 0Ch
		push	[ebp+exit_internal_failure] ; status
		call	exit
; ---------------------------------------------------------------------------

loc_800074C:				; CODE XREF: main+4EDj
		sub	esp, 8
		push	1		; handler
		push	1		; sig
		call	signal
		add	esp, 10h
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	[ebp+cmd], eax
		mov	eax, [ebp+cmd]
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+cmd]	; argv
		push	eax		; file
		call	execvp
		add	esp, 10h
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jnz	short loc_8000796
		mov	eax, 7Fh
		jmp	short loc_800079B
; ---------------------------------------------------------------------------

loc_8000796:				; CODE XREF: main+53Bj
		mov	eax, 7Eh

loc_800079B:				; CODE XREF: main+542j
		mov	[ebp+exit_status], eax
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+saved_errno_0], eax
		sub	esp, 8
		push	2		; fd2
		push	[ebp+saved_stderr_fd] ;	fd
		call	dup2
		add	esp, 10h
		cmp	eax, 2
		jnz	short loc_80007EF
		mov	eax, [ebp+cmd]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFailedToRunCom ; "failed to run	command	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+saved_errno_0] ; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80007EF:				; CODE XREF: main+569j
		sub	esp, 0Ch
		push	[ebp+exit_status] ; status

loc_80007F5:				; DATA XREF: .eh_frame:08000DE4o
					; .eh_frame:08000E04o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 80007FCh
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+4Eo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+BEo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 10h
; char aUsageSCommandA[]
aUsageSCommandA	db 'Usage: %s COMMAND [ARG]...',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s OPTION',0Ah,0
		align 10h
; char aRunCommandIgno[]
aRunCommandIgno	db 'Run COMMAND, ignoring hangup signals.',0Ah ; DATA XREF: usage+6Eo
		db 0Ah,0
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+91o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+B4o
		align 10h
; char aIfStandardInpu[]
aIfStandardInpu	db 0Ah			; DATA XREF: usage+D7o
		db 'If standard input is a terminal, redirect it from /dev/null.',0Ah
		db 'If standard output is a terminal, append output to `nohup.out',27h,' '
		db 'if possible,',0Ah
		db '`$HOME/nohup.out',27h,' otherwise.',0Ah
		db 'If standard error is a terminal, redirect it to standard output.',0Ah
		db 'To save output to FILE, use `%s COMMAND > FILE',27h,'.',0Ah,0
		align 4
; char aNoteYourShellM[]
aNoteYourShellM	db 0Ah			; DATA XREF: usage+F4o
		db 'NOTE: your shell may have its own version of %s, which usually su'
		db 'persedes',0Ah
		db 'the version described here.  Please refer to your shell',27h,'s docu'
		db 'mentation',0Ah
		db 'for details about the options it supports.',0Ah,0
aNohup		db 'nohup',0            ; DATA XREF: usage+104o main+C3o
; char locale
locale		db 0			; DATA XREF: main+37o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+49o
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: main+6Eo
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+B3o
; char shortopts[]
shortopts	db '+',0                ; DATA XREF: main+DCo
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+10Ao
aDevNull	db '/dev/null',0        ; DATA XREF: main+1A9o
		align 4
; char aFailedToRender[]
aFailedToRender	db 'failed to render standard input unusable',0 ; DATA XREF: main+1BFo
; char aIgnoringInput[]
aIgnoringInput	db 'ignoring input',0   ; DATA XREF: main+208o
aNohup_out	db 'nohup.out',0        ; DATA XREF: main+246o
; char aHome[]
aHome		db 'HOME',0             ; DATA XREF: main+2B8o
; char aFailedToOpenS[]
aFailedToOpenS	db 'failed to open %s',0 ; DATA XREF: main+339o main+36Eo
		align 10h
; char aIgnoringInputA[]
aIgnoringInputA	db 'ignoring input and appending output to %s',0 ; DATA XREF: main+3BFo
aAppendingOutpu	db 'appending output to %s',0 ; DATA XREF: main:loc_8000618o
		align 4
; char aFailedToSetThe[]
aFailedToSetThe	db 'failed to set the copy of stderr to close on exec',0
					; DATA XREF: main+42Ao
		align 4
; char aIgnoringInpu_0[]
aIgnoringInpu_0	db 'ignoring input and redirecting stderr to stdout',0
					; DATA XREF: main+461o
aRedirectingStd	db 'redirecting stderr to stdout',0 ; DATA XREF: main:loc_80006BAo
		align 4
; char aFailedToRedire[]
aFailedToRedire	db 'failed to redirect standard error',0 ; DATA XREF: main+4A0o
; char aFailedToRunCom[]
aFailedToRunCom	db 'failed to run command %s',0 ; DATA XREF: main+581o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8000DC4h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80007F5-80015D9h
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 20h, 3Ch
		dd offset loc_80007F5-80015E5h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_80007F5-80014EDh
		dd 122h, 80E4100h, 0D420285h, 3864205h,	483h, 28h, 80h
		dd offset loc_80007F5-80013EBh
		dd 5A8h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+3Ep
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
					; main:loc_800072Cr
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+11Dp main+1EAp ...
		extrn set_program_name:near ; CODE XREF: main+2Cp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+53p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+63p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: main+73p main+2BDp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+9Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+A4p
		extrn Version:dword	; DATA XREF: main+ACr
		extrn parse_long_options:near ;	CODE XREF: main+CDp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+E6p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000350r
					; main+509r
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+11Fp	main+1DCp ...
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: main+137p	main+14Cp ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: main+167p main+1CEp ...
		extrn fd_reopen:near	; CODE XREF: main+1B0p	main+280p ...
; __mode_t umask(__mode_t mask)
		extrn umask:near	; CODE XREF: main+264p	main+3A1p
		extrn open64:near	; CODE XREF: main+296p	main+30Bp
		extrn file_name_concat:near ; CODE XREF: main+2D9p
		extrn quote:near	; CODE XREF: main+32Cp	main+361p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: main+3EBp
		extrn dup_safer:near	; CODE XREF: main+402p
		extrn set_cloexec_flag:near ; CODE XREF: main+41Bp
; int dup2(int fd, int fd2)
		extrn dup2:near		; CODE XREF: main+491p	main+55Ep
; int close(int	fd)
		extrn close:near	; CODE XREF: main+4D2p
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	main+4E3p
; __sighandler_t signal(int sig, __sighandler_t	handler)
		extrn signal:near	; CODE XREF: main+501p
; int execvp(const char	*file, char *const *argv)
		extrn execvp:near	; CODE XREF: main+529p


		end
