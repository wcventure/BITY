;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	0C0B6DA6B8725343E88D315AA28EA3A8
; Input	CRC32 :	50E53CBF

; File Name   :	D:\coreutils-o\runcon.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'runcon.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl getcon(char **con)
getcon		proc near		; CODE XREF: main+261p	main+3F7p

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
getcon		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl freecon(char *con)
freecon		proc near		; CODE XREF: main+4EDp	main+4FCp ...

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
freecon		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl getfilecon(const char *file, char	**con)
getfilecon	proc near		; CODE XREF: main+450p

file		= dword	ptr  8
con		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
getfilecon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl security_check_context(char *con)
security_check_context proc near	; CODE XREF: main+677p

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
security_check_context endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl setexeccon(char *con)
setexeccon	proc near		; CODE XREF: main+6D7p

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
setexeccon	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl security_compute_create(char *scon, char *tcon, security_class_t tclass, char **newcon)
security_compute_create	proc near	; CODE XREF: main+4B2p

tclass		= word ptr -0Ch
scon		= dword	ptr  8
tcon		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
newcon		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_8]
		mov	[ebp+tclass], ax
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
security_compute_create	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; context_t __cdecl context_new(const char *s)
context_new	proc near		; CODE XREF: main+3A0p	main+511p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0
		leave
		retn
context_new	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	context_str(context_t con)
context_str	proc near		; CODE XREF: main+66Bp	main+689p ...

con		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0
		leave
		retn
context_str	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl context_user_set(context_t sc, const char	*s)
context_user_set proc near		; CODE XREF: main+568p

sc		= dword	ptr  8
s		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
context_user_set endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl context_role_set(context_t sc, const char	*s)
context_role_set proc near		; CODE XREF: main+631p

sc		= dword	ptr  8
s		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
context_role_set endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl context_range_set(context_t sc, const char *s)
context_range_set proc near		; CODE XREF: main+5EEp

sc		= dword	ptr  8
s		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
context_range_set endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl context_type_set(context_t sc, const char	*s)
context_type_set proc near		; CODE XREF: main+5ABp

sc		= dword	ptr  8
s		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	dword ptr [eax], 5Fh
		mov	eax, 0FFFFFFFFh
		leave
		retn
context_type_set endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+CEp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80001FB
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80001FB
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80001FB:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+213p	main+250p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_800026C
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000304
; ---------------------------------------------------------------------------

loc_800026C:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSContextC ; "Usage: %s CONTEXT COMMAND [args]\n  or:"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRunAProgramInA ; "Run a	program	in a different security	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000304:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -5Ch
compute_trans	= byte ptr -4Dh
cur_context	= dword	ptr -4Ch
file_context	= dword	ptr -48h
new_context	= dword	ptr -44h
option_index	= dword	ptr -40h
role		= dword	ptr -3Ch
range		= dword	ptr -38h
user		= dword	ptr -34h
type		= dword	ptr -30h
context		= dword	ptr -2Ch
con		= dword	ptr -28h
c		= dword	ptr -24h
exit_status	= dword	ptr -20h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 5Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+role], 0
		mov	[ebp+range], 0
		mov	[ebp+user], 0
		mov	[ebp+type], 0
		mov	[ebp+context], 0
		mov	[ebp+cur_context], 0
		mov	[ebp+file_context], 0
		mov	[ebp+new_context], 0
		mov	[ebp+compute_trans], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h

loc_80003C9:				; CODE XREF: main:loc_8000564j
		mov	[ebp+option_index], 0
		sub	esp, 0Ch
		lea	eax, [ebp+option_index]
		push	eax		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "+r:t:u:l:c"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000409
		mov	eax, ds:optind
		cmp	[ebx], eax
		jz	loc_8000569
		jmp	loc_80005D7
; ---------------------------------------------------------------------------

loc_8000409:				; CODE XREF: main+E6j
		mov	eax, [ebp+c]
		cmp	eax, 6Ch
		jz	loc_80004E7
		cmp	eax, 6Ch
		jg	short loc_800043E
		cmp	eax, 0FFFFFF7Eh
		jz	loc_800051D
		cmp	eax, 63h
		jz	loc_8000517
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000527
		jmp	loc_800055A
; ---------------------------------------------------------------------------

loc_800043E:				; CODE XREF: main+109j
		cmp	eax, 74h
		jz	short loc_8000484
		cmp	eax, 75h
		jz	short loc_80004B7
		cmp	eax, 72h
		jnz	loc_800055A
		cmp	[ebp+role], 0
		jz	short loc_8000477
		sub	esp, 0Ch
		push	offset aMultipleRoles ;	"multiple roles"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000477:				; CODE XREF: main+146j
		mov	eax, ds:optarg
		mov	[ebp+role], eax
		jmp	loc_8000564
; ---------------------------------------------------------------------------

loc_8000484:				; CODE XREF: main+132j
		cmp	[ebp+type], 0
		jz	short loc_80004AA
		sub	esp, 0Ch
		push	offset aMultipleTypes ;	"multiple types"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80004AA:				; CODE XREF: main+179j
		mov	eax, ds:optarg
		mov	[ebp+type], eax
		jmp	loc_8000564
; ---------------------------------------------------------------------------

loc_80004B7:				; CODE XREF: main+137j
		cmp	[ebp+user], 0
		jz	short loc_80004DD
		sub	esp, 0Ch
		push	offset aMultipleUsers ;	"multiple users"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80004DD:				; CODE XREF: main+1ACj
		mov	eax, ds:optarg
		mov	[ebp+user], eax
		jmp	short loc_8000564
; ---------------------------------------------------------------------------

loc_80004E7:				; CODE XREF: main+100j
		cmp	[ebp+range], 0
		jz	short loc_800050D
		sub	esp, 0Ch
		push	offset aMultipleLevelr ; "multiple levelranges"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800050D:				; CODE XREF: main+1DCj
		mov	eax, ds:optarg
		mov	[ebp+range], eax
		jmp	short loc_8000564
; ---------------------------------------------------------------------------

loc_8000517:				; CODE XREF: main+119j
		mov	[ebp+compute_trans], 1
		jmp	short loc_8000564
; ---------------------------------------------------------------------------

loc_800051D:				; CODE XREF: main+110j
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000527:				; CODE XREF: main+124j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aRussellCoker ; "Russell	Coker"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aRuncon	; "runcon"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800055A:				; CODE XREF: main+12Aj	main+13Cj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000564:				; CODE XREF: main+170j	main+1A3j ...
		jmp	loc_80003C9
; ---------------------------------------------------------------------------

loc_8000569:				; CODE XREF: main+EFj
		sub	esp, 0Ch
		lea	eax, [ebp+cur_context]
		push	eax		; con
		call	getcon
		add	esp, 10h
		test	eax, eax
		jns	short loc_80005A4
		sub	esp, 0Ch
		push	offset aFailedToGetCur ; "failed to get	current	context"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80005A4:				; CODE XREF: main+26Bj
		mov	edx, ds:stdout
		mov	eax, [ebp+cur_context]
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	eax, ds:stdout
		sub	esp, 8
		push	eax		; stream
		push	0Ah		; c
		call	fputc_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80005D7:				; CODE XREF: main+F5j
		cmp	[ebp+user], 0
		jnz	short loc_800064C
		cmp	[ebp+role], 0
		jnz	short loc_800064C
		cmp	[ebp+type], 0
		jnz	short loc_800064C
		cmp	[ebp+range], 0
		jnz	short loc_800064C
		movzx	eax, [ebp+compute_trans]
		xor	eax, 1
		test	al, al
		jz	short loc_800064C
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_800062D
		sub	esp, 0Ch
		push	offset aYouMustSpecify ; "you must specify -c, -t, -u, -l, -r, or"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800062D:				; CODE XREF: main+2F2j
		mov	eax, ds:optind
		lea	edx, [eax+1]
		mov	ds:optind, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+context], eax

loc_800064C:				; CODE XREF: main+2CCj	main+2D2j ...
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_800067F
		sub	esp, 0Ch
		push	offset aNoCommandSpeci ; "no command specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800067F:				; CODE XREF: main+344j
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aSMayBeUsedOnly ; "%s may be used only on a SELinux kernel"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		cmp	[ebp+context], 0
		jz	short loc_80006FF
		sub	esp, 0Ch
		push	[ebp+context]	; s
		call	context_new
		add	esp, 10h
		mov	[ebp+con], eax
		cmp	[ebp+con], 0
		jnz	loc_8000974
		sub	esp, 0Ch
		push	[ebp+context]
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToCreate ; "failed to create security context: %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	loc_8000974
; ---------------------------------------------------------------------------

loc_80006FF:				; CODE XREF: main+398j
		sub	esp, 0Ch
		lea	eax, [ebp+cur_context]
		push	eax		; con
		call	getcon
		add	esp, 10h
		test	eax, eax
		jns	short loc_800073A
		sub	esp, 0Ch
		push	offset aFailedToGetCur ; "failed to get	current	context"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800073A:				; CODE XREF: main+401j
		cmp	[ebp+compute_trans], 0
		jz	loc_8000819
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+file_context]
		push	edx		; con
		push	eax		; file
		call	getfilecon
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80007B3
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToGetSec ; "failed to get	security context of %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007B3:				; CODE XREF: main+45Bj
		mov	edx, [ebp+file_context]
		mov	eax, [ebp+cur_context]
		lea	ecx, [ebp+new_context]
		push	ecx		; newcon
		push	0		; tclass
		push	edx		; tcon
		push	eax		; scon
		call	security_compute_create
		add	esp, 10h
		test	eax, eax
		jz	short loc_80007F5
		sub	esp, 0Ch
		push	offset aFailedToComput ; "failed to compute a new context"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007F5:				; CODE XREF: main+4BCj
		mov	eax, [ebp+file_context]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h
		mov	eax, [ebp+cur_context]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h
		mov	eax, [ebp+new_context]
		mov	[ebp+cur_context], eax

loc_8000819:				; CODE XREF: main+42Fj
		mov	eax, [ebp+cur_context]
		sub	esp, 0Ch
		push	eax		; s
		call	context_new
		add	esp, 10h
		mov	[ebp+con], eax
		cmp	[ebp+con], 0
		jnz	short loc_8000868
		mov	eax, [ebp+cur_context]
		sub	esp, 0Ch
		push	eax
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToCreate ; "failed to create security context: %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000868:				; CODE XREF: main+520j
		cmp	[ebp+user], 0
		jz	short loc_80008AB
		sub	esp, 8
		push	[ebp+user]	; s
		push	[ebp+con]	; sc
		call	context_user_set
		add	esp, 10h
		test	eax, eax
		jz	short loc_80008AB
		sub	esp, 0Ch
		push	offset aFailedToSetNew ; "failed to set	new user %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+user]
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008AB:				; CODE XREF: main+55Dj	main+572j
		cmp	[ebp+type], 0
		jz	short loc_80008EE
		sub	esp, 8
		push	[ebp+type]	; s
		push	[ebp+con]	; sc
		call	context_type_set
		add	esp, 10h
		test	eax, eax
		jz	short loc_80008EE
		sub	esp, 0Ch
		push	offset aFailedToSetN_0 ; "failed to set	new type %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+type]
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008EE:				; CODE XREF: main+5A0j	main+5B5j
		cmp	[ebp+range], 0
		jz	short loc_8000931
		sub	esp, 8
		push	[ebp+range]	; s
		push	[ebp+con]	; sc
		call	context_range_set
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000931
		sub	esp, 0Ch
		push	offset aFailedToSetN_1 ; "failed to set	new range %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+range]
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000931:				; CODE XREF: main+5E3j	main+5F8j
		cmp	[ebp+role], 0
		jz	short loc_8000974
		sub	esp, 8
		push	[ebp+role]	; s
		push	[ebp+con]	; sc
		call	context_role_set
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000974
		sub	esp, 0Ch
		push	offset aFailedToSetN_2 ; "failed to set	new role %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+role]
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000974:				; CODE XREF: main+3AFj	main+3EBj ...
		sub	esp, 0Ch
		push	[ebp+con]	; con
		call	context_str
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; con
		call	security_check_context
		add	esp, 10h
		test	eax, eax
		jns	short loc_80009D4
		sub	esp, 0Ch
		push	[ebp+con]	; con
		call	context_str
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quotearg_colon
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidContext ; "invalid context: %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009D4:				; CODE XREF: main+681j
		sub	esp, 0Ch
		push	[ebp+con]	; con
		call	context_str
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; con
		call	setexeccon
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000A34
		sub	esp, 0Ch
		push	[ebp+con]	; con
		call	context_str
		add	esp, 10h
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aUnableToSetSec ; "unable to set	security context %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000A34:				; CODE XREF: main+6E1j
		mov	eax, [ebp+cur_context]
		test	eax, eax
		jz	short loc_8000A4A
		mov	eax, [ebp+cur_context]
		sub	esp, 0Ch
		push	eax		; con
		call	freecon
		add	esp, 10h

loc_8000A4A:				; CODE XREF: main+72Aj
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	edx, eax
		mov	eax, ds:optind
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; argv
		push	eax		; file
		call	execvp
		add	esp, 10h
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jnz	short loc_8000A8E
		mov	eax, 7Fh
		jmp	short loc_8000A93
; ---------------------------------------------------------------------------

loc_8000A8E:				; CODE XREF: main+776j
		mov	eax, 7Eh

loc_8000A93:				; CODE XREF: main+77Dj
		mov	[ebp+exit_status], eax
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	ebx, [eax]
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+exit_status] ; status

loc_8000AC7:				; DATA XREF: .eh_frame:080011A0o
					; .eh_frame:080011C0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_bss		segment	byte public 'BSS' use32
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000AE0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+8Do ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+22Eo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aRole		db 'role',0             ; DATA XREF: .rodata:long_optionso
aType		db 'type',0             ; DATA XREF: .rodata:long_optionso
aUser		db 'user',0             ; DATA XREF: .rodata:long_optionso
aRange		db 'range',0            ; DATA XREF: .rodata:long_optionso
aCompute	db 'compute',0          ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[8]
long_options	option <offset aRole, 1, 0, 72h> ; DATA	XREF: main+C8o
		option <offset aType, 1, 0, 74h> ; "role"
		option <offset aUser, 1, 0, 75h>
		option <offset aRange, 1, 0, 6Ch>
		option <offset aCompute, 0, 0, 63h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSContextC[]
aUsageSContextC	db 'Usage: %s CONTEXT COMMAND [args]',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND'
		db ' [args]',0Ah,0
		align 4
; char aRunAProgramInA[]
aRunAProgramInA	db 'Run a program in a different security context.',0Ah
					; DATA XREF: usage+6Eo
		db 'With neither CONTEXT nor COMMAND, print the current security cont'
		db 'ext.',0Ah
		db 0Ah
		db '  CONTEXT            Complete security context',0Ah
		db '  -c, --compute      compute process transition context before mo'
		db 'difying',0Ah
		db '  -t, --type=TYPE    type (for same role as parent)',0Ah
		db '  -u, --user=USER    user identity',0Ah
		db '  -r, --role=ROLE    role',0Ah
		db '  -l, --range=RANGE  levelrange',0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+91o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+B4o
; char locale
locale		db 0			; DATA XREF: main+76o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+88o
; char shortopts[]
shortopts	db '+r:t:u:l:c',0       ; DATA XREF: main+CDo
; char aMultipleRoles[]
aMultipleRoles	db 'multiple roles',0   ; DATA XREF: main+14Bo
; char aMultipleTypes[]
aMultipleTypes	db 'multiple types',0   ; DATA XREF: main+17Eo
; char aMultipleUsers[]
aMultipleUsers	db 'multiple users',0   ; DATA XREF: main+1B1o
; char aMultipleLevelr[]
aMultipleLevelr	db 'multiple levelranges',0 ; DATA XREF: main+1E1o
aRussellCoker	db 'Russell Coker',0    ; DATA XREF: main+228o
aRuncon		db 'runcon',0           ; DATA XREF: main+233o
; char aFailedToGetCur[]
aFailedToGetCur	db 'failed to get current context',0 ; DATA XREF: main+270o
					; main+406o
		align 4
; char aYouMustSpecify[]
aYouMustSpecify	db 'you must specify -c, -t, -u, -l, -r, or context',0
					; DATA XREF: main+2F7o
; char aNoCommandSpeci[]
aNoCommandSpeci	db 'no command specified',0 ; DATA XREF: main+349o
		align 10h
; char aSMayBeUsedOnly[]
aSMayBeUsedOnly	db '%s may be used only on a SELinux kernel',0 ; DATA XREF: main+379o
; char aFailedToCreate[]
aFailedToCreate	db 'failed to create security context: %s',0 ; DATA XREF: main+3C8o
					; main+536o
		align 10h
; char aFailedToGetSec[]
aFailedToGetSec	db 'failed to get security context of %s',0 ; DATA XREF: main+481o
		align 4
; char aFailedToComput[]
aFailedToComput	db 'failed to compute a new context',0 ; DATA XREF: main+4C1o
; char aFailedToSetNew[]
aFailedToSetNew	db 'failed to set new user %s',0 ; DATA XREF: main+577o
; char aFailedToSetN_0[]
aFailedToSetN_0	db 'failed to set new type %s',0 ; DATA XREF: main+5BAo
; char aFailedToSetN_1[]
aFailedToSetN_1	db 'failed to set new range %s',0 ; DATA XREF: main+5FDo
; char aFailedToSetN_2[]
aFailedToSetN_2	db 'failed to set new role %s',0 ; DATA XREF: main+640o
; char aInvalidContext[]
aInvalidContext	db 'invalid context: %s',0 ; DATA XREF: main+6A2o
		align 4
; char aUnableToSetSec[]
aUnableToSetSec	db 'unable to set security context %s',0 ; DATA XREF: main+702o
; char format[]
format		db '%s',0               ; DATA XREF: main+7A2o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001180h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000AC7-8001C67h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 3Ch
		dd offset loc_8000AC7-8001C6Fh
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 5Ch
		dd offset loc_8000AC7-8001C89h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 7Ch
		dd offset loc_8000AC7-8001C91h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 9Ch
		dd offset loc_8000AC7-8001C99h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 0BCh
		dd offset loc_8000AC7-8001CA1h
		dd 1Fh,	80E4100h, 0D420285h, 0CC55B05h,	404h, 1Ch, 0DCh
		dd offset loc_8000AC7-8001CA2h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 0FCh
		dd offset loc_8000AC7-8001CAAh
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 11Ch
		dd offset loc_8000AC7-8001CB2h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 13Ch
		dd offset loc_8000AC7-8001CBAh
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 15Ch
		dd offset loc_8000AC7-8001CC2h
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 1Ch, 17Ch
		dd offset loc_8000AC7-8001CCAh
		dd 18h,	80E4100h, 0D420285h, 0CC55405h,	404h, 20h, 19Ch
		dd offset loc_8000AC7-8001CD2h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	1C0h
		dd offset loc_8000AC7-8001BDAh
		dd 0DEh, 80E4100h, 0D420285h, 3864205h,	483h, 28h, 1E0h
		dd offset loc_8000AC7-8001B1Ch
		dd 7BDh, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 787502h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: getcon+6p
					; getfilecon+6p ...
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+7Dp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+D9p	main+246p ...
		extrn set_program_name:near ; CODE XREF: main+6Bp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+92p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+A2p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+ADo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+B2p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+D7p
; int optind
		extrn optind:dword	; DATA XREF: main+E8r main+2EBr ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+160p	main+193p ...
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000477r
					; main:loc_80004AAr ...
		extrn Version:dword	; DATA XREF: main:loc_8000527r
		extrn version_etc:near	; CODE XREF: main+239p
; int fputc_unlocked(int c, FILE *stream)
		extrn fputc_unlocked:near ; CODE XREF: main+2B6p
		extrn quotearg_colon:near ; CODE XREF: main+3BBp main+529p ...
		extrn quote:near	; CODE XREF: main+474p	main+6F5p
; int execvp(const char	*file, char *const *argv)
		extrn execvp:near	; CODE XREF: main+764p


		end
