;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	2FC61AC9B6340337AC910D259A0ADBCE
; Input	CRC32 :	BCB5CCBA

; File Name   :	D:\coreutils-o\fmt.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'fmt.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+155p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1C0p	main+20Bp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000159
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000276
; ---------------------------------------------------------------------------

loc_8000159:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSWidthOpt ; "Usage: %s [-WIDTH] [OPTION]... [FILE].."...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aReformatEachPa ; "Reformat each	paragraph in the FILE(s),"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCCrownMarginPr ; "  -c,	--crown-margin	      preserve in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTTaggedParagra ; "  -t,	--tagged-paragraph    indentation"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aWithNoFileOrWh ; "\nWith no FILE, or when FILE is -, read"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000276:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -3Ch
ok		= byte ptr -31h
tmp		= dword	ptr -30h
max_width_option= dword	ptr -2Ch
optchar		= dword	ptr -28h
file		= dword	ptr -24h
in_stream	= dword	ptr -20h
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 38h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	[ebp+max_width_option],	0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:uniform, 0
		movzx	eax, ds:uniform
		mov	ds:split, al
		movzx	eax, ds:split
		mov	ds:tagged, al
		movzx	eax, ds:tagged
		mov	ds:crown, al
		mov	ds:max_width, 4Bh
		mov	ds:prefix, offset locale
		mov	ds:prefix_full_length, 0
		mov	eax, ds:prefix_full_length
		mov	ds:prefix_lead_space, eax
		mov	eax, ds:prefix_lead_space
		mov	ds:prefix_length, eax
		cmp	dword ptr [ebx], 1
		jle	loc_80004C4
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	loc_80004C4
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_80004C4
		mov	eax, [ebp+argv]
		add	eax, 4
		mov	eax, [eax]
		add	eax, 1
		mov	[ebp+max_width_option],	eax
		mov	eax, [ebp+argv]
		lea	edx, [eax+4]
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		mov	[edx], eax
		add	[ebp+argv], 4
		sub	dword ptr [ebx], 1
		jmp	loc_80004C4
; ---------------------------------------------------------------------------

loc_80003C8:				; CODE XREF: main+266j
		mov	eax, [ebp+optchar]
		cmp	eax, 70h
		jz	loc_8000474
		cmp	eax, 70h
		jg	short loc_80003F6
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000487
		cmp	eax, 63h
		jz	short loc_8000446
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000491
		jmp	short loc_8000411
; ---------------------------------------------------------------------------

loc_80003F6:				; CODE XREF: main+156j
		cmp	eax, 74h
		jz	short loc_8000458
		cmp	eax, 74h
		jg	short loc_8000407
		cmp	eax, 73h
		jz	short loc_800044F
		jmp	short loc_8000411
; ---------------------------------------------------------------------------

loc_8000407:				; CODE XREF: main+17Dj
		cmp	eax, 75h
		jz	short loc_8000461
		cmp	eax, 77h
		jz	short loc_800046A

loc_8000411:				; CODE XREF: main+173j	main+184j
		mov	eax, [ebp+optchar]
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_800043C
		sub	esp, 0Ch
		push	offset aInvalidOptionC ; "invalid option -- %c;	-WIDTH is recogni"...
		call	gettext
		add	esp, 10h
		push	[ebp+optchar]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800043C:				; CODE XREF: main+199j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000446:				; CODE XREF: main+166j
		mov	ds:crown, 1
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_800044F:				; CODE XREF: main+182j
		mov	ds:split, 1
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_8000458:				; CODE XREF: main+178j
		mov	ds:tagged, 1
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_8000461:				; CODE XREF: main+189j
		mov	ds:uniform, 1
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_800046A:				; CODE XREF: main+18Ej
		mov	eax, ds:optarg
		mov	[ebp+max_width_option],	eax
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_8000474:				; CODE XREF: main+14Dj
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; p
		call	set_prefix
		add	esp, 10h
		jmp	short loc_80004C4
; ---------------------------------------------------------------------------

loc_8000487:				; CODE XREF: main+15Dj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000491:				; CODE XREF: main+16Dj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aRossPaterson ; "Ross Paterson"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aFmt	; "fmt"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80004C4:				; CODE XREF: main+EAj main+FDj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "0123456789cstuw:p:"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optchar], eax
		cmp	[ebp+optchar], 0FFFFFFFFh
		jnz	loc_80003C8
		cmp	[ebp+max_width_option],	0
		jz	short loc_8000552
		sub	esp, 0Ch
		push	offset locale
		lea	eax, [ebp+tmp]
		push	eax
		push	0Ah
		push	0
		push	[ebp+max_width_option]
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_800051C
		mov	eax, [ebp+tmp]
		cmp	eax, 9C4h
		jbe	short loc_800054A

loc_800051C:				; CODE XREF: main+28Fj
		sub	esp, 0Ch
		push	[ebp+max_width_option]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aInvalidWidthS ;	"invalid width:	%s"
		call	gettext
		add	esp, 10h
		push	esi
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800054A:				; CODE XREF: main+299j
		mov	eax, [ebp+tmp]
		mov	ds:max_width, eax

loc_8000552:				; CODE XREF: main+270j
		mov	eax, ds:max_width
		imul	ecx, eax, 0BBh
		mov	edx, 51EB851Fh
		mov	eax, ecx
		imul	edx
		sar	edx, 6
		mov	eax, ecx
		sar	eax, 1Fh
		sub	edx, eax
		mov	eax, edx
		mov	ds:best_width, eax
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jnz	loc_8000681
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; f
		call	fmt
		add	esp, 10h
		jmp	loc_800068E
; ---------------------------------------------------------------------------

loc_800059A:				; CODE XREF: main+407j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+file], eax
		sub	esp, 8
		push	offset asc_8009E01 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80005DD
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; f
		call	fmt
		add	esp, 10h
		jmp	loc_8000674
; ---------------------------------------------------------------------------

loc_80005DD:				; CODE XREF: main+344j
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+file]
		call	fopen64
		add	esp, 10h
		mov	[ebp+in_stream], eax
		cmp	[ebp+in_stream], 0
		jz	short loc_800063A
		sub	esp, 0Ch
		push	[ebp+in_stream]	; f
		call	fmt
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+in_stream]	; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000674
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	short loc_8000674
; ---------------------------------------------------------------------------

loc_800063A:				; CODE XREF: main+376j
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	edi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	edi
		push	esi		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8000674:				; CODE XREF: main+357j	main+397j ...
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax

loc_8000681:				; CODE XREF: main+2FDj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	loc_800059A

loc_800068E:				; CODE XREF: main+314j
		cmp	[ebp+ok], 0
		jz	short loc_800069B
		mov	eax, 0
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_800069B:				; CODE XREF: main+411j
		mov	eax, 1

loc_80006A0:				; CODE XREF: main+418j
		sub	esp, 0Ch
		push	eax		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_prefix(char *p)
set_prefix	proc near		; CODE XREF: main+1FCp

s		= dword	ptr -0Ch
p		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ds:prefix_lead_space, 0
		jmp	short loc_80006CC
; ---------------------------------------------------------------------------

loc_80006BB:				; CODE XREF: set_prefix+2Bj
		mov	eax, ds:prefix_lead_space
		add	eax, 1
		mov	ds:prefix_lead_space, eax
		add	[ebp+p], 1

loc_80006CC:				; CODE XREF: set_prefix+10j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_80006BB
		mov	eax, [ebp+p]
		mov	ds:prefix, eax
		sub	esp, 0Ch
		push	[ebp+p]		; s
		call	strlen
		add	esp, 10h
		mov	ds:prefix_full_length, eax
		mov	eax, ds:prefix_full_length
		mov	edx, eax
		mov	eax, [ebp+p]
		add	eax, edx
		mov	[ebp+s], eax
		jmp	short loc_8000706
; ---------------------------------------------------------------------------

loc_8000702:				; CODE XREF: set_prefix+70j
		sub	[ebp+s], 1

loc_8000706:				; CODE XREF: set_prefix+57j
		mov	eax, [ebp+s]
		cmp	eax, [ebp+p]
		jbe	short loc_800071B
		mov	eax, [ebp+s]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 20h
		jz	short loc_8000702

loc_800071B:				; CODE XREF: set_prefix+63j
		mov	eax, [ebp+s]
		mov	byte ptr [eax],	0
		mov	edx, [ebp+s]
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		mov	ds:prefix_length, eax
		nop
		leave
		retn
set_prefix	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl fmt(FILE	*f)
fmt		proc near		; CODE XREF: main+30Cp	main+34Fp ...

f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	ds:tabs, 0
		mov	ds:other_indent, 0
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	get_prefix
		add	esp, 10h
		mov	ds:next_char, eax
		jmp	short loc_8000775
; ---------------------------------------------------------------------------

loc_800075F:				; CODE XREF: fmt+52j
		call	fmt_paragraph
		mov	eax, ds:w
		sub	esp, 0Ch
		push	eax		; finish
		call	put_paragraph
		add	esp, 10h

loc_8000775:				; CODE XREF: fmt+2Aj
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	get_paragraph
		add	esp, 10h
		test	al, al
		jnz	short loc_800075F
		nop
		leave
		retn
fmt		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_other_indent(_Bool same_paragraph)
set_other_indent proc near		; CODE XREF: get_paragraph+E8p
					; get_line+2Dp	...

same_paragraph	= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+same_paragraph], al
		movzx	eax, ds:split
		test	al, al
		jz	short loc_80007B0
		mov	eax, ds:first_indent
		mov	ds:other_indent, eax
		jmp	loc_8000835
; ---------------------------------------------------------------------------

loc_80007B0:				; CODE XREF: set_other_indent+15j
		movzx	eax, ds:crown
		test	al, al
		jz	short loc_80007D4
		cmp	[ebp+same_paragraph], 0
		jz	short loc_80007C8
		mov	eax, ds:in_column
		jmp	short loc_80007CD
; ---------------------------------------------------------------------------

loc_80007C8:				; CODE XREF: set_other_indent+35j
		mov	eax, ds:first_indent

loc_80007CD:				; CODE XREF: set_other_indent+3Cj
		mov	ds:other_indent, eax
		jmp	short loc_8000835
; ---------------------------------------------------------------------------

loc_80007D4:				; CODE XREF: set_other_indent+2Fj
		movzx	eax, ds:tagged
		test	al, al
		jz	short loc_800082B
		cmp	[ebp+same_paragraph], 0
		jz	short loc_8000800
		mov	edx, ds:in_column
		mov	eax, ds:first_indent
		cmp	edx, eax
		jz	short loc_8000800
		mov	eax, ds:in_column
		mov	ds:other_indent, eax
		jmp	short loc_8000835
; ---------------------------------------------------------------------------

loc_8000800:				; CODE XREF: set_other_indent+59j
					; set_other_indent+68j
		mov	edx, ds:other_indent
		mov	eax, ds:first_indent
		cmp	edx, eax
		jnz	short loc_8000835
		mov	eax, ds:first_indent
		test	eax, eax
		jnz	short loc_800081F
		mov	eax, 3
		jmp	short loc_8000824
; ---------------------------------------------------------------------------

loc_800081F:				; CODE XREF: set_other_indent+8Cj
		mov	eax, 0

loc_8000824:				; CODE XREF: set_other_indent+93j
		mov	ds:other_indent, eax
		jmp	short loc_8000835
; ---------------------------------------------------------------------------

loc_800082B:				; CODE XREF: set_other_indent+53j
		mov	eax, ds:first_indent
		mov	ds:other_indent, eax

loc_8000835:				; CODE XREF: set_other_indent+21j
					; set_other_indent+48j	...
		nop
		leave
		retn
set_other_indent endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	get_paragraph(FILE *f)
get_paragraph	proc near		; CODE XREF: fmt+48p

c		= dword	ptr -0Ch
f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ds:last_line_length, 0
		mov	eax, ds:next_char
		mov	[ebp+c], eax
		jmp	short loc_800089E
; ---------------------------------------------------------------------------

loc_8000852:				; CODE XREF: get_paragraph+6Aj
					; get_paragraph+70j ...
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	copy_rest
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000880
		mov	ds:next_char, 0FFFFFFFFh
		mov	eax, 0
		jmp	locret_8000A71
; ---------------------------------------------------------------------------

loc_8000880:				; CODE XREF: get_paragraph+32j
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	get_prefix
		add	esp, 10h
		mov	[ebp+c], eax

loc_800089E:				; CODE XREF: get_paragraph+18j
		cmp	[ebp+c], 0Ah
		jz	short loc_8000852
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000852
		mov	edx, ds:next_prefix_indent
		mov	eax, ds:prefix_lead_space
		cmp	edx, eax
		jl	short loc_8000852
		mov	edx, ds:next_prefix_indent
		mov	eax, ds:prefix_full_length
		add	edx, eax
		mov	eax, ds:in_column
		cmp	edx, eax
		jg	short loc_8000852
		mov	eax, ds:next_prefix_indent
		mov	ds:prefix_indent, eax
		mov	eax, ds:in_column
		mov	ds:first_indent, eax
		mov	ds:wptr, offset	parabuf
		mov	ds:w, offset unused_word_type
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_line
		add	esp, 10h
		mov	[ebp+c], eax
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; same_paragraph
		call	set_other_indent
		add	esp, 10h
		movzx	eax, ds:split
		test	al, al
		jnz	loc_8000A2E
		movzx	eax, ds:crown
		test	al, al
		jz	short loc_8000996
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		test	al, al
		jz	loc_8000A2E

loc_8000958:				; CODE XREF: get_paragraph+157j
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_line
		add	esp, 10h
		mov	[ebp+c], eax
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		test	al, al
		jz	loc_8000A2E
		mov	edx, ds:in_column
		mov	eax, ds:other_indent
		cmp	edx, eax
		jz	short loc_8000958
		jmp	loc_8000A2E
; ---------------------------------------------------------------------------

loc_8000996:				; CODE XREF: get_paragraph+108j
		movzx	eax, ds:tagged
		test	al, al
		jz	short loc_8000A0D
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		test	al, al
		jz	short loc_8000A2E
		mov	edx, ds:in_column
		mov	eax, ds:first_indent
		cmp	edx, eax
		jz	short loc_8000A2E

loc_80009C2:				; CODE XREF: get_paragraph+1BDj
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_line
		add	esp, 10h
		mov	[ebp+c], eax
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		test	al, al
		jz	short loc_8000A2E
		mov	edx, ds:in_column
		mov	eax, ds:other_indent
		cmp	edx, eax
		jz	short loc_80009C2
		jmp	short loc_8000A2E
; ---------------------------------------------------------------------------

loc_80009F9:				; CODE XREF: get_paragraph+1F4j
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_line
		add	esp, 10h
		mov	[ebp+c], eax

loc_8000A0D:				; CODE XREF: get_paragraph+167j
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	same_para
		add	esp, 10h
		test	al, al
		jz	short loc_8000A2E
		mov	edx, ds:in_column
		mov	eax, ds:other_indent
		cmp	edx, eax
		jz	short loc_80009F9

loc_8000A2E:				; CODE XREF: get_paragraph+F9j
					; get_paragraph+11Aj ...
		mov	eax, ds:w
		lea	edx, [eax-1Ch]
		mov	eax, ds:w
		sub	eax, 1Ch
		movzx	ecx, byte ptr [eax+0Ch]
		or	ecx, 8
		mov	[eax+0Ch], cl
		movzx	eax, byte ptr [eax+0Ch]
		shr	al, 3
		and	eax, 1
		and	eax, 1
		lea	ecx, [eax+eax]
		movzx	eax, byte ptr [edx+0Ch]
		and	eax, 0FFFFFFFDh
		or	eax, ecx
		mov	[edx+0Ch], al
		mov	eax, [ebp+c]
		mov	ds:next_char, eax
		mov	eax, 1

locret_8000A71:				; CODE XREF: get_paragraph+43j
		leave
		retn
get_paragraph	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl copy_rest(FILE *f, int c)
copy_rest	proc near		; CODE XREF: get_paragraph+23p

s		= dword	ptr -0Ch
f		= dword	ptr  8
c		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ds:out_column, 0
		mov	edx, ds:in_column
		mov	eax, ds:next_prefix_indent
		cmp	edx, eax
		jg	short loc_8000AA6
		cmp	[ebp+c], 0Ah
		jz	loc_8000B73
		cmp	[ebp+c], 0FFFFFFFFh
		jz	loc_8000B73

loc_8000AA6:				; CODE XREF: copy_rest+1Dj
		mov	eax, ds:next_prefix_indent
		sub	esp, 0Ch
		push	eax		; space
		call	put_space
		add	esp, 10h
		mov	eax, ds:prefix
		mov	[ebp+s], eax
		jmp	short loc_8000AE9
; ---------------------------------------------------------------------------

loc_8000AC1:				; CODE XREF: copy_rest+8Dj
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:out_column
		add	eax, 1
		mov	ds:out_column, eax

loc_8000AE9:				; CODE XREF: copy_rest+4Cj
		mov	edx, ds:out_column
		mov	eax, ds:in_column
		cmp	edx, eax
		jz	short loc_8000B02
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000AC1

loc_8000B02:				; CODE XREF: copy_rest+83j
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000B29
		cmp	[ebp+c], 0Ah
		jz	short loc_8000B29
		mov	edx, ds:in_column
		mov	eax, ds:out_column
		sub	edx, eax
		mov	eax, edx
		sub	esp, 0Ch
		push	eax		; space
		call	put_space
		add	esp, 10h

loc_8000B29:				; CODE XREF: copy_rest+93j
					; copy_rest+99j
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000B73
		mov	edx, ds:next_prefix_indent
		mov	eax, ds:prefix_length
		add	edx, eax
		mov	eax, ds:in_column
		cmp	edx, eax
		jg	short loc_8000B73
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_8000B73
; ---------------------------------------------------------------------------

loc_8000B54:				; CODE XREF: copy_rest+10Aj
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax

loc_8000B73:				; CODE XREF: copy_rest+23j
					; copy_rest+2Dj ...
		cmp	[ebp+c], 0Ah
		jz	short loc_8000B7F
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000B54

loc_8000B7F:				; CODE XREF: copy_rest+104j
		mov	eax, [ebp+c]
		leave
		retn
copy_rest	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	same_para(int c)
same_para	proc near		; CODE XREF: get_paragraph+D9p
					; get_paragraph+110p ...

c		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	edx, ds:next_prefix_indent
		mov	eax, ds:prefix_indent
		cmp	edx, eax
		jnz	short loc_8000BBF
		mov	edx, ds:next_prefix_indent
		mov	eax, ds:prefix_full_length
		add	edx, eax
		mov	eax, ds:in_column
		cmp	edx, eax
		jg	short loc_8000BBF
		cmp	[ebp+c], 0Ah
		jz	short loc_8000BBF
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000BBF
		mov	eax, 1
		jmp	short loc_8000BC4
; ---------------------------------------------------------------------------

loc_8000BBF:				; CODE XREF: same_para+10j
					; same_para+26j ...
		mov	eax, 0

loc_8000BC4:				; CODE XREF: same_para+39j
		and	eax, 1
		pop	ebp
		retn
same_para	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl get_line(FILE *f,	int c)
get_line	proc near		; CODE XREF: get_paragraph+C8p
					; get_paragraph+129p ...

end_of_parabuf	= dword	ptr -14h
end_of_word	= dword	ptr -10h
start		= dword	ptr -0Ch
f		= dword	ptr  8
c		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+end_of_parabuf], offset wptr
		mov	[ebp+end_of_word], (offset unused_word_type.text+6D28h)

loc_8000BDD:				; CODE XREF: get_line+1AEj
		mov	eax, ds:w
		mov	edx, ds:wptr
		mov	[eax], edx

loc_8000BEA:				; CODE XREF: get_line+7Fj
		mov	eax, ds:wptr
		cmp	eax, [ebp+end_of_parabuf]
		jnz	short loc_8000C03
		push	1		; same_paragraph
		call	set_other_indent
		add	esp, 4
		call	flush_paragraph

loc_8000C03:				; CODE XREF: get_line+29j
		mov	eax, ds:wptr
		lea	edx, [eax+1]
		mov	ds:wptr, edx
		mov	edx, [ebp+c]
		mov	[eax], dl
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000C4A
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 2000h
		test	eax, eax
		jz	short loc_8000BEA

loc_8000C4A:				; CODE XREF: get_line+62j
		mov	eax, ds:w
		mov	edx, ds:wptr
		mov	ecx, edx
		mov	edx, ds:w
		mov	edx, [edx]
		sub	ecx, edx
		mov	edx, ecx
		mov	[eax+4], edx
		mov	edx, [eax+4]
		mov	eax, ds:in_column
		add	eax, edx
		mov	ds:in_column, eax
		mov	eax, ds:w
		sub	esp, 0Ch
		push	eax		; w
		call	check_punctuation
		add	esp, 10h
		mov	eax, ds:in_column
		mov	[ebp+start], eax
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_space
		add	esp, 10h
		mov	[ebp+c], eax
		mov	eax, ds:w
		mov	edx, ds:in_column
		sub	edx, [ebp+start]
		mov	[eax+8], edx
		mov	eax, ds:w
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000CE3
		mov	edx, ds:w
		movzx	edx, byte ptr [edx+0Ch]
		and	edx, 2
		test	dl, dl
		jz	short loc_8000CEA
		cmp	[ebp+c], 0Ah
		jz	short loc_8000CE3
		mov	edx, ds:w
		mov	edx, [edx+8]
		cmp	edx, 1
		jle	short loc_8000CEA

loc_8000CE3:				; CODE XREF: get_line+F3j
					; get_line+10Aj
		mov	edx, 1
		jmp	short loc_8000CEF
; ---------------------------------------------------------------------------

loc_8000CEA:				; CODE XREF: get_line+104j
					; get_line+118j
		mov	edx, 0

loc_8000CEF:				; CODE XREF: get_line+11Fj
		and	edx, 1
		and	edx, 1
		lea	ecx, ds:0[edx*8]
		movzx	edx, byte ptr [eax+0Ch]
		and	edx, 0FFFFFFF7h
		or	edx, ecx
		mov	[eax+0Ch], dl
		cmp	[ebp+c], 0Ah
		jz	short loc_8000D1F
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000D1F
		movzx	eax, ds:uniform
		test	al, al
		jz	short loc_8000D44

loc_8000D1F:				; CODE XREF: get_line+143j
					; get_line+149j
		mov	eax, ds:w
		mov	edx, ds:w
		movzx	edx, byte ptr [edx+0Ch]
		and	edx, 8
		test	dl, dl
		jz	short loc_8000D3C
		mov	edx, 2
		jmp	short loc_8000D41
; ---------------------------------------------------------------------------

loc_8000D3C:				; CODE XREF: get_line+16Aj
		mov	edx, 1

loc_8000D41:				; CODE XREF: get_line+171j
		mov	[eax+8], edx

loc_8000D44:				; CODE XREF: get_line+154j
		mov	eax, ds:w
		cmp	eax, [ebp+end_of_word]
		jnz	short loc_8000D60
		sub	esp, 0Ch
		push	1		; same_paragraph
		call	set_other_indent
		add	esp, 10h
		call	flush_paragraph

loc_8000D60:				; CODE XREF: get_line+183j
		mov	eax, ds:w
		add	eax, 1Ch
		mov	ds:w, eax
		cmp	[ebp+c], 0Ah
		jz	short loc_8000D7D
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8000BDD

loc_8000D7D:				; CODE XREF: get_line+1A8j
		sub	esp, 0Ch
		push	[ebp+f]		; f
		call	get_prefix
		add	esp, 10h
		leave
		retn
get_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl get_prefix(FILE *f)
get_prefix	proc near		; CODE XREF: fmt+1Dp get_paragraph+5Bp ...

pc		= byte ptr -11h
c		= dword	ptr -10h
p		= dword	ptr -0Ch
f		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ds:in_column, 0
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		sub	esp, 8
		push	eax		; c
		push	[ebp+f]		; f
		call	get_space
		add	esp, 10h
		mov	[ebp+c], eax
		mov	eax, ds:prefix_length
		test	eax, eax
		jnz	short loc_8000DDD
		mov	edx, ds:in_column
		mov	eax, ds:prefix_lead_space
		cmp	edx, eax
		cmovle	eax, edx
		mov	ds:next_prefix_indent, eax
		jmp	short loc_8000E48
; ---------------------------------------------------------------------------

loc_8000DDD:				; CODE XREF: get_prefix+37j
		mov	eax, ds:in_column
		mov	ds:next_prefix_indent, eax
		mov	eax, ds:prefix
		mov	[ebp+p], eax
		jmp	short loc_8000E2A
; ---------------------------------------------------------------------------

loc_8000DF1:				; CODE XREF: get_prefix+A5j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		mov	[ebp+pc], al
		movzx	eax, [ebp+pc]
		cmp	eax, [ebp+c]
		jz	short loc_8000E08
		mov	eax, [ebp+c]
		jmp	short locret_8000E4B
; ---------------------------------------------------------------------------

loc_8000E08:				; CODE XREF: get_prefix+74j
		mov	eax, ds:in_column
		add	eax, 1
		mov	ds:in_column, eax
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		add	[ebp+p], 1

loc_8000E2A:				; CODE XREF: get_prefix+62j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000DF1
		sub	esp, 8
		push	[ebp+c]		; c
		push	[ebp+f]		; f
		call	get_space
		add	esp, 10h
		mov	[ebp+c], eax

loc_8000E48:				; CODE XREF: get_prefix+4Ej
		mov	eax, [ebp+c]

locret_8000E4B:				; CODE XREF: get_prefix+79j
		leave
		retn
get_prefix	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl get_space(FILE *f, int c)
get_space	proc near		; CODE XREF: get_line+CEp
					; get_prefix+25p ...

f		= dword	ptr  8
c		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8

loc_8000E53:				; CODE XREF: get_space+5Bj
		cmp	[ebp+c], 20h
		jnz	short loc_8000E68
		mov	eax, ds:in_column
		add	eax, 1
		mov	ds:in_column, eax
		jmp	short loc_8000E97
; ---------------------------------------------------------------------------

loc_8000E68:				; CODE XREF: get_space+Aj
		cmp	[ebp+c], 9
		jnz	short loc_8000E92
		mov	ds:tabs, 1
		mov	eax, ds:in_column
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		add	eax, 1
		shl	eax, 3
		mov	ds:in_column, eax
		jmp	short loc_8000E97
; ---------------------------------------------------------------------------

loc_8000E92:				; CODE XREF: get_space+1Fj
		mov	eax, [ebp+c]
		jmp	short locret_8000EAA
; ---------------------------------------------------------------------------

loc_8000E97:				; CODE XREF: get_space+19j
					; get_space+43j
		sub	esp, 0Ch
		push	[ebp+f]		; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		jmp	short loc_8000E53
; ---------------------------------------------------------------------------

locret_8000EAA:				; CODE XREF: get_space+48j
		leave
		retn
get_space	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl check_punctuation(WORD *w)
check_punctuation proc near		; CODE XREF: get_line+B5p

fin		= byte ptr -11h
finish		= dword	ptr -10h
start		= dword	ptr -0Ch
w		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+w]
		mov	eax, [eax]
		mov	[ebp+start], eax
		mov	eax, [ebp+w]
		mov	eax, [eax+4]
		lea	edx, [eax-1]
		mov	eax, [ebp+start]
		add	eax, edx
		mov	[ebp+finish], eax
		mov	eax, [ebp+finish]
		movzx	eax, byte ptr [eax]
		mov	[ebp+fin], al
		mov	eax, [ebp+start]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset s	; "([`'\""
		call	strchr
		add	esp, 10h
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+w]
		mov	ecx, edx
		and	ecx, 1
		movzx	edx, byte ptr [eax+0Ch]
		and	edx, 0FFFFFFFEh
		or	edx, ecx
		mov	[eax+0Ch], dl
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+fin]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+w]
		and	edx, 1
		lea	ecx, ds:0[edx*4]
		movzx	edx, byte ptr [eax+0Ch]
		and	edx, 0FFFFFFFBh
		or	edx, ecx
		mov	[eax+0Ch], dl
		jmp	short loc_8000F43
; ---------------------------------------------------------------------------

loc_8000F3F:				; CODE XREF: check_punctuation+BBj
		sub	[ebp+finish], 1

loc_8000F43:				; CODE XREF: check_punctuation+91j
		mov	eax, [ebp+start]
		cmp	eax, [ebp+finish]
		jnb	short loc_8000F69
		mov	eax, [ebp+finish]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset asc_8009E29 ; ")]'\""
		call	strchr
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000F3F

loc_8000F69:				; CODE XREF: check_punctuation+9Dj
		mov	eax, [ebp+finish]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset a_?	; ".?!"
		call	strchr
		add	esp, 10h
		test	eax, eax
		setnz	dl
		mov	eax, [ebp+w]
		and	edx, 1
		lea	ecx, [edx+edx]
		movzx	edx, byte ptr [eax+0Ch]
		and	edx, 0FFFFFFFDh
		or	edx, ecx
		mov	[eax+0Ch], dl
		nop
		leave
		retn
check_punctuation endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void flush_paragraph()
flush_paragraph	proc near		; CODE XREF: get_line+35p
					; get_line+192p

split_point	= dword	ptr -18h
w		= dword	ptr -14h
best_break	= dword	ptr -10h
shift		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:w
		cmp	eax, offset unused_word_type
		jnz	short loc_8000FE8
		mov	eax, ds:stdout
		mov	edx, ds:wptr
		mov	ecx, edx
		mov	edx, offset parabuf
		sub	ecx, edx
		mov	edx, ecx
		push	eax		; stream
		push	edx		; n
		push	1		; size
		push	offset parabuf	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	ds:wptr, offset	parabuf
		jmp	locret_8001130
; ---------------------------------------------------------------------------

loc_8000FE8:				; CODE XREF: flush_paragraph+10j
		call	fmt_paragraph
		mov	eax, ds:w
		mov	[ebp+split_point], eax
		mov	[ebp+best_break], 7FFFFFFFh
		mov	eax, ds:unused_word_type.next_break
		mov	[ebp+w], eax
		jmp	short loc_8001050
; ---------------------------------------------------------------------------

loc_8001006:				; CODE XREF: flush_paragraph+B8j
		mov	eax, [ebp+w]
		mov	edx, [eax+14h]
		mov	eax, [ebp+w]
		mov	eax, [eax+18h]
		mov	eax, [eax+14h]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, [ebp+best_break]
		jge	short loc_800103A
		mov	eax, [ebp+w]
		mov	[ebp+split_point], eax
		mov	eax, [ebp+w]
		mov	edx, [eax+14h]
		mov	eax, [ebp+w]
		mov	eax, [eax+18h]
		mov	eax, [eax+14h]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+best_break], eax

loc_800103A:				; CODE XREF: flush_paragraph+7Cj
		cmp	[ebp+best_break], 7FFFFFF6h
		jg	short loc_8001047
		add	[ebp+best_break], 9

loc_8001047:				; CODE XREF: flush_paragraph+A1j
		mov	eax, [ebp+w]
		mov	eax, [eax+18h]
		mov	[ebp+w], eax

loc_8001050:				; CODE XREF: flush_paragraph+64j
		mov	eax, ds:w
		cmp	[ebp+w], eax
		jnz	short loc_8001006
		sub	esp, 0Ch
		push	[ebp+split_point] ; finish
		call	put_paragraph
		add	esp, 10h
		mov	eax, ds:wptr
		mov	edx, eax
		mov	eax, [ebp+split_point]
		mov	eax, [eax]
		sub	edx, eax
		mov	eax, edx
		mov	edx, eax
		mov	eax, [ebp+split_point]
		mov	eax, [eax]
		sub	esp, 4
		push	edx		; n
		push	eax		; src
		push	offset parabuf	; dest
		call	memmove
		add	esp, 10h
		mov	eax, [ebp+split_point]
		mov	eax, [eax]
		mov	edx, eax
		mov	eax, offset parabuf
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+shift], eax
		mov	eax, ds:wptr
		mov	edx, [ebp+shift]
		neg	edx
		add	eax, edx
		mov	ds:wptr, eax
		mov	eax, [ebp+split_point]
		mov	[ebp+w], eax
		jmp	short loc_80010D2
; ---------------------------------------------------------------------------

loc_80010BD:				; CODE XREF: flush_paragraph+13Aj
		mov	eax, [ebp+w]
		mov	eax, [eax]
		mov	edx, [ebp+shift]
		neg	edx
		add	edx, eax
		mov	eax, [ebp+w]
		mov	[eax], edx
		add	[ebp+w], 1Ch

loc_80010D2:				; CODE XREF: flush_paragraph+11Bj
		mov	eax, ds:w
		cmp	[ebp+w], eax
		jbe	short loc_80010BD
		mov	eax, ds:w
		mov	edx, eax
		mov	eax, [ebp+split_point]
		sub	edx, eax
		mov	eax, edx
		sar	eax, 2
		imul	eax, 0B6DB6DB7h
		add	eax, 1
		shl	eax, 2
		lea	edx, ds:0[eax*8]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	[ebp+split_point] ; src
		push	offset unused_word_type	; dest
		call	memmove
		add	esp, 10h
		mov	eax, ds:w
		mov	edx, [ebp+split_point]
		mov	ecx, offset unused_word_type
		sub	edx, ecx
		neg	edx
		add	eax, edx
		mov	ds:w, eax

locret_8001130:				; CODE XREF: flush_paragraph+43j
		leave
		retn
flush_paragraph	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void fmt_paragraph()
fmt_paragraph	proc near		; CODE XREF: fmt:loc_800075Fp
					; flush_paragraph:loc_8000FE8p

start		= dword	ptr -20h
w		= dword	ptr -1Ch
len		= dword	ptr -18h
wcost		= dword	ptr -14h
best		= dword	ptr -10h
saved_length	= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, ds:w
		mov	dword ptr [eax+14h], 0
		mov	eax, ds:w
		mov	eax, [eax+4]
		mov	[ebp+saved_length], eax
		mov	eax, ds:w
		mov	edx, ds:max_width
		mov	[eax+4], edx
		mov	eax, ds:w
		sub	eax, 1Ch
		mov	[ebp+start], eax
		jmp	loc_8001274
; ---------------------------------------------------------------------------

loc_800116D:				; CODE XREF: fmt_paragraph+149j
		mov	[ebp+best], 7FFFFFFFh
		cmp	[ebp+start], offset unused_word_type
		jnz	short loc_8001184
		mov	eax, ds:first_indent
		jmp	short loc_8001189
; ---------------------------------------------------------------------------

loc_8001184:				; CODE XREF: fmt_paragraph+49j
		mov	eax, ds:other_indent

loc_8001189:				; CODE XREF: fmt_paragraph+50j
		mov	[ebp+len], eax
		mov	eax, [ebp+start]
		mov	[ebp+w], eax
		mov	eax, [ebp+w]
		mov	eax, [eax+4]
		add	[ebp+len], eax

loc_800119B:				; CODE XREF: fmt_paragraph+11Aj
		add	[ebp+w], 1Ch
		sub	esp, 8
		push	[ebp+len]	; len
		push	[ebp+w]		; next
		call	line_cost
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+w]
		mov	eax, [eax+14h]
		add	eax, edx
		mov	[ebp+wcost], eax
		cmp	[ebp+start], offset unused_word_type
		jnz	short loc_8001206
		mov	eax, ds:last_line_length
		test	eax, eax
		jle	short loc_8001206
		mov	eax, ds:last_line_length
		mov	edx, [ebp+len]
		sub	edx, eax
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	ecx, eax
		mov	eax, ds:last_line_length
		mov	edx, [ebp+len]
		sub	edx, eax
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		imul	eax, ecx
		mov	edx, eax
		shr	edx, 1Fh
		add	eax, edx
		sar	eax, 1
		add	[ebp+wcost], eax

loc_8001206:				; CODE XREF: fmt_paragraph+92j
					; fmt_paragraph+9Bj
		mov	eax, [ebp+wcost]
		cmp	eax, [ebp+best]
		jge	short loc_8001226
		mov	eax, [ebp+wcost]
		mov	[ebp+best], eax
		mov	eax, [ebp+start]
		mov	edx, [ebp+w]
		mov	[eax+18h], edx
		mov	eax, [ebp+start]
		mov	edx, [ebp+len]
		mov	[eax+10h], edx

loc_8001226:				; CODE XREF: fmt_paragraph+DAj
		mov	eax, ds:w
		cmp	[ebp+w], eax
		jz	short loc_8001254
		mov	eax, [ebp+w]
		sub	eax, 1Ch
		mov	edx, [eax+8]
		mov	eax, [ebp+w]
		mov	eax, [eax+4]
		add	eax, edx
		add	[ebp+len], eax
		mov	eax, ds:max_width
		cmp	[ebp+len], eax
		jl	loc_800119B
		jmp	short loc_8001255
; ---------------------------------------------------------------------------

loc_8001254:				; CODE XREF: fmt_paragraph+FCj
		nop

loc_8001255:				; CODE XREF: fmt_paragraph+120j
		sub	esp, 0Ch
		push	[ebp+start]	; this
		call	base_cost
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+best]
		add	edx, eax
		mov	eax, [ebp+start]
		mov	[eax+14h], edx
		sub	[ebp+start], 1Ch

loc_8001274:				; CODE XREF: fmt_paragraph+36j
		cmp	[ebp+start], offset unused_word_type
		jnb	loc_800116D
		mov	eax, ds:w
		mov	edx, [ebp+saved_length]
		mov	[eax+4], edx
		nop
		leave
		retn
fmt_paragraph	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; COST __cdecl base_cost(WORD *this)
base_cost	proc near		; CODE XREF: fmt_paragraph+129p

cost		= dword	ptr -4
this		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+cost], 1324h
		cmp	[ebp+this], offset unused_word_type
		jbe	loc_8001329
		mov	eax, [ebp+this]
		sub	eax, 1Ch
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 2
		test	al, al
		jz	short loc_80012DD
		mov	eax, [ebp+this]
		sub	eax, 1Ch
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 8
		test	al, al
		jz	short loc_80012D4
		sub	[ebp+cost], 9C4h
		jmp	short loc_8001329
; ---------------------------------------------------------------------------

loc_80012D4:				; CODE XREF: base_cost+3Aj
		add	[ebp+cost], 57E40h
		jmp	short loc_8001329
; ---------------------------------------------------------------------------

loc_80012DD:				; CODE XREF: base_cost+29j
		mov	eax, [ebp+this]
		sub	eax, 1Ch
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 4
		test	al, al
		jz	short loc_80012F7
		sub	[ebp+cost], 640h
		jmp	short loc_8001329
; ---------------------------------------------------------------------------

loc_80012F7:				; CODE XREF: base_cost+5Dj
		mov	eax, (offset unused_word_type.text+1Ch)
		cmp	[ebp+this], eax
		jbe	short loc_8001329
		mov	eax, [ebp+this]
		sub	eax, 38h
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 8
		test	al, al
		jz	short loc_8001329
		mov	eax, [ebp+this]
		sub	eax, 1Ch
		mov	eax, [eax+4]
		lea	ecx, [eax+2]
		mov	eax, 9C40h
		cdq
		idiv	ecx
		add	[ebp+cost], eax

loc_8001329:				; CODE XREF: base_cost+14j
					; base_cost+43j ...
		mov	eax, [ebp+this]
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 1
		test	al, al
		jz	short loc_8001340
		sub	[ebp+cost], 640h
		jmp	short loc_8001362
; ---------------------------------------------------------------------------

loc_8001340:				; CODE XREF: base_cost+A6j
		mov	eax, [ebp+this]
		movzx	eax, byte ptr [eax+0Ch]
		and	eax, 8
		test	al, al
		jz	short loc_8001362
		mov	eax, [ebp+this]
		mov	eax, [eax+4]
		lea	ecx, [eax+2]
		mov	eax, 57E4h
		cdq
		idiv	ecx
		add	[ebp+cost], eax

loc_8001362:				; CODE XREF: base_cost+AFj
					; base_cost+BDj
		mov	eax, [ebp+cost]
		leave
		retn
base_cost	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; COST __cdecl line_cost(WORD *next, int len)
line_cost	proc near		; CODE XREF: fmt_paragraph+76p

cost		= dword	ptr -8
n		= dword	ptr -4
next		= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, ds:w
		cmp	[ebp+next], eax
		jnz	short loc_800137E
		mov	eax, 0
		jmp	short locret_80013F4
; ---------------------------------------------------------------------------

loc_800137E:				; CODE XREF: line_cost+Ej
		mov	eax, ds:best_width
		sub	eax, [ebp+len]
		mov	[ebp+n], eax
		mov	edx, [ebp+n]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	ecx, eax
		mov	edx, [ebp+n]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		imul	eax, ecx
		mov	[ebp+cost], eax
		mov	eax, [ebp+next]
		mov	edx, [eax+18h]
		mov	eax, ds:w
		cmp	edx, eax
		jz	short loc_80013F1
		mov	eax, [ebp+next]
		mov	eax, [eax+10h]
		mov	edx, [ebp+len]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+n], eax
		mov	edx, [ebp+n]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	ecx, eax
		mov	edx, [ebp+n]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		imul	eax, ecx
		mov	edx, eax
		shr	edx, 1Fh
		add	eax, edx
		sar	eax, 1
		add	[ebp+cost], eax

loc_80013F1:				; CODE XREF: line_cost+4Fj
		mov	eax, [ebp+cost]

locret_80013F4:				; CODE XREF: line_cost+15j
		leave
		retn
line_cost	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl put_paragraph(WORD *finish)
put_paragraph	proc near		; CODE XREF: fmt+3Ap
					; flush_paragraph+C0p

w		= dword	ptr -0Ch
finish		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:first_indent
		sub	esp, 8
		push	eax		; indent
		push	offset unused_word_type	; w
		call	put_line
		add	esp, 10h
		mov	eax, ds:unused_word_type.next_break
		mov	[ebp+w], eax
		jmp	short loc_8001439
; ---------------------------------------------------------------------------

loc_800141C:				; CODE XREF: put_paragraph+49j
		mov	eax, ds:other_indent
		sub	esp, 8
		push	eax		; indent
		push	[ebp+w]		; w
		call	put_line
		add	esp, 10h
		mov	eax, [ebp+w]
		mov	eax, [eax+18h]
		mov	[ebp+w], eax

loc_8001439:				; CODE XREF: put_paragraph+24j
		mov	eax, [ebp+w]
		cmp	eax, [ebp+finish]
		jnz	short loc_800141C
		nop
		leave
		retn
put_paragraph	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl put_line(WORD *w, int indent)
put_line	proc near		; CODE XREF: put_paragraph+14p
					; put_paragraph+32p

endline		= dword	ptr -0Ch
w		= dword	ptr  8
indent		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	ds:out_column, 0
		mov	eax, ds:prefix_indent
		sub	esp, 0Ch
		push	eax		; space
		call	put_space
		add	esp, 10h
		mov	edx, ds:stdout
		mov	eax, ds:prefix
		sub	esp, 8
		push	edx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	edx, ds:out_column
		mov	eax, ds:prefix_length
		add	eax, edx
		mov	ds:out_column, eax
		mov	eax, ds:out_column
		mov	edx, [ebp+indent]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 0Ch
		push	eax		; space
		call	put_space
		add	esp, 10h
		mov	eax, [ebp+w]
		mov	eax, [eax+18h]
		sub	eax, 1Ch
		mov	[ebp+endline], eax
		jmp	short loc_80014D9
; ---------------------------------------------------------------------------

loc_80014B5:				; CODE XREF: put_line+9Bj
		sub	esp, 0Ch
		push	[ebp+w]		; w
		call	put_word
		add	esp, 10h
		mov	eax, [ebp+w]
		mov	eax, [eax+8]
		sub	esp, 0Ch
		push	eax		; space
		call	put_space
		add	esp, 10h
		add	[ebp+w], 1Ch

loc_80014D9:				; CODE XREF: put_line+6Fj
		mov	eax, [ebp+w]
		cmp	eax, [ebp+endline]
		jnz	short loc_80014B5
		sub	esp, 0Ch
		push	[ebp+w]		; w
		call	put_word
		add	esp, 10h
		mov	eax, ds:out_column
		mov	ds:last_line_length, eax
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		leave
		retn
put_line	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl put_word(WORD *w)
put_word	proc near		; CODE XREF: put_line+77p put_line+A3p

s		= dword	ptr -10h
n		= dword	ptr -0Ch
w		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+w]
		mov	eax, [eax]
		mov	[ebp+s], eax
		mov	eax, [ebp+w]
		mov	eax, [eax+4]
		mov	[ebp+n], eax
		jmp	short loc_8001541
; ---------------------------------------------------------------------------

loc_8001522:				; CODE XREF: put_word+3Cj
		mov	eax, [ebp+s]
		lea	edx, [eax+1]
		mov	[ebp+s], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		sub	[ebp+n], 1

loc_8001541:				; CODE XREF: put_word+17j
		cmp	[ebp+n], 0
		jnz	short loc_8001522
		mov	eax, [ebp+w]
		mov	edx, [eax+4]
		mov	eax, ds:out_column
		add	eax, edx
		mov	ds:out_column, eax
		nop
		leave
		retn
put_word	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl put_space(int space)
put_space	proc near		; CODE XREF: copy_rest+3Cp
					; copy_rest+AEp ...

space_target	= dword	ptr -10h
tab_target	= dword	ptr -0Ch
space		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, ds:out_column
		mov	eax, [ebp+space]
		add	eax, edx
		mov	[ebp+space_target], eax
		movzx	eax, ds:tabs
		test	al, al
		jz	short loc_80015EC
		mov	eax, [ebp+space_target]
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		shl	eax, 3
		mov	[ebp+tab_target], eax
		mov	eax, ds:out_column
		add	eax, 1
		cmp	eax, [ebp+tab_target]
		jge	short loc_80015EC
		jmp	short loc_80015C6
; ---------------------------------------------------------------------------

loc_800159E:				; CODE XREF: put_space+72j
		sub	esp, 0Ch
		push	9		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:out_column
		lea	edx, [eax+7]
		test	eax, eax
		cmovs	eax, edx
		sar	eax, 3
		add	eax, 1
		shl	eax, 3
		mov	ds:out_column, eax

loc_80015C6:				; CODE XREF: put_space+40j
		mov	eax, ds:out_column
		cmp	eax, [ebp+tab_target]
		jl	short loc_800159E
		jmp	short loc_80015EC
; ---------------------------------------------------------------------------

loc_80015D2:				; CODE XREF: put_space+98j
		sub	esp, 0Ch
		push	20h		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, ds:out_column
		add	eax, 1
		mov	ds:out_column, eax

loc_80015EC:				; CODE XREF: put_space+1Dj
					; put_space+3Ej ...
		mov	eax, ds:out_column
		cmp	eax, [ebp+space_target]
		jl	short loc_80015D2
		nop
		leave

locret_80015F8:				; DATA XREF: .eh_frame:08009E54o
					; .eh_frame:08009E78o ...
		retn
put_space	endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8001600h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	crown
crown		db ?			; DATA XREF: main+B0w
					; main:loc_8000446w ...
; _Bool	tagged
tagged		db ?			; DATA XREF: main+A4w main+A9r ...
; _Bool	split
split		db ?			; DATA XREF: main+98w main+9Dr ...
; _Bool	uniform
uniform		db ?			; DATA XREF: main+8Aw main+91r ...
; const	char *prefix
prefix		dd ?			; DATA XREF: main+BFw set_prefix+30w ...
; int max_width
max_width	dd ?			; DATA XREF: main+B5w main+2CCw ...
; int prefix_full_length
prefix_full_length dd ?			; DATA XREF: main+C9w main+D3r ...
; int prefix_lead_space
prefix_lead_space dd ?			; DATA XREF: main+D8w main+DDr ...
; int prefix_length
prefix_length	dd ?			; DATA XREF: main+E2w set_prefix+82w ...
; int best_width
best_width	dd ?			; DATA XREF: main+2F1w
					; line_cost:loc_800137Er
; int in_column
in_column	dd ?			; DATA XREF: set_other_indent+37r
					; set_other_indent+5Br	...
; int out_column
out_column	dd ?			; DATA XREF: copy_rest+6w
					; copy_rest+69r ...
		align 20h
; char parabuf[5000]
parabuf		db 1388h dup(?)		; DATA XREF: get_paragraph+ABo
					; flush_paragraph+1Fo ...
; char *wptr
wptr		dd ?			; DATA XREF: get_paragraph+ABw
					; get_line+6o ...
		align 20h
; WORD unused_word_type[1000]
unused_word_type WORD 3E8h dup(<?>)	; DATA XREF: get_paragraph+B5o
					; flush_paragraph+Bo ...
; WORD *w
w		dd ?			; DATA XREF: fmt+31r get_paragraph+B5w ...
; _Bool	tabs
tabs		db ?			; DATA XREF: fmt+6w get_space+21w ...
		align 4
; int prefix_indent
prefix_indent	dd ?			; DATA XREF: get_paragraph+9Cw
					; same_para+9r	...
; int first_indent
first_indent	dd ?			; DATA XREF: set_other_indent+17r
					; set_other_indent:loc_80007C8r ...
; int other_indent
other_indent	dd ?			; DATA XREF: fmt+Dw
					; set_other_indent+1Cw	...
; int next_char
next_char	dd ?			; DATA XREF: fmt+25w get_paragraph+10r ...
; int next_prefix_indent
next_prefix_indent dd ?			; DATA XREF: get_paragraph+72r
					; get_paragraph+81r ...
; int last_line_length
last_line_length dd ?			; DATA XREF: get_paragraph+6w
					; fmt_paragraph+94r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8009760h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+5Do ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+226o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSWidthOpt[]
aUsageSWidthOpt	db 'Usage: %s [-WIDTH] [OPTION]... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 10h
; char aReformatEachPa[]
aReformatEachPa	db 'Reformat each paragraph in the FILE(s), writing to standard outpu'
					; DATA XREF: usage+69o
		db 't.',0Ah
		db 'The option -WIDTH is an abbreviated form of --width=DIGITS.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 10h
; char aCCrownMarginPr[]
aCCrownMarginPr	db '  -c, --crown-margin        preserve indentation of first two lin'
					; DATA XREF: usage+AFo
		db 'es',0Ah
		db '  -p, --prefix=STRING       reformat only lines beginning with ST'
		db 'RING,',0Ah
		db '                              reattaching the prefix to reformatt'
		db 'ed lines',0Ah
		db '  -s, --split-only          split long lines, but do not refill',0Ah
		db 0
		align 4
; char aTTaggedParagra[]
aTTaggedParagra	db '  -t, --tagged-paragraph    indentation of first line different f'
					; DATA XREF: usage+D2o
		db 'rom second',0Ah
		db '  -u, --uniform-spacing     one space between words, two after se'
		db 'ntences',0Ah
		db '  -w, --width=WIDTH         maximum line width (default of 75 col'
		db 'umns)',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+F5o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+118o
		align 10h
; char aWithNoFileOrWh[]
aWithNoFileOrWh	db 0Ah			; DATA XREF: usage+13Bo
		db 'With no FILE, or when FILE is -, read standard input.',0Ah,0
aCrownMargin	db 'crown-margin',0     ; DATA XREF: .rodata:long_optionso
aPrefix		db 'prefix',0           ; DATA XREF: .rodata:long_optionso
aSplitOnly	db 'split-only',0       ; DATA XREF: .rodata:long_optionso
aTaggedParagrap	db 'tagged-paragraph',0 ; DATA XREF: .rodata:long_optionso
aUniformSpacing	db 'uniform-spacing',0  ; DATA XREF: .rodata:long_optionso
aWidth		db 'width',0            ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 10h
; const	option long_options[9]
long_options	option <offset aCrownMargin, 0,	0, 63h>	; DATA XREF: main+248o
		option <offset aPrefix,	1, 0, 70h> ; "crown-margin"
		option <offset aSplitOnly, 0, 0, 73h>
		option <offset aTaggedParagrap,	0, 0, 74h>
		option <offset aUniformSpacing,	0, 0, 75h>
		option <offset aWidth, 1, 0, 77h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char locale
locale		db 0			; DATA XREF: main+46o main+BFo ...
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+58o
		align 4
; char aInvalidOptionC[]
aInvalidOptionC	db 'invalid option -- %c; -WIDTH is recognized only when it is the fi'
					; DATA XREF: main+19Eo
		db 'rst',0Ah
		db 'option; use -w N instead',0
aRossPaterson	db 'Ross Paterson',0    ; DATA XREF: main+220o
aFmt		db 'fmt',0              ; DATA XREF: main+22Bo
; char shortopts[]
shortopts	db '0123456789cstuw:p:',0 ; DATA XREF: main+24Do
; char aInvalidWidthS[]
aInvalidWidthS	db 'invalid width: %s',0 ; DATA XREF: main+2AEo
; char asc_8009E01[]
asc_8009E01	db '-',0                ; DATA XREF: main+332o
aR		db 'r',0                ; DATA XREF: main+35Fo
; char format[]
format		db '%s',0               ; DATA XREF: main+3A3o
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: main+3CCo
; char s[]
s		db '([`',27h,'"',0      ; DATA XREF: check_punctuation+35o
; char asc_8009E29[]
asc_8009E29	db ')]',27h,'"',0       ; DATA XREF: check_punctuation+ACo
; char a__[]
a_?		db '.?!',0              ; DATA XREF: check_punctuation+CAo
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8009E34h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset locret_80015F8-800B44Ch
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset locret_80015F8-800B354h
		dd 165h, 80E4100h, 0D420285h, 3834405h,	2Ch, 5Ch
		dd offset locret_80015F8-800B20Bh
		dd 428h, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h, 1Ch,	8Ch
		dd offset locret_80015F8-800AE13h
		dd 8Ah,	80E4100h, 0D420285h, 0C5860205h, 4040Ch, 1Ch, 0ACh
		dd offset locret_80015F8-800ADA9h
		dd 57h,	80E4100h, 0D420285h, 0C5530205h, 4040Ch, 1Ch, 0CCh
		dd offset locret_80015F8-800AD72h
		dd 0AEh, 80E4100h, 0D420285h, 0C5AA0205h, 4040Ch, 1Ch
		dd 0ECh
		dd offset locret_80015F8-800ACE4h
		dd 23Bh, 80E4100h, 0D420285h, 2370305h,	4040CC5h, 1Ch
		dd 10Ch
		dd offset locret_80015F8-800AAC9h
		dd 111h, 80E4100h, 0D420285h, 10D0305h,	4040CC5h, 1Ch
		dd 12Ch
		dd offset locret_80015F8-800A9D8h
		dd 45h,	80E4100h, 0D420285h, 0C5410205h, 4040Ch, 1Ch, 14Ch
		dd offset locret_80015F8-800A9B3h
		dd 1C4h, 80E4100h, 0D420285h, 1C00305h,	4040CC5h, 1Ch
		dd 16Ch
		dd offset locret_80015F8-800A80Fh
		dd 0C0h, 80E4100h, 0D420285h, 0C5BC0205h, 4040Ch, 1Ch
		dd 18Ch
		dd offset locret_80015F8-800A76Fh
		dd 5Fh,	80E4100h, 0D420285h, 0C55B0205h, 4040Ch, 1Ch, 1ACh
		dd offset locret_80015F8-800A730h
		dd 0F4h, 80E4100h, 0D420285h, 0C5F00205h, 4040Ch, 1Ch
		dd 1CCh
		dd offset locret_80015F8-800A65Ch
		dd 192h, 80E4100h, 0D420285h, 18E0305h,	4040CC5h, 1Ch
		dd 1ECh
		dd offset locret_80015F8-800A4EAh
		dd 15Dh, 80E4100h, 0D420285h, 1590305h,	4040CC5h, 1Ch
		dd 20Ch
		dd offset locret_80015F8-800A3ADh
		dd 0D8h, 80E4100h, 0D420285h, 0C5D40205h, 4040Ch, 1Ch
		dd 22Ch
		dd offset locret_80015F8-800A2F5h
		dd 8Fh,	80E4100h, 0D420285h, 0C58B0205h, 4040Ch, 1Ch, 24Ch
		dd offset locret_80015F8-800A286h
		dd 4Eh,	80E4100h, 0D420285h, 0C54A0205h, 4040Ch, 1Ch, 26Ch
		dd offset locret_80015F8-800A258h
		dd 0C5h, 80E4100h, 0D420285h, 0C5C10205h, 4040Ch, 1Ch
		dd 28Ch
		dd offset locret_80015F8-800A1B3h
		dd 53h,	80E4100h, 0D420285h, 0C54F0205h, 4040Ch, 1Ch, 2ACh
		dd offset locret_80015F8-800A180h
		dd 9Dh,	80E4100h, 0D420285h, 0C5990205h, 4040Ch
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+4Dp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+160p main+23Ep ...
		extrn set_program_name:near ; CODE XREF: main+3Bp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+62p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+72p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+7Do
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+82p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+1B3p	main+2C1p ...
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_800046Ar
					; main:loc_8000474r
		extrn Version:dword	; DATA XREF: main:loc_8000491r
		extrn version_etc:near	; CODE XREF: main+231p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+257p
		extrn xstrtoul:near	; CODE XREF: main+285p
		extrn quote:near	; CODE XREF: main+2A1p	main+3BFp
; int optind
		extrn optind:dword	; DATA XREF: main+2F6r
					; main:loc_800059Ar ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main+303r	main+346r
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+33Ap
		extrn fopen64:near	; CODE XREF: main+367p
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+38Cp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: main+399p main+3DBp
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: set_prefix+3Bp
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: get_paragraph+4Dp
					; copy_rest+61p ...
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: copy_rest+F5p
					; get_line+53p	...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: get_line+64p
					; check_punctuation+5Bp
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: check_punctuation+3Ap
					; check_punctuation+B1p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	flush_paragraph+31p
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: flush_paragraph+E9p
					; flush_paragraph+170p


		end
