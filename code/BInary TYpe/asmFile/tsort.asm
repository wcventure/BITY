;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	F1638E5DE2F5694A20D60CD6C0786743
; Input	CRC32 :	B7D1E771

; File Name   :	D:\coreutils-o\tsort.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'tsort.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+A3p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000E6
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000E6
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000E6:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+B8p main+114p
					; DATA XREF: ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000156
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	short loc_80001C4
; ---------------------------------------------------------------------------

loc_8000156:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOptionFi ; "Usage: %s [OPTION] [FILE]\nWrite totall"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80001C4:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; item *__cdecl	new_item(const char *str)
new_item	proc near		; CODE XREF: search_item+35p
					; search_item+B4p ...

k		= dword	ptr -0Ch
str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	1Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+k], eax
		cmp	[ebp+str], 0
		jz	short loc_80001FD
		sub	esp, 0Ch
		push	[ebp+str]	; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		jmp	short loc_8000202
; ---------------------------------------------------------------------------

loc_80001FD:				; CODE XREF: new_item+1Aj
		mov	edx, 0

loc_8000202:				; CODE XREF: new_item+2Cj
		mov	eax, [ebp+k]
		mov	[eax], edx
		mov	eax, [ebp+k]
		mov	dword ptr [eax+8], 0
		mov	eax, [ebp+k]
		mov	edx, [eax+8]
		mov	eax, [ebp+k]
		mov	[eax+4], edx
		mov	eax, [ebp+k]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+k]
		mov	dword ptr [eax+10h], 0
		mov	eax, [ebp+k]
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+k]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+k]
		leave
		retn
new_item	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; item *__cdecl	search_item(item *root,	const char *str)
search_item	proc near		; CODE XREF: tsort+F1p

p		= dword	ptr -20h
q		= dword	ptr -1Ch
r		= dword	ptr -18h
s		= dword	ptr -14h
t		= dword	ptr -10h
a		= dword	ptr -0Ch
root		= dword	ptr  8
str		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		cmp	[ebp+root], 0
		jnz	short loc_800026F
		push	offset __PRETTY_FUNCTION___5158	; "search_item"
		push	80h		; line
		push	offset file	; "tsort.c"
		push	offset assertion ; "root"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800026F:				; CODE XREF: search_item+Aj
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_800029A
		sub	esp, 0Ch
		push	[ebp+str]	; str
		call	new_item
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+root]
		mov	[eax+8], edx
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		jmp	locret_80005AB
; ---------------------------------------------------------------------------

loc_800029A:				; CODE XREF: search_item+2Dj
		mov	eax, [ebp+root]
		mov	[ebp+t], eax
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	[ebp+s], eax

loc_80002AF:				; CODE XREF: search_item+35Cj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+str]	; s1
		call	strcmp
		add	esp, 10h
		mov	[ebp+a], eax
		cmp	[ebp+a], 0
		jnz	short loc_80002D4
		mov	eax, [ebp+p]
		jmp	locret_80005AB
; ---------------------------------------------------------------------------

loc_80002D4:				; CODE XREF: search_item+80j
		cmp	[ebp+a], 0
		jns	short loc_80002E5
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+q], eax
		jmp	short loc_80002EE
; ---------------------------------------------------------------------------

loc_80002E5:				; CODE XREF: search_item+8Ej
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	[ebp+q], eax

loc_80002EE:				; CODE XREF: search_item+99j
		cmp	[ebp+q], 0
		jnz	loc_800058A
		sub	esp, 0Ch
		push	[ebp+str]	; str
		call	new_item
		add	esp, 10h
		mov	[ebp+q], eax
		cmp	[ebp+a], 0
		jns	short loc_800031A
		mov	eax, [ebp+p]
		mov	edx, [ebp+q]
		mov	[eax+4], edx
		jmp	short loc_8000323
; ---------------------------------------------------------------------------

loc_800031A:				; CODE XREF: search_item+C3j
		mov	eax, [ebp+p]
		mov	edx, [ebp+q]
		mov	[eax+8], edx

loc_8000323:				; CODE XREF: search_item+CEj
		mov	eax, [ebp+s]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+str]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000354
		push	offset __PRETTY_FUNCTION___5158	; "search_item"
		push	0A4h		; line
		push	offset file	; "tsort.c"
		push	offset aStreqStrSStr ; "!STREQ (str, s->str)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000354:				; CODE XREF: search_item+EFj
		mov	eax, [ebp+s]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+str]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000387
		mov	eax, [ebp+s]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	[ebp+r], eax
		mov	[ebp+a], 0FFFFFFFFh
		jmp	loc_8000410
; ---------------------------------------------------------------------------

loc_8000387:				; CODE XREF: search_item+120j
		mov	eax, [ebp+s]
		mov	eax, [eax+8]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	[ebp+r], eax
		mov	[ebp+a], 1
		jmp	short loc_8000410
; ---------------------------------------------------------------------------

loc_800039F:				; CODE XREF: search_item+1CCj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+str]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80003D0
		push	offset __PRETTY_FUNCTION___5158	; "search_item"
		push	0B2h		; line
		push	offset file	; "tsort.c"
		push	offset aStreqStrPStr ; "!STREQ (str, p->str)"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_80003D0:				; CODE XREF: search_item+16Bj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		sub	esp, 8
		push	eax		; s2
		push	[ebp+str]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_80003FD
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		jmp	short loc_8000410
; ---------------------------------------------------------------------------

loc_80003FD:				; CODE XREF: search_item+19Cj
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], 1
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		mov	[ebp+p], eax

loc_8000410:				; CODE XREF: search_item+138j
					; search_item+153j ...
		mov	eax, [ebp+p]
		cmp	eax, [ebp+q]
		jnz	short loc_800039F
		mov	eax, [ebp+s]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_8000431
		mov	eax, [ebp+s]
		mov	eax, [eax+0Ch]
		mov	edx, [ebp+a]
		neg	edx
		cmp	eax, edx
		jnz	short loc_800044A

loc_8000431:				; CODE XREF: search_item+1D6j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+a]
		add	edx, eax
		mov	eax, [ebp+s]
		mov	[eax+0Ch], edx
		mov	eax, [ebp+q]
		jmp	locret_80005AB
; ---------------------------------------------------------------------------

loc_800044A:				; CODE XREF: search_item+1E5j
		mov	eax, [ebp+r]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+a]
		jnz	short loc_80004A8
		mov	eax, [ebp+r]
		mov	[ebp+p], eax
		cmp	[ebp+a], 0
		jns	short loc_8000478
		mov	eax, [ebp+r]
		mov	edx, [eax+8]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+r]
		mov	edx, [ebp+s]
		mov	[eax+8], edx
		jmp	short loc_800048D
; ---------------------------------------------------------------------------

loc_8000478:				; CODE XREF: search_item+215j
		mov	eax, [ebp+r]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+8], edx
		mov	eax, [ebp+r]
		mov	edx, [ebp+s]
		mov	[eax+4], edx

loc_800048D:				; CODE XREF: search_item+22Cj
		mov	eax, [ebp+r]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+r]
		mov	edx, [eax+0Ch]
		mov	eax, [ebp+s]
		mov	[eax+0Ch], edx
		jmp	loc_8000566
; ---------------------------------------------------------------------------

loc_80004A8:				; CODE XREF: search_item+209j
		cmp	[ebp+a], 0
		jns	short loc_80004E3
		mov	eax, [ebp+r]
		mov	eax, [eax+8]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+r]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+r]
		mov	[eax+4], edx
		mov	eax, [ebp+p]
		mov	edx, [eax+8]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+s]
		mov	[eax+8], edx
		jmp	short loc_8000516
; ---------------------------------------------------------------------------

loc_80004E3:				; CODE XREF: search_item+262j
		mov	eax, [ebp+r]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [eax+8]
		mov	eax, [ebp+r]
		mov	[eax+4], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+r]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+8], edx
		mov	eax, [ebp+p]
		mov	edx, [ebp+s]
		mov	[eax+4], edx

loc_8000516:				; CODE XREF: search_item+297j
		mov	eax, [ebp+s]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+r]
		mov	dword ptr [eax+0Ch], 0
		mov	eax, [ebp+p]
		mov	eax, [eax+0Ch]
		cmp	eax, [ebp+a]
		jnz	short loc_8000544
		mov	eax, [ebp+a]
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+s]
		mov	[eax+0Ch], edx
		jmp	short loc_800055C
; ---------------------------------------------------------------------------

loc_8000544:				; CODE XREF: search_item+2E9j
		mov	eax, [ebp+p]
		mov	eax, [eax+0Ch]
		mov	edx, [ebp+a]
		neg	edx
		cmp	eax, edx
		jnz	short loc_800055C
		mov	eax, [ebp+r]
		mov	edx, [ebp+a]
		mov	[eax+0Ch], edx

loc_800055C:				; CODE XREF: search_item+2F8j
					; search_item+307j
		mov	eax, [ebp+p]
		mov	dword ptr [eax+0Ch], 0

loc_8000566:				; CODE XREF: search_item+259j
		mov	eax, [ebp+t]
		mov	eax, [eax+8]
		cmp	eax, [ebp+s]
		jnz	short loc_800057C
		mov	eax, [ebp+t]
		mov	edx, [ebp+p]
		mov	[eax+8], edx
		jmp	short loc_8000585
; ---------------------------------------------------------------------------

loc_800057C:				; CODE XREF: search_item+325j
		mov	eax, [ebp+t]
		mov	edx, [ebp+p]
		mov	[eax+4], edx

loc_8000585:				; CODE XREF: search_item+330j
		mov	eax, [ebp+q]
		jmp	short locret_80005AB
; ---------------------------------------------------------------------------

loc_800058A:				; CODE XREF: search_item+A8j
		mov	eax, [ebp+q]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	short loc_80005A0
		mov	eax, [ebp+p]
		mov	[ebp+t], eax
		mov	eax, [ebp+q]
		mov	[ebp+s], eax

loc_80005A0:				; CODE XREF: search_item+348j
		mov	eax, [ebp+q]
		mov	[ebp+p], eax
		jmp	loc_80002AF
; ---------------------------------------------------------------------------

locret_80005AB:				; CODE XREF: search_item+4Bj
					; search_item+85j ...
		leave
		retn
search_item	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl record_relation(item *j,	item *k)
record_relation	proc near		; CODE XREF: tsort+10Bp

p		= dword	ptr -0Ch
j		= dword	ptr  8
k		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+k]
		mov	edx, [eax]
		mov	eax, [ebp+j]
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800060A
		mov	eax, [ebp+k]
		mov	eax, [eax+10h]
		lea	edx, [eax+1]
		mov	eax, [ebp+k]
		mov	[eax+10h], edx
		sub	esp, 0Ch
		push	8		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	edx, [ebp+k]
		mov	[eax], edx
		mov	eax, [ebp+j]
		mov	edx, [eax+18h]
		mov	eax, [ebp+p]
		mov	[eax+4], edx
		mov	eax, [ebp+j]
		mov	edx, [ebp+p]
		mov	[eax+18h], edx

loc_800060A:				; CODE XREF: record_relation+1Fj
		nop
		leave
		retn
record_relation	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	count_items(item *unused)
count_items	proc near		; DATA XREF: tsort+14Co

unused		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, ds:n_strings
		add	eax, 1
		mov	ds:n_strings, eax
		mov	eax, 0
		pop	ebp
		retn
count_items	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	scan_zeros(item	*k)
scan_zeros	proc near		; DATA XREF: tsort+164o

k		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+k]
		mov	eax, [eax+10h]
		test	eax, eax
		jnz	short loc_8000660
		mov	eax, [ebp+k]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000660
		mov	eax, ds:head
		test	eax, eax
		jnz	short loc_800064D
		mov	eax, [ebp+k]
		mov	ds:head, eax
		jmp	short loc_8000658
; ---------------------------------------------------------------------------

loc_800064D:				; CODE XREF: scan_zeros+1Dj
		mov	eax, ds:zeros
		mov	edx, [ebp+k]
		mov	[eax+14h], edx

loc_8000658:				; CODE XREF: scan_zeros+27j
		mov	eax, [ebp+k]
		mov	ds:zeros, eax

loc_8000660:				; CODE XREF: scan_zeros+Bj
					; scan_zeros+14j
		mov	eax, 0
		pop	ebp
		retn
scan_zeros	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	detect_loop(item *k)
detect_loop	proc near		; DATA XREF: tsort+23Bo

p		= dword	ptr -14h
tmp		= dword	ptr -10h
tmp_0		= dword	ptr -0Ch
k		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+k]
		mov	eax, [eax+10h]
		test	eax, eax
		jz	loc_8000795
		mov	eax, ds:loop
		test	eax, eax
		jnz	short loc_8000691
		mov	eax, [ebp+k]
		mov	ds:loop, eax
		jmp	loc_8000795
; ---------------------------------------------------------------------------

loc_8000691:				; CODE XREF: detect_loop+1Bj
		mov	eax, [ebp+k]
		add	eax, 18h
		mov	[ebp+p], eax
		jmp	loc_8000788
; ---------------------------------------------------------------------------

loc_800069F:				; CODE XREF: detect_loop+128j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	edx, [eax]
		mov	eax, ds:loop
		cmp	edx, eax
		jnz	loc_800077D
		mov	eax, [ebp+k]
		mov	eax, [eax+14h]
		test	eax, eax
		jz	loc_8000767
		jmp	short loc_800072D
; ---------------------------------------------------------------------------

loc_80006C3:				; CODE XREF: detect_loop+CDj
		mov	eax, ds:loop
		mov	eax, [eax+14h]
		mov	[ebp+tmp], eax
		mov	eax, ds:loop
		mov	ecx, [eax]
		mov	edx, ds:program_name
		mov	eax, ds:stderr
		push	ecx
		push	edx
		push	offset format	; "%s: %s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	eax, ds:loop
		cmp	eax, [ebp+k]
		jnz	short loc_8000719
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	eax, [eax]
		mov	edx, [eax+10h]
		sub	edx, 1
		mov	[eax+10h], edx
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+p]
		mov	[eax], edx
		jmp	short loc_8000736
; ---------------------------------------------------------------------------

loc_8000719:				; CODE XREF: detect_loop+91j
		mov	eax, ds:loop
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+tmp]
		mov	ds:loop, eax

loc_800072D:				; CODE XREF: detect_loop+5Aj
		mov	eax, ds:loop
		test	eax, eax
		jnz	short loc_80006C3

loc_8000736:				; CODE XREF: detect_loop+B0j
		jmp	short loc_8000757
; ---------------------------------------------------------------------------

loc_8000738:				; CODE XREF: detect_loop+F7j
		mov	eax, ds:loop
		mov	eax, [eax+14h]
		mov	[ebp+tmp_0], eax
		mov	eax, ds:loop
		mov	dword ptr [eax+14h], 0
		mov	eax, [ebp+tmp_0]
		mov	ds:loop, eax

loc_8000757:				; CODE XREF: detect_loop:loc_8000736j
		mov	eax, ds:loop
		test	eax, eax
		jnz	short loc_8000738
		mov	eax, 1
		jmp	short locret_800079A
; ---------------------------------------------------------------------------

loc_8000767:				; CODE XREF: detect_loop+54j
		mov	edx, ds:loop
		mov	eax, [ebp+k]
		mov	[eax+14h], edx
		mov	eax, [ebp+k]
		mov	ds:loop, eax
		jmp	short loc_8000795
; ---------------------------------------------------------------------------

loc_800077D:				; CODE XREF: detect_loop+46j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		add	eax, 4
		mov	[ebp+p], eax

loc_8000788:				; CODE XREF: detect_loop+33j
		mov	eax, [ebp+p]
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_800069F

loc_8000795:				; CODE XREF: detect_loop+Ej
					; detect_loop+25j ...
		mov	eax, 0

locret_800079A:				; CODE XREF: detect_loop+FEj
		leave
		retn
detect_loop	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	recurse_tree(item *root, _Bool (*action)(item *))
recurse_tree	proc near		; CODE XREF: recurse_tree+41p
					; recurse_tree+84p ...

root		= dword	ptr  8
action		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+root]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_80007C6
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		test	eax, eax
		jnz	short loc_80007C6
		sub	esp, 0Ch
		push	[ebp+root]
		mov	eax, [ebp+action]
		call	eax
		add	esp, 10h
		jmp	short locret_8000838
; ---------------------------------------------------------------------------

loc_80007C6:				; CODE XREF: recurse_tree+Ej
					; recurse_tree+18j
		mov	eax, [ebp+root]
		mov	eax, [eax+4]
		test	eax, eax
		jz	short loc_80007F0
		mov	eax, [ebp+root]
		mov	eax, [eax+4]
		sub	esp, 8
		push	[ebp+action]	; action
		push	eax		; root
		call	recurse_tree
		add	esp, 10h
		test	al, al
		jz	short loc_80007F0
		mov	eax, 1
		jmp	short locret_8000838
; ---------------------------------------------------------------------------

loc_80007F0:				; CODE XREF: recurse_tree+32j
					; recurse_tree+4Bj
		sub	esp, 0Ch
		push	[ebp+root]
		mov	eax, [ebp+action]
		call	eax
		add	esp, 10h
		test	al, al
		jz	short loc_8000809
		mov	eax, 1
		jmp	short locret_8000838
; ---------------------------------------------------------------------------

loc_8000809:				; CODE XREF: recurse_tree+64j
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_8000833
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		sub	esp, 8
		push	[ebp+action]	; action
		push	eax		; root
		call	recurse_tree
		add	esp, 10h
		test	al, al
		jz	short loc_8000833
		mov	eax, 1
		jmp	short locret_8000838
; ---------------------------------------------------------------------------

loc_8000833:				; CODE XREF: recurse_tree+75j
					; recurse_tree+8Ej
		mov	eax, 0

locret_8000838:				; CODE XREF: recurse_tree+28j
					; recurse_tree+52j ...
		leave
		retn
recurse_tree	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl walk_tree(item *root, _Bool (*action)(item *))
walk_tree	proc near		; CODE XREF: tsort+154p tsort+16Cp ...

root		= dword	ptr  8
action		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		test	eax, eax
		jz	short loc_800085F
		mov	eax, [ebp+root]
		mov	eax, [eax+8]
		sub	esp, 8
		push	[ebp+action]	; action
		push	eax		; root
		call	recurse_tree
		add	esp, 10h

loc_800085F:				; CODE XREF: walk_tree+Ej
		nop
		leave
		retn
walk_tree	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	tsort(const char *file)
tsort		proc near		; CODE XREF: main+140p

file		= dword	ptr -3Ch
ok		= byte ptr -2Ah
is_stdin	= byte ptr -29h
j		= dword	ptr -28h
k		= dword	ptr -24h
p		= dword	ptr -20h
root		= dword	ptr -1Ch
len		= dword	ptr -18h
tokenbuffer	= token_buffer ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+arg_0]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		mov	[ebp+j], 0
		mov	[ebp+k], 0
		sub	esp, 8
		push	offset asc_8000F61 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+is_stdin],	al
		sub	esp, 0Ch
		push	0		; str
		call	new_item
		add	esp, 10h
		mov	[ebp+root], eax
		movzx	eax, [ebp+is_stdin]
		xor	eax, 1
		test	al, al
		jz	short loc_80008F9
		mov	eax, ds:stdin
		sub	esp, 4
		push	eax
		push	offset aR	; "r"
		push	[ebp+file]
		call	freopen_safer
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80008F9
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008F9:				; CODE XREF: tsort+5Ej	tsort+7Bj
		sub	esp, 0Ch
		lea	eax, [ebp+tokenbuffer]
		push	eax
		call	init_tokenbuffer
		add	esp, 10h

loc_8000908:				; CODE XREF: tsort+120j
		mov	eax, ds:stdin
		lea	edx, [ebp+tokenbuffer]
		push	edx
		push	3
		push	offset asc_8000F68 ; " \t\n"
		push	eax
		call	readtoken
		add	esp, 10h
		mov	[ebp+len], eax
		cmp	[ebp+len], 0FFFFFFFFh
		jz	short loc_8000984
		cmp	[ebp+len], 0
		jnz	short loc_8000949
		push	offset __PRETTY_FUNCTION___5210	; "tsort"
		push	1C8h		; line
		push	offset file	; "tsort.c"
		push	offset aLen0	; "len != 0"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000949:				; CODE XREF: tsort+CCj
		mov	eax, [ebp+tokenbuffer.buffer]
		sub	esp, 8
		push	eax		; str
		push	[ebp+root]	; root
		call	search_item
		add	esp, 10h
		mov	[ebp+k], eax
		cmp	[ebp+j], 0
		jz	short loc_800097C
		sub	esp, 8
		push	[ebp+k]		; k
		push	[ebp+j]		; j
		call	record_relation
		add	esp, 10h
		mov	[ebp+k], 0

loc_800097C:				; CODE XREF: tsort+100j
		mov	eax, [ebp+k]
		mov	[ebp+j], eax
		jmp	short loc_8000908
; ---------------------------------------------------------------------------

loc_8000984:				; CODE XREF: tsort+C6j
		nop
		cmp	[ebp+k], 0
		jz	short loc_80009AB
		sub	esp, 0Ch
		push	offset aSInputContains ; "%s: input contains an	odd number of tok"...
		call	gettext
		add	esp, 10h
		push	[ebp+file]
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80009AB:				; CODE XREF: tsort+127j
		sub	esp, 8
		push	offset count_items ; action
		push	[ebp+root]	; root
		call	walk_tree
		add	esp, 10h
		jmp	loc_8000AB6
; ---------------------------------------------------------------------------

loc_80009C3:				; CODE XREF: tsort+25Bj
		sub	esp, 8
		push	offset scan_zeros ; action
		push	[ebp+root]	; root
		call	walk_tree
		add	esp, 10h
		jmp	loc_8000A60
; ---------------------------------------------------------------------------

loc_80009DB:				; CODE XREF: tsort+205j
		mov	eax, ds:head
		mov	eax, [eax+18h]
		mov	[ebp+p], eax
		mov	eax, ds:head
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	puts
		add	esp, 10h
		mov	eax, ds:head
		mov	dword ptr [eax], 0
		mov	eax, ds:n_strings
		sub	eax, 1
		mov	ds:n_strings, eax
		jmp	short loc_8000A4D
; ---------------------------------------------------------------------------

loc_8000A13:				; CODE XREF: tsort+1EFj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	edx, [eax+10h]
		sub	edx, 1
		mov	[eax+10h], edx
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	eax, [eax+10h]
		test	eax, eax
		jnz	short loc_8000A44
		mov	eax, ds:zeros
		mov	edx, [ebp+p]
		mov	edx, [edx]
		mov	[eax+14h], edx
		mov	eax, [ebp+p]
		mov	eax, [eax]
		mov	ds:zeros, eax

loc_8000A44:				; CODE XREF: tsort+1C9j
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+p], eax

loc_8000A4D:				; CODE XREF: tsort+1AFj
		cmp	[ebp+p], 0
		jnz	short loc_8000A13
		mov	eax, ds:head
		mov	eax, [eax+14h]
		mov	ds:head, eax

loc_8000A60:				; CODE XREF: tsort+174j
		mov	eax, ds:head
		test	eax, eax
		jnz	loc_80009DB
		mov	eax, ds:n_strings
		test	eax, eax
		jz	short loc_8000AB6
		sub	esp, 0Ch
		push	offset aSInputContai_0 ; "%s: input contains a loop:"
		call	gettext
		add	esp, 10h
		push	[ebp+file]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_8000A9A:				; CODE XREF: tsort+252j
		sub	esp, 8
		push	offset detect_loop ; action
		push	[ebp+root]	; root
		call	walk_tree
		add	esp, 10h
		mov	eax, ds:loop
		test	eax, eax
		jnz	short loc_8000A9A

loc_8000AB6:				; CODE XREF: tsort+15Cj tsort+212j
		mov	eax, ds:n_strings
		test	eax, eax
		jnz	loc_80009C3
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B1A
		cmp	[ebp+is_stdin],	0
		jz	short loc_8000AF2
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		jmp	short loc_8000B02
; ---------------------------------------------------------------------------

loc_8000AF2:				; CODE XREF: tsort+27Aj
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax

loc_8000B02:				; CODE XREF: tsort+28Ej
		call	__errno_location
		mov	eax, [eax]
		push	ebx
		push	offset aS	; "%s"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000B1A:				; CODE XREF: tsort+274j
		movzx	eax, [ebp+ok]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8000B2F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000B2F:				; CODE XREF: tsort+2C6j
		mov	ebx, [ebp+var_4]
		leave
		retn
tsort		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ok		= byte ptr -9
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset shortopts ; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, ds:Version
		push	0
		push	offset aMarkKettenis ; "Mark Kettenis"
		push	offset usage
		push	eax
		push	offset domainname ; "coreutils"
		push	offset aTsort	; "tsort"
		push	dword ptr [ebx+4]
		push	dword ptr [ebx]
		call	parse_long_options
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; longind
		push	0		; longopts
		push	offset shortopts ; shortopts
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8000BF1
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000BF1:				; CODE XREF: main+B1j
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 1
		jle	short loc_8000C4D
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000C4D:				; CODE XREF: main+CBj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jz	short loc_8000C6B
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		jmp	short loc_8000C70
; ---------------------------------------------------------------------------

loc_8000C6B:				; CODE XREF: main+120j
		mov	eax, offset asc_8000F61	; "-"

loc_8000C70:				; CODE XREF: main+135j
		sub	esp, 0Ch
		push	eax		; file
		call	tsort
		add	esp, 10h
		mov	[ebp+ok], al
		cmp	[ebp+ok], 0
		jz	short loc_8000C8C
		mov	eax, 0
		jmp	short loc_8000C91
; ---------------------------------------------------------------------------

loc_8000C8C:				; CODE XREF: main+14Fj
		mov	eax, 1

loc_8000C91:				; CODE XREF: main+156j
		sub	esp, 0Ch
		push	eax		; status

loc_8000C95:				; DATA XREF: .eh_frame:08001040o
					; .eh_frame:08001064o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8000C9Ch
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; item *head
head		dd ?			; DATA XREF: scan_zeros+16r
					; scan_zeros+22w ...
; item *zeros
zeros		dd ?			; DATA XREF: scan_zeros:loc_800064Dr
					; scan_zeros+37w ...
; item *loop
loop		dd ?			; DATA XREF: detect_loop+14r
					; detect_loop+20w ...
; size_t n_strings
n_strings	dd ?			; DATA XREF: count_items+3r
					; count_items+Bw ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 8000CACh
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 10h
; char aUsageSOptionFi[]
aUsageSOptionFi	db 'Usage: %s [OPTION] [FILE]',0Ah ; DATA XREF: usage+43o
		db 'Write totally ordered list consistent with the partial ordering i'
		db 'n FILE.',0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+66o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+89o
; char file[]
file		db 'tsort.c',0          ; DATA XREF: search_item+16o
					; search_item+FBo ...
; char assertion[]
assertion	db 'root',0             ; DATA XREF: search_item+1Bo
; char aStreqStrSStr[]
aStreqStrSStr	db '!STREQ (str, s->str)',0 ; DATA XREF: search_item+100o
; char aStreqStrPStr[]
aStreqStrPStr	db '!STREQ (str, p->str)',0 ; DATA XREF: search_item+17Co
; char format[]
format		db '%s: %s',0Ah,0       ; DATA XREF: detect_loop+7Bo
; char asc_8000F61[]
asc_8000F61	db '-',0                ; DATA XREF: tsort+2Do
					; main:loc_8000C6Bo
aR		db 'r',0                ; DATA XREF: tsort+69o
; char aS[]
aS		db '%s',0               ; DATA XREF: tsort+87o tsort+2A8o
asc_8000F68	db ' ',9,0Ah,0          ; DATA XREF: tsort+B1o
; char aLen0[]
aLen0		db 'len != 0',0         ; DATA XREF: tsort+DDo
		align 4
; char aSInputContains[]
aSInputContains	db '%s: input contains an odd number of tokens',0 ; DATA XREF: tsort+12Co
; char aSInputContai_0[]
aSInputContai_0	db '%s: input contains a loop:',0 ; DATA XREF: tsort+217o
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: tsort+27Fo
; char shortopts
shortopts	db 0			; DATA XREF: main+28o main+9Co
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
aMarkKettenis	db 'Mark Kettenis',0    ; DATA XREF: main+73o
aTsort		db 'tsort',0            ; DATA XREF: main+83o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+F4o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5158[12]
__PRETTY_FUNCTION___5158 db 'search_item',0 ; DATA XREF: search_item+Co
					; search_item+F1o ...
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5210[6]
__PRETTY_FUNCTION___5210 db 'tsort',0   ; DATA XREF: tsort+CEo
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001020h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 20h, 1Ch
		dd offset loc_8000C95-8001CD5h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	40h
		dd offset loc_8000C95-8001BDDh
		dd 0B3h, 80E4100h, 0D420285h, 3834405h,	1Ch, 5Ch
		dd offset loc_8000C95-8001B46h
		dd 7Bh,	80E4100h, 0D420285h, 0C5770205h, 4040Ch, 1Ch, 7Ch
		dd offset loc_8000C95-8001AEBh
		dd 363h, 80E4100h, 0D420285h, 35F0305h,	4040CC5h, 1Ch
		dd 9Ch
		dd offset loc_8000C95-80017A8h
		dd 60h,	80E4100h, 0D420285h, 0C55C0205h, 4040Ch, 1Ch, 0BCh
		dd offset loc_8000C95-8001768h
		dd 17h,	80E4100h, 0D420285h, 0CC55305h,	404h, 1Ch, 0DCh
		dd offset loc_8000C95-8001771h
		dd 43h,	80E4100h, 0D420285h, 0CC57F05h,	404h, 1Ch, 0FCh
		dd offset loc_8000C95-800174Eh
		dd 135h, 80E4100h, 0D420285h, 1310305h,	4040CC5h, 1Ch
		dd 11Ch
		dd offset loc_8000C95-8001639h
		dd 9Eh,	80E4100h, 0D420285h, 0C59A0205h, 4040Ch, 1Ch, 13Ch
		dd offset loc_8000C95-80015BBh
		dd 28h,	80E4100h, 0D420285h, 0CC56405h,	404h, 20h, 15Ch
		dd offset loc_8000C95-80015B3h
		dd 2D2h, 80E4100h, 0D420285h, 3834405h,	0C502CA03h, 4040CC3h
		dd 24h,	180h
		dd offset loc_8000C95-8001305h
		dd 166h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+5Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+78p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r	detect_loop+74r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p	detect_loop+81p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+AEp
					; main:loc_8000C95p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: new_item+Bp
					; record_relation+35p
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: new_item+22p
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: search_item+20p
					; search_item+105p ...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: search_item+71p
					; search_item+E5p ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: tsort+60r
					; tsort:loc_8000908r ...
		extrn freopen_safer:near ; CODE	XREF: tsort+71p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: tsort+7Dp
					; tsort:loc_8000B02p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: tsort+8Fp	tsort+141p ...
		extrn init_tokenbuffer:near ; CODE XREF: tsort+9Ep
		extrn readtoken:near	; CODE XREF: tsort+B7p
; int puts(const char *s)
		extrn puts:near		; CODE XREF: tsort+18Fp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: tsort+26Ap
		extrn quote:near	; CODE XREF: tsort+296p main+E7p
		extrn __stack_chk_fail:near ; CODE XREF: tsort+2C8p
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+5Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+64p
		extrn Version:dword	; DATA XREF: main+6Cr
		extrn parse_long_options:near ;	CODE XREF: main+8Dp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+A6p
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8000BF1r
					; main+CDr ...


		end
