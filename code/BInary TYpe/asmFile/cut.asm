;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	EA1B71496A60E7B85B24886EDF51C192
; Input	CRC32 :	8E8CA85F

; File Name   :	D:\coreutils-o\cut.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'cut.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: set_fields+CFp
					; cut_fields+133p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+1BEp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: set_fields+88p
					; set_fields+146p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_800016B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002F1
; ---------------------------------------------------------------------------

loc_800016B:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s OPTION... [FILE]...\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintSelectedP ; "Print	selected parts of lines	from each"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBBytesListSele ; "  -b,	--bytes=LIST	    select only	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFFieldsListSel ; "  -f,	--fields=LIST	    select only	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aComplementComp ; "	--complement	    complement th"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSOnlyDelimited ; "  -s,	--only-delimited    do not print "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUseOneAndOnlyO ; "\nUse	one, and only one of -b, -c or -f"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEachRangeIsOne ; "Each range is	one of:\n\n  N	   N'th b"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80002F1:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mark_range_start(size_t i)
mark_range_start proc near		; CODE XREF: set_fields+613p
					; set_fields+6ADp

ent_from_table	= dword	ptr -0Ch
i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	edx, [ebp+i]
		mov	eax, ds:range_start_ht
		sub	esp, 8
		push	edx
		push	eax
		call	hash_insert
		add	esp, 10h
		mov	[ebp+ent_from_table], eax
		cmp	[ebp+ent_from_table], 0
		jnz	short loc_8000325
		call	xalloc_die

loc_8000325:				; CODE XREF: mark_range_start+22j
		mov	eax, [ebp+ent_from_table]
		cmp	eax, [ebp+i]
		jz	short loc_8000346
		push	offset __PRETTY_FUNCTION___5209	; "mark_range_start"
		push	0FDh		; line
		push	offset file	; "cut.c"
		push	offset assertion ; "(size_t) ent_from_table == i"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000346:				; CODE XREF: mark_range_start+2Fj
		nop
		leave
		retn
mark_range_start endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mark_printable_field(size_t i)
mark_printable_field proc near		; CODE XREF: set_fields+637p

n		= dword	ptr -0Ch
i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+i]
		shr	eax, 3
		mov	[ebp+n], eax
		mov	edx, ds:printable_field
		mov	eax, [ebp+n]
		add	eax, edx
		mov	ecx, ds:printable_field
		mov	edx, [ebp+n]
		add	edx, ecx
		movzx	edx, byte ptr [edx]
		mov	esi, edx
		mov	edx, [ebp+i]
		and	edx, 7
		mov	ebx, 1
		mov	ecx, edx
		shl	ebx, cl
		mov	edx, ebx
		or	edx, esi
		mov	[eax], dl
		nop
		add	esp, 10h
		pop	ebx
		pop	esi
		pop	ebp
		retn
mark_printable_field endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_printable_field(size_t i)
is_printable_field proc	near		; CODE XREF: print_kth+26p
					; set_fields+5FEp ...

n		= dword	ptr -4
i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+i]
		shr	eax, 3
		mov	[ebp+n], eax
		mov	edx, ds:printable_field
		mov	eax, [ebp+n]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	eax, [ebp+i]
		and	eax, 7
		mov	ecx, eax
		sar	edx, cl
		mov	eax, edx
		and	eax, 1
		test	eax, eax
		setnz	al
		leave
		retn
is_printable_field endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl hash_int(const	void *x, size_t	tablesize)
hash_int	proc near		; DATA XREF: main+394o

y		= dword	ptr -4
x		= dword	ptr  8
tablesize	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+x]
		mov	[ebp+y], eax
		mov	eax, [ebp+y]
		mov	edx, 0
		div	[ebp+tablesize]
		mov	eax, edx
		leave
		retn
hash_int	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	hash_compare_ints(const	void *x, const void *y)
hash_compare_ints proc near		; DATA XREF: main+38Fo

x		= dword	ptr  8
y		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+x]
		cmp	eax, [ebp+y]
		setz	al
		pop	ebp
		retn
hash_compare_ints endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_range_start_index(size_t i)
is_range_start_index proc near		; CODE XREF: print_kth+6Cp

i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, [ebp+i]
		mov	eax, ds:range_start_ht
		sub	esp, 8
		push	edx
		push	eax
		call	hash_lookup
		add	esp, 10h
		test	eax, eax
		setnz	al
		leave
		retn
is_range_start_index endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	print_kth(size_t k, _Bool *range_start)
print_kth	proc near		; CODE XREF: cut_bytes+9Ap
					; cut_fields+44p ...

k_selected	= byte ptr -0Ah
is_selected	= byte ptr -9
k		= dword	ptr  8
range_start	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:eol_range_start
		test	eax, eax
		jz	short loc_800042C
		mov	eax, ds:eol_range_start
		cmp	eax, [ebp+k]
		jbe	short loc_8000445

loc_800042C:				; CODE XREF: print_kth+Dj
		mov	eax, ds:max_range_endpoint
		cmp	[ebp+k], eax
		ja	short loc_800044C
		push	[ebp+k]		; i
		call	is_printable_field
		add	esp, 4
		test	al, al
		jz	short loc_800044C

loc_8000445:				; CODE XREF: print_kth+17j
		mov	eax, 1
		jmp	short loc_8000451
; ---------------------------------------------------------------------------

loc_800044C:				; CODE XREF: print_kth+21j
					; print_kth+30j
		mov	eax, 0

loc_8000451:				; CODE XREF: print_kth+37j
		mov	[ebp+k_selected], al
		and	[ebp+k_selected], 1
		movzx	eax, ds:complement
		xor	al, [ebp+k_selected]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+is_selected], al
		cmp	[ebp+range_start], 0
		jz	short loc_800048E
		cmp	[ebp+is_selected], 0
		jz	short loc_800048E
		sub	esp, 0Ch
		push	[ebp+k]		; i
		call	is_range_start_index
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+range_start]
		mov	[eax], dl

loc_800048E:				; CODE XREF: print_kth+5Ej
					; print_kth+64j
		movzx	eax, [ebp+is_selected]
		leave
		retn
print_kth	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl compare_ranges(const void	*a, const void *b)
compare_ranges	proc near		; DATA XREF: set_fields+596o

a_start		= dword	ptr -8
b_start		= dword	ptr -4
a		= dword	ptr  8
b		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+a]
		mov	eax, [eax]
		mov	[ebp+a_start], eax
		mov	eax, [ebp+b]
		mov	eax, [eax]
		mov	[ebp+b_start], eax
		mov	eax, [ebp+a_start]
		cmp	eax, [ebp+b_start]
		jl	short loc_80004C0
		mov	eax, [ebp+a_start]
		cmp	eax, [ebp+b_start]
		setnle	al
		movzx	eax, al
		jmp	short locret_80004C5
; ---------------------------------------------------------------------------

loc_80004C0:				; CODE XREF: compare_ranges+1Cj
		mov	eax, 0FFFFFFFFh

locret_80004C5:				; CODE XREF: compare_ranges+2Aj
		leave
		retn
compare_ranges	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	set_fields(const char *fieldstr)
set_fields	proc near		; CODE XREF: main+3BEp

fieldstr	= dword	ptr -4Ch
lhs_specified	= byte ptr -39h
rhs_specified	= byte ptr -38h
dash_found	= byte ptr -37h
field_found	= byte ptr -36h
in_digits	= byte ptr -35h
value		= dword	ptr -34h
n_rp_allocated	= dword	ptr -30h
initial		= dword	ptr -2Ch
rp		= dword	ptr -28h
n_rp		= dword	ptr -24h
i		= dword	ptr -20h
j		= dword	ptr -1Ch
len		= dword	ptr -18h
bad_num		= dword	ptr -14h
rsi_candidate	= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 54h
		mov	eax, [ebp+arg_0]
		mov	[ebp+fieldstr],	eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+initial], 1
		mov	[ebp+value], 0
		mov	[ebp+lhs_specified], 0
		mov	[ebp+rhs_specified], 0
		mov	[ebp+dash_found], 0
		mov	[ebp+field_found], 0
		mov	[ebp+rp], 0
		mov	[ebp+n_rp], 0
		mov	[ebp+n_rp_allocated], 0
		mov	[ebp+in_digits], 0

loc_8000516:				; CODE XREF: set_fields+AFj
					; set_fields+4F4j ...
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	short loc_8000578
		mov	[ebp+in_digits], 0
		cmp	[ebp+dash_found], 0
		jz	short loc_8000554
		sub	esp, 0Ch
		push	offset aInvalidByteOrF ; "invalid byte or field	list"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000554:				; CODE XREF: set_fields+61j
		mov	[ebp+dash_found], 1
		add	[ebp+fieldstr],	1
		cmp	[ebp+lhs_specified], 0
		jz	short loc_8000567
		mov	eax, [ebp+value]
		jmp	short loc_800056C
; ---------------------------------------------------------------------------

loc_8000567:				; CODE XREF: set_fields+99j
		mov	eax, 1

loc_800056C:				; CODE XREF: set_fields+9Ej
		mov	[ebp+initial], eax
		mov	[ebp+value], 0
		jmp	short loc_8000516
; ---------------------------------------------------------------------------

loc_8000578:				; CODE XREF: set_fields+57j
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ch
		jz	short loc_80005C0
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_80005C0
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000862

loc_80005C0:				; CODE XREF: set_fields+B9j
					; set_fields+E9j
		mov	[ebp+in_digits], 0
		cmp	[ebp+dash_found], 0
		jz	loc_80007B4
		mov	[ebp+dash_found], 0
		movzx	eax, [ebp+lhs_specified]
		xor	eax, 1
		test	al, al
		jz	short loc_8000612
		movzx	eax, [ebp+rhs_specified]
		xor	eax, 1
		test	al, al
		jz	short loc_8000612
		sub	esp, 0Ch
		push	offset aInvalidRangeWi ; "invalid range	with no	endpoint: -"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000612:				; CODE XREF: set_fields+114j
					; set_fields+11Fj
		movzx	eax, [ebp+rhs_specified]
		xor	eax, 1
		test	al, al
		jz	short loc_800062E
		mov	eax, [ebp+initial]
		mov	ds:eol_range_start, eax
		mov	[ebp+field_found], 1
		jmp	loc_8000843
; ---------------------------------------------------------------------------

loc_800062E:				; CODE XREF: set_fields+154j
		mov	eax, [ebp+value]
		cmp	eax, [ebp+initial]
		jnb	short loc_8000660
		sub	esp, 0Ch
		push	offset aInvalidDecreas ; "invalid decreasing range"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000660:				; CODE XREF: set_fields+16Dj
		mov	eax, ds:eol_range_start
		test	eax, eax
		jz	loc_8000721
		mov	eax, ds:eol_range_start
		cmp	[ebp+initial], eax
		jnb	loc_80007A8
		mov	edx, ds:eol_range_start
		mov	eax, [ebp+value]
		cmp	edx, eax
		ja	short loc_8000695
		mov	eax, [ebp+initial]
		mov	ds:eol_range_start, eax
		jmp	loc_8000718
; ---------------------------------------------------------------------------

loc_8000695:				; CODE XREF: set_fields+1BFj
		cmp	[ebp+initial], 0
		jz	short loc_80006A2
		mov	eax, [ebp+value]
		test	eax, eax
		jnz	short loc_80006CC

loc_80006A2:				; CODE XREF: set_fields+1D2j
		sub	esp, 0Ch
		push	offset aFieldsAndPosit ; "fields and positions are numbered from "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80006CC:				; CODE XREF: set_fields+1D9j
		mov	eax, [ebp+n_rp_allocated]
		cmp	[ebp+n_rp], eax
		jb	short loc_80006EB
		sub	esp, 4
		push	8
		lea	eax, [ebp+n_rp_allocated]
		push	eax
		push	[ebp+rp]
		call	x2nrealloc
		add	esp, 10h
		mov	[ebp+rp], eax

loc_80006EB:				; CODE XREF: set_fields+20Bj
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+initial]
		mov	[edx], eax
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+value]
		mov	[edx+4], eax
		add	[ebp+n_rp], 1

loc_8000718:				; CODE XREF: set_fields+1C9j
		mov	[ebp+field_found], 1
		jmp	loc_80007A8
; ---------------------------------------------------------------------------

loc_8000721:				; CODE XREF: set_fields+1A0j
		cmp	[ebp+initial], 0
		jz	short loc_800072E
		mov	eax, [ebp+value]
		test	eax, eax
		jnz	short loc_8000758

loc_800072E:				; CODE XREF: set_fields+25Ej
		sub	esp, 0Ch
		push	offset aFieldsAndPosit ; "fields and positions are numbered from "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000758:				; CODE XREF: set_fields+265j
		mov	eax, [ebp+n_rp_allocated]
		cmp	[ebp+n_rp], eax
		jb	short loc_8000777
		sub	esp, 4
		push	8
		lea	eax, [ebp+n_rp_allocated]
		push	eax
		push	[ebp+rp]
		call	x2nrealloc
		add	esp, 10h
		mov	[ebp+rp], eax

loc_8000777:				; CODE XREF: set_fields+297j
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+initial]
		mov	[edx], eax
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+value]
		mov	[edx+4], eax
		add	[ebp+n_rp], 1
		mov	[ebp+field_found], 1

loc_80007A8:				; CODE XREF: set_fields+1AEj
					; set_fields+255j
		mov	[ebp+value], 0
		jmp	loc_8000843
; ---------------------------------------------------------------------------

loc_80007B4:				; CODE XREF: set_fields+101j
		mov	eax, [ebp+value]
		test	eax, eax
		jz	short loc_80007C2
		mov	eax, [ebp+value]
		test	eax, eax
		jnz	short loc_80007EC

loc_80007C2:				; CODE XREF: set_fields+2F2j
		sub	esp, 0Ch
		push	offset aFieldsAndPosit ; "fields and positions are numbered from "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80007EC:				; CODE XREF: set_fields+2F9j
		mov	eax, [ebp+n_rp_allocated]
		cmp	[ebp+n_rp], eax
		jb	short loc_800080B
		sub	esp, 4
		push	8
		lea	eax, [ebp+n_rp_allocated]
		push	eax
		push	[ebp+rp]
		call	x2nrealloc
		add	esp, 10h
		mov	[ebp+rp], eax

loc_800080B:				; CODE XREF: set_fields+32Bj
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+value]
		mov	[edx], eax
		mov	eax, [ebp+n_rp]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	edx, eax
		mov	eax, [ebp+value]
		mov	[edx+4], eax
		add	[ebp+n_rp], 1
		mov	[ebp+value], 0
		mov	[ebp+field_found], 1

loc_8000843:				; CODE XREF: set_fields+162j
					; set_fields+2E8j
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	loc_80009EF
		add	[ebp+fieldstr],	1
		mov	[ebp+lhs_specified], 0
		mov	[ebp+rhs_specified], 0
		jmp	loc_80009EA
; ---------------------------------------------------------------------------

loc_8000862:				; CODE XREF: set_fields+F3j
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	loc_80009C0
		movzx	eax, [ebp+in_digits]
		xor	eax, 1
		test	al, al
		jnz	short loc_800088B
		mov	eax, ds:num_start_5266
		test	eax, eax
		jnz	short loc_8000893

loc_800088B:				; CODE XREF: set_fields+3B9j
		mov	eax, [ebp+fieldstr]
		mov	ds:num_start_5266, eax

loc_8000893:				; CODE XREF: set_fields+3C2j
		mov	[ebp+in_digits], 1
		cmp	[ebp+dash_found], 0
		jz	short loc_80008A3
		mov	[ebp+rhs_specified], 1
		jmp	short loc_80008A7
; ---------------------------------------------------------------------------

loc_80008A3:				; CODE XREF: set_fields+3D4j
		mov	[ebp+lhs_specified], 1

loc_80008A7:				; CODE XREF: set_fields+3DAj
		mov	eax, [ebp+value]
		cmp	eax, 19999999h
		ja	short loc_80008FA
		mov	edx, [ebp+value]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		add	eax, edx
		lea	edx, [eax-30h]
		mov	eax, [ebp+value]
		cmp	edx, eax
		jb	short loc_80008FA
		mov	edx, [ebp+value]
		mov	eax, edx
		shl	eax, 2
		add	eax, edx
		add	eax, eax
		mov	edx, eax
		mov	eax, [ebp+fieldstr]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		add	eax, edx
		sub	eax, 30h
		mov	[ebp+value], eax
		mov	eax, 0
		jmp	short loc_80008FF
; ---------------------------------------------------------------------------

loc_80008FA:				; CODE XREF: set_fields+3E8j
					; set_fields+40Bj
		mov	eax, 1

loc_80008FF:				; CODE XREF: set_fields+431j
		test	al, al
		jz	loc_80009B7
		mov	eax, ds:num_start_5266
		sub	esp, 8
		push	offset accept	; "0123456789"
		push	eax		; s
		call	strspn
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, ds:num_start_5266
		sub	esp, 8
		push	[ebp+len]	; size_t
		push	eax		; char *
		call	xstrndup
		add	esp, 10h
		mov	[ebp+bad_num], eax
		mov	eax, ds:operating_mode_0
		cmp	eax, 1
		jnz	short loc_8000971
		sub	esp, 0Ch
		push	[ebp+bad_num]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aByteOffsetSIsT ; "byte offset %s is too	large"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_800099F
; ---------------------------------------------------------------------------

loc_8000971:				; CODE XREF: set_fields+478j
		sub	esp, 0Ch
		push	[ebp+bad_num]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFieldNumberSIs ; "field	number %s is too large"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800099F:				; CODE XREF: set_fields+4A8j
		sub	esp, 0Ch
		push	[ebp+bad_num]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80009B7:				; CODE XREF: set_fields+43Aj
		add	[ebp+fieldstr],	1
		jmp	loc_8000516
; ---------------------------------------------------------------------------

loc_80009C0:				; CODE XREF: set_fields+3AAj
		sub	esp, 0Ch
		push	offset aInvalidByteOrF ; "invalid byte or field	list"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80009EA:				; CODE XREF: set_fields+396j
		jmp	loc_8000516
; ---------------------------------------------------------------------------

loc_80009EF:				; CODE XREF: set_fields+384j
		nop
		mov	ds:max_range_endpoint, 0
		mov	[ebp+i], 0
		jmp	short loc_8000A39
; ---------------------------------------------------------------------------

loc_8000A03:				; CODE XREF: set_fields+578j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	edx, [eax+4]
		mov	eax, ds:max_range_endpoint
		cmp	edx, eax
		jbe	short loc_8000A35
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	eax, [eax+4]
		mov	ds:max_range_endpoint, eax

loc_8000A35:				; CODE XREF: set_fields+555j
		add	[ebp+i], 1

loc_8000A39:				; CODE XREF: set_fields+53Aj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_rp]
		jb	short loc_8000A03
		mov	eax, ds:max_range_endpoint
		shr	eax, 3
		add	eax, 1
		sub	esp, 0Ch
		push	eax
		call	xzalloc
		add	esp, 10h
		mov	ds:printable_field, eax
		push	offset compare_ranges ;	compar
		push	8		; size
		push	[ebp+n_rp]	; nmemb
		push	[ebp+rp]	; base
		call	qsort
		add	esp, 10h
		mov	[ebp+i], 0
		jmp	loc_8000B25
; ---------------------------------------------------------------------------

loc_8000A7E:				; CODE XREF: set_fields+664j
		movzx	eax, ds:complement
		test	al, al
		jz	short loc_8000AA0
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	eax, [eax+4]
		add	eax, 1
		jmp	short loc_8000AB1
; ---------------------------------------------------------------------------

loc_8000AA0:				; CODE XREF: set_fields+5C0j
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	eax, [eax]

loc_8000AB1:				; CODE XREF: set_fields+5D7j
		mov	[ebp+rsi_candidate], eax
		movzx	eax, ds:output_delimiter_specified
		test	al, al
		jz	short loc_8000AE2
		sub	esp, 0Ch
		push	[ebp+rsi_candidate] ; i
		call	is_printable_field
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000AE2
		sub	esp, 0Ch
		push	[ebp+rsi_candidate] ; i
		call	mark_range_start
		add	esp, 10h

loc_8000AE2:				; CODE XREF: set_fields+5F6j
					; set_fields+60Bj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+j], eax
		jmp	short loc_8000B0A
; ---------------------------------------------------------------------------

loc_8000AF8:				; CODE XREF: set_fields+658j
		sub	esp, 0Ch
		push	[ebp+j]		; i
		call	mark_printable_field
		add	esp, 10h
		add	[ebp+j], 1

loc_8000B0A:				; CODE XREF: set_fields+62Fj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+rp]
		add	eax, edx
		mov	eax, [eax+4]
		cmp	eax, [ebp+j]
		jnb	short loc_8000AF8
		add	[ebp+i], 1

loc_8000B25:				; CODE XREF: set_fields+5B2j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+n_rp]
		jb	loc_8000A7E
		movzx	eax, ds:output_delimiter_specified
		test	al, al
		jz	short loc_8000B7C
		movzx	eax, ds:complement
		xor	eax, 1
		test	al, al
		jz	short loc_8000B7C
		mov	eax, ds:eol_range_start
		test	eax, eax
		jz	short loc_8000B7C
		mov	eax, ds:eol_range_start
		sub	esp, 0Ch
		push	eax		; i
		call	is_printable_field
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000B7C
		mov	eax, ds:eol_range_start
		sub	esp, 0Ch
		push	eax		; i
		call	mark_range_start
		add	esp, 10h

loc_8000B7C:				; CODE XREF: set_fields+673j
					; set_fields+681j ...
		sub	esp, 0Ch
		push	[ebp+rp]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, [ebp+field_found]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8000B9F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000B9F:				; CODE XREF: set_fields+6D1j
		mov	ebx, [ebp+var_4]
		leave
		retn
set_fields	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cut_bytes(FILE *stream)
cut_bytes	proc near		; CODE XREF: cut_stream+16p

stream		= dword	ptr -2Ch
range_start	= byte ptr -1Ah
print_delimiter	= byte ptr -19h
byte_idx	= dword	ptr -18h
c		= dword	ptr -14h
rs		= dword	ptr -10h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+stream], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+byte_idx],	0
		mov	[ebp+print_delimiter], 0

loc_8000BC6:				; CODE XREF: cut_bytes+51j
					; cut_bytes+A4j ...
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0Ah
		jnz	short loc_8000BF7
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	[ebp+byte_idx],	0
		mov	[ebp+print_delimiter], 0
		jmp	short loc_8000BC6
; ---------------------------------------------------------------------------

loc_8000BF7:				; CODE XREF: cut_bytes+37j
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000C19
		cmp	[ebp+byte_idx],	0
		jz	loc_8000C99
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000C99
; ---------------------------------------------------------------------------

loc_8000C19:				; CODE XREF: cut_bytes+57j
		movzx	eax, ds:output_delimiter_specified
		test	al, al
		jz	short loc_8000C29
		lea	eax, [ebp+range_start]
		jmp	short loc_8000C2E
; ---------------------------------------------------------------------------

loc_8000C29:				; CODE XREF: cut_bytes+7Ej
		mov	eax, 0

loc_8000C2E:				; CODE XREF: cut_bytes+83j
		mov	[ebp+rs], eax
		add	[ebp+byte_idx],	1
		sub	esp, 8
		push	[ebp+rs]	; range_start
		push	[ebp+byte_idx]	; k
		call	print_kth
		add	esp, 10h
		test	al, al
		jz	loc_8000BC6
		cmp	[ebp+rs], 0
		jz	short loc_8000C82
		mov	eax, [ebp+rs]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000C82
		cmp	[ebp+print_delimiter], 0
		jz	short loc_8000C82
		mov	ecx, ds:stdout
		mov	edx, ds:output_delimiter_length
		mov	eax, ds:output_delimiter_string
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h

loc_8000C82:				; CODE XREF: cut_bytes+AEj
					; cut_bytes+B8j ...
		mov	[ebp+print_delimiter], 1
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000BC6
; ---------------------------------------------------------------------------

loc_8000C99:				; CODE XREF: cut_bytes+5Dj
					; cut_bytes+70j
		nop
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000CAC
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000CAC:				; CODE XREF: cut_bytes+101j
		leave
		retn
cut_bytes	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cut_fields(FILE *stream)
cut_fields	proc near		; CODE XREF: cut_stream+26p

found_any_selected_field= byte ptr -1Ah
buffer_first_field= byte ptr -19h
c		= dword	ptr -18h
field_idx	= dword	ptr -14h
len		= dword	ptr -10h
n_bytes		= dword	ptr -0Ch
stream		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+field_idx], 1
		mov	[ebp+found_any_selected_field],	0
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jz	loc_8000FD2
		sub	esp, 8
		push	[ebp+stream]	; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h
		sub	esp, 8
		push	0		; range_start
		push	1		; k
		call	print_kth
		add	esp, 10h
		xor	eax, 1
		mov	edx, eax
		movzx	eax, ds:suppress_non_delimited
		xor	eax, edx
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+buffer_first_field], al

loc_8000D13:				; CODE XREF: cut_fields+2CCj
					; cut_fields+2DBj ...
		cmp	[ebp+field_idx], 1
		jnz	loc_8000E82
		cmp	[ebp+buffer_first_field], 0
		jz	loc_8000E82
		movzx	eax, ds:delim
		movzx	eax, al
		sub	esp, 4
		push	[ebp+stream]
		push	0Ah
		push	eax
		push	0FFFFFFFFh
		push	0
		push	offset field_1_bufsize
		push	offset field_1_buffer
		call	getndelim2
		add	esp, 20h
		mov	[ebp+len], eax
		cmp	[ebp+len], 0
		jns	short loc_8000DA5
		mov	eax, ds:field_1_buffer
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	ds:field_1_buffer, 0
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	locret_8000FD6
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	feof_unlocked
		add	esp, 10h
		test	eax, eax
		jnz	locret_8000FD6
		call	xalloc_die

loc_8000DA5:				; CODE XREF: cut_fields+A9j
		mov	eax, [ebp+len]
		mov	[ebp+n_bytes], eax
		cmp	[ebp+n_bytes], 0
		jnz	short loc_8000DCA
		push	offset __PRETTY_FUNCTION___5307	; "cut_fields"
		push	271h		; line
		push	offset file	; "cut.c"
		push	offset aN_bytes0 ; "n_bytes != 0"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000DCA:				; CODE XREF: cut_fields+101j
		mov	eax, ds:field_1_buffer
		mov	edx, [ebp+n_bytes]
		sub	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		mov	edx, eax
		movzx	eax, ds:delim
		cmp	dl, al
		jz	short loc_8000E49
		movzx	eax, ds:suppress_non_delimited
		test	al, al
		jnz	loc_8000FCC
		mov	edx, ds:stdout
		mov	eax, ds:field_1_buffer
		push	edx		; stream
		push	[ebp+n_bytes]	; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	eax, ds:field_1_buffer
		mov	edx, [ebp+n_bytes]
		sub	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 0Ah
		jz	loc_8000FCC
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000FCC
; ---------------------------------------------------------------------------

loc_8000E49:				; CODE XREF: cut_fields+146j
		sub	esp, 8
		push	0		; range_start
		push	1		; k
		call	print_kth
		add	esp, 10h
		test	al, al
		jz	short loc_8000E7E
		mov	edx, ds:stdout
		mov	eax, [ebp+n_bytes]
		lea	ecx, [eax-1]
		mov	eax, ds:field_1_buffer
		push	edx		; stream
		push	ecx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		mov	[ebp+found_any_selected_field],	1

loc_8000E7E:				; CODE XREF: cut_fields+1ACj
		add	[ebp+field_idx], 1

loc_8000E82:				; CODE XREF: cut_fields+69j
					; cut_fields+73j
		cmp	[ebp+c], 0FFFFFFFFh
		jz	loc_8000F32
		sub	esp, 8
		push	0		; range_start
		push	[ebp+field_idx]	; k
		call	print_kth
		add	esp, 10h
		test	al, al
		jz	short loc_8000F06
		cmp	[ebp+found_any_selected_field],	0
		jz	short loc_8000EC4
		mov	ecx, ds:stdout
		mov	edx, ds:output_delimiter_length
		mov	eax, ds:output_delimiter_string
		push	ecx		; stream
		push	edx		; n
		push	1		; size
		push	eax		; ptr
		call	fwrite_unlocked
		add	esp, 10h

loc_8000EC4:				; CODE XREF: cut_fields+1F6j
		mov	[ebp+found_any_selected_field],	1
		jmp	short loc_8000ED8
; ---------------------------------------------------------------------------

loc_8000ECA:				; CODE XREF: cut_fields+254j
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000ED8:				; CODE XREF: cut_fields+21Aj
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		movzx	eax, ds:delim
		movzx	eax, al
		cmp	[ebp+c], eax
		jz	short loc_8000F32
		cmp	[ebp+c], 0Ah
		jz	short loc_8000F32
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000ECA
		jmp	short loc_8000F32
; ---------------------------------------------------------------------------

loc_8000F06:				; CODE XREF: cut_fields+1F0j
					; cut_fields+282j
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		movzx	eax, ds:delim
		movzx	eax, al
		cmp	[ebp+c], eax
		jz	short loc_8000F32
		cmp	[ebp+c], 0Ah
		jz	short loc_8000F32
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8000F06

loc_8000F32:				; CODE XREF: cut_fields+1D8j
					; cut_fields+248j ...
		cmp	[ebp+c], 0Ah
		jnz	short loc_8000F67
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	getc_unlocked
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000F67
		sub	esp, 8
		push	[ebp+stream]	; stream
		push	[ebp+c]		; c
		call	ungetc
		add	esp, 10h
		mov	[ebp+c], 0Ah

loc_8000F67:				; CODE XREF: cut_fields+288j
					; cut_fields+29Fj
		movzx	eax, ds:delim
		movzx	eax, al
		cmp	eax, [ebp+c]
		jnz	short loc_8000F7F
		add	[ebp+field_idx], 1
		jmp	loc_8000D13
; ---------------------------------------------------------------------------

loc_8000F7F:				; CODE XREF: cut_fields+2C6j
		cmp	[ebp+c], 0Ah
		jz	short loc_8000F8F
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_8000D13

loc_8000F8F:				; CODE XREF: cut_fields+2D5j
		cmp	[ebp+found_any_selected_field],	0
		jnz	short loc_8000FA9
		movzx	eax, ds:suppress_non_delimited
		xor	eax, 1
		test	al, al
		jnz	short loc_8000FA9
		cmp	[ebp+field_idx], 1
		jz	short loc_8000FB6

loc_8000FA9:				; CODE XREF: cut_fields+2E5j
					; cut_fields+2F3j
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000FB6:				; CODE XREF: cut_fields+2F9j
		cmp	[ebp+c], 0FFFFFFFFh
		jz	short loc_8000FD5
		mov	[ebp+field_idx], 1
		mov	[ebp+found_any_selected_field],	0
		jmp	loc_8000D13
; ---------------------------------------------------------------------------

loc_8000FCC:				; CODE XREF: cut_fields+151j
					; cut_fields+183j ...
		nop
		jmp	loc_8000D13
; ---------------------------------------------------------------------------

loc_8000FD2:				; CODE XREF: cut_fields+26j
		nop
		jmp	short locret_8000FD6
; ---------------------------------------------------------------------------

loc_8000FD5:				; CODE XREF: cut_fields+30Cj
		nop

locret_8000FD6:				; CODE XREF: cut_fields+D6j
					; cut_fields+ECj ...
		leave
		retn
cut_fields	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cut_stream(FILE *stream)
cut_stream	proc near		; CODE XREF: cut_file+74p

stream		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:operating_mode_0
		cmp	eax, 1
		jnz	short loc_8000FF8
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	cut_bytes
		add	esp, 10h
		jmp	short loc_8001006
; ---------------------------------------------------------------------------

loc_8000FF8:				; CODE XREF: cut_stream+Ej
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	cut_fields
		add	esp, 10h

loc_8001006:				; CODE XREF: cut_stream+1Ej
		nop
		leave
		retn
cut_stream	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	cut_file(const char *file)
cut_file	proc near		; CODE XREF: main+47Ep	main+4A8p

stream		= dword	ptr -0Ch
file		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	offset asc_800202A ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001037
		mov	ds:have_read_stdin, 1
		mov	eax, ds:stdin
		mov	[ebp+stream], eax
		jmp	short loc_8001077
; ---------------------------------------------------------------------------

loc_8001037:				; CODE XREF: cut_file+1Bj
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+file]
		call	fopen64
		add	esp, 10h
		mov	[ebp+stream], eax
		cmp	[ebp+stream], 0
		jnz	short loc_8001077
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	locret_8001118
; ---------------------------------------------------------------------------

loc_8001077:				; CODE XREF: cut_file+2Cj cut_file+48j
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	cut_stream
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	ferror_unlocked
		add	esp, 10h
		test	eax, eax
		jz	short loc_80010B8
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_8001118
; ---------------------------------------------------------------------------

loc_80010B8:				; CODE XREF: cut_file+8Cj
		sub	esp, 8
		push	offset asc_800202A ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80010DF
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	clearerr_unlocked
		add	esp, 10h
		jmp	short loc_8001113
; ---------------------------------------------------------------------------

loc_80010DF:				; CODE XREF: cut_file+C4j
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8001113
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_8001118
; ---------------------------------------------------------------------------

loc_8001113:				; CODE XREF: cut_file+D4j cut_file+E7j
		mov	eax, 1

locret_8001118:				; CODE XREF: cut_file+69j cut_file+ADj ...
		leave
		retn
cut_file	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

ok		= byte ptr -12h
delim_specified	= byte ptr -11h
spec_list_string= dword	ptr -10h
optc		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	[ebp+delim_specified], 0
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:operating_mode_0, 0
		mov	ds:suppress_non_delimited, 0
		mov	ds:delim, 0
		mov	ds:have_read_stdin, 0
		jmp	loc_80013BF
; ---------------------------------------------------------------------------

loc_80011AE:				; CODE XREF: main+2C8j
		mov	eax, [ebp+optc]
		cmp	eax, 64h
		jz	loc_80012BC
		cmp	eax, 64h
		jg	short loc_80011EC
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8001371
		cmp	eax, 0FFFFFF7Eh
		jg	short loc_80011E1
		cmp	eax, 0FFFFFF7Dh
		jz	loc_800137B
		jmp	loc_80013B5
; ---------------------------------------------------------------------------

loc_80011E1:				; CODE XREF: main+B5j
		cmp	eax, 62h
		jl	loc_80013B5
		jmp	short loc_8001228
; ---------------------------------------------------------------------------

loc_80011EC:				; CODE XREF: main+A3j
		cmp	eax, 73h
		jz	loc_800135F
		cmp	eax, 73h
		jg	short loc_800120D
		cmp	eax, 66h
		jz	short loc_8001272
		cmp	eax, 6Eh
		jz	loc_80013BF
		jmp	loc_80013B5
; ---------------------------------------------------------------------------

loc_800120D:				; CODE XREF: main+DEj
		cmp	eax, 80h
		jz	loc_8001317
		cmp	eax, 81h
		jz	loc_8001368
		jmp	loc_80013B5
; ---------------------------------------------------------------------------

loc_8001228:				; CODE XREF: main+D0j
		mov	eax, ds:operating_mode_0
		test	eax, eax
		jz	short loc_800125B
		sub	esp, 0Ch
		push	offset aOnlyOneTypeOfL ; "only one type	of list	may be specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800125B:				; CODE XREF: main+115j
		mov	ds:operating_mode_0, 1
		mov	eax, ds:optarg
		mov	[ebp+spec_list_string],	eax
		jmp	loc_80013BF
; ---------------------------------------------------------------------------

loc_8001272:				; CODE XREF: main+E3j
		mov	eax, ds:operating_mode_0
		test	eax, eax
		jz	short loc_80012A5
		sub	esp, 0Ch
		push	offset aOnlyOneTypeOfL ; "only one type	of list	may be specified"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80012A5:				; CODE XREF: main+15Fj
		mov	ds:operating_mode_0, 2
		mov	eax, ds:optarg
		mov	[ebp+spec_list_string],	eax
		jmp	loc_80013BF
; ---------------------------------------------------------------------------

loc_80012BC:				; CODE XREF: main+9Aj
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001301
		mov	eax, ds:optarg
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001301
		sub	esp, 0Ch
		push	offset aTheDelimiterMu ; "the delimiter	must be	a single characte"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001301:				; CODE XREF: main+1ACj	main+1BBj
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		mov	ds:delim, al
		mov	[ebp+delim_specified], 1
		jmp	loc_80013BF
; ---------------------------------------------------------------------------

loc_8001317:				; CODE XREF: main+F8j
		mov	ds:output_delimiter_specified, 1
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_800133D
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		jmp	short loc_8001342
; ---------------------------------------------------------------------------

loc_800133D:				; CODE XREF: main+20Ej
		mov	eax, 1

loc_8001342:				; CODE XREF: main+221j
		mov	ds:output_delimiter_length, eax
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax		; char *
		call	xstrdup
		add	esp, 10h
		mov	ds:output_delimiter_string, eax
		jmp	short loc_80013BF
; ---------------------------------------------------------------------------

loc_800135F:				; CODE XREF: main+D5j
		mov	ds:suppress_non_delimited, 1
		jmp	short loc_80013BF
; ---------------------------------------------------------------------------

loc_8001368:				; CODE XREF: main+103j
		mov	ds:complement, 1
		jmp	short loc_80013BF
; ---------------------------------------------------------------------------

loc_8001371:				; CODE XREF: main+AAj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800137B:				; CODE XREF: main+BCj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aDavidM_Ihnat ; "David M. Ihnat"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aCut	; "cut"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80013B5:				; CODE XREF: main+C2j main+CAj ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80013BF:				; CODE XREF: main+8Fj main+E8j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "b:c:d:f:ns"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80011AE
		mov	eax, ds:operating_mode_0
		test	eax, eax
		jnz	short loc_800141B
		sub	esp, 0Ch
		push	offset aYouMustSpecify ; "you must specify a list of bytes, chara"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800141B:				; CODE XREF: main+2D5j
		movzx	eax, ds:delim
		test	al, al
		jz	short loc_800145A
		mov	eax, ds:operating_mode_0
		cmp	eax, 2
		jz	short loc_800145A
		sub	esp, 0Ch
		push	offset aAnInputDelimit ; "an input delimiter may be specified onl"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800145A:				; CODE XREF: main+30Aj	main+314j
		movzx	eax, ds:suppress_non_delimited
		test	al, al
		jz	short loc_8001499
		mov	eax, ds:operating_mode_0
		cmp	eax, 2
		jz	short loc_8001499
		sub	esp, 0Ch
		push	offset aSuppressingNon ; "suppressing non-delimited lines makes	s"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001499:				; CODE XREF: main+349j	main+353j
		movzx	eax, ds:output_delimiter_specified
		test	al, al
		jz	short loc_80014D2
		sub	esp, 0Ch
		push	0
		push	offset hash_compare_ints
		push	offset hash_int
		push	0
		push	1Fh
		call	hash_initialize
		add	esp, 20h
		mov	ds:range_start_ht, eax
		mov	eax, ds:range_start_ht
		test	eax, eax
		jnz	short loc_80014D2
		call	xalloc_die

loc_80014D2:				; CODE XREF: main+388j	main+3B1j
		sub	esp, 0Ch
		push	[ebp+spec_list_string] ; fieldstr
		call	set_fields
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001545
		mov	eax, ds:operating_mode_0
		cmp	eax, 2
		jnz	short loc_800151B
		sub	esp, 0Ch
		push	offset aMissingListOfF ; "missing list of fields"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800151B:				; CODE XREF: main+3D5j
		sub	esp, 0Ch
		push	offset aMissingListOfP ; "missing list of positions"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001545:				; CODE XREF: main+3CBj
		movzx	eax, [ebp+delim_specified]
		xor	eax, 1
		test	al, al
		jz	short loc_8001557
		mov	ds:delim, 9

loc_8001557:				; CODE XREF: main+434j
		mov	eax, ds:output_delimiter_string
		test	eax, eax
		jnz	short loc_8001587
		movzx	eax, ds:delim
		mov	ds:dummy_5346, al
		mov	ds:byte_8001699, 0
		mov	ds:output_delimiter_string, offset dummy_5346
		mov	ds:output_delimiter_length, 1

loc_8001587:				; CODE XREF: main+444j
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jnz	short loc_80015A5
		sub	esp, 0Ch
		push	offset asc_800202A ; "-"
		call	cut_file
		add	esp, 10h
		mov	[ebp+ok], al
		jmp	short loc_80015F1
; ---------------------------------------------------------------------------

loc_80015A5:				; CODE XREF: main+474j
		mov	[ebp+ok], 1
		jmp	short loc_80015E8
; ---------------------------------------------------------------------------

loc_80015AB:				; CODE XREF: main+4D5j
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebx+4]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; file
		call	cut_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax

loc_80015E8:				; CODE XREF: main+48Fj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jl	short loc_80015AB

loc_80015F1:				; CODE XREF: main+489j
		mov	eax, ds:range_start_ht
		test	eax, eax
		jz	short loc_800160B
		mov	eax, ds:range_start_ht
		sub	esp, 0Ch
		push	eax
		call	hash_free
		add	esp, 10h

loc_800160B:				; CODE XREF: main+4DEj
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_800164A
		mov	eax, ds:stdin
		sub	esp, 0Ch
		push	eax		; stream
		call	fclose
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_800164A
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_800202A ; "-"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0

loc_800164A:				; CODE XREF: main+4FAj	main+510j
		cmp	[ebp+ok], 0
		jz	short loc_8001657
		mov	eax, 0
		jmp	short loc_800165C
; ---------------------------------------------------------------------------

loc_8001657:				; CODE XREF: main+534j
		mov	eax, 1

loc_800165C:				; CODE XREF: main+53Bj
		sub	esp, 0Ch
		push	eax		; status

loc_8001660:				; DATA XREF: .eh_frame:08002210o
					; .eh_frame:08002230o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8001668h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; char *field_1_buffer
field_1_buffer	dd ?			; DATA XREF: cut_fields+95o
					; cut_fields+ABr ...
; size_t field_1_bufsize
field_1_bufsize	dd ?			; DATA XREF: cut_fields+90o
; size_t max_range_endpoint
max_range_endpoint dd ?			; DATA XREF: print_kth:loc_800042Cr
					; set_fields+529w ...
; size_t eol_range_start
eol_range_start	dd ?			; DATA XREF: print_kth+6r print_kth+Fr ...
; unsigned __int8 *printable_field
printable_field	dd ?			; DATA XREF: mark_printable_field+11r
					; mark_printable_field+1Cr ...
; operating_mode operating_mode_0
operating_mode_0 dd ?			; DATA XREF: set_fields+470r
					; cut_stream+6r ...
; _Bool	suppress_non_delimited
suppress_non_delimited db ?		; DATA XREF: cut_fields+51r
					; cut_fields+148r ...
; _Bool	complement
complement	db ?			; DATA XREF: print_kth+45r
					; set_fields:loc_8000A7Er ...
; unsigned __int8 delim
delim		db ?			; DATA XREF: cut_fields+79r
					; cut_fields+13Dr ...
; _Bool	output_delimiter_specified
output_delimiter_specified db ?		; DATA XREF: set_fields+5EDr
					; set_fields+66Ar ...
; size_t output_delimiter_length
output_delimiter_length	dd ?		; DATA XREF: cut_bytes+C6r
					; cut_fields+1FEr ...
; char *output_delimiter_string
output_delimiter_string	dd ?		; DATA XREF: cut_bytes+CCr
					; cut_fields+204r ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: cut_file+1Dw main+88w ...
		align 10h
; Hash_table *range_start_ht
range_start_ht	dd ?			; DATA XREF: mark_range_start+9r
					; is_range_start_index+9r ...
; Function-local static	variable
; const	char *num_start_5266
num_start_5266	dd ?			; DATA XREF: set_fields+3BBr
					; set_fields+3C7w ...
; Function-local static	variable
; char dummy_5346[2]
dummy_5346	db ?			; DATA XREF: main+44Dw	main+459o
byte_8001699	db ?			; DATA XREF: main+452w
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 80016A0h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+43o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+27Eo
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aBytes		db 'bytes',0            ; DATA XREF: .rodata:longoptso
aCharacters	db 'characters',0       ; DATA XREF: .rodata:longoptso
aFields		db 'fields',0           ; DATA XREF: .rodata:longoptso
aDelimiter	db 'delimiter',0        ; DATA XREF: .rodata:longoptso
aOnlyDelimited	db 'only-delimited',0   ; DATA XREF: .rodata:longoptso
aOutputDelimite	db 'output-delimiter',0 ; DATA XREF: .rodata:longoptso
aComplement	db 'complement',0       ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[10]
longopts	option <offset aBytes, 1, 0, 62h> ; DATA XREF: main+2AAo
		option <offset aCharacters, 1, 0, 63h> ; "bytes"
		option <offset aFields,	1, 0, 66h>
		option <offset aDelimiter, 1, 0, 64h>
		option <offset aOnlyDelimited, 0, 0, 73h>
		option <offset aOutputDelimite,	1, 0, 80h>
		option <offset aComplement, 0, 0, 81h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s OPTION... [FILE]...',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aPrintSelectedP[]
aPrintSelectedP	db 'Print selected parts of lines from each FILE to standard output.',0Ah
					; DATA XREF: usage+69o
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aBBytesListSele[]
aBBytesListSele	db '  -b, --bytes=LIST        select only these bytes',0Ah
					; DATA XREF: usage+AFo
		db '  -c, --characters=LIST   select only these characters',0Ah
		db '  -d, --delimiter=DELIM   use DELIM instead of TAB for field deli'
		db 'miter',0Ah,0
		align 4
; char aFFieldsListSel[]
aFFieldsListSel	db '  -f, --fields=LIST       select only these fields;  also print a'
					; DATA XREF: usage+D2o
		db 'ny line',0Ah
		db '                            that contains no delimiter character,'
		db ' unless',0Ah
		db '                            the -s option is specified',0Ah
		db '  -n                      (ignored)',0Ah,0
		align 4
; char aComplementComp[]
aComplementComp	db '      --complement        complement the set of selected bytes, c'
					; DATA XREF: usage+F5o
		db 'haracters',0Ah
		db '                            or fields',0Ah,0
		align 10h
; char aSOnlyDelimited[]
aSOnlyDelimited	db '  -s, --only-delimited    do not print lines not containing delim'
					; DATA XREF: usage+118o
		db 'iters',0Ah
		db '      --output-delimiter=STRING  use STRING as the output delimit'
		db 'er',0Ah
		db '                            the default is to use the input delim'
		db 'iter',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+13Bo
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+15Eo
		align 4
; char aUseOneAndOnlyO[]
aUseOneAndOnlyO	db 0Ah			; DATA XREF: usage+181o
		db 'Use one, and only one of -b, -c or -f.  Each LIST is made up of o'
		db 'ne',0Ah
		db 'range, or many ranges separated by commas.  Selected input is wri'
		db 'tten',0Ah
		db 'in the same order that it is read, and is written exactly once.',0Ah
		db 0
; char aEachRangeIsOne[]
aEachRangeIsOne	db 'Each range is one of:',0Ah ; DATA XREF: usage+1A4o
		db 0Ah
		db '  N     N',27h,'th byte, character or field, counted from 1',0Ah
		db '  N-    from N',27h,'th byte, character or field, to end of line',0Ah
		db '  N-M   from N',27h,'th to M',27h,'th (included) byte, character or fie'
		db 'ld',0Ah
		db '  -M    from first to M',27h,'th (included) byte, character or field'
		db 0Ah
		db 0Ah
		db 'With no FILE, or when FILE is -, read standard input.',0Ah,0
; char file[]
file		db 'cut.c',0            ; DATA XREF: mark_range_start+3Bo
					; cut_fields+10Do
; char assertion[]
assertion	db '(size_t) ent_from_table == i',0 ; DATA XREF: mark_range_start+40o
; char aInvalidByteOrF[]
aInvalidByteOrF	db 'invalid byte or field list',0 ; DATA XREF: set_fields+66o
					; set_fields+4FCo
		align 4
; char aInvalidRangeWi[]
aInvalidRangeWi	db 'invalid range with no endpoint: -',0 ; DATA XREF: set_fields+124o
; char aInvalidDecreas[]
aInvalidDecreas	db 'invalid decreasing range',0 ; DATA XREF: set_fields+172o
		align 10h
; char aFieldsAndPosit[]
aFieldsAndPosit	db 'fields and positions are numbered from 1',0 ; DATA XREF: set_fields+1DEo
					; set_fields+26Ao ...
; char accept[]
accept		db '0123456789',0       ; DATA XREF: set_fields+448o
; char aByteOffsetSIsT[]
aByteOffsetSIsT	db 'byte offset %s is too large',0 ; DATA XREF: set_fields+48Do
; char aFieldNumberSIs[]
aFieldNumberSIs	db 'field number %s is too large',0 ; DATA XREF: set_fields+4BDo
; char aN_bytes0[]
aN_bytes0	db 'n_bytes != 0',0     ; DATA XREF: cut_fields+112o
; char asc_800202A[]
asc_800202A	db '-',0                ; DATA XREF: cut_file+9o cut_file+B2o ...
aR		db 'r',0                ; DATA XREF: cut_file+31o
; char format[]
format		db '%s',0               ; DATA XREF: cut_file+54o cut_file+98o ...
; char locale
locale		db 0			; DATA XREF: main+2Co
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Eo
		align 4
; char aOnlyOneTypeOfL[]
aOnlyOneTypeOfL	db 'only one type of list may be specified',0 ; DATA XREF: main+11Ao
					; main+164o
		align 4
; char aTheDelimiterMu[]
aTheDelimiterMu	db 'the delimiter must be a single character',0 ; DATA XREF: main+1C0o
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+26Eo
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+273o
aDavidM_Ihnat	db 'David M. Ihnat',0   ; DATA XREF: main+278o
aCut		db 'cut',0              ; DATA XREF: main+283o
; char shortopts[]
shortopts	db 'b:c:d:f:ns',0       ; DATA XREF: main+2AFo
; char aYouMustSpecify[]
aYouMustSpecify	db 'you must specify a list of bytes, characters, or fields',0
					; DATA XREF: main+2DAo
; char aAnInputDelimit[]
aAnInputDelimit	db 'an input delimiter may be specified only when operating on fields'
					; DATA XREF: main+319o
		db 0
		align 4
; char aSuppressingNon[]
aSuppressingNon	db 'suppressing non-delimited lines makes sense',0Ah ; DATA XREF: main+358o
		db 9,'only when operating on fields',0
; char aMissingListOfF[]
aMissingListOfF	db 'missing list of fields',0 ; DATA XREF: main+3DAo
; char aMissingListOfP[]
aMissingListOfP	db 'missing list of positions',0 ; DATA XREF: main+404o
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5209[17]
__PRETTY_FUNCTION___5209 db 'mark_range_start',0 ; DATA XREF: mark_range_start+31o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5307[11]
__PRETTY_FUNCTION___5307 db 'cut_fields',0 ; DATA XREF: cut_fields+103o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80021F0h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8001660-8003870h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8001660-800387Eh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 18h,	60h
		dd offset loc_8001660-8003786h
		dd 1CEh, 80E4100h, 0D420285h, 3834405h,	1Ch, 7Ch
		dd offset loc_8001660-80035D4h
		dd 4Dh,	80E4100h, 0D420285h, 0C5490205h, 4040Ch, 24h, 9Ch
		dd offset loc_8001660-80035A7h
		dd 49h,	80E4100h, 0D420285h, 3864505h, 0C37E0483h, 0C541C641h
		dd 4040Ch, 1Ch,	0C4h
		dd offset loc_8001660-8003586h
		dd 36h,	80E4100h, 0D420285h, 0CC57205h,	404h, 1Ch, 0E4h
		dd offset loc_8001660-8003570h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55705h,	404h, 1Ch, 104h
		dd offset loc_8001660-8003575h
		dd 0Eh,	80E4100h, 0D420285h, 0CC54A05h,	404h, 1Ch, 124h
		dd offset loc_8001660-8003587h
		dd 22h,	80E4100h, 0D420285h, 0CC55E05h,	404h, 1Ch, 144h
		dd offset loc_8001660-8003585h
		dd 81h,	80E4100h, 0D420285h, 0C57D0205h, 4040Ch, 1Ch, 164h
		dd offset loc_8001660-8003524h
		dd 33h,	80E4100h, 0D420285h, 0CC56F05h,	404h, 20h, 184h
		dd offset loc_8001660-8003511h
		dd 6DDh, 80E4100h, 0D420285h, 3834405h,	0C506D503h, 4040CC3h
		dd 1Ch,	1A8h
		dd offset loc_8001660-8002E58h
		dd 10Ah, 80E4100h, 0D420285h, 1060305h,	4040CC5h, 1Ch
		dd 1C8h
		dd offset loc_8001660-8002D6Eh
		dd 32Ah, 80E4100h, 0D420285h, 3260305h,	4040CC5h, 1Ch
		dd 1E8h
		dd offset loc_8001660-8002A64h
		dd 31h,	80E4100h, 0D420285h, 0CC56D05h,	404h, 1Ch, 208h
		dd offset loc_8001660-8002A53h
		dd 111h, 80E4100h, 0D420285h, 10D0305h,	4040CC5h, 24h
		dd 228h
		dd offset loc_8001660-8002962h
		dd 54Bh, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+33p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1C9p
					; set_fields+4EBp ...
		extrn hash_insert:near	; CODE XREF: mark_range_start+13p
		extrn xalloc_die:near	; CODE XREF: mark_range_start+24p
					; cut_fields+F2p ...
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: mark_range_start+45p
					; cut_fields+117p
		extrn hash_lookup:near	; CODE XREF: is_range_start_index+13p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: set_fields+7Bp
					; set_fields+139p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: set_fields+BBp
		extrn x2nrealloc:near	; CODE XREF: set_fields+219p
					; set_fields+2A5p ...
; size_t strspn(const char *s, const char *accept)
		extrn strspn:near	; CODE XREF: set_fields+44Ep
; char *xstrndup(const char *, size_t)
		extrn xstrndup:near	; CODE XREF: set_fields+465p
		extrn quote:near	; CODE XREF: set_fields+480p
					; set_fields+4B0p
; void free(void *ptr)
		extrn free:near		; CODE XREF: set_fields+4DEp
					; set_fields+6BBp ...
		extrn xzalloc:near	; CODE XREF: set_fields+589p
; void qsort(void *base, size_t	nmemb, size_t size, __compar_fn_t compar)
		extrn qsort:near	; CODE XREF: set_fields+5A3p
		extrn __stack_chk_fail:near ; CODE XREF: set_fields+6D3p
					; cut_bytes+103p
; int getc_unlocked(FILE *stream)
		extrn getc_unlocked:near ; CODE	XREF: cut_bytes+28p
					; cut_fields+17p ...
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: cut_bytes+3Ep
					; cut_bytes+68p ...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	cut_bytes+D6p
					; cut_fields+169p ...
; int ungetc(int c, FILE *stream)
		extrn ungetc:near	; CODE XREF: cut_fields+35p
					; cut_fields+2AAp
		extrn getndelim2:near	; CODE XREF: cut_fields+9Ap
; int ferror_unlocked(FILE *stream)
		extrn ferror_unlocked:near ; CODE XREF:	cut_fields+CCp
					; cut_file+82p
; int feof_unlocked(FILE *stream)
		extrn feof_unlocked:near ; CODE	XREF: cut_fields+E2p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: cut_file+11p cut_file+BAp
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: cut_file+24r main+4FCr
		extrn fopen64:near	; CODE XREF: cut_file+39p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: cut_file+4Ap
					; cut_file+8Ep	...
; void clearerr_unlocked(FILE *stream)
		extrn clearerr_unlocked:near ; CODE XREF: cut_file+CCp
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: cut_file+DCp main+505p
		extrn set_program_name:near ; CODE XREF: main+21p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+48p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+58p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+63o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+68p
; char *optarg
		extrn optarg:dword	; DATA XREF: main+14Br	main+195r ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: main+219p
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: main+236p
		extrn Version:dword	; DATA XREF: main:loc_800137Br
		extrn version_etc:near	; CODE XREF: main+289p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+2B9p
		extrn hash_initialize:near ; CODE XREF:	main+39Dp
; int optind
		extrn optind:dword	; DATA XREF: main:loc_8001587r
					; main:loc_80015ABr ...
		extrn hash_free:near	; CODE XREF: main+4E9p


		end
