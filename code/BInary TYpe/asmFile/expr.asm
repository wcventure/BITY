;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	4952EF37C5004FBAD841561F9C945F3B
; Input	CRC32 :	BFA8C003

; File Name   :	D:\coreutils-o\expr.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'expr.c'

		include	uni.inc	; see unicode subdir of	ida for	info on	unicode

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+61p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+1D0p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000FA
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000FA
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000FA:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_clear(intmax_t *z)
mpz_clear	proc near		; CODE XREF: freev+2Ep	tostring+39p

z		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
mpz_clear	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_init_set_ui(intmax_t	*z, unsigned int i)
mpz_init_set_ui	proc near		; CODE XREF: int_value+2Cp

z		= dword	ptr  8
i		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+i]
		mov	edx, 0
		mov	ecx, [ebp+z]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		pop	ebp
		retn
mpz_init_set_ui	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl mpz_init_set_str(intmax_t	*z, char *s, int base)
mpz_init_set_str proc near		; CODE XREF: toarith+4Ep

z		= dword	ptr  8
s		= dword	ptr  0Ch
base		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	0
		push	[ebp+z]
		push	[ebp+base]
		push	0
		push	[ebp+s]
		call	xstrtoimax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000175
		mov	eax, 0
		jmp	short locret_800017A
; ---------------------------------------------------------------------------

loc_8000175:				; CODE XREF: mpz_init_set_str+20j
		mov	eax, 0FFFFFFFFh

locret_800017A:				; CODE XREF: mpz_init_set_str+27j
		leave
		retn
mpz_init_set_str endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_add(intmax_t	*r, intmax_t *a0, intmax_t *b0)
mpz_add		proc near		; CODE XREF: eval3+EFp
					; DATA XREF: eval3+CBo

a		= qword	ptr -20h
b		= qword	ptr -18h
val		= qword	ptr -10h
var_4		= dword	ptr -4
r		= dword	ptr  8
a0		= dword	ptr  0Ch
b0		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+a0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+a], eax
		mov	dword ptr [ebp+a+4], edx
		mov	eax, [ebp+b0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+b], eax
		mov	dword ptr [ebp+b+4], edx
		mov	ecx, dword ptr [ebp+a]
		mov	ebx, dword ptr [ebp+a+4]
		mov	eax, dword ptr [ebp+b]
		mov	edx, dword ptr [ebp+b+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	ecx, 1
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		cmp	edx, dword ptr [ebp+a+4]
		jl	short loc_80001D4
		cmp	edx, dword ptr [ebp+a+4]
		jg	short loc_80001CF
		cmp	eax, dword ptr [ebp+a]
		jb	short loc_80001D4

loc_80001CF:				; CODE XREF: mpz_add+4Cj
		mov	ecx, 0

loc_80001D4:				; CODE XREF: mpz_add+47j mpz_add+51j
		mov	eax, dword ptr [ebp+b+4]
		shr	eax, 1Fh
		xor	eax, ecx
		test	al, al
		jz	short loc_80001EA
		sub	esp, 0Ch
		push	2Bh		; op
		call	integer_overflow
; ---------------------------------------------------------------------------

loc_80001EA:				; CODE XREF: mpz_add+62j
		mov	ecx, [ebp+r]
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
mpz_add		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_sub(intmax_t	*r, intmax_t *a0, intmax_t *b0)
mpz_sub		proc near		; DATA XREF: eval3:loc_8001636o

a		= qword	ptr -20h
b		= qword	ptr -18h
val		= qword	ptr -10h
r		= dword	ptr  8
a0		= dword	ptr  0Ch
b0		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+a0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+a], eax
		mov	dword ptr [ebp+a+4], edx
		mov	eax, [ebp+b0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+b], eax
		mov	dword ptr [ebp+b+4], edx
		mov	eax, dword ptr [ebp+a]
		mov	edx, dword ptr [ebp+a+4]
		sub	eax, dword ptr [ebp+b]
		sbb	edx, dword ptr [ebp+b+4]
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	ecx, 1
		mov	eax, dword ptr [ebp+a]
		mov	edx, dword ptr [ebp+a+4]
		cmp	edx, dword ptr [ebp+val+4]
		jl	short loc_8000251
		cmp	edx, dword ptr [ebp+val+4]
		jg	short loc_800024C
		cmp	eax, dword ptr [ebp+val]
		jb	short loc_8000251

loc_800024C:				; CODE XREF: mpz_sub+47j
		mov	ecx, 0

loc_8000251:				; CODE XREF: mpz_sub+42j mpz_sub+4Cj
		mov	eax, dword ptr [ebp+b+4]
		shr	eax, 1Fh
		xor	eax, ecx
		test	al, al
		jz	short loc_8000267
		sub	esp, 0Ch
		push	2Dh		; op
		call	integer_overflow
; ---------------------------------------------------------------------------

loc_8000267:				; CODE XREF: mpz_sub+5Dj
		mov	ecx, [ebp+r]
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		leave
		retn
mpz_sub		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_mul(intmax_t	*r, intmax_t *a0, intmax_t *b0)
mpz_mul		proc near		; DATA XREF: eval4:loc_800152Ao

a		= qword	ptr -20h
b		= qword	ptr -18h
val		= qword	ptr -10h
r		= dword	ptr  8
a0		= dword	ptr  0Ch
b0		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+a0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+a], eax
		mov	dword ptr [ebp+a+4], edx
		mov	eax, [ebp+b0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+b], eax
		mov	dword ptr [ebp+b+4], edx
		mov	eax, dword ptr [ebp+a+4]
		imul	eax, dword ptr [ebp+b]
		mov	edx, eax
		mov	eax, dword ptr [ebp+b+4]
		imul	eax, dword ptr [ebp+a]
		lea	ecx, [edx+eax]
		mov	eax, dword ptr [ebp+b]
		mul	dword ptr [ebp+a]
		add	ecx, edx
		mov	edx, ecx
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	eax, dword ptr [ebp+a+4]
		or	eax, dword ptr [ebp+a]
		test	eax, eax
		jz	short loc_8000324
		mov	eax, dword ptr [ebp+b+4]
		or	eax, dword ptr [ebp+b]
		test	eax, eax
		jz	short loc_8000324
		mov	eax, dword ptr [ebp+val+4]
		shr	eax, 1Fh
		movzx	eax, al
		mov	edx, dword ptr [ebp+a+4]
		shr	edx, 1Fh
		movzx	ecx, dl
		mov	edx, dword ptr [ebp+b+4]
		shr	edx, 1Fh
		movzx	edx, dl
		xor	edx, ecx
		cmp	eax, edx
		jnz	short loc_800031A
		push	dword ptr [ebp+a+4]
		push	dword ptr [ebp+a]
		push	dword ptr [ebp+val+4]
		push	dword ptr [ebp+val]
		call	__divdi3
		add	esp, 10h
		mov	ecx, edx
		xor	ecx, dword ptr [ebp+b+4]
		xor	eax, dword ptr [ebp+b]
		or	eax, ecx
		test	eax, eax
		jz	short loc_8000324

loc_800031A:				; CODE XREF: mpz_mul+7Ej
		sub	esp, 0Ch
		push	2Ah		; op
		call	integer_overflow
; ---------------------------------------------------------------------------

loc_8000324:				; CODE XREF: mpz_mul+53j mpz_mul+5Dj ...
		mov	ecx, [ebp+r]
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		leave
		retn
mpz_mul		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_tdiv_q(intmax_t *r, intmax_t	*a0, intmax_t *b0)
mpz_tdiv_q	proc near		; CODE XREF: eval4+159p
					; DATA XREF: eval4+12Eo

a		= qword	ptr -18h
b		= qword	ptr -10h
r		= dword	ptr  8
a0		= dword	ptr  0Ch
b0		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+a0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+a], eax
		mov	dword ptr [ebp+a+4], edx
		mov	eax, [ebp+b0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+b], eax
		mov	dword ptr [ebp+b+4], edx
		mov	eax, dword ptr [ebp+a+4]
		xor	eax, 80000000h
		or	eax, dword ptr [ebp+a]
		test	eax, eax
		jnz	short loc_8000384
		mov	eax, dword ptr [ebp+b+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+b]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jnz	short loc_8000384
		sub	esp, 0Ch
		push	2Fh		; op
		call	integer_overflow
; ---------------------------------------------------------------------------

loc_8000384:				; CODE XREF: mpz_tdiv_q+2Fj
					; mpz_tdiv_q+43j
		push	dword ptr [ebp+b+4]
		push	dword ptr [ebp+b]
		push	dword ptr [ebp+a+4]
		push	dword ptr [ebp+a]
		call	__divdi3
		add	esp, 10h
		mov	ecx, [ebp+r]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		leave
		retn
mpz_tdiv_q	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl mpz_tdiv_r(intmax_t *r, intmax_t	*a0, intmax_t *b0)
mpz_tdiv_r	proc near		; DATA XREF: eval4:loc_8001523o

a		= qword	ptr -18h
b		= qword	ptr -10h
r		= dword	ptr  8
a0		= dword	ptr  0Ch
b0		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+a0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+a], eax
		mov	dword ptr [ebp+a+4], edx
		mov	eax, [ebp+b0]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	dword ptr [ebp+b], eax
		mov	dword ptr [ebp+b+4], edx
		mov	eax, dword ptr [ebp+a+4]
		xor	eax, 80000000h
		or	eax, dword ptr [ebp+a]
		test	eax, eax
		jnz	short loc_80003E8
		mov	eax, dword ptr [ebp+b+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+b]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	short loc_8000400

loc_80003E8:				; CODE XREF: mpz_tdiv_r+2Fj
		mov	eax, dword ptr [ebp+a]
		mov	edx, dword ptr [ebp+a+4]
		push	dword ptr [ebp+b+4]
		push	dword ptr [ebp+b]
		push	edx
		push	eax
		call	__moddi3
		add	esp, 10h
		jmp	short loc_800040A
; ---------------------------------------------------------------------------

loc_8000400:				; CODE XREF: mpz_tdiv_r+43j
		mov	eax, 0
		mov	edx, 0

loc_800040A:				; CODE XREF: mpz_tdiv_r+5Bj
		mov	ecx, [ebp+r]
		mov	[ecx], eax
		mov	[ecx+4], edx
		nop
		leave
		retn
mpz_tdiv_r	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	mpz_get_str(const char *str, int base, intmax_t	*z)
mpz_get_str	proc near		; CODE XREF: tostring+24p

z		= dword	ptr -30h
str		= dword	ptr -2Ch
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
base		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+str], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+z], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	imaxtostr
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8000468
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000468:				; CODE XREF: mpz_get_str+4Cj
		leave
		retn
mpz_get_str	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl mpz_sgn(intmax_t *z)
mpz_sgn		proc near		; CODE XREF: null+20p getsize+Cp ...

z		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		test	edx, edx
		js	short loc_80004A1
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, eax
		mov	ebx, edx
		mov	ebx, ebx
		sar	ebx, 1Fh
		mov	ecx, ebx
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		mov	eax, edx
		xor	edx, edx
		shr	eax, 1Fh
		movzx	eax, al
		jmp	short loc_80004A6
; ---------------------------------------------------------------------------

loc_80004A1:				; CODE XREF: mpz_sgn+Ej
		mov	eax, 0FFFFFFFFh

loc_80004A6:				; CODE XREF: mpz_sgn+35j
		pop	ebx
		pop	ebp
		retn
mpz_sgn		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl mpz_fits_ulong_p(intmax_t	*z)
mpz_fits_ulong_p proc near		; CODE XREF: getsize+25p

z		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		test	edx, edx
		js	short loc_80004CB
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		test	edx, edx
		jg	short loc_80004CB
		mov	eax, 1
		jmp	short loc_80004D0
; ---------------------------------------------------------------------------

loc_80004CB:				; CODE XREF: mpz_fits_ulong_p+Dj
					; mpz_fits_ulong_p+19j
		mov	eax, 0

loc_80004D0:				; CODE XREF: mpz_fits_ulong_p+20j
		pop	ebp
		retn
mpz_fits_ulong_p endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl mpz_get_ui(intmax_t *z)
mpz_get_ui	proc near		; CODE XREF: getsize+37p

z		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		pop	ebp
		retn
mpz_get_ui	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl mpz_out_str(FILE *stream,	int base, intmax_t *z)
mpz_out_str	proc near		; CODE XREF: printv+28p

z		= dword	ptr -30h
stream		= dword	ptr -2Ch
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
base		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+stream], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+z], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+z]
		mov	edx, [eax+4]
		mov	eax, [eax]
		sub	esp, 4
		lea	ecx, [ebp+buf]
		push	ecx
		push	edx
		push	eax
		call	imaxtostr
		add	esp, 10h
		sub	esp, 8
		push	[ebp+stream]
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		setnz	al
		movzx	eax, al
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_800053E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_800053E:				; CODE XREF: mpz_out_str+58j
		leave
		retn
mpz_out_str	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+101p
					; DATA XREF: main+8Do

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_800057B
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000715
; ---------------------------------------------------------------------------

loc_800057B:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSExpressi ; "Usage: %s EXPRESSION\n  or:  %s OPTION\"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintTheValueO ; "\nPrint the value of EXPRESSION to stan"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aArg1Arg2Arg1Is ; "\n  ARG1 < ARG2	ARG1 is	less than"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aArg1Arg2Arithm ; "\n  ARG1 + ARG2	arithmetic sum of"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aArg1Arg2Arit_0 ; "\n  ARG1 * ARG2	arithmetic produc"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aStringRegexpAn ; "\n  STRING : REGEXP	anchored pattern "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTokenInterpret ; "  + TOKEN		       interpret "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBewareThatMany ; "\nBeware that	many operators need to be"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aExitStatusIs0I ; "\nExit status	is 0 if	EXPRESSION is nei"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000715:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void syntax_error()
syntax_error	proc near		; CODE XREF: main+12Dp	eval7+15p ...
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	offset aSyntaxError ; "syntax error"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h
		nop
		leave
		retn
syntax_error	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl integer_overflow(char op)
integer_overflow proc near		; CODE XREF: mpz_add+69p mpz_sub+64p ...

op		= byte ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+op], al
		movsx	eax, [ebp+op]
		push	eax
		push	offset format	; "%c"
		push	22h		; errnum
		push	3		; status
		call	error
		add	esp, 10h
		call	abort
integer_overflow endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl die(int errno_val, const	char *msg)
die		proc near

errno_val	= dword	ptr  8
msg		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		push	[ebp+msg]
		push	offset aS	; "%s"
		push	[ebp+errno_val]	; errnum
		push	3		; status
		call	error
		add	esp, 10h
		call	abort
die		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

v		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	3		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		sub	esp, 8
		push	0
		push	offset aPaulEggert ; "Paul Eggert"
		push	offset aJamesYoungman ;	"James Youngman"
		push	offset aMikeParker ; "Mike Parker"
		push	offset usage
		push	offset a8_4	; "8.4"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aExpr	; "expr"
		push	dword ptr [ebx+4]
		push	dword ptr [ebx]
		call	parse_long_options
		add	esp, 30h
		cmp	dword ptr [ebx], 1
		jle	short loc_8000867
		mov	eax, [ebx+4]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024B0 ; "--"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000867
		sub	dword ptr [ebx], 1
		add	dword ptr [ebx+4], 4

loc_8000867:				; CODE XREF: main+B1j main+CEj
		cmp	dword ptr [ebx], 1
		jg	short loc_8000896
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000896:				; CODE XREF: main+DAj
		mov	eax, [ebx+4]
		add	eax, 4
		mov	ds:args, eax
		sub	esp, 0Ch
		push	1		; evaluate
		call	eval
		add	esp, 10h
		mov	[ebp+v], eax
		call	nomoreargs
		xor	eax, 1
		test	al, al
		jz	short loc_80008C2
		call	syntax_error

loc_80008C2:				; CODE XREF: main+12Bj
		sub	esp, 0Ch
		push	[ebp+v]		; v
		call	printv
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+v]		; v
		call	null
		add	esp, 10h
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; status
		call	exit
main		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl int_value(unsigned int	i)
int_value	proc near		; CODE XREF: docolon+1ABp docolon+1EBp ...

v		= dword	ptr -0Ch
i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+v], eax
		mov	eax, [ebp+v]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 8
		push	[ebp+i]		; i
		push	eax		; z
		call	mpz_init_set_ui
		add	esp, 10h
		mov	eax, [ebp+v]
		leave
		retn
int_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl str_value(const char *s)
str_value	proc near		; CODE XREF: docolon+18Ep docolon+1D6p ...

v		= dword	ptr -0Ch
s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+v], eax
		mov	eax, [ebp+v]
		mov	dword ptr [eax], 1
		sub	esp, 0Ch
		push	[ebp+s]		; char *
		call	xstrdup
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+v]
		mov	[eax+4], edx
		mov	eax, [ebp+v]
		leave
		retn
str_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl freev(VALUE *v)
freev		proc near		; CODE XREF: eval6+ABp	eval6+115p ...

v		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+v]
		mov	eax, [eax]
		cmp	eax, 1
		jnz	short loc_8000981
		mov	eax, [ebp+v]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		jmp	short loc_8000993
; ---------------------------------------------------------------------------

loc_8000981:				; CODE XREF: freev+Ej
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 0Ch
		push	eax		; z
		call	mpz_clear
		add	esp, 10h

loc_8000993:				; CODE XREF: freev+22j
		sub	esp, 0Ch
		push	[ebp+v]		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
freev		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl printv(VALUE *v)
printv		proc near		; CODE XREF: main+138p

v		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+v]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_80009BA
		cmp	eax, 1
		jz	short loc_80009E3
		jmp	short loc_80009F7
; ---------------------------------------------------------------------------

loc_80009BA:				; CODE XREF: printv+Dj
		mov	eax, [ebp+v]
		lea	edx, [eax+4]
		mov	eax, ds:stdout
		sub	esp, 4
		push	edx		; z
		push	0Ah		; base
		push	eax		; stream
		call	mpz_out_str
		add	esp, 10h
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80009FC
; ---------------------------------------------------------------------------

loc_80009E3:				; CODE XREF: printv+12j
		mov	eax, [ebp+v]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; s
		call	puts
		add	esp, 10h
		jmp	short loc_80009FC
; ---------------------------------------------------------------------------

loc_80009F7:				; CODE XREF: printv+14j
		call	abort
; ---------------------------------------------------------------------------

loc_80009FC:				; CODE XREF: printv+3Dj printv+51j
		nop
		leave
		retn
printv		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	null(VALUE *v)
null		proc near		; CODE XREF: main+146p	eval1+43p ...

cp		= dword	ptr -0Ch
v		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+v]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000A15
		cmp	eax, 1
		jz	short loc_8000A2E
		jmp	short loc_8000A7F
; ---------------------------------------------------------------------------

loc_8000A15:				; CODE XREF: null+Dj
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 4
		push	eax		; z
		call	mpz_sgn
		add	esp, 8
		test	eax, eax
		setz	al
		jmp	short locret_8000A84
; ---------------------------------------------------------------------------

loc_8000A2E:				; CODE XREF: null+12j
		mov	eax, [ebp+v]
		mov	eax, [eax+4]
		mov	[ebp+cp], eax
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000A48
		mov	eax, 1
		jmp	short locret_8000A84
; ---------------------------------------------------------------------------

loc_8000A48:				; CODE XREF: null+40j
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		setz	al
		movzx	eax, al
		add	[ebp+cp], eax

loc_8000A59:				; CODE XREF: null+77j
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		cmp	al, 30h
		jz	short loc_8000A6A
		mov	eax, 0
		jmp	short locret_8000A84
; ---------------------------------------------------------------------------

loc_8000A6A:				; CODE XREF: null+62j
		add	[ebp+cp], 1
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000A59
		mov	eax, 1
		jmp	short locret_8000A84
; ---------------------------------------------------------------------------

loc_8000A7F:				; CODE XREF: null+14j
		call	abort
; ---------------------------------------------------------------------------

locret_8000A84:				; CODE XREF: null+2Dj null+47j ...
		leave
		retn
null		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	looks_like_integer(const char *cp)
looks_like_integer proc	near		; CODE XREF: toarith+29p eval2+138p ...

cp		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		setz	al
		movzx	eax, al
		add	[ebp+cp], eax

loc_8000A9A:				; CODE XREF: looks_like_integer+38j
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8000AB2
		mov	eax, 0
		jmp	short loc_8000AC5
; ---------------------------------------------------------------------------

loc_8000AB2:				; CODE XREF: looks_like_integer+23j
		add	[ebp+cp], 1
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000A9A
		mov	eax, 1

loc_8000AC5:				; CODE XREF: looks_like_integer+2Aj
		pop	ebp
		retn
looks_like_integer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl tostring(VALUE *v)
tostring	proc near		; CODE XREF: docolon+30p docolon+41p ...

s		= dword	ptr -0Ch
v		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+v]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000ADD
		cmp	eax, 1
		jz	short loc_8000B21
		jmp	short loc_8000B1C
; ---------------------------------------------------------------------------

loc_8000ADD:				; CODE XREF: tostring+Dj
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 4
		push	eax		; z
		push	0Ah		; base
		push	0		; str
		call	mpz_get_str
		add	esp, 10h
		mov	[ebp+s], eax
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 0Ch
		push	eax		; z
		call	mpz_clear
		add	esp, 10h
		mov	eax, [ebp+v]
		mov	edx, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+v]
		mov	dword ptr [eax], 1
		jmp	short loc_8000B22
; ---------------------------------------------------------------------------

loc_8000B1C:				; CODE XREF: tostring+14j
		call	abort
; ---------------------------------------------------------------------------

loc_8000B21:				; CODE XREF: tostring+12j
		nop

loc_8000B22:				; CODE XREF: tostring+53j
		nop
		leave
		retn
tostring	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	toarith(VALUE *v)
toarith		proc near		; CODE XREF: eval6+27Dp eval6+292p ...

s		= dword	ptr -0Ch
v		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+v]
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8000B3B
		cmp	eax, 1
		jz	short loc_8000B42
		jmp	short loc_8000BB1
; ---------------------------------------------------------------------------

loc_8000B3B:				; CODE XREF: toarith+Dj
		mov	eax, 1
		jmp	short locret_8000BB6
; ---------------------------------------------------------------------------

loc_8000B42:				; CODE XREF: toarith+12j
		mov	eax, [ebp+v]
		mov	eax, [eax+4]
		mov	[ebp+s], eax
		push	[ebp+s]		; cp
		call	looks_like_integer
		add	esp, 4
		xor	eax, 1
		test	al, al
		jz	short loc_8000B64
		mov	eax, 0
		jmp	short locret_8000BB6
; ---------------------------------------------------------------------------

loc_8000B64:				; CODE XREF: toarith+36j
		mov	eax, [ebp+v]
		add	eax, 4
		sub	esp, 4
		push	0Ah		; base
		push	[ebp+s]		; s
		push	eax		; z
		call	mpz_init_set_str
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000B93
		push	[ebp+s]
		push	offset aS	; "%s"
		push	22h		; errnum
		push	3		; status
		call	error
		add	esp, 10h

loc_8000B93:				; CODE XREF: toarith+58j
		sub	esp, 0Ch
		push	[ebp+s]		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+v]
		mov	dword ptr [eax], 0
		mov	eax, 1
		jmp	short locret_8000BB6
; ---------------------------------------------------------------------------

loc_8000BB1:				; CODE XREF: toarith+14j
		call	abort
; ---------------------------------------------------------------------------

locret_8000BB6:				; CODE XREF: toarith+1Bj toarith+3Dj ...
		leave
		retn
toarith		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl getsize(intmax_t *i)
getsize		proc near		; CODE XREF: eval6+2C3p eval6+2D8p

ul		= dword	ptr -4
i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		sub	esp, 4
		push	[ebp+i]		; z
		call	mpz_sgn
		add	esp, 8
		test	eax, eax
		jns	short loc_8000BD7
		mov	eax, 0FFFFFFFFh
		jmp	short locret_8000C0A
; ---------------------------------------------------------------------------

loc_8000BD7:				; CODE XREF: getsize+16j
		sub	esp, 4
		push	[ebp+i]		; z
		call	mpz_fits_ulong_p
		add	esp, 8
		test	eax, eax
		jz	short loc_8000C05
		sub	esp, 4
		push	[ebp+i]		; z
		call	mpz_get_ui
		add	esp, 8
		mov	[ebp+ul], eax
		cmp	[ebp+ul], 0FFFFFFFFh
		jz	short loc_8000C05
		mov	eax, [ebp+ul]
		jmp	short locret_8000C0A
; ---------------------------------------------------------------------------

loc_8000C05:				; CODE XREF: getsize+2Fj getsize+46j
		mov	eax, 0FFFFFFFEh

locret_8000C0A:				; CODE XREF: getsize+1Dj getsize+4Bj
		leave
		retn
getsize		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	nextarg(const char *str)
nextarg		proc near		; CODE XREF: eval7+22p	eval7+49p ...

r		= byte ptr -9
str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:args
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8000C24
		mov	eax, 0
		jmp	short locret_8000C59
; ---------------------------------------------------------------------------

loc_8000C24:				; CODE XREF: nextarg+Fj
		mov	eax, ds:args
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+str]	; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+r], al
		mov	eax, ds:args
		movzx	edx, [ebp+r]
		shl	edx, 2
		add	eax, edx
		mov	ds:args, eax
		movzx	eax, [ebp+r]

locret_8000C59:				; CODE XREF: nextarg+16j
		leave
		retn
nextarg		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	nomoreargs()
nomoreargs	proc near		; CODE XREF: main+121p	eval7+Cp ...
		push	ebp
		mov	ebp, esp
		mov	eax, ds:args
		mov	eax, [eax]
		test	eax, eax
		setz	al
		pop	ebp
		retn
nomoreargs	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl docolon(VALUE *sv, VALUE *pv)
docolon		proc near		; CODE XREF: eval6+104p eval5+55p

pv		= dword	ptr -150h
sv		= dword	ptr -14Ch
v		= dword	ptr -144h
errmsg		= dword	ptr -140h
matchlen	= dword	ptr -13Ch
re_regs		= re_registers ptr -138h
re_buffer	= re_pattern_buffer ptr	-12Ch
fastmap		= byte ptr -10Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 154h
		mov	eax, [ebp+arg_0]
		mov	[ebp+sv], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+pv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	[ebp+sv]	; v
		call	tostring
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+pv]	; v
		call	tostring
		add	esp, 10h
		mov	[ebp+re_regs.num_regs],	0
		mov	[ebp+re_regs.start], 0
		mov	[ebp+re_regs.end], 0
		mov	[ebp+re_buffer.buffer],	0
		mov	[ebp+re_buffer.allocated], 0
		lea	eax, [ebp+fastmap]
		mov	[ebp+re_buffer.fastmap], eax
		mov	[ebp+re_buffer.translate], 0
		mov	ds:re_syntax_options, 2C6h
		mov	eax, [ebp+pv]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	ecx, eax
		mov	eax, [ebp+pv]
		mov	eax, [eax+4]
		sub	esp, 4
		lea	edx, [ebp+re_buffer]
		push	edx		; buffer
		push	ecx		; length
		push	eax		; pattern
		call	re_compile_pattern
		add	esp, 10h
		mov	[ebp+errmsg], eax
		cmp	[ebp+errmsg], 0
		jz	short loc_8000D61
		push	[ebp+errmsg]
		push	offset aS	; "%s"
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8000D61:				; CODE XREF: docolon+DCj
		movzx	eax, [ebp+re_buffer._bf1c]
		and	eax, 7Fh
		mov	[ebp+re_buffer._bf1c], al
		mov	eax, [ebp+sv]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	ecx, eax
		mov	eax, [ebp+sv]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		lea	edx, [ebp+re_regs]
		push	edx		; regs
		push	0		; start
		push	ecx		; length
		push	eax		; string
		lea	eax, [ebp+re_buffer]
		push	eax		; buffer
		call	re_match
		add	esp, 20h
		mov	[ebp+matchlen],	eax
		cmp	[ebp+matchlen],	0
		js	short loc_8000E27
		mov	eax, [ebp+re_buffer.re_nsub]
		test	eax, eax
		jz	short loc_8000E0D
		mov	eax, [ebp+sv]
		mov	eax, [eax+4]
		mov	edx, [ebp+re_regs.end]
		add	edx, 4
		mov	edx, [edx]
		add	eax, edx
		mov	byte ptr [eax],	0
		mov	eax, [ebp+sv]
		mov	eax, [eax+4]
		mov	edx, [ebp+re_regs.start]
		add	edx, 4
		mov	edx, [edx]
		add	eax, edx
		sub	esp, 0Ch
		push	eax		; s
		call	str_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	loc_8000E9F
; ---------------------------------------------------------------------------

loc_8000E0D:				; CODE XREF: docolon+159j
		mov	eax, [ebp+matchlen]
		sub	esp, 0Ch
		push	eax		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	short loc_8000E9F
; ---------------------------------------------------------------------------

loc_8000E27:				; CODE XREF: docolon+14Fj
		cmp	[ebp+matchlen],	0FFFFFFFFh
		jnz	short loc_8000E67
		mov	eax, [ebp+re_buffer.re_nsub]
		test	eax, eax
		jz	short loc_8000E52
		sub	esp, 0Ch
		push	offset locale	; s
		call	str_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	short loc_8000E9F
; ---------------------------------------------------------------------------

loc_8000E52:				; CODE XREF: docolon+1CCj
		sub	esp, 0Ch
		push	0		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	short loc_8000E9F
; ---------------------------------------------------------------------------

loc_8000E67:				; CODE XREF: docolon+1C2j
		sub	esp, 0Ch
		push	offset aErrorInRegular ; "error	in regular expression matcher"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		cmp	[ebp+matchlen],	0FFFFFFFEh
		jnz	short loc_8000E8B
		call	__errno_location
		mov	eax, [eax]
		jmp	short loc_8000E90
; ---------------------------------------------------------------------------

loc_8000E8B:				; CODE XREF: docolon+214j
		mov	eax, 4Bh

loc_8000E90:				; CODE XREF: docolon+21Dj
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	3		; status
		call	error
		add	esp, 10h

loc_8000E9F:				; CODE XREF: docolon+19Cj docolon+1B9j ...
		mov	eax, [ebp+re_regs.num_regs]
		test	eax, eax
		jz	short loc_8000ECD
		mov	eax, [ebp+re_regs.start]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+re_regs.end]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h

loc_8000ECD:				; CODE XREF: docolon+23Bj
		mov	[ebp+re_buffer.fastmap], 0
		sub	esp, 0Ch
		lea	eax, [ebp+re_buffer]
		push	eax		; preg
		call	regfree
		add	esp, 10h
		mov	eax, [ebp+v]
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8000F00
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000F00:				; CODE XREF: docolon+28Dj
		mov	ebx, [ebp+var_4]
		leave
		retn
docolon		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval7(_Bool evaluate)
eval7		proc near		; CODE XREF: eval6+3BDp

evaluate	= byte ptr -1Ch
v		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		call	nomoreargs
		test	al, al
		jz	short loc_8000F1F
		call	syntax_error

loc_8000F1F:				; CODE XREF: eval7+13j
		sub	esp, 0Ch
		push	offset str	; "()+"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8000F67
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval
		add	esp, 10h
		mov	[ebp+v], eax
		sub	esp, 0Ch
		push	(offset	str+2)	; str
		call	nextarg
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000F62
		call	syntax_error

loc_8000F62:				; CODE XREF: eval7+56j
		mov	eax, [ebp+v]
		jmp	short locret_8000F9C
; ---------------------------------------------------------------------------

loc_8000F67:				; CODE XREF: eval7+2Cj
		sub	esp, 0Ch
		push	(offset	str+2)	; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8000F80
		call	syntax_error

loc_8000F80:				; CODE XREF: eval7+74j
		mov	eax, ds:args
		lea	edx, [eax+4]
		mov	ds:args, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	str_value
		add	esp, 10h

locret_8000F9C:				; CODE XREF: eval7+60j
		leave
		retn
eval7		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval6(_Bool evaluate)
eval6		proc near		; CODE XREF: eval6+6Bp	eval6+D7p ...

evaluate	= byte ptr -3Ch
v		= dword	ptr -34h
r		= dword	ptr -30h
l		= dword	ptr -2Ch
pos		= dword	ptr -28h
i1		= dword	ptr -24h
i2		= dword	ptr -20h
llen		= dword	ptr -1Ch
pos_0		= dword	ptr -18h
len		= dword	ptr -14h
vlen		= dword	ptr -10h
vlim		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		sub	esp, 0Ch
		push	(offset	str+4)	; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8000FED
		call	nomoreargs
		test	al, al
		jz	short loc_8000FCC
		call	syntax_error

loc_8000FCC:				; CODE XREF: eval6+27j
		mov	eax, ds:args
		lea	edx, [eax+4]
		mov	ds:args, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	str_value
		add	esp, 10h
		jmp	locret_8001363
; ---------------------------------------------------------------------------

loc_8000FED:				; CODE XREF: eval6+1Ej
		sub	esp, 0Ch
		push	offset aLength	; "length"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001059
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+r], eax
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	tostring
		add	esp, 10h
		mov	eax, [ebp+r]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		sub	esp, 0Ch
		push	eax		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+v], eax
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+v]
		jmp	locret_8001363
; ---------------------------------------------------------------------------

loc_8001059:				; CODE XREF: eval6+61j
		sub	esp, 0Ch
		push	offset aMatch	; "match"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80010D9
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+l], eax
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+r], eax
		cmp	[ebp+evaluate],	0
		jz	short loc_80010BD
		sub	esp, 8
		push	[ebp+r]		; pv
		push	[ebp+l]		; sv
		call	docolon
		add	esp, 10h
		mov	[ebp+v], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		jmp	short loc_80010C3
; ---------------------------------------------------------------------------

loc_80010BD:				; CODE XREF: eval6+F9j
		mov	eax, [ebp+l]
		mov	[ebp+v], eax

loc_80010C3:				; CODE XREF: eval6+11Dj
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+v]
		jmp	locret_8001363
; ---------------------------------------------------------------------------

loc_80010D9:				; CODE XREF: eval6+CDj
		sub	esp, 0Ch
		push	offset aIndex	; "index"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	loc_80011A1
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+l], eax
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+r], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	tostring
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	tostring
		add	esp, 10h
		mov	eax, [ebp+r]
		mov	edx, [eax+4]
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 8
		push	edx		; reject
		push	eax		; s
		call	strcspn
		add	esp, 10h
		mov	[ebp+pos], eax
		mov	eax, [ebp+l]
		mov	edx, [eax+4]
		mov	eax, [ebp+pos]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001169
		mov	eax, [ebp+pos]
		add	eax, 1
		jmp	short loc_800116E
; ---------------------------------------------------------------------------

loc_8001169:				; CODE XREF: eval6+1C1j
		mov	eax, 0

loc_800116E:				; CODE XREF: eval6+1C9j
		sub	esp, 0Ch
		push	eax		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+v], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+v]
		jmp	locret_8001363
; ---------------------------------------------------------------------------

loc_80011A1:				; CODE XREF: eval6+14Dj
		sub	esp, 0Ch
		push	offset aSubstr	; "substr"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	loc_8001353
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+l], eax
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+i1], eax
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+i2], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	tostring
		add	esp, 10h
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+llen], eax
		sub	esp, 0Ch
		push	[ebp+i1]	; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_800123F
		sub	esp, 0Ch
		push	[ebp+i2]	; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001257

loc_800123F:				; CODE XREF: eval6+28Aj
		sub	esp, 0Ch
		push	offset locale	; s
		call	str_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	loc_8001324
; ---------------------------------------------------------------------------

loc_8001257:				; CODE XREF: eval6+29Fj
		mov	eax, [ebp+i1]
		add	eax, 4
		sub	esp, 0Ch
		push	eax		; i
		call	getsize
		add	esp, 10h
		mov	[ebp+pos_0], eax
		mov	eax, [ebp+i2]
		add	eax, 4
		sub	esp, 0Ch
		push	eax		; i
		call	getsize
		add	esp, 10h
		mov	[ebp+len], eax
		mov	eax, [ebp+llen]
		cmp	eax, [ebp+pos_0]
		jb	short loc_800129B
		cmp	[ebp+pos_0], 0
		jz	short loc_800129B
		cmp	[ebp+len], 0
		jz	short loc_800129B
		cmp	[ebp+len], 0FFFFFFFFh
		jnz	short loc_80012B0

loc_800129B:				; CODE XREF: eval6+2E9j eval6+2EFj ...
		sub	esp, 0Ch
		push	offset locale	; s
		call	str_value
		add	esp, 10h
		mov	[ebp+v], eax
		jmp	short loc_8001324
; ---------------------------------------------------------------------------

loc_80012B0:				; CODE XREF: eval6+2FBj
		mov	eax, [ebp+llen]
		sub	eax, [ebp+pos_0]
		lea	edx, [eax+1]
		mov	eax, [ebp+len]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+vlen], eax
		sub	esp, 0Ch
		push	0Ch		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+v], eax
		mov	eax, [ebp+v]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+vlen]
		add	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+v]
		mov	[eax+4], edx
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		mov	edx, [ebp+pos_0]
		sub	edx, 1
		add	edx, eax
		mov	eax, [ebp+v]
		mov	eax, [eax+4]
		sub	esp, 4
		push	[ebp+vlen]
		push	edx
		push	eax
		call	mempcpy
		add	esp, 10h
		mov	[ebp+vlim], eax
		mov	eax, [ebp+vlim]
		mov	byte ptr [eax],	0

loc_8001324:				; CODE XREF: eval6+2B4j eval6+310j
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+i1]	; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+i2]	; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+v]
		jmp	short locret_8001363
; ---------------------------------------------------------------------------

loc_8001353:				; CODE XREF: eval6+215j
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval7
		add	esp, 10h

locret_8001363:				; CODE XREF: eval6+4Aj	eval6+B6j ...
		leave
		retn
eval6		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval5(_Bool evaluate)
eval5		proc near		; CODE XREF: eval4+15p	eval4+87p

evaluate	= byte ptr -1Ch
l		= dword	ptr -14h
r		= dword	ptr -10h
v		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+l], eax

loc_8001384:				; CODE XREF: eval5+82j
		sub	esp, 0Ch
		push	offset asc_8002508 ; ":*/%"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80013E9
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval6
		add	esp, 10h
		mov	[ebp+r], eax
		cmp	[ebp+evaluate],	0
		jz	short loc_80013D9
		sub	esp, 8
		push	[ebp+r]		; pv
		push	[ebp+l]		; sv
		call	docolon
		add	esp, 10h
		mov	[ebp+v], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+v]
		mov	[ebp+l], eax

loc_80013D9:				; CODE XREF: eval5+4Aj
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		jmp	short loc_8001384
; ---------------------------------------------------------------------------

loc_80013E9:				; CODE XREF: eval5+31j
		mov	eax, [ebp+l]
		leave
		retn
eval5		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval4(_Bool evaluate)
eval4		proc near		; CODE XREF: eval3+15p	eval3+6Ap

evaluate	= byte ptr -1Ch
fxn		= dword	ptr -14h
l		= dword	ptr -10h
r		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval5
		add	esp, 10h
		mov	[ebp+l], eax

loc_800140E:				; CODE XREF: eval4+16Cj
		sub	esp, 0Ch
		push	(offset	asc_8002508+2) ; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_800142B
		mov	[ebp+fxn], 0
		jmp	short loc_800146D
; ---------------------------------------------------------------------------

loc_800142B:				; CODE XREF: eval4+32j
		sub	esp, 0Ch
		push	(offset	asc_8002508+4) ; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001448
		mov	[ebp+fxn], 1
		jmp	short loc_800146D
; ---------------------------------------------------------------------------

loc_8001448:				; CODE XREF: eval4+4Fj
		sub	esp, 0Ch
		push	(offset	asc_8002508+6) ; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001465
		mov	[ebp+fxn], 2
		jmp	short loc_800146D
; ---------------------------------------------------------------------------

loc_8001465:				; CODE XREF: eval4+6Cj
		mov	eax, [ebp+l]
		jmp	loc_800155F
; ---------------------------------------------------------------------------

loc_800146D:				; CODE XREF: eval4+3Bj	eval4+58j ...
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval5
		add	esp, 10h
		mov	[ebp+r], eax
		cmp	[ebp+evaluate],	0
		jz	loc_800154C
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_80014B4
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80014D4

loc_80014B4:				; CODE XREF: eval4+AFj
		sub	esp, 0Ch
		push	offset aNonNumericArgu ; "non-numeric argument"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_80014D4:				; CODE XREF: eval4+C4j
		cmp	[ebp+fxn], 0
		jz	short loc_8001510
		mov	eax, [ebp+r]
		add	eax, 4
		sub	esp, 0Ch
		push	eax		; z
		call	mpz_sgn
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001510
		sub	esp, 0Ch
		push	offset aDivisionByZero ; "division by zero"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8001510:				; CODE XREF: eval4+EAj	eval4+100j
		cmp	[ebp+fxn], 0
		jz	short loc_800152A
		cmp	[ebp+fxn], 1
		jnz	short loc_8001523
		mov	eax, offset mpz_tdiv_q
		jmp	short loc_800152F
; ---------------------------------------------------------------------------

loc_8001523:				; CODE XREF: eval4+12Cj
		mov	eax, offset mpz_tdiv_r
		jmp	short loc_800152F
; ---------------------------------------------------------------------------

loc_800152A:				; CODE XREF: eval4+126j
		mov	eax, offset mpz_mul

loc_800152F:				; CODE XREF: eval4+133j eval4+13Aj
		mov	edx, [ebp+r]
		lea	ebx, [edx+4]
		mov	edx, [ebp+l]
		lea	ecx, [edx+4]
		mov	edx, [ebp+l]
		add	edx, 4
		sub	esp, 4
		push	ebx		; b0
		push	ecx		; a0
		push	edx		; r
		call	eax ; mpz_tdiv_q
		add	esp, 10h

loc_800154C:				; CODE XREF: eval4+96j
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		jmp	loc_800140E
; ---------------------------------------------------------------------------

loc_800155F:				; CODE XREF: eval4+7Aj
		mov	ebx, [ebp+var_4]
		leave
		retn
eval4		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval3(_Bool evaluate)
eval3		proc near		; CODE XREF: eval2+16p	eval2+FDp

evaluate	= byte ptr -1Ch
fxn		= dword	ptr -14h
l		= dword	ptr -10h
r		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval4
		add	esp, 10h
		mov	[ebp+l], eax

loc_8001584:				; CODE XREF: eval3+102j
		sub	esp, 0Ch
		push	(offset	str+4)	; str
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80015A1
		mov	[ebp+fxn], 0
		jmp	short loc_80015C6
; ---------------------------------------------------------------------------

loc_80015A1:				; CODE XREF: eval3+32j
		sub	esp, 0Ch
		push	offset asc_8002536 ; "-"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80015BE
		mov	[ebp+fxn], 1
		jmp	short loc_80015C6
; ---------------------------------------------------------------------------

loc_80015BE:				; CODE XREF: eval3+4Fj
		mov	eax, [ebp+l]
		jmp	loc_800166B
; ---------------------------------------------------------------------------

loc_80015C6:				; CODE XREF: eval3+3Bj	eval3+58j
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval4
		add	esp, 10h
		mov	[ebp+r], eax
		cmp	[ebp+evaluate],	0
		jz	short loc_8001658
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_8001609
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	toarith
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001629

loc_8001609:				; CODE XREF: eval3+8Ej
		sub	esp, 0Ch
		push	offset aNonNumericArgu ; "non-numeric argument"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 10h

loc_8001629:				; CODE XREF: eval3+A3j
		cmp	[ebp+fxn], 0
		jnz	short loc_8001636
		mov	ebx, offset mpz_add
		jmp	short loc_800163B
; ---------------------------------------------------------------------------

loc_8001636:				; CODE XREF: eval3+C9j
		mov	ebx, offset mpz_sub

loc_800163B:				; CODE XREF: eval3+D0j
		mov	eax, [ebp+r]
		lea	ecx, [eax+4]
		mov	eax, [ebp+l]
		lea	edx, [eax+4]
		mov	eax, [ebp+l]
		add	eax, 4
		sub	esp, 4
		push	ecx		; b0
		push	edx		; a0
		push	eax		; r
		call	ebx ; mpz_add
		add	esp, 10h

loc_8001658:				; CODE XREF: eval3+79j
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		jmp	loc_8001584
; ---------------------------------------------------------------------------

loc_800166B:				; CODE XREF: eval3+5Dj
		mov	ebx, [ebp+var_4]
		leave
		retn
eval3		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval2(_Bool evaluate)
eval2		proc near		; CODE XREF: eval1+14p	eval1+65p

evaluate	= byte ptr -2Ch
val		= byte ptr -19h
l		= dword	ptr -18h
fxn		= dword	ptr -14h
cmp		= dword	ptr -10h
r		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval3
		add	esp, 10h
		mov	[ebp+l], eax

loc_8001691:				; CODE XREF: eval2+2DCj
		mov	[ebp+val], 0
		sub	esp, 0Ch
		push	offset asc_8002538 ; "<"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80016B5
		mov	[ebp+fxn], 0
		jmp	loc_8001765
; ---------------------------------------------------------------------------

loc_80016B5:				; CODE XREF: eval2+37j
		sub	esp, 0Ch
		push	offset asc_800253A ; "<="
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_80016D5
		mov	[ebp+fxn], 1
		jmp	loc_8001765
; ---------------------------------------------------------------------------

loc_80016D5:				; CODE XREF: eval2+57j
		sub	esp, 0Ch
		push	offset asc_800253D ; "="
		call	nextarg
		add	esp, 10h
		test	al, al
		jnz	short loc_80016FD
		sub	esp, 0Ch
		push	offset asc_800253F ; "=="
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001706

loc_80016FD:				; CODE XREF: eval2+77j
		mov	[ebp+fxn], 2
		jmp	short loc_8001765
; ---------------------------------------------------------------------------

loc_8001706:				; CODE XREF: eval2+8Bj
		sub	esp, 0Ch
		push	offset asc_8002542 ; "!="
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001723
		mov	[ebp+fxn], 3
		jmp	short loc_8001765
; ---------------------------------------------------------------------------

loc_8001723:				; CODE XREF: eval2+A8j
		sub	esp, 0Ch
		push	offset asc_8002545 ; ">="
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_8001740
		mov	[ebp+fxn], 4
		jmp	short loc_8001765
; ---------------------------------------------------------------------------

loc_8001740:				; CODE XREF: eval2+C5j
		sub	esp, 0Ch
		push	offset asc_8002548 ; ">"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	short loc_800175D
		mov	[ebp+fxn], 5
		jmp	short loc_8001765
; ---------------------------------------------------------------------------

loc_800175D:				; CODE XREF: eval2+E2j
		mov	eax, [ebp+l]
		jmp	loc_8001951
; ---------------------------------------------------------------------------

loc_8001765:				; CODE XREF: eval2+40j	eval2+60j ...
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval3
		add	esp, 10h
		mov	[ebp+r], eax
		cmp	[ebp+evaluate],	0
		jz	loc_800191D
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	tostring
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	tostring
		add	esp, 10h
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; cp
		call	looks_like_integer
		add	esp, 10h
		test	al, al
		jz	short loc_80017EB
		mov	eax, [ebp+r]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; cp
		call	looks_like_integer
		add	esp, 10h
		test	al, al
		jz	short loc_80017EB
		mov	eax, [ebp+r]
		mov	edx, [eax+4]
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 8
		push	edx
		push	eax
		call	strintcmp
		add	esp, 10h
		mov	[ebp+cmp], eax
		jmp	loc_80018BB
; ---------------------------------------------------------------------------

loc_80017EB:				; CODE XREF: eval2+142j eval2+158j
		call	__errno_location
		mov	dword ptr [eax], 0
		mov	eax, [ebp+r]
		mov	edx, [eax+4]
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcoll
		add	esp, 10h
		mov	[ebp+cmp], eax
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	loc_80018BB
		sub	esp, 0Ch
		push	offset aStringComparis ; "string comparison failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSetLc_allCToWo ; "set LC_ALL='C' to work around the probl"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+r]
		mov	eax, [eax+4]
		sub	esp, 4
		push	eax
		push	6
		push	1
		call	quotearg_n_style
		add	esp, 10h
		mov	esi, eax
		mov	eax, [ebp+l]
		mov	eax, [eax+4]
		sub	esp, 4
		push	eax
		push	6
		push	0
		call	quotearg_n_style
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aTheStringsComp ; "the strings compared were %s and %s"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	2		; status
		call	error
		add	esp, 20h

loc_80018BB:				; CODE XREF: eval2+176j eval2+1ABj
		cmp	[ebp+fxn], 5	; switch 6 cases
		ja	short loc_8001918 ; jumptable 080018CE default case
		mov	eax, [ebp+fxn]
		shl	eax, 2
		add	eax, offset off_80025B4
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80018D0:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		mov	eax, [ebp+cmp]	; jumptable 080018CE case 0
		shr	eax, 1Fh
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_80018DB:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		cmp	[ebp+cmp], 0	; jumptable 080018CE case 1
		setle	al
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_80018E7:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		cmp	[ebp+cmp], 0	; jumptable 080018CE case 2
		setz	al
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_80018F3:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		cmp	[ebp+cmp], 0	; jumptable 080018CE case 3
		setnz	al
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_80018FF:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		mov	eax, [ebp+cmp]	; jumptable 080018CE case 4
		not	eax
		shr	eax, 1Fh
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_800190C:				; CODE XREF: eval2+25Ej
					; DATA XREF: .rodata:off_80025B4o
		cmp	[ebp+cmp], 0	; jumptable 080018CE case 5
		setnle	al
		mov	[ebp+val], al
		jmp	short loc_800191D
; ---------------------------------------------------------------------------

loc_8001918:				; CODE XREF: eval2+24Fj
		call	abort		; jumptable 080018CE default case
; ---------------------------------------------------------------------------

loc_800191D:				; CODE XREF: eval2+10Cj eval2+269j ...
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		movzx	eax, [ebp+val]
		sub	esp, 0Ch
		push	eax		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+l], eax
		jmp	loc_8001691
; ---------------------------------------------------------------------------

loc_8001951:				; CODE XREF: eval2+F0j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
eval2		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval1(_Bool evaluate)
eval1		proc near		; CODE XREF: eval+14p eval+62p

evaluate	= byte ptr -1Ch
l		= dword	ptr -10h
r		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval2
		add	esp, 10h
		mov	[ebp+l], eax

loc_8001977:				; CODE XREF: eval1+D0j
					; eval1:loc_8001A32j
		sub	esp, 0Ch
		push	offset asc_80025CC ; "&"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	loc_8001A2D
		cmp	[ebp+evaluate],	0
		jz	short loc_80019B1
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	null
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80019B1
		mov	eax, 1
		jmp	short loc_80019B6
; ---------------------------------------------------------------------------

loc_80019B1:				; CODE XREF: eval1+3Bj	eval1+50j
		mov	eax, 0

loc_80019B6:				; CODE XREF: eval1+57j
		and	eax, 1
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval2
		add	esp, 10h
		mov	[ebp+r], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	null
		add	esp, 10h
		test	al, al
		jnz	short loc_80019EC
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	null
		add	esp, 10h
		test	al, al
		jz	short loc_8001A1A

loc_80019EC:				; CODE XREF: eval1+80j
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+l], eax
		jmp	short loc_8001A32
; ---------------------------------------------------------------------------

loc_8001A1A:				; CODE XREF: eval1+92j
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		jmp	loc_8001977
; ---------------------------------------------------------------------------

loc_8001A2D:				; CODE XREF: eval1+31j
		mov	eax, [ebp+l]
		jmp	short locret_8001A37
; ---------------------------------------------------------------------------

loc_8001A32:				; CODE XREF: eval1+C0j
		jmp	loc_8001977
; ---------------------------------------------------------------------------

locret_8001A37:				; CODE XREF: eval1+D8j
		leave
		retn
eval1		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; VALUE	*__cdecl eval(_Bool evaluate)
eval		proc near		; CODE XREF: main+116p	eval7+36p

evaluate	= byte ptr -1Ch
l		= dword	ptr -10h
r		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+evaluate],	al
		movzx	eax, [ebp+evaluate]
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval1
		add	esp, 10h
		mov	[ebp+l], eax

loc_8001A58:				; CODE XREF: eval+A3j eval+C7j ...
		sub	esp, 0Ch
		push	offset asc_80025CE ; "|"
		call	nextarg
		add	esp, 10h
		test	al, al
		jz	loc_8001B18
		cmp	[ebp+evaluate],	0
		jz	short loc_8001A8F
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	null
		add	esp, 10h
		test	al, al
		jz	short loc_8001A8F
		mov	eax, 1
		jmp	short loc_8001A94
; ---------------------------------------------------------------------------

loc_8001A8F:				; CODE XREF: eval+3Bj eval+4Dj
		mov	eax, 0

loc_8001A94:				; CODE XREF: eval+54j
		and	eax, 1
		sub	esp, 0Ch
		push	eax		; evaluate
		call	eval1
		add	esp, 10h
		mov	[ebp+r], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	null
		add	esp, 10h
		test	al, al
		jz	short loc_8001B05
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		mov	eax, [ebp+r]
		mov	[ebp+l], eax
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	null
		add	esp, 10h
		test	al, al
		jz	loc_8001A58
		sub	esp, 0Ch
		push	[ebp+l]		; v
		call	freev
		add	esp, 10h
		sub	esp, 0Ch
		push	0		; i
		call	int_value
		add	esp, 10h
		mov	[ebp+l], eax
		jmp	loc_8001A58
; ---------------------------------------------------------------------------

loc_8001B05:				; CODE XREF: eval+7Dj
		sub	esp, 0Ch
		push	[ebp+r]		; v
		call	freev
		add	esp, 10h
		jmp	loc_8001A58
; ---------------------------------------------------------------------------

loc_8001B18:				; CODE XREF: eval+31j
		mov	eax, [ebp+l]
		leave

locret_8001B1C:				; DATA XREF: .eh_frame:080025F0o
					; .eh_frame:08002610o ...
		retn
eval		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 8001B20h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; char **args
args		dd ?			; DATA XREF: main+10Cw	nextarg+6r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 8001B24h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+97o
		align 10h
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 10h
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSExpressi[]
aUsageSExpressi	db 'Usage: %s EXPRESSION',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s OPTION',0Ah,0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+7Bo
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+9Eo
		align 4
; char aPrintTheValueO[]
aPrintTheValueO	db 0Ah			; DATA XREF: usage+C1o
		db 'Print the value of EXPRESSION to standard output.  A blank line b'
		db 'elow',0Ah
		db 'separates increasing precedence groups.  EXPRESSION may be:',0Ah
		db 0Ah
		db '  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise A'
		db 'RG2',0Ah
		db 0Ah
		db '  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherw'
		db 'ise 0',0Ah,0
		align 4
; char aArg1Arg2Arg1Is[]
aArg1Arg2Arg1Is	db 0Ah			; DATA XREF: usage+E4o
		db '  ARG1 < ARG2       ARG1 is less than ARG2',0Ah
		db '  ARG1 <= ARG2      ARG1 is less than or equal to ARG2',0Ah
		db '  ARG1 = ARG2       ARG1 is equal to ARG2',0Ah
		db '  ARG1 != ARG2      ARG1 is unequal to ARG2',0Ah
		db '  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2',0Ah
		db '  ARG1 > ARG2       ARG1 is greater than ARG2',0Ah,0
		align 10h
; char aArg1Arg2Arithm[]
aArg1Arg2Arithm	db 0Ah			; DATA XREF: usage+107o
		db '  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2',0Ah
		db '  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2',0Ah,0
		align 4
; char aArg1Arg2Arit_0[]
aArg1Arg2Arit_0	db 0Ah			; DATA XREF: usage+12Ao
		db '  ARG1 * ARG2       arithmetic product of ARG1 and ARG2',0Ah
		db '  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2',0Ah
		db '  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2',0Ah
		db 0
		align 10h
; char aStringRegexpAn[]
aStringRegexpAn	db 0Ah			; DATA XREF: usage+14Do
		db '  STRING : REGEXP   anchored pattern match of REGEXP in STRING',0Ah
		db 0Ah
		db '  match STRING REGEXP        same as STRING : REGEXP',0Ah
		db '  substr STRING POS LENGTH   substring of STRING, POS counted fro'
		db 'm 1',0Ah
		db '  index STRING CHARS         index in STRING where any CHARS is f'
		db 'ound, or 0',0Ah
		db '  length STRING              length of STRING',0Ah,0
		align 4
; char aTokenInterpret[]
aTokenInterpret	db '  + TOKEN                    interpret TOKEN as a string, even if'
					; DATA XREF: usage+170o
		db ' it is a',0Ah
		db '                               keyword like `match',27h,' or an oper'
		db 'ator like `/',27h,0Ah
		db 0Ah
		db '  ( EXPRESSION )             value of EXPRESSION',0Ah,0
		align 4
; char aBewareThatMany[]
aBewareThatMany	db 0Ah			; DATA XREF: usage+193o
		db 'Beware that many operators need to be escaped or quoted for shell'
		db 's.',0Ah
		db 'Comparisons are arithmetic if both ARGs are numbers, else lexicog'
		db 'raphical.',0Ah
		db 'Pattern matches return the string matched between \( and \) or nu'
		db 'll; if',0Ah
		db '\( and \) are not used, they return the number of characters matc'
		db 'hed or 0.',0Ah,0
; char aExitStatusIs0I[]
aExitStatusIs0I	db 0Ah			; DATA XREF: usage+1B6o
		db 'Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRES'
		db 'SION is null',0Ah
		db 'or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error'
		db ' occurred.',0Ah,0
; char aSyntaxError[]
aSyntaxError	db 'syntax error',0     ; DATA XREF: syntax_error+9o
; char format[]
format		db '%c',0               ; DATA XREF: integer_overflow+11o
; char aS[]
aS		db '%s',0               ; DATA XREF: die+9o toarith+5Do ...
; char locale
locale		db 0			; DATA XREF: main+28o docolon+1D1o ...
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
aPaulEggert	db 'Paul Eggert',0      ; DATA XREF: main+7Eo
aJamesYoungman	db 'James Youngman',0   ; DATA XREF: main+83o
aMikeParker	db 'Mike Parker',0      ; DATA XREF: main+88o
a8_4		db '8.4',0              ; DATA XREF: main+92o
aExpr		db 'expr',0             ; DATA XREF: main+9Co
; char asc_80024B0[]
asc_80024B0	db '--',0               ; DATA XREF: main+BEo
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+DFo
		align 4
; char aErrorInRegular[]
aErrorInRegular	db 'error in regular expression matcher',0 ; DATA XREF: docolon+1FEo
; char str[]
str:					; DATA XREF: eval7+1Do	eval7+44o ...
		unicode	0, <()+>
; char aLength[]
aLength		db 'length',0           ; DATA XREF: eval6+52o
; char aMatch[]
aMatch		db 'match',0            ; DATA XREF: eval6+BEo
; char aIndex[]
aIndex		db 'index',0            ; DATA XREF: eval6+13Eo
; char aSubstr[]
aSubstr		db 'substr',0           ; DATA XREF: eval6+206o
; char asc_8002508[]
asc_8002508:				; DATA XREF: eval5+22o	eval4+23o ...
		unicode	0, <:*/%>
; char aNonNumericArgu[]
aNonNumericArgu	db 'non-numeric argument',0 ; DATA XREF: eval4+C9o eval3+A8o
; char aDivisionByZero[]
aDivisionByZero	db 'division by zero',0 ; DATA XREF: eval4+105o
; char asc_8002536[]
asc_8002536	db '-',0                ; DATA XREF: eval3+40o
; char asc_8002538[]
asc_8002538	db '<',0                ; DATA XREF: eval2+28o
; char asc_800253A[]
asc_800253A	db '<=',0               ; DATA XREF: eval2+48o
; char asc_800253D[]
asc_800253D	db '=',0                ; DATA XREF: eval2+68o
; char asc_800253F[]
asc_800253F	db '==',0               ; DATA XREF: eval2+7Co
; char asc_8002542[]
asc_8002542	db '!=',0               ; DATA XREF: eval2+99o
; char asc_8002545[]
asc_8002545	db '>=',0               ; DATA XREF: eval2+B6o
; char asc_8002548[]
asc_8002548	db '>',0                ; DATA XREF: eval2+D3o
; char aStringComparis[]
aStringComparis	db 'string comparison failed',0 ; DATA XREF: eval2+1B4o
		align 4
; char aSetLc_allCToWo[]
aSetLc_allCToWo	db 'set LC_ALL=',27h,'C',27h,' to work around the problem',0
					; DATA XREF: eval2+1DCo
		align 10h
; char aTheStringsComp[]
aTheStringsComp	db 'the strings compared were %s and %s',0 ; DATA XREF: eval2+22Co
off_80025B4	dd offset loc_80018D0	; DATA XREF: eval2+257o
		dd offset loc_80018DB	; jump table for switch	statement
		dd offset loc_80018E7
		dd offset loc_80018F3
		dd offset loc_80018FF
		dd offset loc_800190C
; char asc_80025CC[2]
asc_80025CC	db '&',0                ; DATA XREF: eval1+22o
; char asc_80025CE[2]
asc_80025CE	db '|',0                ; DATA XREF: eval+22o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80025D0h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_8001B1C-800410Ch
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 20h, 3Ch
		dd offset locret_8001B1C-8004118h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset locret_8001B1C-8004020h
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 80h
		dd offset locret_8001B1C-800403Ah
		dd 16h,	80E4100h, 0D420285h, 0CC55205h,	404h, 1Ch, 0A0h
		dd offset locret_8001B1C-8004044h
		dd 30h,	80E4100h, 0D420285h, 0CC56C05h,	404h, 20h, 0C0h
		dd offset locret_8001B1C-8004034h
		dd 82h,	80E4100h, 0D420285h, 3834405h, 0C3C57A02h, 4040Ch
		dd 1Ch,	0E4h
		dd offset locret_8001B1C-8003FD6h
		dd 7Ah,	80E4100h, 0D420285h, 0C5760205h, 4040Ch, 1Ch, 104h
		dd offset locret_8001B1C-8003F7Ch
		dd 0BDh, 80E4100h, 0D420285h, 0C5B90205h, 4040Ch, 1Ch
		dd 124h
		dd offset locret_8001B1C-8003EDFh
		dd 6Eh,	80E4100h, 0D420285h, 0C56A0205h, 4040Ch, 1Ch, 144h
		dd offset locret_8001B1C-8003E91h
		dd 72h,	80E4100h, 0D420285h, 0C56E0205h, 4040Ch, 1Ch, 164h
		dd offset locret_8001B1C-8003E3Fh
		dd 55h,	80E4100h, 0D420285h, 0C5510205h, 4040Ch, 20h, 184h
		dd offset locret_8001B1C-8003E0Ah
		dd 3Fh,	80E4100h, 0D420285h, 3834105h, 0C541C379h, 4040Ch
		dd 1Ch,	1A8h
		dd offset locret_8001B1C-8003DEFh
		dd 29h,	80E4100h, 0D420285h, 0CC56505h,	404h, 1Ch, 1C8h
		dd offset locret_8001B1C-8003DE6h
		dd 0Dh,	80E4100h, 0D420285h, 0CC54905h,	404h, 1Ch, 1E8h
		dd offset locret_8001B1C-8003DF9h
		dd 61h,	80E4100h, 0D420285h, 0C55D0205h, 4040Ch, 1Ch, 208h
		dd offset locret_8001B1C-8003DB8h
		dd 1E0h, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 228h
		dd offset locret_8001B1C-8003BF8h
		dd 29h,	80E4100h, 0D420285h, 0CC56505h,	404h, 18h, 248h
		dd offset locret_8001B1C-8003BEFh
		dd 27h,	80E4100h, 0D420285h, 5,	18h, 264h
		dd offset locret_8001B1C-8003BE4h
		dd 20h,	80E4100h, 0D420285h, 5,	24h, 280h
		dd offset locret_8001B1C-8003BE0h
		dd 15Ah, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h, 1Ch, 2A8h
		dd offset locret_8001B1C-8003AAEh
		dd 39h,	80E4100h, 0D420285h, 0CC57505h,	404h, 1Ch, 2C8h
		dd offset locret_8001B1C-8003A95h
		dd 3Ah,	80E4100h, 0D420285h, 0CC57605h,	404h, 1Ch, 2E8h
		dd offset locret_8001B1C-8003A7Bh
		dd 47h,	80E4100h, 0D420285h, 0C5430205h, 4040Ch, 1Ch, 308h
		dd offset locret_8001B1C-8003A54h
		dd 5Bh,	80E4100h, 0D420285h, 0C5570205h, 4040Ch, 1Ch, 328h
		dd offset locret_8001B1C-8003A19h
		dd 87h,	80E4100h, 0D420285h, 0C5830205h, 4040Ch, 1Ch, 348h
		dd offset locret_8001B1C-80039B2h
		dd 41h,	80E4100h, 0D420285h, 0CC57D05h,	404h, 1Ch, 368h
		dd offset locret_8001B1C-8003991h
		dd 5Eh,	80E4100h, 0D420285h, 0C55A0205h, 4040Ch, 1Ch, 388h
		dd offset locret_8001B1C-8003953h
		dd 93h,	80E4100h, 0D420285h, 0C58F0205h, 4040Ch, 1Ch, 3A8h
		dd offset locret_8001B1C-80038E0h
		dd 54h,	80E4100h, 0D420285h, 0C5500205h, 4040Ch, 1Ch, 3C8h
		dd offset locret_8001B1C-80038ACh
		dd 4Fh,	80E4100h, 0D420285h, 0C54B0205h, 4040Ch, 1Ch, 3E8h
		dd offset locret_8001B1C-800387Dh
		dd 11h,	80E4100h, 0D420285h, 0CC54D05h,	404h, 20h, 408h
		dd offset locret_8001B1C-800388Ch
		dd 299h, 80E4100h, 0D420285h, 3834705h,	0C5028E03h, 4040CC3h
		dd 1Ch,	42Ch
		dd offset locret_8001B1C-8003617h
		dd 99h,	80E4100h, 0D420285h, 0C5950205h, 4040Ch, 1Ch, 44Ch
		dd offset locret_8001B1C-800359Eh
		dd 3C7h, 80E4100h, 0D420285h, 3C30305h,	4040CC5h, 1Ch
		dd 46Ch
		dd offset locret_8001B1C-80031F7h
		dd 89h,	80E4100h, 0D420285h, 0C5850205h, 4040Ch, 20h, 48Ch
		dd offset locret_8001B1C-800318Eh
		dd 176h, 80E4100h, 0D420285h, 3834405h,	0C5016E03h, 4040CC3h
		dd 20h,	4B0h
		dd offset locret_8001B1C-800303Ch
		dd 10Ch, 80E4100h, 0D420285h, 3834405h,	0C5010403h, 4040CC3h
		dd 28h,	4D4h
		dd offset locret_8001B1C-8002F54h
		dd 2E8h, 80E4100h, 0D420285h, 3864505h,	0DD030483h, 0C641C302h
		dd 40CC541h, 4,	1Ch, 500h
		dd offset locret_8001B1C-8002C98h
		dd 0E1h, 80E4100h, 0D420285h, 0C5DD0205h, 4040Ch, 1Ch
		dd 520h
		dd offset locret_8001B1C-8002BD7h
		dd 0E4h, 80E4100h, 0D420285h, 0C5E00205h, 4040Ch
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+72r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; mpz_out_str+3Dp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn xstrtoimax:near	; CODE XREF: mpz_init_set_str+16p
		extrn __divdi3:near	; CODE XREF: mpz_mul+8Cp
					; mpz_tdiv_q+5Bp
		extrn __moddi3:near	; CODE XREF: mpz_tdiv_r+53p
		extrn imaxtostr:near	; CODE XREF: mpz_get_str+2Ep
					; mpz_out_str+2Ep
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: mpz_get_str+3Ap
					; str_value+25p
		extrn __stack_chk_fail:near ; CODE XREF: mpz_get_str+4Ep
					; mpz_out_str+5Ap ...
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: usage+6Ap printv+35p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1DBp main+155p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: syntax_error+1Ep
					; integer_overflow+1Ap	...
; void abort(void)
		extrn abort:near	; CODE XREF: integer_overflow+22p
					; die+1Bp ...
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+6Co
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+71p
		extrn parse_long_options:near ;	CODE XREF: main+A6p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+C4p nextarg+26p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: int_value+Bp str_value+Bp ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: freev+1Ap	freev+3Cp ...
; int puts(const char *s)
		extrn puts:near		; CODE XREF: printv+49p
; reg_syntax_t re_syntax_options
		extrn re_syntax_options:dword ;	DATA XREF: docolon+91w
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: docolon+A8p docolon+112p	...
; const	char *re_compile_pattern(const char *pattern, size_t length, struct re_pattern_buffer *buffer)
		extrn re_compile_pattern:near ;	CODE XREF: docolon+C7p
; int re_match(struct re_pattern_buffer	*buffer, const char *string, int length, int start, struct re_registers	*regs)
		extrn re_match:near	; CODE XREF: docolon+13Ap
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: docolon+216p
					; eval2:loc_80017EBp ...
; void regfree(regex_t *preg)
		extrn regfree:near	; CODE XREF: docolon+275p
; size_t strcspn(const char *s,	const char *reject)
		extrn strcspn:near	; CODE XREF: eval6+1A6p
		extrn mempcpy:near	; CODE XREF: eval6+375p
		extrn strintcmp:near	; CODE XREF: eval2+16Bp
; int strcoll(const char *s1, const char *s2)
		extrn strcoll:near	; CODE XREF: eval2+197p
		extrn quotearg_n_style:near ; CODE XREF: eval2+207p eval2+21Fp


		end
