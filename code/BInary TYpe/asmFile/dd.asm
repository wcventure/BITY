;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	31B913DD1F91D206716E59B00082E379
; Input	CRC32 :	DA9EBB5F

; File Name   :	D:\coreutils-o\dd.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'dd.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: translate_buffer+1Ep

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned int __cdecl select_plural(uintmax_t n)
select_plural	proc near		; CODE XREF: print_stats+FBp
					; print_stats+184p

n		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+n], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+n+4], eax
		cmp	dword ptr [ebp+n+4], 0
		jbe	short loc_8000048
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		push	0
		push	0F4240h
		push	edx
		push	eax
		call	__umoddi3
		add	esp, 10h
		add	eax, 0F4240h
		jmp	short locret_800004B
; ---------------------------------------------------------------------------

loc_8000048:				; CODE XREF: select_plural+16j
		mov	eax, dword ptr [ebp+n]

locret_800004B:				; CODE XREF: select_plural+34j
		leave
		retn
select_plural	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void *__cdecl	ptr_align(const	void *ptr, size_t alignment)
ptr_align	proc near		; CODE XREF: dd_copy+60p dd_copy+AAp

p0		= dword	ptr -8
p1		= dword	ptr -4
ptr		= dword	ptr  8
alignment	= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+ptr]
		mov	[ebp+p0], eax
		mov	eax, [ebp+alignment]
		lea	edx, [eax-1]
		mov	eax, [ebp+p0]
		add	eax, edx
		mov	[ebp+p1], eax
		mov	eax, [ebp+p1]
		mov	edx, 0
		div	[ebp+alignment]
		mov	eax, edx
		neg	eax
		mov	edx, eax
		mov	eax, [ebp+p1]
		add	eax, edx
		leave
		retn
ptr_align	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+307p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000165
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000165
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000165:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl ignore_value(int	i)
ignore_value	proc near		; CODE XREF: iwrite+CDp

i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		nop
		pop	ebp
		retn
ignore_value	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void maybe_close_stdout()
maybe_close_stdout proc	near		; DATA XREF: main+80o
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		movzx	eax, close_stdout_required
		test	al, al
		jz	short loc_80001B9
		call	close_stdout
		jmp	short loc_80001D8
; ---------------------------------------------------------------------------

loc_80001B9:				; CODE XREF: maybe_close_stdout+Fj
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	eax
		call	close_stream
		add	esp, 10h
		test	eax, eax
		jz	short loc_80001D8
		sub	esp, 0Ch
		push	1		; status
		call	_exit
; ---------------------------------------------------------------------------

loc_80001D8:				; CODE XREF: maybe_close_stdout+16j
					; maybe_close_stdout+2Bj
		nop
		leave
		retn
maybe_close_stdout endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: parse_symbols+93p
					; scanargs+8Cp	...

siginfo_name	= dword	ptr -0Ch
status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		cmp	[ebp+status], 0
		jz	short loc_8000219
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80004E7
; ---------------------------------------------------------------------------

loc_8000219:				; CODE XREF: usage+Cj
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOperand_ ; "Usage: %s [OPERAND]...\n  or:	 %s OPTIO"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aCopyAFileConve ; "Copy a file, converting and formatting "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfFileReadFrom ; "  if=FILE	    read from FILE instea"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBlocksAndBytes ; "\nBLOCKS and BYTES may be followed by	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAsciiFromEbcdi ; "  ascii     from EBCDIC to ASCII\n  ebc"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNocreatDoNotCr ; "  nocreat   do not create the	output fi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoerrorContinu ; "  noerror   continue after read errors\"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aEachFlagSymbol ; "\nEach FLAG symbol may be:\n\n  append "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDirectUseDirec ; "  direct    use direct I/O for data\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDirectoryFailU ; "  directory  fail unless a directory\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aDsyncUseSynchr ; "  dsync     use synchronized I/O for da"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSyncLikewiseBu ; "  sync      likewise,	but also for meta"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFullblockAccum ; "  fullblock  accumulate full blocks of "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNonblockUseNon ; "  nonblock  use non-blocking I/O\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoatimeDoNotUp ; "  noatime   do not update access time\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNocttyDoNotAss ; "  noctty    do not assign controlling	t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNofollowDoNotF ; "  nofollow  do not follow symlinks\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	[ebp+siginfo_name], offset aUsr1 ; "USR1"
		sub	esp, 0Ch
		push	offset aSendingASSigna ; "\nSending a %s signal	to a running `dd'"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	[ebp+siginfo_name]
		push	[ebp+siginfo_name]
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80004E7:				; CODE XREF: usage+39j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl translate_charset(const char *new_trans)
translate_charset proc near		; CODE XREF: apply_translations+17p
					; apply_translations+D3p ...

i		= dword	ptr -4
new_trans	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+i], 0
		jmp	short loc_8000527
; ---------------------------------------------------------------------------

loc_8000501:				; CODE XREF: translate_charset+3Cj
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	eax, [ebp+new_trans]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		mov	[eax], dl
		add	[ebp+i], 1

loc_8000527:				; CODE XREF: translate_charset+Dj
		cmp	[ebp+i], 0FFh
		jle	short loc_8000501
		mov	ds:translation_needed, 1
		nop
		leave
		retn
translate_charset endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	multiple_bits_set(int i)
multiple_bits_set proc near		; CODE XREF: scanargs+5D9p
					; scanargs+611p ...

i		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+i]
		sub	eax, 1
		and	eax, [ebp+i]
		test	eax, eax
		setnz	al
		pop	ebp
		retn
multiple_bits_set endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void print_stats()
print_stats	proc near		; CODE XREF: quit+Bp
					; process_signals:loc_8000B0Ap	...

var_2F8		= dword	ptr -2F8h
var_2F4		= dword	ptr -2F4h
var_2F0		= dword	ptr -2F0h
var_2EC		= dword	ptr -2ECh
var_2E8		= dword	ptr -2E8h
var_2E4		= dword	ptr -2E4h
var_2E0		= qword	ptr -2E0h
bytes_per_second= dword	ptr -2D0h
human_opts	= dword	ptr -2CCh
delta_s		= qword	ptr -2C8h
now		= qword	ptr -2C0h
XTIME_PRECISIONe0= qword ptr -2B8h
delta_xtime	= qword	ptr -2B0h
hbuf		= byte ptr -2A8h
var_1C		= dword	ptr -1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 2ECh
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		call	gethrxtime
		mov	dword ptr [ebp+now], eax
		mov	dword ptr [ebp+now+4], edx
		mov	[ebp+human_opts], 1D1h
		mov	ebx, dword ptr ds:w_partial
		mov	esi, dword ptr ds:w_partial+4
		mov	eax, dword ptr ds:w_full
		mov	edx, dword ptr ds:w_full+4
		mov	[ebp+var_2E8], eax
		mov	[ebp+var_2E4], edx
		mov	edx, dword ptr ds:r_partial
		mov	ecx, dword ptr ds:r_partial+4
		mov	[ebp+var_2F0], edx
		mov	[ebp+var_2EC], ecx
		mov	eax, dword ptr ds:r_full
		mov	edx, dword ptr ds:r_full+4
		mov	[ebp+var_2F8], eax
		mov	[ebp+var_2F4], edx
		sub	esp, 0Ch
		push	offset aLluLluRecordsI ; "%llu+%llu records in\n%llu+%llu records"...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 8
		push	esi
		push	ebx
		push	[ebp+var_2E4]
		push	[ebp+var_2E8]
		push	[ebp+var_2EC]
		push	[ebp+var_2F0]
		push	[ebp+var_2F4]
		push	[ebp+var_2F8]
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 30h
		mov	eax, dword ptr ds:r_truncate
		mov	edx, dword ptr ds:r_truncate+4
		or	eax, edx
		test	eax, eax
		jz	short loc_8000679
		mov	ebx, dword ptr ds:r_truncate
		mov	esi, dword ptr ds:r_truncate+4
		mov	eax, dword ptr ds:r_truncate
		mov	edx, dword ptr ds:r_truncate+4
		sub	esp, 8
		push	edx
		push	eax		; n
		call	select_plural
		add	esp, 10h
		sub	esp, 4
		push	eax		; n
		push	offset msgid2	; "%llu	truncated records\n"
		push	offset msgid1	; "%llu	truncated record\n"
		call	ngettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h

loc_8000679:				; CODE XREF: print_stats+DDj
		mov	eax, ds:status_flags
		and	eax, 1
		test	eax, eax
		jnz	loc_800082E
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		push	0
		push	1
		push	0
		push	1
		push	[ebp+human_opts]
		lea	ecx, [ebp+hbuf]
		push	ecx
		push	edx
		push	eax
		call	human_readable
		add	esp, 20h
		mov	edi, eax
		mov	ebx, dword ptr ds:w_bytes
		mov	esi, dword ptr ds:w_bytes+4
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		sub	esp, 8
		push	edx
		push	eax		; n
		call	select_plural
		add	esp, 10h
		sub	esp, 4
		push	eax		; n
		push	offset aLluBytesSCopie ; "%llu bytes (%s) copied"
		push	offset aLluByteSCopied ; "%llu byte (%s) copied"
		call	ngettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	edi
		push	esi
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 20h
		mov	eax, dword ptr ds:start_time
		mov	edx, dword ptr ds:start_time+4
		cmp	edx, dword ptr [ebp+now+4]
		jg	loc_80007D8
		cmp	edx, dword ptr [ebp+now+4]
		jl	short loc_8000731
		cmp	eax, dword ptr [ebp+now]
		jnb	loc_80007D8

loc_8000731:				; CODE XREF: print_stats+1D6j
		fld	ds:dbl_8004D68
		fstp	[ebp+XTIME_PRECISIONe0]
		mov	eax, dword ptr [ebp+now]
		mov	edx, dword ptr [ebp+now+4]
		mov	dword ptr [ebp+delta_xtime], eax
		mov	dword ptr [ebp+delta_xtime+4], edx
		mov	eax, dword ptr ds:start_time
		mov	edx, dword ptr ds:start_time+4
		sub	dword ptr [ebp+delta_xtime], eax
		sbb	dword ptr [ebp+delta_xtime+4], edx
		fild	[ebp+delta_xtime]
		cmp	dword ptr [ebp+delta_xtime+4], 0
		jns	short loc_8000783
		fld	ds:tbyte_8004D70
		faddp	st(1), st

loc_8000783:				; CODE XREF: print_stats+22Cj
		fstp	[ebp+var_2E0]
		fld	[ebp+var_2E0]
		fdiv	[ebp+XTIME_PRECISIONe0]
		fstp	[ebp+delta_s]
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		push	dword ptr [ebp+delta_xtime+4]
		push	dword ptr [ebp+delta_xtime]
		push	0
		push	3B9ACA00h
		push	[ebp+human_opts]
		lea	ecx, [ebp+hbuf]
		push	ecx
		push	edx
		push	eax
		call	human_readable
		add	esp, 20h
		mov	[ebp+bytes_per_second],	eax
		jmp	short loc_80007F6
; ---------------------------------------------------------------------------

loc_80007D8:				; CODE XREF: print_stats+1CAj
					; print_stats+1DEj
		fldz
		fstp	[ebp+delta_s]
		sub	esp, 0Ch
		push	offset aInfinityB ; "Infinity B"
		call	gettext
		add	esp, 10h
		mov	[ebp+bytes_per_second],	eax

loc_80007F6:				; CODE XREF: print_stats+289j
		sub	esp, 0Ch
		push	offset aGSSS	; ", %g	s, %s/s\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	[ebp+bytes_per_second]
		push	dword ptr [ebp+delta_s+4]
		push	dword ptr [ebp+delta_s]
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 20h
		jmp	short loc_800082F
; ---------------------------------------------------------------------------

loc_800082E:				; CODE XREF: print_stats+136j
		nop

loc_800082F:				; CODE XREF: print_stats+2DFj
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8000840
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000840:				; CODE XREF: print_stats+2ECj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
print_stats	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void cleanup()
cleanup		proc near		; CODE XREF: quit+6p
					; process_signals+7Ep
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_8000897
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClosingInputFi ; "closing input	file %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000897:				; CODE XREF: cleanup+14j
		sub	esp, 0Ch
		push	1		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jns	short loc_80008E1
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aClosingOutputF ; "closing output file %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80008E1:				; CODE XREF: cleanup+5Ej
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
cleanup		endp ; sp-analysis failed


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl quit(int	code)
quit		proc near		; CODE XREF: write_output+B1p
					; skip+2FCp ...

code		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	cleanup
		call	print_stats
		call	process_signals
		sub	esp, 0Ch
		push	[ebp+code]	; status
		call	exit
quit		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl interrupt_handler(int sig)
interrupt_handler proc near		; DATA XREF: install_signal_handlers+11Co

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+sig]
		mov	ds:interrupt_signal, eax
		nop
		pop	ebp
		retn
interrupt_handler endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl siginfo_handler(int sig)
siginfo_handler	proc near		; DATA XREF: install_signal_handlers+DFo

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, ds:info_signal_count
		add	eax, 1
		mov	ds:info_signal_count, eax
		nop
		pop	ebp
		retn
siginfo_handler	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void install_signal_handlers()
install_signal_handlers	proc near	; CODE XREF: main+2Dp

catch_siginfo	= byte ptr -0A9h
act		= sigaction ptr	-0A8h
var_1C		= dword	ptr -1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 0ACh
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+catch_siginfo], al
		sub	esp, 0Ch
		push	offset caught_signals ;	set
		call	sigemptyset
		add	esp, 10h
		cmp	[ebp+catch_siginfo], 0
		jz	short loc_80009A8
		sub	esp, 4
		lea	eax, [ebp+act]
		push	eax		; oact
		push	0		; act
		push	0Ah		; sig
		call	sigaction_0
		add	esp, 10h
		mov	eax, dword ptr [ebp+act.__sigaction_handler]
		cmp	eax, 1
		jz	short loc_80009A8
		sub	esp, 8
		push	0Ah		; signo
		push	offset caught_signals ;	set
		call	sigaddset
		add	esp, 10h

loc_80009A8:				; CODE XREF: install_signal_handlers+49j
					; install_signal_handlers+6Aj
		sub	esp, 4
		lea	eax, [ebp+act]
		push	eax		; oact
		push	0		; act
		push	2		; sig
		call	sigaction_0
		add	esp, 10h
		mov	eax, dword ptr [ebp+act.__sigaction_handler]
		cmp	eax, 1
		jz	short loc_80009DB
		sub	esp, 8
		push	2		; signo
		push	offset caught_signals ;	set
		call	sigaddset
		add	esp, 10h

loc_80009DB:				; CODE XREF: install_signal_handlers+9Dj
		lea	eax, [ebp+act.sa_mask]
		mov	ebx, offset caught_signals
		mov	edx, 20h
		mov	edi, eax
		mov	esi, ebx
		mov	ecx, edx
		rep movsd
		sub	esp, 8
		push	0Ah		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000A30
		mov	dword ptr [ebp+act.__sigaction_handler], offset	siginfo_handler
		mov	[ebp+act.sa_flags], 0
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+act]
		push	eax		; act
		push	0Ah		; sig
		call	sigaction_0
		add	esp, 10h

loc_8000A30:				; CODE XREF: install_signal_handlers+DDj
		sub	esp, 8
		push	2		; signo
		push	offset caught_signals ;	set
		call	sigismember
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000A6D
		mov	dword ptr [ebp+act.__sigaction_handler], offset	interrupt_handler
		mov	[ebp+act.sa_flags], 0C0000000h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+act]
		push	eax		; act
		push	2		; sig
		call	sigaction_0
		add	esp, 10h

loc_8000A6D:				; CODE XREF: install_signal_handlers+11Aj
		nop
		mov	eax, [ebp+var_1C]
		xor	eax, large gs:14h
		jz	short loc_8000A7F
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000A7F:				; CODE XREF: install_signal_handlers+14Ej
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
install_signal_handlers	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void process_signals()
process_signals	proc near		; CODE XREF: quit+10p
					; iread:loc_8000B5Dp ...

interrupt	= dword	ptr -94h
infos		= dword	ptr -90h
oldset		= sigset_t ptr -8Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 98h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		jmp	loc_8000B29
; ---------------------------------------------------------------------------

loc_8000AA0:				; CODE XREF: process_signals+A9j
					; process_signals+B6j
		sub	esp, 4
		lea	eax, [ebp+oldset]
		push	eax		; oset
		push	offset caught_signals ;	set
		push	0		; how
		call	sigprocmask
		add	esp, 10h
		mov	eax, ds:interrupt_signal
		mov	[ebp+interrupt], eax
		mov	eax, ds:info_signal_count
		mov	[ebp+infos], eax
		cmp	[ebp+infos], 0
		jz	short loc_8000AE6
		mov	eax, [ebp+infos]
		sub	eax, 1
		mov	ds:info_signal_count, eax

loc_8000AE6:				; CODE XREF: process_signals+4Fj
		sub	esp, 4
		push	0		; oset
		lea	eax, [ebp+oldset]
		push	eax		; set
		push	2		; how
		call	sigprocmask
		add	esp, 10h
		cmp	[ebp+interrupt], 0
		jz	short loc_8000B0A
		call	cleanup

loc_8000B0A:				; CODE XREF: process_signals+7Cj
		call	print_stats
		cmp	[ebp+interrupt], 0
		jz	short loc_8000B29
		sub	esp, 0Ch
		push	[ebp+interrupt]	; sig
		call	raise
		add	esp, 10h

loc_8000B29:				; CODE XREF: process_signals+14j
					; process_signals+8Fj
		mov	eax, ds:interrupt_signal
		test	eax, eax
		jnz	loc_8000AA0
		mov	eax, ds:info_signal_count
		test	eax, eax
		jnz	loc_8000AA0
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000B55
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000B55:				; CODE XREF: process_signals+C7j
		leave
		retn
process_signals	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; ssize_t __cdecl iread(int fd,	char *buf, size_t size)
iread		proc near		; CODE XREF: iread_fullblock+1Bp
					; DATA XREF: scanargs:loc_800165Bo

nread		= dword	ptr -0Ch
fd		= dword	ptr  8
buf		= dword	ptr  0Ch
size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h

loc_8000B5D:				; CODE XREF: iread+32j
		call	process_signals
		sub	esp, 4
		push	[ebp+size]	; nbytes
		push	[ebp+buf]	; buf
		push	[ebp+fd]	; fd
		call	read
		add	esp, 10h
		mov	[ebp+nread], eax
		cmp	[ebp+nread], 0
		jns	short loc_8000B8B
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 4
		jz	short loc_8000B5D

loc_8000B8B:				; CODE XREF: iread+26j
		mov	eax, [ebp+nread]
		leave
		retn
iread		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; ssize_t __cdecl iread_fullblock(int fd, char *buf, size_t size)
iread_fullblock	proc near		; DATA XREF: scanargs+5AFo

nread		= dword	ptr -10h
ncurr		= dword	ptr -0Ch
fd		= dword	ptr  8
buf		= dword	ptr  0Ch
size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+nread], 0
		jmp	short loc_8000BD9
; ---------------------------------------------------------------------------

loc_8000B9F:				; CODE XREF: iread_fullblock+4Dj
		sub	esp, 4
		push	[ebp+size]	; size
		push	[ebp+buf]	; buf
		push	[ebp+fd]	; fd
		call	iread
		add	esp, 10h
		mov	[ebp+ncurr], eax
		cmp	[ebp+ncurr], 0
		jns	short loc_8000BC1
		mov	eax, [ebp+ncurr]
		jmp	short locret_8000BE5
; ---------------------------------------------------------------------------

loc_8000BC1:				; CODE XREF: iread_fullblock+2Aj
		cmp	[ebp+ncurr], 0
		jz	short loc_8000BE1
		mov	eax, [ebp+ncurr]
		add	[ebp+nread], eax
		mov	eax, [ebp+ncurr]
		add	[ebp+buf], eax
		mov	eax, [ebp+ncurr]
		sub	[ebp+size], eax

loc_8000BD9:				; CODE XREF: iread_fullblock+Dj
		cmp	[ebp+size], 0
		jnz	short loc_8000B9F
		jmp	short loc_8000BE2
; ---------------------------------------------------------------------------

loc_8000BE1:				; CODE XREF: iread_fullblock+35j
		nop

loc_8000BE2:				; CODE XREF: iread_fullblock+4Fj
		mov	eax, [ebp+nread]

locret_8000BE5:				; CODE XREF: iread_fullblock+2Fj
		leave
		retn
iread_fullblock	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl iwrite(int fd,	const char *buf, size_t	size)
iwrite		proc near		; CODE XREF: write_output+1Ap
					; dd_copy+239p	...

total_written	= dword	ptr -1Ch
old_flags	= dword	ptr -18h
nwritten	= dword	ptr -14h
off		= qword	ptr -10h
fd		= dword	ptr  8
buf		= dword	ptr  0Ch
size		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		mov	[ebp+total_written], 0
		mov	eax, ds:output_flags
		and	eax, 4000h
		test	eax, eax
		jz	loc_8000D1E
		mov	eax, ds:output_blocksize
		cmp	[ebp+size], eax
		jnb	loc_8000D1E
		sub	esp, 8
		push	3
		push	1
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+old_flags], eax
		mov	eax, [ebp+old_flags]
		and	ah, 0BFh
		sub	esp, 4
		push	eax
		push	4
		push	1
		call	rpl_fcntl
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000C7B
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToTurnOf ; "failed to turn off O_DIRECT: %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000C7B:				; CODE XREF: iwrite+59j
		push	1
		push	0
		push	0
		push	1
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+off], eax
		mov	dword ptr [ebp+off+4], edx
		cmp	dword ptr [ebp+off+4], 0
		js	short loc_8000CBC
		sub	esp, 8
		push	4
		push	0
		push	0
		push	dword ptr [ebp+off+4]
		push	dword ptr [ebp+off]
		push	1
		call	posix_fadvise64
		add	esp, 20h
		sub	esp, 0Ch
		push	eax		; i
		call	ignore_value
		add	esp, 10h

loc_8000CBC:				; CODE XREF: iwrite+AEj
		mov	eax, ds:conversions_mask
		or	ah, 80h
		mov	ds:conversions_mask, eax
		jmp	short loc_8000D1E
; ---------------------------------------------------------------------------

loc_8000CCB:				; CODE XREF: iwrite+13Dj
		call	process_signals
		mov	eax, [ebp+size]
		sub	eax, [ebp+total_written]
		mov	ecx, [ebp+buf]
		mov	edx, [ebp+total_written]
		add	edx, ecx
		sub	esp, 4
		push	eax		; n
		push	edx		; buf
		push	[ebp+fd]	; fd
		call	write
		add	esp, 10h
		mov	[ebp+nwritten],	eax
		cmp	[ebp+nwritten],	0
		jns	short loc_8000D05
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 4
		jz	short loc_8000D1E
		jmp	short loc_8000D26
; ---------------------------------------------------------------------------

loc_8000D05:				; CODE XREF: iwrite+10Ej
		cmp	[ebp+nwritten],	0
		jnz	short loc_8000D18
		call	__errno_location
		mov	dword ptr [eax], 1Ch
		jmp	short loc_8000D26
; ---------------------------------------------------------------------------

loc_8000D18:				; CODE XREF: iwrite+122j
		mov	eax, [ebp+nwritten]
		add	[ebp+total_written], eax

loc_8000D1E:				; CODE XREF: iwrite+1Bj iwrite+29j ...
		mov	eax, [ebp+total_written]
		cmp	eax, [ebp+size]
		jb	short loc_8000CCB

loc_8000D26:				; CODE XREF: iwrite+11Cj iwrite+12Fj
		mov	eax, [ebp+total_written]
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
iwrite		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void write_output()
write_output	proc near		; CODE XREF: copy_simple+6Ep
					; copy_with_block+6Ap ...

nwritten	= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	edx, ds:output_blocksize
		mov	eax, ds:obuf
		sub	esp, 4
		push	edx		; size
		push	eax		; buf
		push	1		; fd
		call	iwrite
		add	esp, 10h
		mov	[ebp+nwritten],	eax
		mov	ecx, [ebp+nwritten]
		mov	ebx, 0
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:w_bytes, eax
		mov	dword ptr ds:w_bytes+4,	edx
		mov	eax, ds:output_blocksize
		cmp	[ebp+nwritten],	eax
		jz	short loc_8000DE6
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingToS ; "writing to %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		cmp	[ebp+nwritten],	0
		jz	short loc_8000DDC
		mov	eax, dword ptr ds:w_partial
		mov	edx, dword ptr ds:w_partial+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:w_partial,	eax
		mov	dword ptr ds:w_partial+4, edx

loc_8000DDC:				; CODE XREF: write_output+8Ej
		sub	esp, 0Ch
		push	1		; code
		call	quit
; ---------------------------------------------------------------------------

loc_8000DE6:				; CODE XREF: write_output+4Fj
		mov	eax, dword ptr ds:w_full
		mov	edx, dword ptr ds:w_full+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:w_full, eax
		mov	dword ptr ds:w_full+4, edx
		mov	ds:oc, 0
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
write_output	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	operand_matches(const char *str, const char *pattern, char delim)
operand_matches	proc near		; CODE XREF: parse_symbols+A8p
					; operand_is+Bp

delim		= byte ptr -4
str		= dword	ptr  8
pattern		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_8]
		mov	[ebp+delim], al
		jmp	short loc_8000E45
; ---------------------------------------------------------------------------

loc_8000E22:				; CODE XREF: operand_matches+39j
		mov	eax, [ebp+str]
		lea	edx, [eax+1]
		mov	[ebp+str], edx
		movzx	ecx, byte ptr [eax]
		mov	eax, [ebp+pattern]
		lea	edx, [eax+1]
		mov	[ebp+pattern], edx
		movzx	eax, byte ptr [eax]
		cmp	cl, al
		jz	short loc_8000E45
		mov	eax, 0
		jmp	short locret_8000E73
; ---------------------------------------------------------------------------

loc_8000E45:				; CODE XREF: operand_matches+Cj
					; operand_matches+28j
		mov	eax, [ebp+pattern]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000E22
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000E64
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+delim]
		jnz	short loc_8000E6B

loc_8000E64:				; CODE XREF: operand_matches+43j
		mov	eax, 1
		jmp	short loc_8000E70
; ---------------------------------------------------------------------------

loc_8000E6B:				; CODE XREF: operand_matches+4Ej
		mov	eax, 0

loc_8000E70:				; CODE XREF: operand_matches+55j
		and	eax, 1

locret_8000E73:				; CODE XREF: operand_matches+2Fj
		leave
		retn
operand_matches	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl parse_symbols(const char *str, const symbol_value	*table,	const char *error_msgid)
parse_symbols	proc near		; CODE XREF: scanargs+104p
					; scanargs+146p ...

value		= dword	ptr -18h
entry		= dword	ptr -14h
strcomma	= dword	ptr -10h
slen		= dword	ptr -0Ch
var_4		= dword	ptr -4
str		= dword	ptr  8
table		= dword	ptr  0Ch
error_msgid	= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[ebp+value], 0

loc_8000E83:				; CODE XREF: parse_symbols+E1j
		sub	esp, 8
		push	2Ch		; c
		push	[ebp+str]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+strcomma],	eax
		mov	eax, [ebp+table]
		mov	[ebp+entry], eax
		jmp	short loc_8000F11
; ---------------------------------------------------------------------------

loc_8000E9E:				; CODE XREF: parse_symbols+B5j
					; parse_symbols+C3j
		mov	eax, [ebp+entry]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000F0D
		cmp	[ebp+strcomma],	0
		jz	short loc_8000EBA
		mov	edx, [ebp+strcomma]
		mov	eax, [ebp+str]
		sub	edx, eax
		mov	eax, edx
		jmp	short loc_8000EC8
; ---------------------------------------------------------------------------

loc_8000EBA:				; CODE XREF: parse_symbols+37j
		sub	esp, 0Ch
		push	[ebp+str]	; s
		call	strlen
		add	esp, 10h

loc_8000EC8:				; CODE XREF: parse_symbols+43j
		mov	[ebp+slen], eax
		push	[ebp+slen]
		push	[ebp+str]
		push	6
		push	0
		call	quotearg_n_style_mem
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+error_msgid] ; msgid
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	eax
		push	offset format	; "%s: %s"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000F0D:				; CODE XREF: parse_symbols+31j
		add	[ebp+entry], 10h

loc_8000F11:				; CODE XREF: parse_symbols+27j
		mov	eax, [ebp+entry]
		sub	esp, 4
		push	2Ch		; delim
		push	eax		; pattern
		push	[ebp+str]	; str
		call	operand_matches
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	loc_8000E9E
		mov	eax, [ebp+entry]
		mov	eax, [eax+0Ch]
		test	eax, eax
		jz	loc_8000E9E
		mov	eax, [ebp+entry]
		mov	eax, [eax+0Ch]
		or	[ebp+value], eax
		cmp	[ebp+strcomma],	0
		jz	short loc_8000F5B
		mov	eax, [ebp+strcomma]
		add	eax, 1
		mov	[ebp+str], eax
		jmp	loc_8000E83
; ---------------------------------------------------------------------------

loc_8000F5B:				; CODE XREF: parse_symbols+D6j
		nop
		mov	eax, [ebp+value]
		mov	ebx, [ebp+var_4]
		leave
		retn
parse_symbols	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl parse_integer(const	char *str, _Bool *invalid)
parse_integer	proc near		; CODE XREF: parse_integer+64p
					; scanargs+1F3p

invalid		= dword	ptr -30h
str		= dword	ptr -2Ch
suffix		= dword	ptr -28h
e		= dword	ptr -24h
n		= qword	ptr -20h
multiplier	= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_0]
		mov	[ebp+str], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+invalid], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aBcegkkmptwyz0 ;	"bcEGkKMPTwYZ0"
		lea	eax, [ebp+n]
		push	eax
		push	0Ah
		lea	eax, [ebp+suffix]
		push	eax
		push	[ebp+str]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+e], eax
		cmp	[ebp+e], 2
		jnz	loc_800105A
		mov	eax, [ebp+suffix]
		movzx	eax, byte ptr [eax]
		cmp	al, 78h
		jnz	loc_800105A
		mov	eax, [ebp+suffix]
		add	eax, 1
		sub	esp, 8
		push	[ebp+invalid]	; invalid
		push	eax		; str
		call	parse_integer
		add	esp, 10h
		mov	dword ptr [ebp+multiplier], eax
		mov	dword ptr [ebp+multiplier+4], edx
		mov	eax, dword ptr [ebp+multiplier+4]
		or	eax, dword ptr [ebp+multiplier]
		test	eax, eax
		jz	short loc_8001035
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	ecx, dword ptr [ebp+multiplier]
		mov	ebx, ecx
		imul	ebx, edx
		mov	ecx, dword ptr [ebp+multiplier+4]
		imul	ecx, eax
		add	ecx, ebx
		mul	dword ptr [ebp+multiplier]
		add	ecx, edx
		mov	edx, ecx
		push	dword ptr [ebp+multiplier+4]
		push	dword ptr [ebp+multiplier]
		push	edx
		push	eax
		call	__udivdi3
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jz	short loc_8001035
		mov	eax, [ebp+invalid]
		mov	byte ptr [eax],	1
		mov	eax, 0
		mov	edx, 0
		jmp	short loc_8001078
; ---------------------------------------------------------------------------

loc_8001035:				; CODE XREF: parse_integer+7Aj
					; parse_integer+BDj
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	ecx, dword ptr [ebp+multiplier]
		mov	ebx, ecx
		imul	ebx, edx
		mov	ecx, dword ptr [ebp+multiplier+4]
		imul	ecx, eax
		add	ecx, ebx
		mul	dword ptr [ebp+multiplier]
		add	ecx, edx
		mov	edx, ecx
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		jmp	short loc_8001072
; ---------------------------------------------------------------------------

loc_800105A:				; CODE XREF: parse_integer+43j
					; parse_integer+51j
		cmp	[ebp+e], 0
		jz	short loc_8001072
		mov	eax, [ebp+invalid]
		mov	byte ptr [eax],	1
		mov	eax, 0
		mov	edx, 0
		jmp	short loc_8001078
; ---------------------------------------------------------------------------

loc_8001072:				; CODE XREF: parse_integer+F4j
					; parse_integer+FAj
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]

loc_8001078:				; CODE XREF: parse_integer+CFj
					; parse_integer+10Cj
		mov	esi, [ebp+var_C]
		xor	esi, large gs:14h
		jz	short loc_8001089
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001089:				; CODE XREF: parse_integer+11Ej
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
parse_integer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	operand_is(const char *operand,	const char *name)
operand_is	proc near		; CODE XREF: scanargs+A0p scanargs+C4p ...

operand		= dword	ptr  8
name		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	3Dh		; delim
		push	[ebp+name]	; pattern
		push	[ebp+operand]	; str
		call	operand_matches
		add	esp, 0Ch
		leave
		retn
operand_is	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl scanargs(int argc, char *const *argv)
scanargs	proc near		; CODE XREF: main+141p

argv		= dword	ptr -3Ch
invalid		= byte ptr -29h
i		= dword	ptr -28h
blocksize	= dword	ptr -24h
name		= dword	ptr -20h
val		= dword	ptr -1Ch
n		= qword	ptr -18h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
argc		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 44h
		mov	eax, [ebp+arg_4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+blocksize], 0
		mov	eax, ds:optind
		mov	[ebp+i], eax
		jmp	loc_800157C
; ---------------------------------------------------------------------------

loc_80010D1:				; CODE XREF: scanargs+4DDj
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		mov	[ebp+name], eax
		sub	esp, 8
		push	3Dh		; c
		push	[ebp+name]	; s
		call	strchr
		add	esp, 10h
		mov	[ebp+val], eax
		cmp	[ebp+val], 0
		jnz	short loc_8001136
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aUnrecognizedOp ; "unrecognized operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001136:				; CODE XREF: scanargs+57j
		add	[ebp+val], 1
		sub	esp, 8
		push	offset aIf	; "if"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_800115E
		mov	eax, [ebp+val]
		mov	ds:input_file, eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_800115E:				; CODE XREF: scanargs+AAj
		sub	esp, 8
		push	offset aOf	; "of"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001182
		mov	eax, [ebp+val]
		mov	ds:output_file,	eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_8001182:				; CODE XREF: scanargs+CEj
		sub	esp, 8
		push	offset aConv	; "conv"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_80011C4
		sub	esp, 4
		push	offset error_msgid ; "invalid conversion"
		push	offset conversions ; table
		push	[ebp+val]	; str
		call	parse_symbols
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:conversions_mask
		or	eax, edx
		mov	ds:conversions_mask, eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_80011C4:				; CODE XREF: scanargs+F2j
		sub	esp, 8
		push	offset aIflag	; "iflag"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001206
		sub	esp, 4
		push	offset aInvalidInputFl ; "invalid input	flag"
		push	offset flags	; table
		push	[ebp+val]	; str
		call	parse_symbols
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:input_flags
		or	eax, edx
		mov	ds:input_flags,	eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_8001206:				; CODE XREF: scanargs+134j
		sub	esp, 8
		push	offset aOflag	; "oflag"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001248
		sub	esp, 4
		push	offset aInvalidOutputF ; "invalid output flag"
		push	offset flags	; table
		push	[ebp+val]	; str
		call	parse_symbols
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:output_flags
		or	eax, edx
		mov	ds:output_flags, eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_8001248:				; CODE XREF: scanargs+176j
		sub	esp, 8
		push	offset aStatus	; "status"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_800128A
		sub	esp, 4
		push	offset aInvalidStatusF ; "invalid status flag"
		push	offset statuses	; table
		push	[ebp+val]	; str
		call	parse_symbols
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:status_flags
		or	eax, edx
		mov	ds:status_flags, eax
		jmp	loc_8001578
; ---------------------------------------------------------------------------

loc_800128A:				; CODE XREF: scanargs+1B8j
		mov	[ebp+invalid], 0
		sub	esp, 8
		lea	eax, [ebp+invalid]
		push	eax		; invalid
		push	[ebp+val]	; str
		call	parse_integer
		add	esp, 10h
		mov	dword ptr [ebp+n], eax
		mov	dword ptr [ebp+n+4], edx
		sub	esp, 8
		push	offset aIbs	; "ibs"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001330
		movzx	eax, [ebp+invalid]
		movzx	ecx, al
		mov	eax, dword ptr [ebp+n+4]
		or	eax, dword ptr [ebp+n]
		test	eax, eax
		jz	short loc_800130D
		mov	eax, ds:page_size
		add	eax, 2
		add	eax, eax
		neg	eax
		cmp	eax, 7FFFFFFEh
		ja	short loc_80012F4
		mov	eax, ds:page_size
		add	eax, 2
		add	eax, eax
		neg	eax
		mov	edx, 0
		jmp	short loc_80012FE
; ---------------------------------------------------------------------------

loc_80012F4:				; CODE XREF: scanargs+23Aj
		mov	eax, 7FFFFFFFh
		mov	edx, 0

loc_80012FE:				; CODE XREF: scanargs+24Dj
		cmp	edx, dword ptr [ebp+n+4]
		ja	short loc_8001314
		cmp	edx, dword ptr [ebp+n+4]
		jb	short loc_800130D
		cmp	eax, dword ptr [ebp+n]
		jnb	short loc_8001314

loc_800130D:				; CODE XREF: scanargs+227j
					; scanargs+261j
		mov	eax, 1
		jmp	short loc_8001319
; ---------------------------------------------------------------------------

loc_8001314:				; CODE XREF: scanargs+25Cj
					; scanargs+266j
		mov	eax, 0

loc_8001319:				; CODE XREF: scanargs+26Dj
		or	eax, ecx
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		mov	eax, dword ptr [ebp+n]
		mov	ds:input_blocksize, eax
		jmp	loc_8001542
; ---------------------------------------------------------------------------

loc_8001330:				; CODE XREF: scanargs+216j
		sub	esp, 8
		push	offset aObs	; "obs"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_80013B0
		movzx	eax, [ebp+invalid]
		movzx	ecx, al
		mov	eax, dword ptr [ebp+n+4]
		or	eax, dword ptr [ebp+n]
		test	eax, eax
		jz	short loc_800138D
		mov	eax, ds:page_size
		neg	eax
		cmp	eax, 7FFFFFFEh
		ja	short loc_8001374
		mov	eax, ds:page_size
		neg	eax
		mov	edx, 0
		jmp	short loc_800137E
; ---------------------------------------------------------------------------

loc_8001374:				; CODE XREF: scanargs+2BFj
		mov	eax, 7FFFFFFFh
		mov	edx, 0

loc_800137E:				; CODE XREF: scanargs+2CDj
		cmp	edx, dword ptr [ebp+n+4]
		ja	short loc_8001394
		cmp	edx, dword ptr [ebp+n+4]
		jb	short loc_800138D
		cmp	eax, dword ptr [ebp+n]
		jnb	short loc_8001394

loc_800138D:				; CODE XREF: scanargs+2B1j
					; scanargs+2E1j
		mov	eax, 1
		jmp	short loc_8001399
; ---------------------------------------------------------------------------

loc_8001394:				; CODE XREF: scanargs+2DCj
					; scanargs+2E6j
		mov	eax, 0

loc_8001399:				; CODE XREF: scanargs+2EDj
		or	eax, ecx
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		mov	eax, dword ptr [ebp+n]
		mov	ds:output_blocksize, eax
		jmp	loc_8001542
; ---------------------------------------------------------------------------

loc_80013B0:				; CODE XREF: scanargs+2A0j
		sub	esp, 8
		push	offset aBs	; "bs"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001438
		movzx	eax, [ebp+invalid]
		movzx	ecx, al
		mov	eax, dword ptr [ebp+n+4]
		or	eax, dword ptr [ebp+n]
		test	eax, eax
		jz	short loc_8001417
		mov	eax, ds:page_size
		add	eax, 2
		add	eax, eax
		neg	eax
		cmp	eax, 7FFFFFFEh
		ja	short loc_80013FE
		mov	eax, ds:page_size
		add	eax, 2
		add	eax, eax
		neg	eax
		mov	edx, 0
		jmp	short loc_8001408
; ---------------------------------------------------------------------------

loc_80013FE:				; CODE XREF: scanargs+344j
		mov	eax, 7FFFFFFFh
		mov	edx, 0

loc_8001408:				; CODE XREF: scanargs+357j
		cmp	edx, dword ptr [ebp+n+4]
		ja	short loc_800141E
		cmp	edx, dword ptr [ebp+n+4]
		jb	short loc_8001417
		cmp	eax, dword ptr [ebp+n]
		jnb	short loc_800141E

loc_8001417:				; CODE XREF: scanargs+331j
					; scanargs+36Bj
		mov	eax, 1
		jmp	short loc_8001423
; ---------------------------------------------------------------------------

loc_800141E:				; CODE XREF: scanargs+366j
					; scanargs+370j
		mov	eax, 0

loc_8001423:				; CODE XREF: scanargs+377j
		or	eax, ecx
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		mov	eax, dword ptr [ebp+n]
		mov	[ebp+blocksize], eax
		jmp	loc_8001542
; ---------------------------------------------------------------------------

loc_8001438:				; CODE XREF: scanargs+320j
		sub	esp, 8
		push	offset aCbs	; "cbs"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_8001489
		movzx	eax, [ebp+invalid]
		movzx	edx, al
		mov	eax, dword ptr [ebp+n+4]
		or	eax, dword ptr [ebp+n]
		test	eax, eax
		jz	short loc_8001466
		cmp	dword ptr [ebp+n+4], 0
		jbe	short loc_800146D

loc_8001466:				; CODE XREF: scanargs+3B9j
		mov	eax, 1
		jmp	short loc_8001472
; ---------------------------------------------------------------------------

loc_800146D:				; CODE XREF: scanargs+3BFj
		mov	eax, 0

loc_8001472:				; CODE XREF: scanargs+3C6j
		or	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+invalid], al
		mov	eax, dword ptr [ebp+n]
		mov	ds:conversion_blocksize, eax
		jmp	loc_8001542
; ---------------------------------------------------------------------------

loc_8001489:				; CODE XREF: scanargs+3A8j
		sub	esp, 8
		push	offset aSkip	; "skip"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_80014B6
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	dword ptr ds:skip_records, eax
		mov	dword ptr ds:skip_records+4, edx
		jmp	loc_8001542
; ---------------------------------------------------------------------------

loc_80014B6:				; CODE XREF: scanargs+3F9j
		sub	esp, 8
		push	offset aSeek	; "seek"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_80014E0
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	dword ptr ds:seek_records, eax
		mov	dword ptr ds:seek_records+4, edx
		jmp	short loc_8001542
; ---------------------------------------------------------------------------

loc_80014E0:				; CODE XREF: scanargs+426j
		sub	esp, 8
		push	offset aCount	; "count"
		push	[ebp+name]	; operand
		call	operand_is
		add	esp, 10h
		test	al, al
		jz	short loc_800150A
		mov	eax, dword ptr [ebp+n]
		mov	edx, dword ptr [ebp+n+4]
		mov	dword ptr max_records, eax
		mov	dword ptr max_records+4, edx
		jmp	short loc_8001542
; ---------------------------------------------------------------------------

loc_800150A:				; CODE XREF: scanargs+450j
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aUnrecognizedOp ; "unrecognized operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001542:				; CODE XREF: scanargs+286j
					; scanargs+306j ...
		movzx	eax, [ebp+invalid]
		test	al, al
		jz	short loc_8001578
		sub	esp, 0Ch
		push	[ebp+val]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidNumberS ; "invalid number %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001578:				; CODE XREF: scanargs+B4j scanargs+D8j ...
		add	[ebp+i], 1

loc_800157C:				; CODE XREF: scanargs+27j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+argc]
		jl	loc_80010D1
		cmp	[ebp+blocksize], 0
		jz	short loc_80015A2
		mov	eax, [ebp+blocksize]
		mov	ds:output_blocksize, eax
		mov	eax, ds:output_blocksize
		mov	ds:input_blocksize, eax
		jmp	short loc_80015AF
; ---------------------------------------------------------------------------

loc_80015A2:				; CODE XREF: scanargs+4E7j
		mov	eax, ds:conversions_mask
		or	ah, 8
		mov	ds:conversions_mask, eax

loc_80015AF:				; CODE XREF: scanargs+4FBj
		mov	eax, ds:input_blocksize
		test	eax, eax
		jnz	short loc_80015C2
		mov	ds:input_blocksize, 200h

loc_80015C2:				; CODE XREF: scanargs+511j
		mov	eax, ds:output_blocksize
		test	eax, eax
		jnz	short loc_80015D5
		mov	ds:output_blocksize, 200h

loc_80015D5:				; CODE XREF: scanargs+524j
		mov	eax, ds:conversion_blocksize
		test	eax, eax
		jnz	short loc_80015EB
		mov	eax, ds:conversions_mask
		and	eax, 0FFFFFFE7h
		mov	ds:conversions_mask, eax

loc_80015EB:				; CODE XREF: scanargs+537j
		mov	eax, ds:input_flags
		and	eax, 101000h
		test	eax, eax
		jz	short loc_8001608
		mov	eax, ds:input_flags
		or	eax, 101000h
		mov	ds:input_flags,	eax

loc_8001608:				; CODE XREF: scanargs+552j
		mov	eax, ds:output_flags
		and	eax, 1
		test	eax, eax
		jz	short loc_8001648
		sub	esp, 0Ch
		push	offset aInvalidOutputF ; "invalid output flag"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aFullblock ; "'fullblock'"
		push	eax
		push	offset format	; "%s: %s"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001648:				; CODE XREF: scanargs+56Dj
		mov	eax, ds:input_flags
		and	eax, 1
		test	eax, eax
		jz	short loc_800165B
		mov	eax, offset iread_fullblock
		jmp	short loc_8001660
; ---------------------------------------------------------------------------

loc_800165B:				; CODE XREF: scanargs+5ADj
		mov	eax, offset iread

loc_8001660:				; CODE XREF: scanargs+5B4j
		mov	ds:iread_fnc, eax
		mov	eax, ds:input_flags
		and	eax, 0FFFFFFFEh
		mov	ds:input_flags,	eax
		mov	eax, ds:conversions_mask
		and	eax, 7
		sub	esp, 0Ch
		push	eax		; i
		call	multiple_bits_set
		add	esp, 10h
		test	al, al
		jz	short loc_80016AA
		sub	esp, 0Ch
		push	offset aCannotCombineA ; "cannot combine any two of {ascii,ebcdic"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80016AA:				; CODE XREF: scanargs+5E3j
		mov	eax, ds:conversions_mask
		and	eax, 18h
		sub	esp, 0Ch
		push	eax		; i
		call	multiple_bits_set
		add	esp, 10h
		test	al, al
		jz	short loc_80016E2
		sub	esp, 0Ch
		push	offset aCannotCombineB ; "cannot combine block and unblock"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80016E2:				; CODE XREF: scanargs+61Bj
		mov	eax, ds:conversions_mask
		and	eax, 60h
		sub	esp, 0Ch
		push	eax		; i
		call	multiple_bits_set
		add	esp, 10h
		test	al, al
		jz	short loc_800171A
		sub	esp, 0Ch
		push	offset aCannotCombineL ; "cannot combine lcase and ucase"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800171A:				; CODE XREF: scanargs+653j
		mov	eax, ds:conversions_mask
		and	eax, 3000h
		sub	esp, 0Ch
		push	eax		; i
		call	multiple_bits_set
		add	esp, 10h
		test	al, al
		jz	short loc_8001754
		sub	esp, 0Ch
		push	offset aCannotCombineE ; "cannot combine excl and nocreat"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001754:				; CODE XREF: scanargs+68Dj
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8001766
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001766:				; CODE XREF: scanargs+6BAj
		mov	ebx, [ebp+var_4]
		leave
		retn
scanargs	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void apply_translations()
apply_translations proc	near		; CODE XREF: main+149p

i		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, ds:conversions_mask
		and	eax, 1
		test	eax, eax
		jz	short loc_800178A
		push	offset ebcdic_to_ascii ; new_trans
		call	translate_charset
		add	esp, 4

loc_800178A:				; CODE XREF: apply_translations+10j
		mov	eax, ds:conversions_mask
		and	eax, 40h
		test	eax, eax
		jz	short loc_80017DB
		mov	[ebp+i], 0
		jmp	short loc_80017C9
; ---------------------------------------------------------------------------

loc_800179F:				; CODE XREF: apply_translations+65j
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	toupper
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		mov	[eax], dl
		add	[ebp+i], 1

loc_80017C9:				; CODE XREF: apply_translations+32j
		cmp	[ebp+i], 0FFh
		jle	short loc_800179F
		mov	ds:translation_needed, 1
		jmp	short loc_800182A
; ---------------------------------------------------------------------------

loc_80017DB:				; CODE XREF: apply_translations+29j
		mov	eax, ds:conversions_mask
		and	eax, 20h
		test	eax, eax
		jz	short loc_800182A
		mov	[ebp+i], 0
		jmp	short loc_800181A
; ---------------------------------------------------------------------------

loc_80017F0:				; CODE XREF: apply_translations+B6j
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	tolower
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		mov	[eax], dl
		add	[ebp+i], 1

loc_800181A:				; CODE XREF: apply_translations+83j
		cmp	[ebp+i], 0FFh
		jle	short loc_80017F0
		mov	ds:translation_needed, 1

loc_800182A:				; CODE XREF: apply_translations+6Ej
					; apply_translations+7Aj
		mov	eax, ds:conversions_mask
		and	eax, 2
		test	eax, eax
		jz	short loc_800185C
		sub	esp, 0Ch
		push	offset ascii_to_ebcdic ; new_trans
		call	translate_charset
		add	esp, 10h
		mov	eax, 25h
		mov	newline_character, al
		mov	eax, 40h
		mov	byte ptr space_character, al ; " "
		jmp	short loc_800188C
; ---------------------------------------------------------------------------

loc_800185C:				; CODE XREF: apply_translations+C9j
		mov	eax, ds:conversions_mask
		and	eax, 4
		test	eax, eax
		jz	short loc_800188C
		sub	esp, 0Ch
		push	offset ascii_to_ibm ; new_trans
		call	translate_charset
		add	esp, 10h
		mov	eax, 25h
		mov	newline_character, al
		mov	eax, 40h
		mov	byte ptr space_character, al ; " "

loc_800188C:				; CODE XREF: apply_translations+EFj
					; apply_translations+FBj
		nop
		leave
		retn
apply_translations endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl translate_buffer(char *buf, size_t nread)
translate_buffer proc near		; CODE XREF: dd_copy+5E1p

cp		= dword	ptr -8
i		= dword	ptr -4
buf		= dword	ptr  8
nread		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+nread]
		mov	[ebp+i], eax
		mov	eax, [ebp+buf]
		mov	[ebp+cp], eax
		jmp	short loc_80018CE
; ---------------------------------------------------------------------------

loc_80018A3:				; CODE XREF: translate_buffer+43j
		mov	eax, [ebp+cp]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		movzx	eax, ds:trans_table[eax]
		mov	edx, eax
		mov	eax, [ebp+cp]
		mov	[eax], dl
		sub	[ebp+i], 1
		add	[ebp+cp], 1

loc_80018CE:				; CODE XREF: translate_buffer+12j
		cmp	[ebp+i], 0
		jnz	short loc_80018A3
		nop
		leave
		retn
translate_buffer endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	swab_buffer(char *buf, size_t *nread)
swab_buffer	proc near		; CODE XREF: dd_copy+601p

bufstart	= dword	ptr -0Ch
cp		= dword	ptr -8
i		= dword	ptr -4
buf		= dword	ptr  8
nread		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	eax, [ebp+buf]
		mov	[ebp+bufstart],	eax
		movzx	eax, ds:char_is_saved
		test	al, al
		jz	short loc_8001912
		sub	[ebp+bufstart],	1
		movzx	edx, ds:saved_char
		mov	eax, [ebp+bufstart]
		mov	[eax], dl
		mov	eax, [ebp+nread]
		mov	eax, [eax]
		lea	edx, [eax+1]
		mov	eax, [ebp+nread]
		mov	[eax], edx
		mov	ds:char_is_saved, 0

loc_8001912:				; CODE XREF: swab_buffer+15j
		mov	eax, [ebp+nread]
		mov	eax, [eax]
		and	eax, 1
		test	eax, eax
		jz	short loc_8001944
		mov	eax, [ebp+nread]
		mov	eax, [eax]
		lea	edx, [eax-1]
		mov	eax, [ebp+nread]
		mov	[eax], edx
		mov	eax, [ebp+nread]
		mov	edx, [eax]
		mov	eax, [ebp+bufstart]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	ds:saved_char, al
		mov	ds:char_is_saved, 1

loc_8001944:				; CODE XREF: swab_buffer+45j
		mov	eax, [ebp+nread]
		mov	edx, [eax]
		mov	eax, [ebp+bufstart]
		add	eax, edx
		mov	[ebp+cp], eax
		mov	eax, [ebp+nread]
		mov	eax, [eax]
		shr	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_8001971
; ---------------------------------------------------------------------------

loc_800195D:				; CODE XREF: swab_buffer+9Ej
		mov	eax, [ebp+cp]
		movzx	edx, byte ptr [eax-2]
		mov	eax, [ebp+cp]
		mov	[eax], dl
		sub	[ebp+i], 1
		sub	[ebp+cp], 2

loc_8001971:				; CODE XREF: swab_buffer+84j
		cmp	[ebp+i], 0
		jnz	short loc_800195D
		add	[ebp+bufstart],	1
		mov	eax, [ebp+bufstart]
		leave
		retn
swab_buffer	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl advance_input_offset(uintmax_t offset)
advance_input_offset proc near		; CODE XREF: skip+214p	skip+3DBp ...

offset		= qword	ptr -10h
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 0Ch
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+offset],	eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+offset+4], eax
		mov	ecx, dword ptr ds:input_offset
		mov	ebx, dword ptr ds:input_offset+4
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:input_offset, eax
		mov	dword ptr ds:input_offset+4, edx
		mov	eax, dword ptr ds:input_offset
		mov	edx, dword ptr ds:input_offset+4
		cmp	edx, dword ptr [ebp+offset+4]
		ja	short loc_80019D5
		cmp	edx, dword ptr [ebp+offset+4]
		jb	short loc_80019CE
		cmp	eax, dword ptr [ebp+offset]
		jnb	short loc_80019D5

loc_80019CE:				; CODE XREF: advance_input_offset+47j
		mov	ds:input_offset_overflow, 1

loc_80019D5:				; CODE XREF: advance_input_offset+42j
					; advance_input_offset+4Cj
		nop
		add	esp, 0Ch
		pop	ebx
		pop	ebp
		retn
advance_input_offset endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; off_t	__cdecl	skip_via_lseek(const char *filename, int fdesc,	off_t offset, int whence)
skip_via_lseek	proc near		; CODE XREF: skip+DBp skip+262p ...

offset		= qword	ptr -68h
filename	= dword	ptr -5Ch
got_original_tape_position= byte ptr -51h
new_position	= qword	ptr -50h
s1		= mtget	ptr -44h
s2		= mtget	ptr -28h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
fdesc		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
whence		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 64h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+offset],	eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+offset+4], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 4
		lea	eax, [ebp+s1]
		push	eax
		push	801C6D02h	; request
		push	[ebp+fdesc]	; fd
		call	ioctl
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+got_original_tape_position], al
		push	[ebp+whence]
		push	dword ptr [ebp+offset+4]
		push	dword ptr [ebp+offset]
		push	[ebp+fdesc]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+new_position], eax
		mov	dword ptr [ebp+new_position+4],	edx
		cmp	dword ptr [ebp+new_position+4],	0
		js	short loc_8001ABE
		cmp	[ebp+got_original_tape_position], 0
		jz	short loc_8001ABE
		sub	esp, 4
		lea	eax, [ebp+s2]
		push	eax
		push	801C6D02h	; request
		push	[ebp+fdesc]	; fd
		call	ioctl
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001ABE
		mov	edx, [ebp+s1.mt_resid]
		mov	eax, [ebp+s2.mt_resid]
		cmp	edx, eax
		jnz	short loc_8001ABE
		mov	edx, [ebp+s1.mt_fileno]
		mov	eax, [ebp+s2.mt_fileno]
		cmp	edx, eax
		jnz	short loc_8001ABE
		mov	edx, [ebp+s1.mt_blkno]
		mov	eax, [ebp+s2.mt_blkno]
		cmp	edx, eax
		jnz	short loc_8001ABE
		mov	ebx, [ebp+s2.mt_type]
		sub	esp, 0Ch
		push	offset aWarningWorking ; "warning: working around lseek	kernel bu"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	ebx
		push	[ebp+filename]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		call	__errno_location
		mov	dword ptr [eax], 0
		mov	dword ptr [ebp+new_position], 0FFFFFFFFh
		mov	dword ptr [ebp+new_position+4],	0FFFFFFFFh

loc_8001ABE:				; CODE XREF: skip_via_lseek+61j
					; skip_via_lseek+67j ...
		mov	eax, dword ptr [ebp+new_position]
		mov	edx, dword ptr [ebp+new_position+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_8001AD5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001AD5:				; CODE XREF: skip_via_lseek+F2j
		mov	ebx, [ebp+var_4]
		leave
		retn
skip_via_lseek	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl skip(int fdesc, const char *file, uintmax_t	records, size_t	blocksize, char	*buf)
skip		proc near		; CODE XREF: dd_copy+143p dd_copy+1F1p

records		= qword	ptr -0A8h
buf		= dword	ptr -0A0h
file		= dword	ptr -9Ch
lseek_errno	= dword	ptr -90h
nread		= dword	ptr -8Ch
offset		= qword	ptr -88h
st		= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
fdesc		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
blocksize	= dword	ptr  18h
arg_14		= dword	ptr  1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 9Ch
		mov	eax, [ebp+arg_4]
		mov	[ebp+file], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+records], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+records+4], eax
		mov	eax, [ebp+arg_14]
		mov	[ebp+buf], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+blocksize]
		mov	edx, 0
		mov	ecx, dword ptr [ebp+records]
		mov	ebx, ecx
		imul	ebx, edx
		mov	ecx, dword ptr [ebp+records+4]
		imul	ecx, eax
		add	ecx, ebx
		mul	dword ptr [ebp+records]
		add	ecx, edx
		mov	edx, ecx
		mov	dword ptr [ebp+offset],	eax
		mov	dword ptr [ebp+offset+4], edx
		mov	dword ptr [ebp+offset],	eax
		mov	dword ptr [ebp+offset+4], edx
		call	__errno_location
		mov	dword ptr [eax], 0
		mov	eax, [ebp+blocksize]
		mov	edx, 0
		push	edx
		push	eax
		push	7FFFFFFFh
		push	0FFFFFFFFh
		call	__divdi3
		add	esp, 10h
		cmp	edx, dword ptr [ebp+records+4]
		jb	loc_8001D1D
		cmp	edx, dword ptr [ebp+records+4]
		ja	short loc_8001B99
		cmp	eax, dword ptr [ebp+records]
		jb	loc_8001D1D

loc_8001B99:				; CODE XREF: skip+B1j
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		sub	esp, 0Ch
		push	1		; whence
		push	edx
		push	eax		; offset
		push	[ebp+fdesc]	; fdesc
		push	[ebp+file]	; filename
		call	skip_via_lseek
		add	esp, 20h
		test	edx, edx
		js	loc_8001D1D
		cmp	[ebp+fdesc], 0
		jnz	loc_8001CF8
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	0
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001C1D
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001C1D:				; CODE XREF: skip+108j
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8001CCB
		mov	eax, dword ptr [ebp+st.st_size]
		mov	edx, dword ptr [ebp+st.st_size+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	esi, dword ptr ds:input_offset
		mov	edi, dword ptr ds:input_offset+4
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		add	eax, esi
		adc	edx, edi
		cmp	ebx, edx
		ja	short loc_8001CCB
		cmp	ebx, edx
		jb	short loc_8001C62
		cmp	ecx, eax
		jnb	short loc_8001CCB

loc_8001C62:				; CODE XREF: skip+182j
		mov	eax, dword ptr [ebp+st.st_size]
		mov	edx, dword ptr [ebp+st.st_size+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		sub	eax, ecx
		sbb	edx, ebx
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, [ebp+blocksize]
		mov	edx, 0
		push	edx
		push	eax
		push	ebx
		push	ecx
		call	__udivdi3
		add	esp, 10h
		mov	dword ptr [ebp+records], eax
		mov	dword ptr [ebp+records+4], edx
		mov	eax, dword ptr [ebp+st.st_size]
		mov	edx, dword ptr [ebp+st.st_size+4]
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr ds:input_offset
		mov	edx, dword ptr ds:input_offset+4
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		mov	dword ptr [ebp+offset],	eax
		mov	dword ptr [ebp+offset+4], edx
		jmp	short loc_8001CDF
; ---------------------------------------------------------------------------

loc_8001CCB:				; CODE XREF: skip+150j	skip+17Ej ...
		mov	dword ptr [ebp+records], 0
		mov	dword ptr [ebp+records+4], 0

loc_8001CDF:				; CODE XREF: skip+1EFj
		sub	esp, 8
		push	dword ptr [ebp+offset+4]
		push	dword ptr [ebp+offset] ; offset
		call	advance_input_offset
		add	esp, 10h
		jmp	short loc_8001D0C
; ---------------------------------------------------------------------------

loc_8001CF8:				; CODE XREF: skip+EFj
		mov	dword ptr [ebp+records], 0
		mov	dword ptr [ebp+records+4], 0

loc_8001D0C:				; CODE XREF: skip+21Cj
		mov	eax, dword ptr [ebp+records]
		mov	edx, dword ptr [ebp+records+4]
		jmp	loc_8001EEE
; ---------------------------------------------------------------------------

loc_8001D1D:				; CODE XREF: skip+A5j skip+B9j ...
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+lseek_errno], eax
		sub	esp, 0Ch
		push	2		; whence
		push	0
		push	0		; offset
		push	[ebp+fdesc]	; fdesc
		push	[ebp+file]	; filename
		call	skip_via_lseek
		add	esp, 20h
		test	edx, edx
		js	loc_8001DDB
		cmp	[ebp+lseek_errno], 0
		jnz	short loc_8001D5F
		mov	[ebp+lseek_errno], 4Bh

loc_8001D5F:				; CODE XREF: skip+279j
		cmp	[ebp+fdesc], 0
		jnz	short loc_8001D9C
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCannotSkip ; "%s: cannot skip"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+lseek_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001DD1
; ---------------------------------------------------------------------------

loc_8001D9C:				; CODE XREF: skip+289j
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCannotSeek ; "%s: cannot seek"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+lseek_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001DD1:				; CODE XREF: skip+2C0j
		sub	esp, 0Ch
		push	1		; code
		call	quit
; ---------------------------------------------------------------------------

loc_8001DDB:				; CODE XREF: skip+26Cj	skip+3FFj
		mov	eax, ds:iread_fnc
		sub	esp, 4
		push	[ebp+blocksize]	; size_t
		push	[ebp+buf]	; char *
		push	[ebp+fdesc]	; int
		call	eax ; iread_fnc
		add	esp, 10h
		mov	[ebp+nread], eax
		cmp	[ebp+nread], 0
		jns	loc_8001E9A
		cmp	[ebp+fdesc], 0
		jnz	short loc_8001E5B
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aReadingS ; "reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, ds:conversions_mask
		and	eax, 100h
		test	eax, eax
		jz	short loc_8001E90
		call	print_stats
		jmp	short loc_8001EBD
; ---------------------------------------------------------------------------

loc_8001E5B:				; CODE XREF: skip+331j
		sub	esp, 0Ch
		push	[ebp+file]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCannotSeek ; "%s: cannot seek"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	[ebp+lseek_errno] ; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001E90:				; CODE XREF: skip+378j
		sub	esp, 0Ch
		push	1		; code
		call	quit
; ---------------------------------------------------------------------------

loc_8001E9A:				; CODE XREF: skip+327j
		cmp	[ebp+nread], 0
		jz	short loc_8001EE1
		cmp	[ebp+fdesc], 0
		jnz	short loc_8001EBD
		mov	eax, [ebp+nread]
		cdq
		sub	esp, 8
		push	edx
		push	eax		; offset
		call	advance_input_offset
		add	esp, 10h

loc_8001EBD:				; CODE XREF: skip+37Fj	skip+3CDj
		add	dword ptr [ebp+records], 0FFFFFFFFh
		adc	dword ptr [ebp+records+4], 0FFFFFFFFh
		mov	eax, dword ptr [ebp+records+4]
		or	eax, dword ptr [ebp+records]
		test	eax, eax
		jnz	loc_8001DDB
		jmp	short loc_8001EE2
; ---------------------------------------------------------------------------

loc_8001EE1:				; CODE XREF: skip+3C7j
		nop

loc_8001EE2:				; CODE XREF: skip+405j
		mov	eax, dword ptr [ebp+records]
		mov	edx, dword ptr [ebp+records+4]

loc_8001EEE:				; CODE XREF: skip+23Ej
		mov	edi, [ebp+var_1C]
		xor	edi, large gs:14h
		jz	short loc_8001EFF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001EFF:				; CODE XREF: skip+41Ej
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
skip		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	advance_input_after_read_error(size_t nbytes)
advance_input_after_read_error proc near ; CODE	XREF: dd_copy+3C6p

offset		= qword	ptr -18h
diff		= qword	ptr -10h
nbytes		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		movzx	eax, ds:input_seekable
		xor	eax, 1
		test	al, al
		jz	short loc_8001F44
		mov	eax, ds:input_seek_errno
		cmp	eax, 1Dh
		jnz	short loc_8001F31
		mov	eax, 1
		jmp	loc_80020FB
; ---------------------------------------------------------------------------

loc_8001F31:				; CODE XREF: advance_input_after_read_error+1Ej
		call	__errno_location
		mov	edx, eax
		mov	eax, ds:input_seek_errno
		mov	[edx], eax
		jmp	loc_80020BD
; ---------------------------------------------------------------------------

loc_8001F44:				; CODE XREF: advance_input_after_read_error+14j
		mov	eax, [ebp+nbytes]
		mov	edx, 0
		sub	esp, 8
		push	edx
		push	eax		; offset
		call	advance_input_offset
		add	esp, 10h
		movzx	eax, ds:input_offset_overflow
		movzx	ecx, al
		mov	eax, dword ptr ds:input_offset
		mov	edx, dword ptr ds:input_offset+4
		mov	eax, edx
		shr	eax, 1Fh
		movzx	eax, al
		or	eax, ecx
		test	eax, eax
		setnz	al
		mov	ds:input_offset_overflow, al
		movzx	eax, ds:input_offset_overflow
		test	al, al
		jz	short loc_8001FC8
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aOffsetOverflow ; "offset overflow while	reading	file %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80020FB
; ---------------------------------------------------------------------------

loc_8001FC8:				; CODE XREF: advance_input_after_read_error+84j
		push	1
		push	0
		push	0
		push	0
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+offset],	eax
		mov	dword ptr [ebp+offset+4], edx
		cmp	dword ptr [ebp+offset+4], 0
		js	loc_80020BD
		mov	ecx, dword ptr [ebp+offset]
		mov	ebx, dword ptr [ebp+offset+4]
		mov	eax, dword ptr ds:input_offset
		mov	edx, dword ptr ds:input_offset+4
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_800200F
		mov	eax, 1
		jmp	loc_80020FB
; ---------------------------------------------------------------------------

loc_800200F:				; CODE XREF: advance_input_after_read_error+FCj
		mov	ecx, dword ptr ds:input_offset
		mov	ebx, dword ptr ds:input_offset+4
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		mov	dword ptr [ebp+diff], eax
		mov	dword ptr [ebp+diff+4],	edx
		cmp	dword ptr [ebp+diff+4],	0
		js	short loc_800204C
		mov	eax, [ebp+nbytes]
		mov	edx, 0
		cmp	edx, dword ptr [ebp+diff+4]
		jg	short loc_800206C
		cmp	edx, dword ptr [ebp+diff+4]
		jl	short loc_800204C
		cmp	eax, dword ptr [ebp+diff]
		jnb	short loc_800206C

loc_800204C:				; CODE XREF: advance_input_after_read_error+12Cj
					; advance_input_after_read_error+13Ej
		sub	esp, 0Ch
		push	offset aWarningInvalid ; "warning: invalid file	offset after fail"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800206C:				; CODE XREF: advance_input_after_read_error+139j
					; advance_input_after_read_error+143j
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	1		; whence
		push	dword ptr [ebp+diff+4]
		push	dword ptr [ebp+diff] ; offset
		push	0		; fdesc
		push	eax		; filename
		call	skip_via_lseek
		add	esp, 20h
		test	edx, edx
		js	short loc_8002092
		mov	eax, 1
		jmp	short loc_80020FB
; ---------------------------------------------------------------------------

loc_8002092:				; CODE XREF: advance_input_after_read_error+182j
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80020BD
		sub	esp, 0Ch
		push	offset aCannotWorkArou ; "cannot work around kernel bug	after all"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80020BD:				; CODE XREF: advance_input_after_read_error+38j
					; advance_input_after_read_error+DBj ...
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSCannotSeek ; "%s: cannot seek"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0

loc_80020FB:				; CODE XREF: advance_input_after_read_error+25j
					; advance_input_after_read_error+BCj ...
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
advance_input_after_read_error endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl copy_simple(const char *buf, size_t nread)
copy_simple	proc near		; CODE XREF: dd_copy+664p

start		= dword	ptr -10h
nfree		= dword	ptr -0Ch
buf		= dword	ptr  8
nread		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+buf]
		mov	[ebp+start], eax

loc_800210E:				; CODE XREF: copy_simple+77j
		mov	edx, ds:output_blocksize
		mov	eax, ds:oc
		sub	edx, eax
		mov	eax, [ebp+nread]
		cmp	edx, eax
		cmovbe	eax, edx
		mov	[ebp+nfree], eax
		mov	edx, ds:obuf
		mov	eax, ds:oc
		add	eax, edx
		sub	esp, 4
		push	[ebp+nfree]	; n
		push	[ebp+start]	; src
		push	eax		; dest
		call	memcpy
		add	esp, 10h
		mov	eax, [ebp+nfree]
		sub	[ebp+nread], eax
		mov	eax, [ebp+nfree]
		add	[ebp+start], eax
		mov	edx, ds:oc
		mov	eax, [ebp+nfree]
		add	eax, edx
		mov	ds:oc, eax
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002175
		call	write_output

loc_8002175:				; CODE XREF: copy_simple+6Cj
		cmp	[ebp+nread], 0
		jnz	short loc_800210E
		nop
		leave
		retn
copy_simple	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl copy_with_block(const char *buf,	size_t nread)
copy_with_block	proc near		; CODE XREF: dd_copy+62Ap dd_copy+69Cp

i		= dword	ptr -10h
j		= dword	ptr -0Ch
buf		= dword	ptr  8
nread		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+nread]
		mov	[ebp+i], eax
		jmp	loc_800228B
; ---------------------------------------------------------------------------

loc_800218F:				; CODE XREF: copy_with_block+111j
		mov	eax, [ebp+buf]
		movzx	edx, byte ptr [eax]
		movzx	eax, newline_character
		cmp	dl, al
		jnz	short loc_8002207
		mov	edx, ds:col
		mov	eax, ds:conversion_blocksize
		cmp	edx, eax
		jnb	short loc_80021FB
		mov	eax, ds:col
		mov	[ebp+j], eax
		jmp	short loc_80021F1
; ---------------------------------------------------------------------------

loc_80021B9:				; CODE XREF: copy_with_block+7Bj
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, byte ptr space_character ;	" "
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_80021ED
		call	write_output

loc_80021ED:				; CODE XREF: copy_with_block+68j
		add	[ebp+j], 1

loc_80021F1:				; CODE XREF: copy_with_block+39j
		mov	eax, ds:conversion_blocksize
		cmp	[ebp+j], eax
		jb	short loc_80021B9

loc_80021FB:				; CODE XREF: copy_with_block+2Fj
		mov	ds:col,	0
		jmp	short loc_8002283
; ---------------------------------------------------------------------------

loc_8002207:				; CODE XREF: copy_with_block+20j
		mov	edx, ds:col
		mov	eax, ds:conversion_blocksize
		cmp	edx, eax
		jnz	short loc_8002234
		mov	eax, dword ptr ds:r_truncate
		mov	edx, dword ptr ds:r_truncate+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:r_truncate, eax
		mov	dword ptr ds:r_truncate+4, edx
		jmp	short loc_8002276
; ---------------------------------------------------------------------------

loc_8002234:				; CODE XREF: copy_with_block+96j
		mov	edx, ds:col
		mov	eax, ds:conversion_blocksize
		cmp	edx, eax
		jnb	short loc_8002276
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		mov	eax, [ebp+buf]
		movzx	eax, byte ptr [eax]
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002276
		call	write_output

loc_8002276:				; CODE XREF: copy_with_block+B4j
					; copy_with_block+C3j ...
		mov	eax, ds:col
		add	eax, 1
		mov	ds:col,	eax

loc_8002283:				; CODE XREF: copy_with_block+87j
		sub	[ebp+i], 1
		add	[ebp+buf], 1

loc_800228B:				; CODE XREF: copy_with_block+Cj
		cmp	[ebp+i], 0
		jnz	loc_800218F
		nop
		leave
		retn
copy_with_block	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl copy_with_unblock(const char *buf, size_t nread)
copy_with_unblock proc near		; CODE XREF: dd_copy+64Dp dd_copy+6BCp

c		= byte ptr -0Dh
i		= dword	ptr -0Ch
buf		= dword	ptr  8
nread		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	loc_80023BF
; ---------------------------------------------------------------------------

loc_80022AA:				; CODE XREF: copy_with_unblock+12Dj
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		mov	eax, ds:col
		lea	edx, [eax+1]
		mov	ds:col,	edx
		mov	edx, ds:conversion_blocksize
		cmp	eax, edx
		jb	short loc_8002325
		mov	ds:pending_spaces_5646,	0
		mov	eax, ds:pending_spaces_5646
		mov	ds:col,	eax
		sub	[ebp+i], 1
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, newline_character
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	loc_80023BB
		call	write_output
		jmp	loc_80023BB
; ---------------------------------------------------------------------------

loc_8002325:				; CODE XREF: copy_with_unblock+36j
		movzx	eax, byte ptr space_character ;	" "
		cmp	[ebp+c], al
		jnz	short loc_8002381
		mov	eax, ds:pending_spaces_5646
		add	eax, 1
		mov	ds:pending_spaces_5646,	eax
		jmp	short loc_80023BB
; ---------------------------------------------------------------------------

loc_8002340:				; CODE XREF: copy_with_unblock+F0j
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, byte ptr space_character ;	" "
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002374
		call	write_output

loc_8002374:				; CODE XREF: copy_with_unblock+D5j
		mov	eax, ds:pending_spaces_5646
		sub	eax, 1
		mov	ds:pending_spaces_5646,	eax

loc_8002381:				; CODE XREF: copy_with_unblock+97j
		mov	eax, ds:pending_spaces_5646
		test	eax, eax
		jnz	short loc_8002340
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, [ebp+c]
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_80023BB
		call	write_output

loc_80023BB:				; CODE XREF: copy_with_unblock+7Dj
					; copy_with_unblock+88j ...
		add	[ebp+i], 1

loc_80023BF:				; CODE XREF: copy_with_unblock+Dj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nread]
		jb	loc_80022AA
		nop
		leave
		retn
copy_with_unblock endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_fd_flags(int	fd, int	add_flags, const char *name)
set_fd_flags	proc near		; CODE XREF: main+17Ep	main+26Bp

name		= dword	ptr -7Ch
ok		= byte ptr -75h
new_flags	= dword	ptr -74h
old_flags	= dword	ptr -70h
st		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
fd		= dword	ptr  8
add_flags	= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		add	esp, 0FFFFFF80h
		mov	eax, [ebp+arg_8]
		mov	[ebp+name], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		and	[ebp+add_flags], 0FFFDFEFFh
		cmp	[ebp+add_flags], 0
		jz	loc_80024F7
		sub	esp, 8
		push	3
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		mov	[ebp+old_flags], eax
		mov	eax, [ebp+old_flags]
		or	eax, [ebp+add_flags]
		mov	[ebp+new_flags], eax
		mov	[ebp+ok], 1
		cmp	[ebp+old_flags], 0
		jns	short loc_8002427
		mov	[ebp+ok], 0
		jmp	loc_80024B6
; ---------------------------------------------------------------------------

loc_8002427:				; CODE XREF: set_fd_flags+4Ej
		mov	eax, [ebp+old_flags]
		cmp	eax, [ebp+new_flags]
		jz	loc_80024B6
		mov	eax, [ebp+new_flags]
		and	eax, 10000h
		test	eax, eax
		jz	short loc_800248C
		sub	esp, 8
		lea	eax, [ebp+st]
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_800245B
		mov	[ebp+ok], 0
		jmp	short loc_8002485
; ---------------------------------------------------------------------------

loc_800245B:				; CODE XREF: set_fd_flags+85j
		mov	eax, [ebp+new_flags]
		and	eax, 10000h
		test	eax, eax
		jz	short loc_8002485
		mov	eax, [ebp+st.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jz	short loc_8002485
		call	__errno_location
		mov	dword ptr [eax], 14h
		mov	[ebp+ok], 0

loc_8002485:				; CODE XREF: set_fd_flags+8Bj
					; set_fd_flags+97j ...
		and	[ebp+new_flags], 0FFFEFFFFh

loc_800248C:				; CODE XREF: set_fd_flags+6Fj
		cmp	[ebp+ok], 0
		jz	short loc_80024B6
		mov	eax, [ebp+old_flags]
		cmp	eax, [ebp+new_flags]
		jz	short loc_80024B6
		sub	esp, 4
		push	[ebp+new_flags]
		push	4
		push	[ebp+fd]
		call	rpl_fcntl
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80024B6
		mov	[ebp+ok], 0

loc_80024B6:				; CODE XREF: set_fd_flags+54j
					; set_fd_flags+5Fj ...
		movzx	eax, [ebp+ok]
		xor	eax, 1
		test	al, al
		jz	short loc_80024F7
		sub	esp, 0Ch
		push	[ebp+name]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSettingFlagsFo ; "setting flags	for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80024F7:				; CODE XREF: set_fd_flags+24j
					; set_fd_flags+F1j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_8002509
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002509:				; CODE XREF: set_fd_flags+134j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
set_fd_flags	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int dd_copy()
dd_copy		proc near		; CODE XREF: main+558p

n_bytes_read	= dword	ptr -5Ch
bufstart	= dword	ptr -58h
nread		= dword	ptr -54h
partread	= dword	ptr -50h
exit_status	= dword	ptr -4Ch
i		= dword	ptr -48h
ibuf		= dword	ptr -44h
nwritten	= dword	ptr -40h
nwritten_0	= dword	ptr -3Ch
write_records	= qword	ptr -38h
us_bytes	= qword	ptr -30h
us_blocks	= qword	ptr -28h
var_1C		= dword	ptr -1Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 5Ch
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+partread],	0
		mov	[ebp+exit_status], 0
		mov	eax, ds:page_size
		add	eax, 2
		lea	edx, [eax+eax]
		mov	eax, ds:input_blocksize
		add	eax, edx
		sub	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:real_buf_5667, eax
		mov	eax, ds:real_buf_5667
		mov	[ebp+ibuf], eax
		add	[ebp+ibuf], 2
		mov	eax, ds:page_size
		sub	esp, 8
		push	eax		; alignment
		push	[ebp+ibuf]	; ptr
		call	ptr_align
		add	esp, 10h
		mov	[ebp+ibuf], eax
		mov	eax, ds:conversions_mask
		and	eax, 800h
		test	eax, eax
		jz	short loc_80025C9
		mov	edx, ds:page_size
		mov	eax, ds:output_blocksize
		add	eax, edx
		sub	eax, 1
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	ds:real_obuf_5668, eax
		mov	edx, ds:page_size
		mov	eax, ds:real_obuf_5668
		sub	esp, 8
		push	edx		; alignment
		push	eax		; ptr
		call	ptr_align
		add	esp, 10h
		mov	ds:obuf, eax
		jmp	short loc_80025DB
; ---------------------------------------------------------------------------

loc_80025C9:				; CODE XREF: dd_copy+77j
		mov	ds:real_obuf_5668, 0
		mov	eax, [ebp+ibuf]
		mov	ds:obuf, eax

loc_80025DB:				; CODE XREF: dd_copy+B7j
		mov	eax, dword ptr ds:skip_records
		mov	edx, dword ptr ds:skip_records+4
		or	eax, edx
		test	eax, eax
		jz	loc_80026C5
		mov	eax, ds:input_blocksize
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr ds:skip_records
		mov	edx, dword ptr ds:skip_records+4
		mov	edi, ebx
		imul	edi, eax
		mov	esi, edx
		imul	esi, ecx
		add	esi, edi
		mul	ecx
		lea	ecx, [esi+edx]
		mov	edx, ecx
		mov	ecx, dword ptr ds:input_offset
		mov	ebx, dword ptr ds:input_offset+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+us_bytes], eax
		mov	dword ptr [ebp+us_bytes+4], edx
		mov	ebx, ds:input_blocksize
		mov	eax, dword ptr ds:skip_records
		mov	edx, dword ptr ds:skip_records+4
		mov	ecx, ds:input_file
		sub	esp, 8
		push	[ebp+ibuf]	; buf
		push	ebx		; blocksize
		push	edx
		push	eax		; records
		push	ecx		; file
		push	0		; fdesc
		call	skip
		add	esp, 20h
		mov	dword ptr [ebp+us_blocks], eax
		mov	dword ptr [ebp+us_blocks+4], edx
		mov	eax, dword ptr ds:input_offset
		mov	edx, dword ptr ds:input_offset+4
		sub	dword ptr [ebp+us_bytes], eax
		sbb	dword ptr [ebp+us_bytes+4], edx
		mov	eax, dword ptr [ebp+us_blocks+4]
		or	eax, dword ptr [ebp+us_blocks]
		test	eax, eax
		jnz	short loc_8002694
		movzx	eax, ds:input_offset_overflow
		xor	eax, 1
		test	al, al
		jz	short loc_80026C5
		mov	eax, dword ptr [ebp+us_bytes+4]
		or	eax, dword ptr [ebp+us_bytes]
		test	eax, eax
		jz	short loc_80026C5

loc_8002694:				; CODE XREF: dd_copy+16Aj
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aSCannotSkipToS ; "%s: cannot skip to specified offset"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_80026C5:				; CODE XREF: dd_copy+DAj dd_copy+178j	...
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		or	eax, edx
		test	eax, eax
		jz	loc_80027B1
		mov	esi, ds:obuf
		mov	ebx, ds:output_blocksize
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		mov	ecx, ds:output_file
		sub	esp, 8
		push	esi		; buf
		push	ebx		; blocksize
		push	edx
		push	eax		; records
		push	ecx		; file
		push	1		; fdesc
		call	skip
		add	esp, 20h
		mov	dword ptr [ebp+write_records], eax
		mov	dword ptr [ebp+write_records+4], edx
		mov	eax, dword ptr [ebp+write_records+4]
		or	eax, dword ptr [ebp+write_records]
		test	eax, eax
		jz	loc_80027B1
		mov	edx, ds:output_blocksize
		mov	eax, ds:obuf
		sub	esp, 4
		push	edx		; n
		push	0		; c
		push	eax		; s
		call	memset
		add	esp, 10h

loc_8002737:				; CODE XREF: dd_copy+29Fj
		mov	edx, ds:output_blocksize
		mov	eax, ds:obuf
		sub	esp, 4
		push	edx		; size
		push	eax		; buf
		push	1		; fd
		call	iwrite
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jz	short loc_800279F
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingToS ; "writing to %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; code
		call	quit
; ---------------------------------------------------------------------------

loc_800279F:				; CODE XREF: dd_copy+24Aj
		add	dword ptr [ebp+write_records], 0FFFFFFFFh
		adc	dword ptr [ebp+write_records+4], 0FFFFFFFFh
		mov	eax, dword ptr [ebp+write_records+4]
		or	eax, dword ptr [ebp+write_records]
		test	eax, eax
		jnz	short loc_8002737

loc_80027B1:				; CODE XREF: dd_copy+1C4j dd_copy+207j
		mov	eax, dword ptr max_records
		mov	edx, dword ptr max_records+4
		or	eax, edx
		test	eax, eax
		jnz	short loc_80027CA
		mov	eax, [ebp+exit_status]
		jmp	loc_8002E63
; ---------------------------------------------------------------------------

loc_80027CA:				; CODE XREF: dd_copy+2B0j dd_copy+632j ...
		mov	ecx, dword ptr ds:r_partial
		mov	ebx, dword ptr ds:r_partial+4
		mov	eax, dword ptr ds:r_full
		mov	edx, dword ptr ds:r_full+4
		add	ecx, eax
		adc	ebx, edx
		mov	eax, dword ptr max_records
		mov	edx, dword ptr max_records+4
		cmp	ebx, edx
		jb	short loc_8002804
		cmp	ebx, edx
		ja	loc_8002B87
		cmp	ecx, eax
		jnb	loc_8002B87

loc_8002804:				; CODE XREF: dd_copy+2E2j
		mov	eax, ds:conversions_mask
		and	eax, 400h
		test	eax, eax
		jz	short loc_800284E
		mov	eax, ds:conversions_mask
		and	eax, 100h
		test	eax, eax
		jz	short loc_800284E
		mov	eax, ds:input_blocksize
		mov	edx, ds:conversions_mask
		and	edx, 18h
		test	edx, edx
		jz	short loc_8002839
		mov	edx, 20h
		jmp	short loc_800283E
; ---------------------------------------------------------------------------

loc_8002839:				; CODE XREF: dd_copy+320j
		mov	edx, 0

loc_800283E:				; CODE XREF: dd_copy+327j
		sub	esp, 4
		push	eax		; n
		push	edx		; c
		push	[ebp+ibuf]	; s
		call	memset
		add	esp, 10h

loc_800284E:				; CODE XREF: dd_copy+300j dd_copy+30Ej
		mov	eax, ds:iread_fnc
		mov	edx, ds:input_blocksize
		sub	esp, 4
		push	edx		; size_t
		push	[ebp+ibuf]	; char *
		push	0		; int
		call	eax ; iread_fnc
		add	esp, 10h
		mov	[ebp+nread], eax
		cmp	[ebp+nread], 0
		jz	loc_8002B8A
		cmp	[ebp+nread], 0
		jns	loc_800292E
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aReadingS ; "reading %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, ds:conversions_mask
		and	eax, 100h
		test	eax, eax
		jz	short loc_8002922
		call	print_stats
		mov	eax, ds:input_blocksize
		sub	eax, [ebp+partread]
		sub	esp, 0Ch
		push	eax		; nbytes
		call	advance_input_after_read_error
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80028FD
		mov	[ebp+exit_status], 1
		mov	ds:input_seekable, 0
		mov	ds:input_seek_errno, 1Dh

loc_80028FD:				; CODE XREF: dd_copy+3D3j
		mov	eax, ds:conversions_mask
		and	eax, 400h
		test	eax, eax
		jz	loc_8002B81
		cmp	[ebp+partread],	0
		jnz	loc_8002B81
		mov	[ebp+nread], 0
		jmp	short loc_800292E
; ---------------------------------------------------------------------------

loc_8002922:				; CODE XREF: dd_copy+3B3j
		mov	[ebp+exit_status], 1
		jmp	loc_8002B8B
; ---------------------------------------------------------------------------

loc_800292E:				; CODE XREF: dd_copy+368j dd_copy+410j
		mov	eax, [ebp+nread]
		mov	[ebp+n_bytes_read], eax
		mov	eax, [ebp+nread]
		cdq
		sub	esp, 8
		push	edx
		push	eax		; offset
		call	advance_input_offset
		add	esp, 10h
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:input_blocksize
		cmp	edx, eax
		jnb	loc_80029D6
		mov	eax, dword ptr ds:r_partial
		mov	edx, dword ptr ds:r_partial+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:r_partial,	eax
		mov	dword ptr ds:r_partial+4, edx
		mov	eax, [ebp+n_bytes_read]
		mov	[ebp+partread],	eax
		mov	eax, ds:conversions_mask
		and	eax, 400h
		test	eax, eax
		jz	short loc_80029F9
		mov	eax, ds:conversions_mask
		and	eax, 100h
		test	eax, eax
		jnz	short loc_80029CC
		mov	edx, ds:input_blocksize
		mov	eax, [ebp+n_bytes_read]
		sub	edx, eax
		mov	eax, ds:conversions_mask
		and	eax, 18h
		test	eax, eax
		jz	short loc_80029B1
		mov	ebx, 20h
		jmp	short loc_80029B6
; ---------------------------------------------------------------------------

loc_80029B1:				; CODE XREF: dd_copy+498j
		mov	ebx, 0

loc_80029B6:				; CODE XREF: dd_copy+49Fj
		mov	ecx, [ebp+n_bytes_read]
		mov	eax, [ebp+ibuf]
		add	eax, ecx
		sub	esp, 4
		push	edx		; n
		push	ebx		; c
		push	eax		; s
		call	memset
		add	esp, 10h

loc_80029CC:				; CODE XREF: dd_copy+481j
		mov	eax, ds:input_blocksize
		mov	[ebp+n_bytes_read], eax
		jmp	short loc_80029F9
; ---------------------------------------------------------------------------

loc_80029D6:				; CODE XREF: dd_copy+43Fj
		mov	eax, dword ptr ds:r_full
		mov	edx, dword ptr ds:r_full+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:r_full, eax
		mov	dword ptr ds:r_full+4, edx
		mov	[ebp+partread],	0

loc_80029F9:				; CODE XREF: dd_copy+473j dd_copy+4C4j
		mov	eax, ds:obuf
		cmp	[ebp+ibuf], eax
		jnz	loc_8002ADC
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:obuf
		sub	esp, 4
		push	edx		; size
		push	eax		; buf
		push	1		; fd
		call	iwrite
		add	esp, 10h
		mov	[ebp+nwritten],	eax
		mov	ecx, [ebp+nwritten]
		mov	ebx, 0
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:w_bytes, eax
		mov	dword ptr ds:w_bytes+4,	edx
		mov	eax, [ebp+n_bytes_read]
		cmp	[ebp+nwritten],	eax
		jz	short loc_8002A8E
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingS ; "writing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	loc_8002E63
; ---------------------------------------------------------------------------

loc_8002A8E:				; CODE XREF: dd_copy+539j
		mov	edx, [ebp+n_bytes_read]
		mov	eax, ds:input_blocksize
		cmp	edx, eax
		jnz	short loc_8002ABB
		mov	eax, dword ptr ds:w_full
		mov	edx, dword ptr ds:w_full+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:w_full, eax
		mov	dword ptr ds:w_full+4, edx
		jmp	loc_8002B82
; ---------------------------------------------------------------------------

loc_8002ABB:				; CODE XREF: dd_copy+588j
		mov	eax, dword ptr ds:w_partial
		mov	edx, dword ptr ds:w_partial+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:w_partial,	eax
		mov	dword ptr ds:w_partial+4, edx
		jmp	loc_8002B82
; ---------------------------------------------------------------------------

loc_8002ADC:				; CODE XREF: dd_copy+4F1j
		movzx	eax, ds:translation_needed
		test	al, al
		jz	short loc_8002AF9
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 8
		push	eax		; nread
		push	[ebp+ibuf]	; buf
		call	translate_buffer
		add	esp, 10h

loc_8002AF9:				; CODE XREF: dd_copy+5D5j
		mov	eax, ds:conversions_mask
		and	eax, 80h
		test	eax, eax
		jz	short loc_8002B1E
		sub	esp, 8
		lea	eax, [ebp+n_bytes_read]
		push	eax		; nread
		push	[ebp+ibuf]	; buf
		call	swab_buffer
		add	esp, 10h
		mov	[ebp+bufstart],	eax
		jmp	short loc_8002B24
; ---------------------------------------------------------------------------

loc_8002B1E:				; CODE XREF: dd_copy+5F5j
		mov	eax, [ebp+ibuf]
		mov	[ebp+bufstart],	eax

loc_8002B24:				; CODE XREF: dd_copy+60Cj
		mov	eax, ds:conversions_mask
		and	eax, 8
		test	eax, eax
		jz	short loc_8002B47
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 8
		push	eax		; nread
		push	[ebp+bufstart]	; buf
		call	copy_with_block
		add	esp, 10h
		jmp	loc_80027CA
; ---------------------------------------------------------------------------

loc_8002B47:				; CODE XREF: dd_copy+61Ej
		mov	eax, ds:conversions_mask
		and	eax, 10h
		test	eax, eax
		jz	short loc_8002B6A
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 8
		push	eax		; nread
		push	[ebp+bufstart]	; buf
		call	copy_with_unblock
		add	esp, 10h
		jmp	loc_80027CA
; ---------------------------------------------------------------------------

loc_8002B6A:				; CODE XREF: dd_copy+641j
		mov	eax, [ebp+n_bytes_read]
		sub	esp, 8
		push	eax		; nread
		push	[ebp+bufstart]	; buf
		call	copy_simple
		add	esp, 10h
		jmp	loc_80027CA
; ---------------------------------------------------------------------------

loc_8002B81:				; CODE XREF: dd_copy+3F9j dd_copy+403j
		nop

loc_8002B82:				; CODE XREF: dd_copy+5A6j dd_copy+5C7j
		jmp	loc_80027CA
; ---------------------------------------------------------------------------

loc_8002B87:				; CODE XREF: dd_copy+2E6j dd_copy+2EEj
		nop
		jmp	short loc_8002B8B
; ---------------------------------------------------------------------------

loc_8002B8A:				; CODE XREF: dd_copy+35Ej
		nop

loc_8002B8B:				; CODE XREF: dd_copy+419j dd_copy+678j
		movzx	eax, ds:char_is_saved
		test	al, al
		jz	short loc_8002C0A
		mov	eax, ds:conversions_mask
		and	eax, 8
		test	eax, eax
		jz	short loc_8002BB6
		sub	esp, 8
		push	1		; nread
		push	offset saved_char ; buf
		call	copy_with_block
		add	esp, 10h
		jmp	short loc_8002C0A
; ---------------------------------------------------------------------------

loc_8002BB6:				; CODE XREF: dd_copy+690j
		mov	eax, ds:conversions_mask
		and	eax, 10h
		test	eax, eax
		jz	short loc_8002BD6
		sub	esp, 8
		push	1		; nread
		push	offset saved_char ; buf
		call	copy_with_unblock
		add	esp, 10h
		jmp	short loc_8002C0A
; ---------------------------------------------------------------------------

loc_8002BD6:				; CODE XREF: dd_copy+6B0j
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, ds:saved_char
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002C0A
		call	write_output

loc_8002C0A:				; CODE XREF: dd_copy+684j dd_copy+6A4j ...
		mov	eax, ds:conversions_mask
		and	eax, 8
		test	eax, eax
		jz	short loc_8002C6B
		mov	eax, ds:col
		test	eax, eax
		jz	short loc_8002C6B
		mov	eax, ds:col
		mov	[ebp+i], eax
		jmp	short loc_8002C61
; ---------------------------------------------------------------------------

loc_8002C29:				; CODE XREF: dd_copy+759j
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, byte ptr space_character ;	" "
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002C5D
		call	write_output

loc_8002C5D:				; CODE XREF: dd_copy+746j
		add	[ebp+i], 1

loc_8002C61:				; CODE XREF: dd_copy+717j
		mov	eax, ds:conversion_blocksize
		cmp	[ebp+i], eax
		jb	short loc_8002C29

loc_8002C6B:				; CODE XREF: dd_copy+704j dd_copy+70Dj
		mov	eax, ds:col
		test	eax, eax
		jz	short loc_8002CB4
		mov	eax, ds:conversions_mask
		and	eax, 10h
		test	eax, eax
		jz	short loc_8002CB4
		mov	ecx, ds:obuf
		mov	eax, ds:oc
		lea	edx, [eax+1]
		mov	ds:oc, edx
		lea	edx, [ecx+eax]
		movzx	eax, newline_character
		mov	[edx], al
		mov	edx, ds:oc
		mov	eax, ds:output_blocksize
		cmp	edx, eax
		jb	short loc_8002CB4
		call	write_output

loc_8002CB4:				; CODE XREF: dd_copy+762j dd_copy+76Ej ...
		mov	eax, ds:oc
		test	eax, eax
		jz	loc_8002D6F
		mov	edx, ds:oc
		mov	eax, ds:obuf
		sub	esp, 4
		push	edx		; size
		push	eax		; buf
		push	1		; fd
		call	iwrite
		add	esp, 10h
		mov	[ebp+nwritten_0], eax
		mov	ecx, [ebp+nwritten_0]
		mov	ebx, 0
		mov	eax, dword ptr ds:w_bytes
		mov	edx, dword ptr ds:w_bytes+4
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:w_bytes, eax
		mov	dword ptr ds:w_bytes+4,	edx
		cmp	[ebp+nwritten_0], 0
		jz	short loc_8002D22
		mov	eax, dword ptr ds:w_partial
		mov	edx, dword ptr ds:w_partial+4
		add	eax, 1
		adc	edx, 0
		mov	dword ptr ds:w_partial,	eax
		mov	dword ptr ds:w_partial+4, edx

loc_8002D22:				; CODE XREF: dd_copy+7F4j
		mov	eax, ds:oc
		cmp	[ebp+nwritten_0], eax
		jz	short loc_8002D6F
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aWritingS ; "writing %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	loc_8002E63
; ---------------------------------------------------------------------------

loc_8002D6F:				; CODE XREF: dd_copy+7ABj dd_copy+81Aj
		mov	eax, ds:conversions_mask
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8002DF3
		sub	esp, 0Ch
		push	1		; fildes
		call	fdatasync
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002DF3
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 26h
		jz	short loc_8002DE6
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 16h
		jz	short loc_8002DE6
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFdatasyncFaile ; "fdatasync failed for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+exit_status], 1

loc_8002DE6:				; CODE XREF: dd_copy+888j dd_copy+894j
		mov	eax, ds:conversions_mask
		or	ah, 80h
		mov	ds:conversions_mask, eax

loc_8002DF3:				; CODE XREF: dd_copy+86Bj dd_copy+87Cj
		mov	eax, ds:conversions_mask
		and	eax, 8000h
		test	eax, eax
		jz	short loc_8002E60
		jmp	short loc_8002E4F
; ---------------------------------------------------------------------------

loc_8002E03:				; CODE XREF: dd_copy+94Ej
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 4
		jz	short loc_8002E4F
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFsyncFailedFor ; "fsync	failed for %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 1
		jmp	short loc_8002E63
; ---------------------------------------------------------------------------

loc_8002E4F:				; CODE XREF: dd_copy+8F1j dd_copy+8FDj
		sub	esp, 0Ch
		push	1		; fd
		call	fsync
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8002E03

loc_8002E60:				; CODE XREF: dd_copy+8EFj
		mov	eax, [ebp+exit_status]

loc_8002E63:				; CODE XREF: dd_copy+2B5j dd_copy+579j ...
		mov	edi, [ebp+var_1C]
		xor	edi, large gs:14h
		jz	short loc_8002E74
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8002E74:				; CODE XREF: dd_copy+95Dj
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
dd_copy		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -0ACh
i		= dword	ptr -0A8h
perms		= dword	ptr -0A4h
opts		= dword	ptr -0A0h
obs		= dword	ptr -9Ch
ftruncate_errno	= dword	ptr -98h
exit_status	= dword	ptr -94h
offset		= qword	ptr -90h
size		= qword	ptr -88h
stdout_stat	= stat ptr -7Ch
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 0A8h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		call	install_signal_handlers
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset shortopts ; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset maybe_close_stdout ; func
		call	atexit
		add	esp, 10h
		call	getpagesize
		mov	ds:page_size, eax
		mov	eax, ds:Version
		sub	esp, 8
		push	0
		push	offset aStuartKemp ; "Stuart Kemp"
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aPaulRubin ; "Paul Rubin"
		push	offset usage
		push	eax
		push	offset domainname ; "coreutils"
		push	offset aDd	; "dd"
		push	[ebp+argv]
		push	dword ptr [ebx]
		call	parse_long_options
		add	esp, 30h
		mov	close_stdout_required, 0
		sub	esp, 0Ch
		push	0		; longind
		push	0		; longopts
		push	offset shortopts ; shortopts
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		cmp	eax, 0FFFFFFFFh
		jz	short loc_8002F7E
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002F7E:				; CODE XREF: main+F6j
		mov	[ebp+i], 0
		jmp	short loc_8002FA6
; ---------------------------------------------------------------------------

loc_8002F8A:				; CODE XREF: main+134j
		mov	eax, [ebp+i]
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset trans_table
		mov	[eax], dl
		add	[ebp+i], 1

loc_8002FA6:				; CODE XREF: main+10Cj
		cmp	[ebp+i], 0FFh
		jle	short loc_8002F8A
		sub	esp, 8
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	scanargs
		add	esp, 10h
		call	apply_translations
		mov	eax, ds:input_file
		test	eax, eax
		jnz	short loc_8003004
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ds:input_file, eax
		mov	edx, ds:input_file
		mov	eax, ds:input_flags
		sub	esp, 4
		push	edx		; name
		push	eax		; add_flags
		push	0		; fd
		call	set_fd_flags
		add	esp, 10h
		jmp	short loc_800305A
; ---------------------------------------------------------------------------

loc_8003004:				; CODE XREF: main+155j
		mov	edx, ds:input_flags
		mov	eax, ds:input_file
		push	0
		push	edx
		push	eax
		push	0
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_800305A
		mov	eax, ds:input_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aOpeningS ; "opening %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800305A:				; CODE XREF: main+186j	main+1A3j
		push	1
		push	0
		push	0
		push	0
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+offset],	eax
		mov	dword ptr [ebp+offset+4], edx
		mov	eax, dword ptr [ebp+offset+4]
		not	eax
		shr	eax, 1Fh
		mov	ds:input_seekable, al
		mov	eax, dword ptr [ebp+offset]
		mov	edx, dword ptr [ebp+offset+4]
		test	edx, edx
		jns	short loc_80030A0
		mov	eax, 0
		mov	edx, 0

loc_80030A0:				; CODE XREF: main+218j
		mov	dword ptr ds:input_offset, eax
		mov	dword ptr ds:input_offset+4, edx
		call	__errno_location
		mov	eax, [eax]
		mov	ds:input_seek_errno, eax
		mov	eax, ds:output_file
		test	eax, eax
		jnz	short loc_80030F4
		sub	esp, 0Ch
		push	offset aStandardOutput ; "standard output"
		call	gettext
		add	esp, 10h
		mov	ds:output_file,	eax
		mov	edx, ds:output_file
		mov	eax, ds:output_flags
		sub	esp, 4
		push	edx		; name
		push	eax		; add_flags
		push	1		; fd
		call	set_fd_flags
		add	esp, 10h
		jmp	loc_80033C4
; ---------------------------------------------------------------------------

loc_80030F4:				; CODE XREF: main+242j
		mov	[ebp+perms], 1B6h
		mov	eax, ds:conversions_mask
		and	eax, 1000h
		test	eax, eax
		jz	short loc_8003113
		mov	edx, 0
		jmp	short loc_8003118
; ---------------------------------------------------------------------------

loc_8003113:				; CODE XREF: main+28Ej
		mov	edx, 40h

loc_8003118:				; CODE XREF: main+295j
		mov	eax, ds:output_flags
		or	edx, eax
		mov	eax, ds:conversions_mask
		and	eax, 2000h
		test	eax, eax
		jz	short loc_8003134
		mov	eax, 80h
		jmp	short loc_8003139
; ---------------------------------------------------------------------------

loc_8003134:				; CODE XREF: main+2AFj
		mov	eax, 0

loc_8003139:				; CODE XREF: main+2B6j
		mov	ecx, edx
		or	ecx, eax
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		or	eax, edx
		test	eax, eax
		jnz	short loc_800315C
		mov	eax, ds:conversions_mask
		and	eax, 200h
		test	eax, eax
		jz	short loc_8003163

loc_800315C:				; CODE XREF: main+2D0j
		mov	eax, 0
		jmp	short loc_8003168
; ---------------------------------------------------------------------------

loc_8003163:				; CODE XREF: main+2DEj
		mov	eax, 200h

loc_8003168:				; CODE XREF: main+2E5j
		or	eax, ecx
		mov	[ebp+opts], eax
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		or	eax, edx
		test	eax, eax
		jz	short loc_80031A7
		mov	eax, [ebp+opts]
		or	eax, 2
		mov	edx, eax
		mov	eax, ds:output_file
		push	[ebp+perms]
		push	edx
		push	eax
		push	1
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8003206

loc_80031A7:				; CODE XREF: main+303j
		mov	eax, [ebp+opts]
		or	eax, 1
		mov	edx, eax
		mov	eax, ds:output_file
		push	[ebp+perms]
		push	edx
		push	eax
		push	1
		call	fd_reopen
		add	esp, 10h
		test	eax, eax
		jns	short loc_8003206
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aOpeningS ; "opening %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8003206:				; CODE XREF: main+329j	main+34Fj
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		or	eax, edx
		test	eax, eax
		jz	loc_80033C4
		mov	eax, ds:conversions_mask
		and	eax, 200h
		test	eax, eax
		jnz	loc_80033C4
		mov	eax, ds:output_blocksize
		mov	ecx, eax
		mov	ebx, 0
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		mov	edi, ebx
		imul	edi, eax
		mov	esi, edx
		imul	esi, ecx
		add	esi, edi
		mul	ecx
		lea	ecx, [esi+edx]
		mov	edx, ecx
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	dword ptr [ebp+size], eax
		mov	dword ptr [ebp+size+4],	edx
		mov	eax, ds:output_blocksize
		mov	[ebp+obs], eax
		mov	eax, ds:output_blocksize
		mov	edx, 0
		push	edx
		push	eax
		push	7FFFFFFFh
		push	0FFFFFFFFh
		call	__divdi3
		add	esp, 10h
		mov	ecx, eax
		mov	ebx, edx
		mov	eax, dword ptr ds:seek_records
		mov	edx, dword ptr ds:seek_records+4
		cmp	ebx, edx
		ja	short loc_80032E4
		cmp	ebx, edx
		jb	short loc_80032B0
		cmp	ecx, eax
		jnb	short loc_80032E4

loc_80032B0:				; CODE XREF: main+42Ej
		mov	ebx, dword ptr ds:seek_records
		mov	esi, dword ptr ds:seek_records+4
		sub	esp, 0Ch
		push	offset aOffsetTooLarge ; "offset too large: cannot truncate to a "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+obs]
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80032E4:				; CODE XREF: main+42Aj	main+432j
		mov	eax, dword ptr [ebp+size]
		mov	edx, dword ptr [ebp+size+4]
		sub	esp, 4
		push	edx
		push	eax
		push	1
		call	ftruncate64
		add	esp, 10h
		test	eax, eax
		jz	loc_80033C4
		call	__errno_location
		mov	eax, [eax]
		mov	[ebp+ftruncate_errno], eax
		sub	esp, 8
		lea	eax, [ebp+stdout_stat]
		push	eax
		push	1
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_8003362
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotFstatS ; "cannot fstat %s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8003362:				; CODE XREF: main+4ABj
		mov	eax, [ebp+stdout_stat.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jz	short loc_8003380
		mov	eax, [ebp+stdout_stat.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80033C4

loc_8003380:				; CODE XREF: main+4F3j
		mov	eax, ds:output_file
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aFailedToTrunca ; "failed to truncate to	%llu bytes in out"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	dword ptr [ebp+size+4]
		push	dword ptr [ebp+size]
		push	eax		; format
		push	[ebp+ftruncate_errno] ;	errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80033C4:				; CODE XREF: main+273j	main+399j ...
		call	gethrxtime
		mov	dword ptr ds:start_time, eax
		mov	dword ptr ds:start_time+4, edx
		call	dd_copy
		mov	[ebp+exit_status], eax
		sub	esp, 0Ch
		push	[ebp+exit_status] ; code

loc_80033E8:				; DATA XREF: .eh_frame:08004D9Co
					; .eh_frame:08004DBCo ...
		call	quit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_data		segment	para public 'DATA' use32
		assume cs:_data
		;org 80033F0h
; uintmax_t max_records
max_records	dq 0FFFFFFFFFFFFFFFFh	; DATA XREF: scanargs+458w
					; dd_copy:loc_80027B1r	...
; char newline_character
newline_character db 0Ah		; DATA XREF: apply_translations+E0w
					; apply_translations+112w ...
; char space_character[1]
space_character	db ' '                  ; DATA XREF: apply_translations+EAw
					; apply_translations+11Cw ...
; _Bool	close_stdout_required
close_stdout_required db 1		; DATA XREF: maybe_close_stdout+6r
					; main+D0w
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8003400h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; const	char *input_file
input_file	dd ?			; DATA XREF: cleanup+16r scanargs+AFw	...
; const	char *output_file
output_file	dd ?			; DATA XREF: cleanup+60r iwrite+5Br ...
; size_t page_size
page_size	dd ?			; DATA XREF: scanargs+229r
					; scanargs+23Cr ...
; size_t input_blocksize
input_blocksize	dd ?			; DATA XREF: scanargs+281w
					; scanargs+4F6w ...
; size_t output_blocksize
output_blocksize dd ?			; DATA XREF: iwrite+21r
					; write_output+8r ...
; size_t conversion_blocksize
conversion_blocksize dd	?		; DATA XREF: scanargs+3DAw
					; scanargs:loc_80015D5r ...
; uintmax_t skip_records
skip_records	dq ?			; DATA XREF: scanargs+401w
					; dd_copy:loc_80025DBr	...
; uintmax_t seek_records
seek_records	dq ?			; DATA XREF: scanargs+42Ew
					; dd_copy:loc_80026C5r	...
; int conversions_mask
conversions_mask dd ?			; DATA XREF: iwrite:loc_8000CBCr
					; iwrite+DDw ...
; int input_flags
input_flags	dd ?			; DATA XREF: scanargs+150r
					; scanargs+157w ...
; int output_flags
output_flags	dd ?			; DATA XREF: iwrite+Fr	scanargs+192r ...
; int status_flags
status_flags	dd ?			; DATA XREF: print_stats:loc_8000679r
					; scanargs+1D4r ...
; _Bool	translation_needed
translation_needed db ?			; DATA XREF: translate_charset+3Ew
					; apply_translations+67w ...
		align 10h
; uintmax_t w_partial
w_partial	dq ?			; DATA XREF: print_stats+32r
					; write_output+90r ...
; uintmax_t w_full
w_full		dq ?			; DATA XREF: print_stats+3Er
					; write_output:loc_8000DE6r ...
; uintmax_t r_partial
r_partial	dq ?			; DATA XREF: print_stats+55r
					; dd_copy:loc_80027CAr	...
; uintmax_t r_full
r_full		dq ?			; DATA XREF: print_stats+6Dr
					; dd_copy+2C6r	...
; uintmax_t w_bytes
w_bytes		dq ?			; DATA XREF: print_stats+13Cr
					; print_stats+168r ...
; xtime_t start_time
start_time	dq ?			; DATA XREF: print_stats+1B9r
					; print_stats+208r ...
; _Bool	input_seekable
input_seekable	db ?			; DATA XREF: advance_input_after_read_error+8r
					; dd_copy+3DCw	...
		align 4
; int input_seek_errno
input_seek_errno dd ?			; DATA XREF: advance_input_after_read_error+16r
					; advance_input_after_read_error+31r ...
; uintmax_t input_offset
input_offset	dq ?			; DATA XREF: advance_input_offset+13r
					; advance_input_offset+29w ...
; _Bool	input_offset_overflow
input_offset_overflow db ?		; DATA XREF: advance_input_offset:loc_80019CEw
					; advance_input_after_read_error+52r ...
		align 8
; uintmax_t r_truncate
r_truncate	dq ?			; DATA XREF: print_stats+CEr
					; print_stats+DFr ...
; char *obuf
obuf		dd ?			; DATA XREF: write_output+Er
					; copy_simple+24r ...
; size_t oc
oc		dd ?			; DATA XREF: write_output+D2w
					; copy_simple+12r ...
; size_t col
col		dd ?			; DATA XREF: copy_with_block+22r
					; copy_with_block+31r ...
		align 10h
; sigset_t caught_signals
caught_signals	sigset_t <?>		; DATA XREF: install_signal_handlers+35o
					; install_signal_handlers+71o ...
; volatile sig_atomic_t	interrupt_signal
interrupt_signal dd ?			; DATA XREF: interrupt_handler+6w
					; process_signals+32r ...
; volatile sig_atomic_t	info_signal_count
info_signal_count dd ?			; DATA XREF: siginfo_handler+3r
					; siginfo_handler+Bw ...
; ssize_t (*iread_fnc)(int, char *, size_t)
iread_fnc	dd ?			; DATA XREF: scanargs:loc_8001660w
					; skip:loc_8001DDBr ...
		align 20h
; unsigned __int8 trans_table[256]
trans_table	db 100h	dup(?)		; DATA XREF: translate_charset+12o
					; translate_charset+2Ao ...
; _Bool	char_is_saved
char_is_saved	db ?			; DATA XREF: swab_buffer+Cr
					; swab_buffer+34w ...
; char saved_char[3]
saved_char	db 3 dup(?)		; DATA XREF: swab_buffer+1Br
					; swab_buffer+61w ...
; Function-local static	variable
; size_t pending_spaces_5646
pending_spaces_5646 dd ?		; DATA XREF: copy_with_unblock+38w
					; copy_with_unblock+42r ...
; Function-local static	variable
; char *real_buf_5667
real_buf_5667	dd ?			; DATA XREF: dd_copy+43w dd_copy+48r
; Function-local static	variable
; char *real_obuf_5668
real_obuf_5668	dd ?			; DATA XREF: dd_copy+95w dd_copy+A0r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8003660h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+60o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 20h
; const	symbol_value conversions[16]
conversions	db 61h,	73h, 63h, 2 dup(69h), 5	dup(0);	symbol ; DATA XREF: scanargs+FCo
		db 2 dup(0)
		dd 801h			; value
		db 65h,	62h, 63h, 64h, 69h, 63h, 4 dup(0); symbol
		db 2 dup(0)
		dd 802h			; value
		db 69h,	62h, 6Dh, 7 dup(0); symbol
		db 2 dup(0)
		dd 804h			; value
		db 62h,	6Ch, 6Fh, 63h, 6Bh, 5 dup(0); symbol
		db 2 dup(0)
		dd 808h			; value
		db 75h,	6Eh, 62h, 6Ch, 6Fh, 63h, 6Bh, 3	dup(0);	symbol
		db 2 dup(0)
		dd 810h			; value
		db 6Ch,	63h, 61h, 73h, 65h, 5 dup(0); symbol
		db 2 dup(0)
		dd 820h			; value
		db 75h,	63h, 61h, 73h, 65h, 5 dup(0); symbol
		db 2 dup(0)
		dd 840h			; value
		db 73h,	77h, 61h, 62h, 6 dup(0); symbol
		db 2 dup(0)
		dd 880h			; value
		db 6Eh,	6Fh, 65h, 2 dup(72h), 6Fh, 72h,	3 dup(0); symbol
		db 2 dup(0)
		dd 100h			; value
		db 6Eh,	6Fh, 63h, 72h, 65h, 61h, 74h, 3	dup(0);	symbol
		db 2 dup(0)
		dd 1000h		; value
		db 65h,	78h, 63h, 6Ch, 6 dup(0); symbol
		db 2 dup(0)
		dd 2000h		; value
		db 6Eh,	6Fh, 74h, 72h, 75h, 6Eh, 63h, 3	dup(0);	symbol
		db 2 dup(0)
		dd 200h			; value
		db 73h,	79h, 6Eh, 63h, 6 dup(0); symbol
		db 2 dup(0)
		dd 400h			; value
		db 66h,	64h, 61h, 74h, 61h, 73h, 79h, 6Eh, 63h,	0; symbol
		db 2 dup(0)
		dd 4000h		; value
		db 66h,	73h, 79h, 6Eh, 63h, 5 dup(0); symbol
		db 2 dup(0)
		dd 8000h		; value
		db 0Ah dup(0)		; symbol
		db 2 dup(0)
		dd 0			; value
; const	symbol_value flags[15]
flags		db 61h,	2 dup(70h), 65h, 6Eh, 64h, 4 dup(0); symbol
					; DATA XREF: scanargs+13Eo
					; scanargs+180o
		db 2 dup(0)
		dd 400h			; value
		db 62h,	69h, 6Eh, 61h, 72h, 79h, 4 dup(0); symbol
		db 2 dup(0)
		dd 0			; value
		db 63h,	69h, 6Fh, 7 dup(0); symbol
		db 2 dup(0)
		dd 0			; value
		db 64h,	69h, 72h, 65h, 63h, 74h, 4 dup(0); symbol
		db 2 dup(0)
		dd 4000h		; value
		db 64h,	69h, 72h, 65h, 63h, 74h, 6Fh, 72h, 79h,	0; symbol
		db 2 dup(0)
		dd 10000h		; value
		db 64h,	73h, 79h, 6Eh, 63h, 5 dup(0); symbol
		db 2 dup(0)
		dd 1000h		; value
		db 6Eh,	6Fh, 61h, 74h, 69h, 6Dh, 65h, 3	dup(0);	symbol
		db 2 dup(0)
		dd 40000h		; value
		db 6Eh,	6Fh, 63h, 2 dup(74h), 79h, 4 dup(0); symbol
		db 2 dup(0)
		dd 100h			; value
		db 6Eh,	6Fh, 66h, 6Fh, 2 dup(6Ch), 6Fh,	77h, 2 dup(0); symbol
		db 2 dup(0)
		dd 20000h		; value
		db 6Eh,	6Fh, 6Ch, 69h, 6Eh, 6Bh, 73h, 3	dup(0);	symbol
		db 2 dup(0)
		dd 0			; value
		db 6Eh,	6Fh, 6Eh, 62h, 6Ch, 6Fh, 63h, 6Bh, 2 dup(0); symbol
		db 2 dup(0)
		dd 800h			; value
		db 73h,	79h, 6Eh, 63h, 6 dup(0); symbol
		db 2 dup(0)
		dd 101000h		; value
		db 74h,	65h, 78h, 74h, 6 dup(0); symbol
		db 2 dup(0)
		dd 0			; value
		db 66h,	75h, 2 dup(6Ch), 62h, 6Ch, 6Fh,	63h, 6Bh, 0; symbol
		db 2 dup(0)
		dd 1			; value
		db 0Ah dup(0)		; symbol
		db 2 dup(0)
		dd 0			; value
		align 20h
; const	symbol_value statuses[2]
statuses	db 6Eh,	6Fh, 78h, 66h, 65h, 72h, 4 dup(0); symbol ; DATA XREF: scanargs+1C2o
		db 2 dup(0)
		dd 1			; value
		db 0Ah dup(0)		; symbol
		db 2 dup(0)
		dd 0			; value
; char ascii_to_ebcdic[256]
ascii_to_ebcdic	db 0, 1, 2, 3, 37h, 2Dh, 2Eh, 2Fh, 16h,	5, 25h,	0Bh, 0Ch
					; DATA XREF: apply_translations+CEo
		db 0Dh,	0Eh, 0Fh, 10h, 11h, 12h, 13h, 3Ch, 3Dh,	32h, 26h
		db 18h,	19h, 3Fh, 27h, 1Ch, 1Dh, 1Eh, 1Fh, 40h,	4Fh, 7Fh
		db 7Bh,	5Bh, 6Ch, 50h, 7Dh, 4Dh, 5Dh, 5Ch, 4Eh,	6Bh, 60h
		db 4Bh,	61h, 0F0h, 0F1h, 0F2h, 0F3h, 0F4h, 0F5h, 0F6h
		db 0F7h, 0F8h, 0F9h, 7Ah, 5Eh, 4Ch, 7Eh, 6Eh, 6Fh, 7Ch
		db 0C1h, 0C2h, 0C3h, 0C4h, 0C5h, 0C6h, 0C7h, 0C8h, 0C9h
		db 0D1h, 0D2h, 0D3h, 0D4h, 0D5h, 0D6h, 0D7h, 0D8h, 0D9h
		db 0E2h, 0E3h, 0E4h, 0E5h, 0E6h, 0E7h, 0E8h, 0E9h, 4Ah
		db 0E0h, 5Ah, 5Fh, 6Dh,	79h, 81h, 82h, 83h, 84h, 85h, 86h
		db 87h,	88h, 89h, 91h, 92h, 93h, 94h, 95h, 96h,	97h, 98h
		db 99h,	0A2h, 0A3h, 0A4h, 0A5h,	0A6h, 0A7h, 0A8h, 0A9h
		db 0C0h, 6Ah, 0D0h, 0A1h, 7, 20h, 21h, 22h, 23h, 24h, 15h
		db 6, 17h, 28h,	29h, 2Ah, 2Bh, 2Ch, 9, 0Ah, 1Bh, 30h, 31h
		db 1Ah,	33h, 34h, 35h, 36h, 8, 38h, 39h, 3Ah, 3Bh, 4, 14h
		db 3Eh,	0E1h, 41h, 42h,	43h, 44h, 45h, 46h, 47h, 48h, 49h
		db 51h,	52h, 53h, 54h, 55h, 56h, 57h, 58h, 59h,	62h, 63h
		db 64h,	65h, 66h, 67h, 68h, 69h, 70h, 71h, 72h,	73h, 74h
		db 75h,	76h, 77h, 78h, 80h, 8Ah, 8Bh, 8Ch, 8Dh,	8Eh, 8Fh
		db 90h,	9Ah, 9Bh, 9Ch, 9Dh, 9Eh, 9Fh, 0A0h, 0AAh, 0ABh
		db 0ACh, 0ADh, 0AEh, 0AFh, 0B0h, 0B1h, 0B2h, 0B3h, 0B4h
		db 0B5h, 0B6h, 0B7h, 0B8h, 0B9h, 0BAh, 0BBh, 0BCh, 0BDh
		db 0BEh, 0BFh, 0CAh, 0CBh, 0CCh, 0CDh, 0CEh, 0CFh, 0DAh
		db 0DBh, 0DCh, 0DDh, 0DEh, 0DFh, 0EAh, 0EBh, 0ECh, 0EDh
		db 0EEh, 0EFh, 0FAh, 0FBh, 0FCh, 0FDh, 0FEh, 0FFh
; char ascii_to_ibm[256]
ascii_to_ibm	db 0, 1, 2, 3, 37h, 2Dh, 2Eh, 2Fh, 16h,	5, 25h,	0Bh, 0Ch
					; DATA XREF: apply_translations+100o
		db 0Dh,	0Eh, 0Fh, 10h, 11h, 12h, 13h, 3Ch, 3Dh,	32h, 26h
		db 18h,	19h, 3Fh, 27h, 1Ch, 1Dh, 1Eh, 1Fh, 40h,	5Ah, 7Fh
		db 7Bh,	5Bh, 6Ch, 50h, 7Dh, 4Dh, 5Dh, 5Ch, 4Eh,	6Bh, 60h
		db 4Bh,	61h, 0F0h, 0F1h, 0F2h, 0F3h, 0F4h, 0F5h, 0F6h
		db 0F7h, 0F8h, 0F9h, 7Ah, 5Eh, 4Ch, 7Eh, 6Eh, 6Fh, 7Ch
		db 0C1h, 0C2h, 0C3h, 0C4h, 0C5h, 0C6h, 0C7h, 0C8h, 0C9h
		db 0D1h, 0D2h, 0D3h, 0D4h, 0D5h, 0D6h, 0D7h, 0D8h, 0D9h
		db 0E2h, 0E3h, 0E4h, 0E5h, 0E6h, 0E7h, 0E8h, 0E9h, 0ADh
		db 0E0h, 0BDh, 5Fh, 6Dh, 79h, 81h, 82h,	83h, 84h, 85h
		db 86h,	87h, 88h, 89h, 91h, 92h, 93h, 94h, 95h,	96h, 97h
		db 98h,	99h, 0A2h, 0A3h, 0A4h, 0A5h, 0A6h, 0A7h, 0A8h
		db 0A9h, 0C0h, 4Fh, 0D0h, 0A1h,	7, 20h,	21h, 22h, 23h
		db 24h,	15h, 6,	17h, 28h, 29h, 2Ah, 2Bh, 2Ch, 9, 0Ah, 1Bh
		db 30h,	31h, 1Ah, 33h, 34h, 35h, 36h, 8, 38h, 39h, 3Ah
		db 3Bh,	4, 14h,	3Eh, 0E1h, 41h,	42h, 43h, 44h, 45h, 46h
		db 47h,	48h, 49h, 51h, 52h, 53h, 54h, 55h, 56h,	57h, 58h
		db 59h,	62h, 63h, 64h, 65h, 66h, 67h, 68h, 69h,	70h, 71h
		db 72h,	73h, 74h, 75h, 76h, 77h, 78h, 80h, 8Ah,	8Bh, 8Ch
		db 8Dh,	8Eh, 8Fh, 90h, 9Ah, 9Bh, 9Ch, 9Dh, 9Eh,	9Fh, 0A0h
		db 0AAh, 0ABh, 0ACh, 0ADh, 0AEh, 0AFh, 0B0h, 0B1h, 0B2h
		db 0B3h, 0B4h, 0B5h, 0B6h, 0B7h, 0B8h, 0B9h, 0BAh, 0BBh
		db 0BCh, 0BDh, 0BEh, 0BFh, 0CAh, 0CBh, 0CCh, 0CDh, 0CEh
		db 0CFh, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh, 0DFh, 0EAh, 0EBh
		db 0ECh, 0EDh, 0EEh, 0EFh, 0FAh, 0FBh, 0FCh, 0FDh, 0FEh
		db 0FFh
; char ebcdic_to_ascii[256]
ebcdic_to_ascii	db 0, 1, 2, 3, 9Ch, 9, 86h, 7Fh, 97h, 8Dh, 8Eh,	0Bh, 0Ch
					; DATA XREF: apply_translations+12o
		db 0Dh,	0Eh, 0Fh, 10h, 11h, 12h, 13h, 9Dh, 85h,	8, 87h
		db 18h,	19h, 92h, 8Fh, 1Ch, 1Dh, 1Eh, 1Fh, 80h,	81h, 82h
		db 83h,	84h, 0Ah, 17h, 1Bh, 88h, 89h, 8Ah, 8Bh,	8Ch, 5
		db 6, 7, 90h, 91h, 16h,	93h, 94h, 95h, 96h, 4, 98h, 99h
		db 9Ah,	9Bh, 14h, 15h, 9Eh, 1Ah, 20h, 0A0h, 0A1h, 0A2h
		db 0A3h, 0A4h, 0A5h, 0A6h, 0A7h, 0A8h, 5Bh, 2Eh, 3Ch, 28h
		db 2Bh,	21h, 26h, 0A9h,	0AAh, 0ABh, 0ACh, 0ADh,	0AEh, 0AFh
		db 0B0h, 0B1h, 5Dh, 24h, 2Ah, 29h, 3Bh,	5Eh, 2Dh, 2Fh
		db 0B2h, 0B3h, 0B4h, 0B5h, 0B6h, 0B7h, 0B8h, 0B9h, 7Ch
		db 2Ch,	25h, 5Fh, 3Eh, 3Fh, 0BAh, 0BBh,	0BCh, 0BDh, 0BEh
		db 0BFh, 0C0h, 0C1h, 0C2h, 60h,	3Ah, 23h, 40h, 27h, 3Dh
		db 22h,	0C3h, 61h, 62h,	63h, 64h, 65h, 66h, 67h, 68h, 69h
		db 0C4h, 0C5h, 0C6h, 0C7h, 0C8h, 0C9h, 0CAh, 6Ah, 6Bh
		db 6Ch,	6Dh, 6Eh, 6Fh, 70h, 71h, 72h, 0CBh, 0CCh, 0CDh
		db 0CEh, 0CFh, 0D0h, 0D1h, 7Eh,	73h, 74h, 75h, 76h, 77h
		db 78h,	79h, 7Ah, 0D2h,	0D3h, 0D4h, 0D5h, 0D6h,	0D7h, 0D8h
		db 0D9h, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh, 0DFh, 0E0h, 0E1h
		db 0E2h, 0E3h, 0E4h, 0E5h, 0E6h, 0E7h, 7Bh, 41h, 42h, 43h
		db 44h,	45h, 46h, 47h, 48h, 49h, 0E8h, 0E9h, 0EAh, 0EBh
		db 0ECh, 0EDh, 7Dh, 4Ah, 4Bh, 4Ch, 4Dh,	4Eh, 4Fh, 50h
		db 51h,	52h, 0EEh, 0EFh, 0F0h, 0F1h, 0F2h, 0F3h, 5Ch, 9Fh
		db 53h,	54h, 55h, 56h, 57h, 58h, 59h, 5Ah, 0F4h, 0F5h
		db 0F6h, 0F7h, 0F8h, 0F9h, 30h,	31h, 32h, 33h, 34h, 35h
		db 36h,	37h, 38h, 39h, 0FAh, 0FBh, 0FCh, 0FDh, 0FEh, 0FFh
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+17o
		align 4
; char aUsageSOperand_[]
aUsageSOperand_	db 'Usage: %s [OPERAND]...',0Ah ; DATA XREF: usage+4Do
		db '  or:  %s OPTION',0Ah,0
		align 4
; char aCopyAFileConve[]
aCopyAFileConve	db 'Copy a file, converting and formatting according to the operands.'
					; DATA XREF: usage+71o
		db 0Ah
		db 0Ah
		db '  bs=BYTES        read and write BYTES bytes at a time (also see '
		db 'ibs=,obs=)',0Ah
		db '  cbs=BYTES       convert BYTES bytes at a time',0Ah
		db '  conv=CONVS      convert the file as per the comma separated sym'
		db 'bol list',0Ah
		db '  count=BLOCKS    copy only BLOCKS input blocks',0Ah
		db '  ibs=BYTES       read BYTES bytes at a time (default: 512)',0Ah,0
		align 4
; char aIfFileReadFrom[]
aIfFileReadFrom	db '  if=FILE         read from FILE instead of stdin',0Ah
					; DATA XREF: usage+94o
		db '  iflag=FLAGS     read as per the comma separated symbol list',0Ah
		db '  obs=BYTES       write BYTES bytes at a time (default: 512)',0Ah
		db '  of=FILE         write to FILE instead of stdout',0Ah
		db '  oflag=FLAGS     write as per the comma separated symbol list',0Ah
		db '  seek=BLOCKS     skip BLOCKS obs-sized blocks at start of output'
		db 0Ah
		db '  skip=BLOCKS     skip BLOCKS ibs-sized blocks at start of input',0Ah
		db '  status=noxfer   suppress transfer statistics',0Ah,0
		align 10h
; char aBlocksAndBytes[]
aBlocksAndBytes	db 0Ah			; DATA XREF: usage+B7o
		db 'BLOCKS and BYTES may be followed by the following multiplicative '
		db 'suffixes:',0Ah
		db 'c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*102'
		db '4, xM =M',0Ah
		db 'GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, '
		db 'Y.',0Ah
		db 0Ah
		db 'Each CONV symbol may be:',0Ah
		db 0Ah,0
		align 4
; char aAsciiFromEbcdi[]
aAsciiFromEbcdi	db '  ascii     from EBCDIC to ASCII',0Ah ; DATA XREF: usage+DAo
		db '  ebcdic    from ASCII to EBCDIC',0Ah
		db '  ibm       from ASCII to alternate EBCDIC',0Ah
		db '  block     pad newline-terminated records with spaces to cbs-siz'
		db 'e',0Ah
		db '  unblock   replace trailing spaces in cbs-size records with newl'
		db 'ine',0Ah
		db '  lcase     change upper case to lower case',0Ah,0
		align 4
; char aNocreatDoNotCr[]
aNocreatDoNotCr	db '  nocreat   do not create the output file',0Ah ; DATA XREF: usage+FDo
		db '  excl      fail if the output file already exists',0Ah
		db '  notrunc   do not truncate the output file',0Ah
		db '  ucase     change lower case to upper case',0Ah
		db '  swab      swap every pair of input bytes',0Ah,0
		align 10h
; char aNoerrorContinu[]
aNoerrorContinu	db '  noerror   continue after read errors',0Ah ; DATA XREF: usage+120o
		db '  sync      pad every input block with NULs to ibs-size; when use'
		db 'd',0Ah
		db '            with block or unblock, pad with spaces rather than NU'
		db 'Ls',0Ah
		db '  fdatasync  physically write output file data before finishing',0Ah
		db '  fsync     likewise, but also write metadata',0Ah,0
		align 10h
; char aEachFlagSymbol[]
aEachFlagSymbol	db 0Ah			; DATA XREF: usage+143o
		db 'Each FLAG symbol may be:',0Ah
		db 0Ah
		db '  append    append mode (makes sense only for output; conv=notrun'
		db 'c suggested)',0Ah,0
		align 4
; char aDirectUseDirec[]
aDirectUseDirec	db '  direct    use direct I/O for data',0Ah,0 ; DATA XREF: usage+166o
		align 4
; char aDirectoryFailU[]
aDirectoryFailU	db '  directory  fail unless a directory',0Ah,0 ; DATA XREF: usage+189o
		align 4
; char aDsyncUseSynchr[]
aDsyncUseSynchr	db '  dsync     use synchronized I/O for data',0Ah,0 ; DATA XREF: usage+1ACo
		align 4
; char aSyncLikewiseBu[]
aSyncLikewiseBu	db '  sync      likewise, but also for metadata',0Ah,0
					; DATA XREF: usage+1CFo
		align 4
; char aFullblockAccum[]
aFullblockAccum	db '  fullblock  accumulate full blocks of input (iflag only)',0Ah,0
					; DATA XREF: usage+1F2o
		align 4
; char aNonblockUseNon[]
aNonblockUseNon	db '  nonblock  use non-blocking I/O',0Ah,0 ; DATA XREF: usage+215o
		align 4
; char aNoatimeDoNotUp[]
aNoatimeDoNotUp	db '  noatime   do not update access time',0Ah,0 ; DATA XREF: usage+238o
		align 10h
; char aNocttyDoNotAss[]
aNocttyDoNotAss	db '  noctty    do not assign controlling terminal from file',0Ah,0
					; DATA XREF: usage+25Bo
		align 4
; char aNofollowDoNotF[]
aNofollowDoNotF	db '  nofollow  do not follow symlinks',0Ah,0 ; DATA XREF: usage+27Eo
aUsr1		db 'USR1',0             ; DATA XREF: usage+298o
		align 4
; char aSendingASSigna[]
aSendingASSigna	db 0Ah			; DATA XREF: usage+2A2o
		db 'Sending a %s signal to a running `dd',27h,' process makes it',0Ah
		db 'print I/O statistics to standard error and then resume copying.',0Ah
		db 0Ah
		db '  $ dd if=/dev/zero of=/dev/null& pid=$!',0Ah
		db '  $ kill -%s $pid; sleep 1; kill $pid',0Ah
		db '  18335302+0 records in',0Ah
		db '  18335302+0 records out',0Ah
		db '  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s',0Ah
		db 0Ah
		db 'Options are:',0Ah
		db 0Ah,0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+2CAo
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+2EDo
		align 4
; char aLluLluRecordsI[]
aLluLluRecordsI	db '%llu+%llu records in',0Ah ; DATA XREF: print_stats+87o
		db '%llu+%llu records out',0Ah,0
; char msgid2[]
msgid2		db '%llu truncated records',0Ah,0 ; DATA XREF: print_stats+107o
; char msgid1[]
msgid1		db '%llu truncated record',0Ah,0 ; DATA XREF: print_stats+10Co
; char aLluBytesSCopie[]
aLluBytesSCopie	db '%llu bytes (%s) copied',0 ; DATA XREF: print_stats+190o
; char aLluByteSCopied[]
aLluByteSCopied	db '%llu byte (%s) copied',0 ; DATA XREF: print_stats+195o
; char aInfinityB[]
aInfinityB	db 'Infinity B',0       ; DATA XREF: print_stats+296o
; char aGSSS[]
aGSSS		db ', %g s, %s/s',0Ah,0 ; DATA XREF: print_stats+2ACo
; char aClosingInputFi[]
aClosingInputFi	db 'closing input file %s',0 ; DATA XREF: cleanup+2Co
; char aClosingOutputF[]
aClosingOutputF	db 'closing output file %s',0 ; DATA XREF: cleanup+76o
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: install_signal_handlers+1Ao
		align 4
; char aFailedToTurnOf[]
aFailedToTurnOf	db 'failed to turn off O_DIRECT: %s',0 ; DATA XREF: iwrite+71o
; char aWritingToS[]
aWritingToS	db 'writing to %s',0    ; DATA XREF: write_output+67o
					; dd_copy+262o
; char format[]
format		db '%s: %s',0           ; DATA XREF: parse_symbols+7Do
					; scanargs+588o
aBcegkkmptwyz0	db 'bcEGkKMPTwYZ0',0    ; DATA XREF: parse_integer+22o
; char aUnrecognizedOp[]
aUnrecognizedOp	db 'unrecognized operand %s',0 ; DATA XREF: scanargs+6Co
					; scanargs+478o
; char aIf[]
aIf		db 'if',0               ; DATA XREF: scanargs+98o
; char aOf[]
aOf		db 'of',0               ; DATA XREF: scanargs+BCo
; char aConv[]
aConv		db 'conv',0             ; DATA XREF: scanargs+E0o
; char error_msgid[]
error_msgid	db 'invalid conversion',0 ; DATA XREF: scanargs+F7o
; char aIflag[]
aIflag		db 'iflag',0            ; DATA XREF: scanargs+122o
; char aInvalidInputFl[]
aInvalidInputFl	db 'invalid input flag',0 ; DATA XREF: scanargs+139o
; char aOflag[]
aOflag		db 'oflag',0            ; DATA XREF: scanargs+164o
; char aInvalidOutputF[]
aInvalidOutputF	db 'invalid output flag',0 ; DATA XREF: scanargs+17Bo
					; scanargs+572o
; char aStatus[]
aStatus		db 'status',0           ; DATA XREF: scanargs+1A6o
; char aInvalidStatusF[]
aInvalidStatusF	db 'invalid status flag',0 ; DATA XREF: scanargs+1BDo
; char aIbs[]
aIbs		db 'ibs',0              ; DATA XREF: scanargs+204o
; char aObs[]
aObs		db 'obs',0              ; DATA XREF: scanargs+28Eo
; char aBs[]
aBs		db 'bs',0               ; DATA XREF: scanargs+30Eo
; char aCbs[]
aCbs		db 'cbs',0              ; DATA XREF: scanargs+396o
; char aSkip[]
aSkip		db 'skip',0             ; DATA XREF: scanargs+3E7o
; char aSeek[]
aSeek		db 'seek',0             ; DATA XREF: scanargs+414o
; char aCount[]
aCount		db 'count',0            ; DATA XREF: scanargs+43Eo
; char aInvalidNumberS[]
aInvalidNumberS	db 'invalid number %s',0 ; DATA XREF: scanargs+4B8o
aFullblock	db 27h,'fullblock',27h,0 ; DATA XREF: scanargs+582o
; char aCannotCombineA[]
aCannotCombineA	db 'cannot combine any two of {ascii,ebcdic,ibm}',0
					; DATA XREF: scanargs+5E8o
		align 4
; char aCannotCombineB[]
aCannotCombineB	db 'cannot combine block and unblock',0 ; DATA XREF: scanargs+620o
		align 10h
; char aCannotCombineL[]
aCannotCombineL	db 'cannot combine lcase and ucase',0 ; DATA XREF: scanargs+658o
		align 10h
; char aCannotCombineE[]
aCannotCombineE	db 'cannot combine excl and nocreat',0 ; DATA XREF: scanargs+692o
; char aWarningWorking[]
aWarningWorking	db 'warning: working around lseek kernel bug for file (%s)',0Ah
					; DATA XREF: skip_via_lseek+A8o
		db '  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types',0
; char aCannotFstatS[]
aCannotFstatS	db 'cannot fstat %s',0  ; DATA XREF: skip+120o main+4C3o
; char aSCannotSkip[]
aSCannotSkip	db '%s: cannot skip',0  ; DATA XREF: skip+2A1o
; char aSCannotSeek[]
aSCannotSeek	db '%s: cannot seek',0  ; DATA XREF: skip+2D8o skip+397o ...
; char aReadingS[]
aReadingS	db 'reading %s',0       ; DATA XREF: skip+349o dd_copy+384o
; char aOffsetOverflow[]
aOffsetOverflow	db 'offset overflow while reading file %s',0
					; DATA XREF: advance_input_after_read_error+9Co
		align 4
; char aWarningInvalid[]
aWarningInvalid	db 'warning: invalid file offset after failed read',0
					; DATA XREF: advance_input_after_read_error+148o
		align 4
; char aCannotWorkArou[]
aCannotWorkArou	db 'cannot work around kernel bug after all',0
					; DATA XREF: advance_input_after_read_error+199o
; char aSettingFlagsFo[]
aSettingFlagsFo	db 'setting flags for %s',0 ; DATA XREF: set_fd_flags+106o
		align 4
; char aSCannotSkipToS[]
aSCannotSkipToS	db '%s: cannot skip to specified offset',0 ; DATA XREF: dd_copy+19Ao
; char aWritingS[]
aWritingS	db 'writing %s',0       ; DATA XREF: dd_copy+551o dd_copy+832o
; char aFdatasyncFaile[]
aFdatasyncFaile	db 'fdatasync failed for %s',0 ; DATA XREF: dd_copy+8ACo
; char aFsyncFailedFor[]
aFsyncFailedFor	db 'fsync failed for %s',0 ; DATA XREF: dd_copy+915o
; char shortopts
shortopts	db 0			; DATA XREF: main+49o main+DEo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+5Bo
aStuartKemp	db 'Stuart Kemp',0      ; DATA XREF: main+A1o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+A6o
aPaulRubin	db 'Paul Rubin',0       ; DATA XREF: main+ABo
aDd		db 'dd',0               ; DATA XREF: main+BBo
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: main+15Ao
; char aOpeningS[]
aOpeningS	db 'opening %s',0       ; DATA XREF: main+1BBo main+367o
; char aStandardOutput[]
aStandardOutput	db 'standard output',0  ; DATA XREF: main+247o
; char aOffsetTooLarge[]
aOffsetTooLarge	db 'offset too large: cannot truncate to a length of seek=%llu (%lu-b'
					; DATA XREF: main+443o
		db 'yte) blocks',0
		align 10h
; char aFailedToTrunca[]
aFailedToTrunca	db 'failed to truncate to %llu bytes in output file %s',0
					; DATA XREF: main+51Ao
		align 8
dbl_8004D68	dq 1.0e9		; DATA XREF: print_stats:loc_8000731r
tbyte_8004D70	dt 1.8446744073709551616e19 ; DATA XREF: print_stats+22Er
		align 4
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8004D7Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80033E8-8008184h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 1Ch, 3Ch
		dd offset loc_80033E8-8008192h
		dd 3Bh,	80E4100h, 0D420285h, 0CC57705h,	404h, 1Ch, 5Ch
		dd offset loc_80033E8-8008177h
		dd 32h,	80E4100h, 0D420285h, 0CC56E05h,	404h, 20h, 7Ch
		dd offset loc_80033E8-8008165h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	0A0h
		dd offset loc_80033E8-800806Dh
		dd 6, 80E4100h,	0D420285h, 0CC54205h, 404h, 1Ch, 0C0h
		dd offset loc_80033E8-8008087h
		dd 3Ah,	80E4100h, 0D420285h, 0CC57605h,	404h, 1Ch, 0E0h
		dd offset loc_80033E8-800806Dh
		dd 317h, 80E4100h, 0D420285h, 3864505h,	483h, 1Ch, 100h
		dd offset loc_80033E8-8007D76h
		dd 48h,	80E4100h, 0D420285h, 0C5440205h, 4040Ch, 1Ch, 120h
		dd offset loc_80033E8-8007D4Eh
		dd 13h,	80E4100h, 0D420285h, 0CC54F05h,	404h, 2Ch, 140h
		dd offset loc_80033E8-8007D5Bh
		dd 2FBh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C302EB03h
		dd 0C741C641h, 40CC541h, 4, 24h, 170h
		dd offset loc_80033E8-8007A90h
		dd 0A1h, 80E4100h, 0D420285h, 3864205h,	99020483h, 41C641C3h
		dd 4040CC5h, 18h, 198h
		dd offset loc_80033E8-8007A17h
		dd 20h,	80E4100h, 0D420285h, 5,	1Ch, 1B4h
		dd offset loc_80033E8-8007A13h
		dd 0Eh,	80E4100h, 0D420285h, 0CC54A05h,	404h, 1Ch, 1D4h
		dd offset loc_80033E8-8007A25h
		dd 13h,	80E4100h, 0D420285h, 0CC54F05h,	404h, 2Ch, 1F4h
		dd offset loc_80033E8-8007A32h
		dd 15Dh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3014D03h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 224h
		dd offset loc_80033E8-8007905h
		dd 0D0h, 80E4100h, 0D420285h, 0C5CC0205h, 4040Ch, 1Ch
		dd 244h
		dd offset loc_80033E8-8007855h
		dd 39h,	80E4100h, 0D420285h, 0CC57505h,	404h, 1Ch, 264h
		dd offset loc_80033E8-800783Ch
		dd 57h,	80E4100h, 0D420285h, 0C5530205h, 4040Ch, 28h, 284h
		dd offset loc_80033E8-8007805h
		dd 149h, 80E4100h, 0D420285h, 3864505h,	3E030483h, 0C641C301h
		dd 40CC541h, 4,	24h, 2B0h
		dd offset loc_80033E8-80076E8h
		dd 0E4h, 80E4100h, 0D420285h, 3864505h,	0D9020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 2D8h
		dd offset loc_80033E8-800762Ch
		dd 61h,	80E4100h, 0D420285h, 0C55D0205h, 4040Ch, 20h, 2F8h
		dd offset loc_80033E8-80075EBh
		dd 0EFh, 80E4100h, 0D420285h, 3834405h,	0C3C5E702h, 4040Ch
		dd 28h,	31Ch
		dd offset loc_80033E8-8007520h
		dd 12Ch, 80E4100h, 0D420285h, 3864505h,	21030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 348h
		dd offset loc_80033E8-8007420h
		dd 15h,	80E4100h, 0D420285h, 0CC55105h,	404h, 20h, 368h
		dd offset loc_80033E8-800742Bh
		dd 6C6h, 80E4100h, 0D420285h, 3834405h,	0C506BE03h, 4040CC3h
		dd 1Ch,	38Ch
		dd offset loc_80033E8-8006D89h
		dd 124h, 80E4100h, 0D420285h, 1200305h,	4040CC5h, 1Ch
		dd 3ACh
		dd offset loc_80033E8-8006C85h
		dd 48h,	80E4100h, 0D420285h, 0C5440205h, 4040Ch, 1Ch, 3CCh
		dd offset loc_80033E8-8006C5Dh
		dd 0A9h, 80E4100h, 0D420285h, 0C5A50205h, 4040Ch, 20h
		dd 3ECh
		dd offset loc_80033E8-8006BD4h
		dd 5Ch,	80E4100h, 0D420285h, 3834405h, 41C35302h, 4040CC5h
		dd 20h,	410h
		dd offset loc_80033E8-8006B9Ch
		dd 0FEh, 80E4100h, 0D420285h, 3834405h,	0C3C5F602h, 4040Ch
		dd 2Ch,	434h
		dd offset loc_80033E8-8006AC2h
		dd 42Dh, 80E4100h, 0D420285h, 3874905h,	5830486h, 0C3041D03h
		dd 0C741C641h, 40CC541h, 4, 28h, 464h
		dd offset loc_80033E8-80066C5h
		dd 1FBh, 80E4100h, 0D420285h, 3864505h,	0F0030483h, 0C641C301h
		dd 40CC541h, 4,	1Ch, 490h
		dd offset loc_80033E8-80064F6h
		dd 7Ch,	80E4100h, 0D420285h, 0C5780205h, 4040Ch, 1Ch, 4B0h
		dd offset loc_80033E8-800649Ah
		dd 11Ah, 80E4100h, 0D420285h, 1160305h,	4040CC5h, 1Ch
		dd 4D0h
		dd offset loc_80033E8-80063A0h
		dd 136h, 80E4100h, 0D420285h, 1320305h,	4040CC5h, 28h
		dd 4F0h
		dd offset loc_80033E8-800628Ah
		dd 142h, 80E4100h, 0D420285h, 3864505h,	37030483h, 0C641C301h
		dd 40CC541h, 4,	2Ch, 51Ch
		dd offset loc_80033E8-8006174h
		dd 96Ch, 80E4100h, 0D420285h, 3874605h,	5830486h, 0C3095F03h
		dd 0C741C641h, 40CC541h, 4, 2Ch, 54Ch
		dd offset loc_80033E8-8005838h
		dd 571h, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn __umoddi3:near	; CODE XREF: select_plural+27p
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+68r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+83p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+50p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn close_stdout:near	; CODE XREF: maybe_close_stdout+11p
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: maybe_close_stdout:loc_80001B9r
					; usage+26r ...
		extrn close_stream:near	; CODE XREF: maybe_close_stdout+21p
; void exit(int	status)
		extrn _exit:near	; CODE XREF: maybe_close_stdout+32p
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+31p	print_stats+C6p ...
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+312p quit+1Bp
		extrn gethrxtime:near	; CODE XREF: print_stats+17p
					; main:loc_80033C4p
; char *ngettext(const char *msgid1, const char	*msgid2, unsigned __int32 n)
		extrn ngettext:near	; CODE XREF: print_stats+111p
					; print_stats+19Ap
		extrn human_readable:near ; CODE XREF: print_stats+15Ep
					; print_stats+27Bp
		extrn __stack_chk_fail:near ; CODE XREF: print_stats+2EEp
					; install_signal_handlers+150p	...
; int close(int	fd)
		extrn close:near	; CODE XREF: cleanup+Ap cleanup+54p
		extrn quote:near	; CODE XREF: cleanup+1Fp cleanup+69p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: cleanup+3Bp
					; cleanup+85p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: cleanup+47p cleanup+91p ...
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: install_signal_handlers+1Fp
; int sigemptyset(sigset_t *set)
		extrn sigemptyset:near	; CODE XREF: install_signal_handlers+3Ap
; int sigaction_0(int sig, const struct	sigaction *act,	struct sigaction *oact)
		extrn sigaction_0:near	; CODE XREF: install_signal_handlers+59p
					; install_signal_handlers+8Cp ...
; int sigaddset(sigset_t *set, int signo)
		extrn sigaddset:near	; CODE XREF: install_signal_handlers+76p
					; install_signal_handlers+A9p
; int sigismember(const	sigset_t *set, int signo)
		extrn sigismember:near	; CODE XREF: install_signal_handlers+D3p
					; install_signal_handlers+110p
; int sigprocmask(int how, const sigset_t *set,	sigset_t *oset)
		extrn sigprocmask:near	; CODE XREF: process_signals+2Ap
					; process_signals+6Dp
; int raise(int	sig)
		extrn raise:near	; CODE XREF: process_signals+9Ap
; ssize_t read(int fd, void *buf, size_t nbytes)
		extrn read:near		; CODE XREF: iread+17p
		extrn rpl_fcntl:near	; CODE XREF: iwrite+36p iwrite+4Fp ...
		extrn lseek64:near	; CODE XREF: iwrite+9Cp
					; skip_via_lseek+4Fp ...
		extrn posix_fadvise64:near ; CODE XREF:	iwrite+C1p
; ssize_t write(int fd,	const void *buf, size_t	n)
		extrn write:near	; CODE XREF: iwrite+FFp
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: parse_symbols+16p
					; scanargs+48p
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: parse_symbols+4Bp
		extrn quotearg_n_style_mem:near	; CODE XREF: parse_symbols+60p
		extrn __udivdi3:near	; CODE XREF: parse_integer+A1p
					; skip+1B2p
		extrn xstrtoumax:near	; CODE XREF: parse_integer+34p
; int optind
		extrn optind:dword	; DATA XREF: scanargs+1Fr
; int toupper(int c)
		extrn toupper:near	; CODE XREF: apply_translations+46p
; int tolower(int c)
		extrn tolower:near	; CODE XREF: apply_translations+97p
; int ioctl(int	fd, unsigned __int32 request, ...)
		extrn ioctl:near	; CODE XREF: skip_via_lseek+33p
					; skip_via_lseek+78p
		extrn __divdi3:near	; CODE XREF: skip+97p main+411p
		extrn fstat64:near	; CODE XREF: skip+FEp set_fd_flags+7Bp ...
; void *memcpy(void *dest, const void *src, size_t n)
		extrn memcpy:near	; CODE XREF: copy_simple+3Bp
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: dd_copy+3Bp dd_copy+8Dp
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: dd_copy+21Fp dd_copy+336p ...
; int fdatasync(int fildes)
		extrn fdatasync:near	; CODE XREF: dd_copy+872p
; int fsync(int	fd)
		extrn fsync:near	; CODE XREF: dd_copy+944p
		extrn set_program_name:near ; CODE XREF: main+3Ep
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+65p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+75p
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+85p
; int getpagesize(void)
		extrn getpagesize:near	; CODE XREF: main+8Dp
		extrn Version:dword	; DATA XREF: main+97r
		extrn parse_long_options:near ;	CODE XREF: main+C8p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+EBp
		extrn fd_reopen:near	; CODE XREF: main+199p	main+31Fp ...
		extrn ftruncate64:near	; CODE XREF: main+47Bp


		end
