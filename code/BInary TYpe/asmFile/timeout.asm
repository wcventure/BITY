;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	6F1E4B66448667805FFFECBC7DB0435E
; Input	CRC32 :	EA76AC12

; File Name   :	D:\coreutils-o\timeout.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'timeout.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+73p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+137p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000FA
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000FA
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000FA:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl send_sig(int where, int sig)
send_sig	proc near		; CODE XREF: cleanup+4Dp cleanup+68p

where		= dword	ptr  8
sig		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+sig]
		mov	ds:sigs_to_ignore[eax*4], 1
		sub	esp, 8
		push	[ebp+sig]	; sig
		push	[ebp+where]	; pid
		call	kill
		add	esp, 10h
		leave
		retn
send_sig	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl cleanup(int sig)
cleanup		proc near		; DATA XREF: install_signal_handlers+29o

sig		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		cmp	[ebp+sig], 0Eh
		jnz	short loc_8000175
		mov	ds:timed_out, 1
		mov	eax, term_signal
		mov	[ebp+sig], eax

loc_8000175:				; CODE XREF: cleanup+Aj
		mov	eax, ds:monitored_pid
		test	eax, eax
		jz	short loc_80001C9
		mov	eax, [ebp+sig]
		mov	eax, ds:sigs_to_ignore[eax*4]
		test	eax, eax
		jz	short loc_800019C
		mov	eax, [ebp+sig]
		mov	ds:sigs_to_ignore[eax*4], 0
		jmp	short locret_80001D8
; ---------------------------------------------------------------------------

loc_800019C:				; CODE XREF: cleanup+33j
		sub	esp, 8
		push	[ebp+sig]	; sig
		push	0		; where
		call	send_sig
		add	esp, 10h
		cmp	[ebp+sig], 9
		jz	short locret_80001D8
		cmp	[ebp+sig], 12h
		jz	short locret_80001D8
		sub	esp, 8
		push	12h		; sig
		push	0		; where
		call	send_sig
		add	esp, 10h
		jmp	short locret_80001D8
; ---------------------------------------------------------------------------

loc_80001C9:				; CODE XREF: cleanup+25j
		mov	eax, [ebp+sig]
		sub	eax, 0FFFFFF80h
		sub	esp, 0Ch
		push	eax		; status
		call	_exit
; ---------------------------------------------------------------------------

locret_80001D8:				; CODE XREF: cleanup+43j cleanup+59j ...
		leave
		retn
cleanup		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+FAp main+104p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_8000215
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000316
; ---------------------------------------------------------------------------

loc_8000215:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOptionNu ; "Usage: %s [OPTION] NUMBER[SUFFIX] COMMA"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aStartCommandAn ; "Start	COMMAND, and kill it if	still run"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSSignalSignalS ; "  -s,	--signal=SIGNAL\n		 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfTheCommandTi ; "\nIf the command times out, then exit	w"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000316:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	apply_time_suffix(unsigned int *x, char	suffix_char)
apply_time_suffix proc near		; CODE XREF: main+19Fp

suffix_char	= byte ptr -14h
multiplier	= dword	ptr -4
x		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, [ebp+arg_4]
		mov	[ebp+suffix_char], al
		mov	[ebp+multiplier], 1
		movsx	eax, [ebp+suffix_char]
		cmp	eax, 68h
		jz	short loc_800036D
		cmp	eax, 68h
		jg	short loc_800034D
		test	eax, eax
		jz	short loc_8000357
		cmp	eax, 64h
		jz	short loc_800035E
		jmp	short loc_80003BA
; ---------------------------------------------------------------------------

loc_800034D:				; CODE XREF: apply_time_suffix+1Fj
		cmp	eax, 6Dh
		jz	short loc_800037F
		cmp	eax, 73h
		jnz	short loc_80003BA

loc_8000357:				; CODE XREF: apply_time_suffix+23j
		mov	eax, 1
		jmp	short locret_80003DD
; ---------------------------------------------------------------------------

loc_800035E:				; CODE XREF: apply_time_suffix+28j
		mov	edx, [ebp+multiplier]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 3
		mov	[ebp+multiplier], eax

loc_800036D:				; CODE XREF: apply_time_suffix+1Aj
		mov	eax, [ebp+multiplier]
		shl	eax, 2
		mov	edx, eax
		shl	edx, 4
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+multiplier], eax

loc_800037F:				; CODE XREF: apply_time_suffix+2Fj
		cmp	[ebp+multiplier], 4444444h
		jbe	short loc_800038F
		mov	eax, 0
		jmp	short locret_80003DD
; ---------------------------------------------------------------------------

loc_800038F:				; CODE XREF: apply_time_suffix+65j
		mov	eax, [ebp+multiplier]
		shl	eax, 2
		mov	edx, eax
		shl	edx, 4
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+multiplier], eax
		nop
		mov	eax, [ebp+x]
		mov	ecx, [eax]
		mov	eax, 0FFFFFFFFh
		mov	edx, 0
		div	[ebp+multiplier]
		cmp	ecx, eax
		jbe	short loc_80003C8
		jmp	short loc_80003C1
; ---------------------------------------------------------------------------

loc_80003BA:				; CODE XREF: apply_time_suffix+2Aj
					; apply_time_suffix+34j
		mov	eax, 0
		jmp	short locret_80003DD
; ---------------------------------------------------------------------------

loc_80003C1:				; CODE XREF: apply_time_suffix+97j
		mov	eax, 0
		jmp	short locret_80003DD
; ---------------------------------------------------------------------------

loc_80003C8:				; CODE XREF: apply_time_suffix+95j
		mov	eax, [ebp+x]
		mov	eax, [eax]
		imul	eax, [ebp+multiplier]
		mov	edx, eax
		mov	eax, [ebp+x]
		mov	[eax], edx
		mov	eax, 1

locret_80003DD:				; CODE XREF: apply_time_suffix+3Bj
					; apply_time_suffix+6Cj ...
		leave
		retn
apply_time_suffix endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl install_signal_handlers(int sigterm)
install_signal_handlers	proc near	; CODE XREF: main+227p

sa		= sigaction ptr	-98h
var_C		= dword	ptr -0Ch
sigterm		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 98h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		lea	eax, [ebp+sa]
		add	eax, 4
		push	eax		; set
		call	sigemptyset
		add	esp, 10h
		mov	dword ptr [ebp+sa.__sigaction_handler],	offset cleanup
		mov	[ebp+sa.sa_flags], 10000000h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	0Eh		; sig
		call	sigaction_0
		add	esp, 10h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	2		; sig
		call	sigaction_0
		add	esp, 10h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	3		; sig
		call	sigaction_0
		add	esp, 10h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	1		; sig
		call	sigaction_0
		add	esp, 10h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	0Fh		; sig
		call	sigaction_0
		add	esp, 10h
		sub	esp, 4
		push	0		; oact
		lea	eax, [ebp+sa]
		push	eax		; act
		push	[ebp+sigterm]	; sig
		call	sigaction_0
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80004B0
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80004B0:				; CODE XREF: install_signal_handlers+CAj
		leave
		retn
install_signal_handlers	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: bp-based frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -5Ch
timeout		= dword	ptr -54h
ep		= dword	ptr -50h
status		= dword	ptr -4Ch
var_48		= dword	ptr -48h
var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
c		= dword	ptr -38h
exit_status	= dword	ptr -34h
signame		= byte ptr -2Fh
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		push	ecx
		sub	esp, 5Ch
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	7Dh		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		sub	esp, 8
		push	offset aPBdraigBrady ; "Pádraig Brady"
		push	offset aPadraigBrady ; "Padraig	Brady"
		call	proper_name_utf8
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:Version
		push	0
		push	edx
		push	offset usage
		push	eax
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aTimeout	; "timeout"
		push	[ebp+argv]
		push	dword ptr [ebx]
		call	parse_long_options
		add	esp, 20h
		jmp	short loc_80005BB
; ---------------------------------------------------------------------------

loc_800057B:				; CODE XREF: main+12Cj
		mov	eax, [ebp+c]
		cmp	eax, 73h
		jnz	short loc_80005B1
		mov	eax, ds:optarg
		sub	esp, 8
		lea	edx, [ebp+signame]
		push	edx
		push	eax
		call	operand2sig
		add	esp, 10h
		mov	term_signal, eax
		mov	eax, term_signal
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_80005BB
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80005B1:				; CODE XREF: main+CFj
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80005BB:				; CODE XREF: main+C7j main+F3j
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "+s:"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_800057B
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 1
		jg	short loc_80005FA
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80005FA:				; CODE XREF: main+13Cj
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	0
		lea	edx, [ebp+timeout]
		push	edx
		push	0Ah
		lea	edx, [ebp+ep]
		push	edx
		push	eax
		call	xstrtoul
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000660
		mov	eax, [ebp+ep]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000640
		mov	eax, [ebp+ep]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000660

loc_8000640:				; CODE XREF: main+17Fj
		mov	eax, [ebp+ep]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; suffix_char
		lea	eax, [ebp+timeout]
		push	eax		; x
		call	apply_time_suffix
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80006A9

loc_8000660:				; CODE XREF: main+175j	main+18Cj
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidTimeInt ; "invalid time interval	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80006A9:				; CODE XREF: main+1ACj
		mov	eax, ds:optind
		add	eax, 1
		mov	ds:optind, eax
		mov	eax, ds:optind
		shl	eax, 2
		add	[ebp+argv], eax
		sub	esp, 8
		push	0		; pgid
		push	0		; pid
		call	setpgid
		add	esp, 10h
		mov	eax, term_signal
		sub	esp, 0Ch
		push	eax		; sigterm
		call	install_signal_handlers
		add	esp, 10h
		sub	esp, 8
		push	1		; handler
		push	15h		; sig
		call	signal
		add	esp, 10h
		sub	esp, 8
		push	1		; handler
		push	16h		; sig
		call	signal
		add	esp, 10h
		sub	esp, 8
		push	0		; handler
		push	11h		; sig
		call	signal
		add	esp, 10h
		call	fork
		mov	ds:monitored_pid, eax
		mov	eax, ds:monitored_pid
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000754
		sub	esp, 0Ch
		push	offset aForkSystemCall ; "fork system call failed"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 7Dh
		jmp	loc_80008CD
; ---------------------------------------------------------------------------

loc_8000754:				; CODE XREF: main+26Ej
		mov	eax, ds:monitored_pid
		test	eax, eax
		jnz	loc_80007EF
		sub	esp, 8
		push	0		; handler
		push	15h		; sig
		call	signal
		add	esp, 10h
		sub	esp, 8
		push	0		; handler
		push	16h		; sig
		call	signal
		add	esp, 10h
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+argv]	; argv
		push	eax		; file
		call	execvp
		add	esp, 10h
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jnz	short loc_80007A6
		mov	eax, 7Fh
		jmp	short loc_80007AB
; ---------------------------------------------------------------------------

loc_80007A6:				; CODE XREF: main+2EBj
		mov	eax, 7Eh

loc_80007AB:				; CODE XREF: main+2F2j
		mov	[ebp+exit_status], eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToRunCom ; "failed to run	command	%s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+exit_status]
		jmp	loc_80008CD
; ---------------------------------------------------------------------------

loc_80007EF:				; CODE XREF: main+2A9j
		mov	eax, [ebp+timeout]
		sub	esp, 0Ch
		push	eax		; seconds
		call	alarm
		add	esp, 10h
		lea	eax, [ebp+status]
		sub	esp, 0Ch
		push	eax		; stat_loc
		call	wait
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	short loc_8000843
		sub	esp, 0Ch
		push	offset aErrorWaitingFo ; "error	waiting	for command"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+status], 7Dh
		jmp	short loc_80008BA
; ---------------------------------------------------------------------------

loc_8000843:				; CODE XREF: main+35Ej
		mov	eax, [ebp+status]
		mov	[ebp+var_48], eax
		mov	eax, [ebp+var_48]
		and	eax, 7Fh
		test	eax, eax
		jnz	short loc_8000869
		mov	eax, [ebp+status]
		mov	[ebp+var_44], eax
		mov	eax, [ebp+var_44]
		and	eax, 0FF00h
		sar	eax, 8
		mov	[ebp+status], eax
		jmp	short loc_80008BA
; ---------------------------------------------------------------------------

loc_8000869:				; CODE XREF: main+39Fj
		mov	eax, [ebp+status]
		mov	[ebp+var_40], eax
		mov	eax, [ebp+var_40]
		and	eax, 7Fh
		add	eax, 1
		sar	al, 1
		test	al, al
		jle	short loc_8000892
		mov	eax, [ebp+status]
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+var_3C]
		and	eax, 7Fh
		sub	eax, 0FFFFFF80h
		mov	[ebp+status], eax
		jmp	short loc_80008BA
; ---------------------------------------------------------------------------

loc_8000892:				; CODE XREF: main+3CAj
		mov	ebx, [ebp+status]
		sub	esp, 0Ch
		push	offset aUnknownStatusF ; "unknown status from command (0x%X)"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+status], 1

loc_80008BA:				; CODE XREF: main+38Fj	main+3B5j ...
		mov	eax, ds:timed_out
		test	eax, eax
		jz	short loc_80008CA
		mov	eax, 7Ch
		jmp	short loc_80008CD
; ---------------------------------------------------------------------------

loc_80008CA:				; CODE XREF: main+40Fj
		mov	eax, [ebp+status]

loc_80008CD:				; CODE XREF: main+29Dj	main+338j ...
		mov	ecx, [ebp+var_1C]
		xor	ecx, large gs:14h
		jz	short loc_80008DE
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80008DE:				; CODE XREF: main+425j
		lea	esp, [ebp-0Ch]
		pop	ecx
		pop	ebx
		pop	esi
		pop	ebp
		lea	esp, [ecx-4]

locret_80008E8:				; DATA XREF: .eh_frame:08001098o
					; .eh_frame:080010B8o ...
		retn
main		endp

_text		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read/Write
_data		segment	dword public 'DATA' use32
		assume cs:_data
		;org 80008ECh
; int term_signal
term_signal	dd 0Fh			; DATA XREF: cleanup+16r main+E6w ...
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8000900h
		assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
; int timed_out
timed_out	dd ?			; DATA XREF: cleanup+Cw
					; main:loc_80008BAr
; int monitored_pid
monitored_pid	dd ?			; DATA XREF: cleanup:loc_8000175r
					; main+261w ...
		align 20h
; int sigs_to_ignore[65]
sigs_to_ignore	dd 41h dup(?)		; DATA XREF: send_sig+9w cleanup+2Ar ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000A40h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+51o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+B0o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aSignal		db 'signal',0           ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[2]
long_options	option <offset aSignal,	1, 0, 73h> ; DATA XREF:	main+10Eo
		option	<0>		; "signal"
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSOptionNu[]
aUsageSOptionNu	db 'Usage: %s [OPTION] NUMBER[SUFFIX] COMMAND [ARG]...',0Ah
					; DATA XREF: usage+4Ao
		db '  or:  %s [OPTION]',0Ah,0
		align 10h
; char aStartCommandAn[]
aStartCommandAn	db 'Start COMMAND, and kill it if still running after NUMBER seconds.'
					; DATA XREF: usage+6Eo
		db 0Ah
		db 'SUFFIX may be `s',27h,' for seconds (the default), `m',27h,' for minute'
		db 's,',0Ah
		db '`h',27h,' for hours or `d',27h,' for days.',0Ah
		db 0Ah,0
		align 4
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+91o
		db 'ns too.',0Ah,0
		align 10h
; char aSSignalSignalS[]
aSSignalSignalS	db '  -s, --signal=SIGNAL',0Ah ; DATA XREF: usage+B4o
		db '                   specify the signal to be sent on timeout.',0Ah
		db '                   SIGNAL may be a name like `HUP',27h,' or a number'
		db '.',0Ah
		db '                   See `kill -l` for a list of signals',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D7o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+FAo
		align 4
; char aIfTheCommandTi[]
aIfTheCommandTi	db 0Ah			; DATA XREF: usage+11Do
		db 'If the command times out, then exit with status 124.  Otherwise, '
		db 'exit',0Ah
		db 'with the status of COMMAND.  If no signal is specified, send the '
		db 'TERM',0Ah
		db 'signal upon timeout.  The TERM signal kills any process that does'
		db ' not',0Ah
		db 'block or catch that signal.  For other processes, it may be neces'
		db 'sary to',0Ah
		db 'use the KILL (9) signal, since this signal cannot be caught.',0Ah,0
; char locale
locale		db 0			; DATA XREF: main+3Ao
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+4Co
aPBdraigBrady	db 'Pádraig Brady',0   ; DATA XREF: main+8Eo
aPadraigBrady	db 'Padraig Brady',0    ; DATA XREF: main+93o
aTimeout	db 'timeout',0          ; DATA XREF: main+B5o
; char shortopts[]
shortopts	db '+s:',0              ; DATA XREF: main+113o
; char aInvalidTimeInt[]
aInvalidTimeInt	db 'invalid time interval %s',0 ; DATA XREF: main+1D2o
; char aForkSystemCall[]
aForkSystemCall	db 'fork system call failed',0 ; DATA XREF: main+273o
; char aFailedToRunCom[]
aFailedToRunCom	db 'failed to run command %s',0 ; DATA XREF: main+312o
; char aErrorWaitingFo[]
aErrorWaitingFo	db 'error waiting for command',0 ; DATA XREF: main+363o
; char aUnknownStatusF[]
aUnknownStatusF	db 'unknown status from command (0x%X)',0 ; DATA XREF: main+3E6o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8001078h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset locret_80008E8-8001980h
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 20h, 3Ch
		dd offset locret_80008E8-800198Ch
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset locret_80008E8-8001894h
		dd 27h,	80E4100h, 0D420285h, 0CC56305h,	404h, 1Ch, 80h
		dd offset locret_80008E8-800188Dh
		dd 83h,	80E4100h, 0D420285h, 0C57F0205h, 4040Ch, 1Ch, 0A0h
		dd offset locret_80008E8-800182Ah
		dd 147h, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 0C0h
		dd offset locret_80008E8-8001703h
		dd 0BEh, 80E4100h, 0D420285h, 0C5BA0205h, 4040Ch, 1Ch
		dd 0E0h
		dd offset locret_80008E8-8001665h
		dd 0D3h, 80E4100h, 0D420285h, 0C5CF0205h, 4040Ch, 38h
		dd 100h
		dd offset locret_80008E8-80015B2h
		dd 437h, 10C4400h, 5104700h, 45007502h,	7475030Fh, 2061006h
		dd 3107C75h, 3787502h, 0CC10420h, 0C3410001h, 0C541C641h
		dd 4040C43h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+41p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; int kill(__pid_t pid,	int sig)
		extrn kill:near		; CODE XREF: send_sig+1Dp
; void exit(int	status)
		extrn _exit:near	; CODE XREF: cleanup+7Cp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+142p
; int sigemptyset(sigset_t *set)
		extrn sigemptyset:near	; CODE XREF: install_signal_handlers+21p
; int sigaction_0(int sig, const struct	sigaction *act,	struct sigaction *oact)
		extrn sigaction_0:near	; CODE XREF: install_signal_handlers+48p
					; install_signal_handlers+5Ep ...
		extrn __stack_chk_fail:near ; CODE XREF: install_signal_handlers+CCp
					; main+427p
		extrn set_program_name:near ; CODE XREF: main+2Fp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+56p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+66p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+7Eo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+83p
		extrn proper_name_utf8:near ; CODE XREF: main+98p
		extrn Version:dword	; DATA XREF: main+A2r
		extrn parse_long_options:near ;	CODE XREF: main+BFp
; char *optarg
		extrn optarg:dword	; DATA XREF: main+D1r
		extrn operand2sig:near	; CODE XREF: main+DEp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+11Dp
; int optind
		extrn optind:dword	; DATA XREF: main+12Er
					; main:loc_80005FAr ...
		extrn xstrtoul:near	; CODE XREF: main+16Bp
		extrn quote:near	; CODE XREF: main+1C5p	main+305p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: main+1E5p	main+290p ...
; int setpgid(__pid_t pid, __pid_t pgid)
		extrn setpgid:near	; CODE XREF: main+216p
; __sighandler_t signal(int sig, __sighandler_t	handler)
		extrn signal:near	; CODE XREF: main+236p	main+245p ...
; __pid_t fork(void)
		extrn fork:near		; CODE XREF: main+25Cp
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: main+282p main+2E1p ...
; int execvp(const char	*file, char *const *argv)
		extrn execvp:near	; CODE XREF: main+2D9p
; unsigned int alarm(unsigned int seconds)
		extrn alarm:near	; CODE XREF: main+344p
; __pid_t wait(void *stat_loc)
		extrn wait:near		; CODE XREF: main+353p


		end
