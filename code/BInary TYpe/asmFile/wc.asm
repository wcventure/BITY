;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	C273D93B5431F22A43D980F13DA795B5
; Input	CRC32 :	B7DC6781

; File Name   :	D:\coreutils-o\wc.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'wc.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: wc+9E3p wc+A29p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+F1p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_basic(char c)
is_basic	proc near		; CODE XREF: wc+50Ap

c		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		movzx	eax, [ebp+c]
		shr	al, 5
		movzx	eax, al
		mov	edx, ds:is_basic_table[eax*4]
		movzx	eax, [ebp+c]
		movzx	eax, al
		and	eax, 1Fh
		mov	ecx, eax
		shr	edx, cl
		mov	eax, edx
		and	eax, 1
		test	eax, eax
		setnz	al
		leave
		retn
is_basic	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+1D2p	main+214p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_80001A0
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_800025B
; ---------------------------------------------------------------------------

loc_80001A0:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	[FILE]...\n  or: "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintNewlineWo ; "Print	newline, word, and byte	counts fo"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFiles0FromFRea ; "	--files0-from=F	   read	input fro"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_800025B:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl write_counts(uintmax_t lines, uintmax_t words, uintmax_t	chars, uintmax_t bytes,	uintmax_t linelength, const char *file)
write_counts	proc near		; CODE XREF: wc+B5Ap main+93Fp

file		= dword	ptr -54h
linelength	= qword	ptr -50h
bytes		= qword	ptr -48h
chars		= qword	ptr -40h
words		= qword	ptr -38h
lines		= qword	ptr -30h
format_int	= dword	ptr -28h
buf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h
arg_14		= dword	ptr  1Ch
arg_18		= dword	ptr  20h
arg_1C		= dword	ptr  24h
arg_20		= dword	ptr  28h
arg_24		= dword	ptr  2Ch
arg_28		= dword	ptr  30h

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	eax, [ebp+arg_0]
		mov	dword ptr [ebp+lines], eax
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+lines+4], eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+words], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+words+4], eax
		mov	eax, [ebp+arg_10]
		mov	dword ptr [ebp+chars], eax
		mov	eax, [ebp+arg_14]
		mov	dword ptr [ebp+chars+4], eax
		mov	eax, [ebp+arg_18]
		mov	dword ptr [ebp+bytes], eax
		mov	eax, [ebp+arg_1C]
		mov	dword ptr [ebp+bytes+4], eax
		mov	eax, [ebp+arg_20]
		mov	dword ptr [ebp+linelength], eax
		mov	eax, [ebp+arg_24]
		mov	dword ptr [ebp+linelength+4], eax
		mov	eax, [ebp+arg_28]
		mov	[ebp+file], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+format_int], (offset format_sp_int_5810+1)	; "%*s"
		movzx	eax, ds:print_lines
		test	al, al
		jz	short loc_80002FE
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+lines+4]
		push	dword ptr [ebp+lines]
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:number_width
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+format_int] ; format
		call	printf
		add	esp, 10h
		mov	[ebp+format_int], offset format_sp_int_5810 ; "	%*s"

loc_80002FE:				; CODE XREF: write_counts+63j
		movzx	eax, ds:print_words
		test	al, al
		jz	short loc_800033C
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+words+4]
		push	dword ptr [ebp+words]
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:number_width
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+format_int] ; format
		call	printf
		add	esp, 10h
		mov	[ebp+format_int], offset format_sp_int_5810 ; "	%*s"

loc_800033C:				; CODE XREF: write_counts+A1j
		movzx	eax, ds:print_chars
		test	al, al
		jz	short loc_800037A
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+chars+4]
		push	dword ptr [ebp+chars]
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:number_width
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+format_int] ; format
		call	printf
		add	esp, 10h
		mov	[ebp+format_int], offset format_sp_int_5810 ; "	%*s"

loc_800037A:				; CODE XREF: write_counts+DFj
		movzx	eax, ds:print_bytes
		test	al, al
		jz	short loc_80003B8
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+bytes+4]
		push	dword ptr [ebp+bytes]
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:number_width
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+format_int] ; format
		call	printf
		add	esp, 10h
		mov	[ebp+format_int], offset format_sp_int_5810 ; "	%*s"

loc_80003B8:				; CODE XREF: write_counts+11Dj
		movzx	eax, ds:print_linelength
		test	al, al
		jz	short loc_80003EF
		sub	esp, 4
		lea	eax, [ebp+buf]
		push	eax
		push	dword ptr [ebp+linelength+4]
		push	dword ptr [ebp+linelength]
		call	umaxtostr
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:number_width
		sub	esp, 4
		push	edx
		push	eax
		push	[ebp+format_int] ; format
		call	printf
		add	esp, 10h

loc_80003EF:				; CODE XREF: write_counts+15Bj
		cmp	[ebp+file], 0
		jz	short loc_8000408
		sub	esp, 8
		push	[ebp+file]
		push	offset format	; " %s"
		call	printf
		add	esp, 10h

loc_8000408:				; CODE XREF: write_counts+18Dj
		sub	esp, 0Ch
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_8000427
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000427:				; CODE XREF: write_counts+1BAj
		leave
		retn
write_counts	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wc(int fd, const char *file_x, fstatus *fstatus)
wc		proc near		; CODE XREF: wc_file+35p wc_file+88p

var_40B8	= dword	ptr -40B8h
var_40B4	= dword	ptr -40B4h
fstatus		= dword	ptr -40B0h
file_x		= dword	ptr -40ACh
ok		= byte ptr -40A3h
count_bytes	= byte ptr -40A2h
count_chars	= byte ptr -40A1h
in_word		= byte ptr -40A0h
in_shift	= byte ptr -409Fh
in_word_0	= byte ptr -409Eh
count_complicated= byte	ptr -409Dh
wide_char	= dword	ptr -409Ch
bytes_read	= dword	ptr -4098h
p		= dword	ptr -4094h
prev		= dword	ptr -4090h
p_0		= dword	ptr -408Ch
n		= dword	ptr -4088h
p_1		= dword	ptr -4084h
file		= dword	ptr -4080h
width		= dword	ptr -407Ch
lines		= qword	ptr -4078h
words		= qword	ptr -4070h
chars		= qword	ptr -4068h
bytes		= qword	ptr -4060h
linelength	= qword	ptr -4058h
linepos		= qword	ptr -4050h
linepos_0	= qword	ptr -4048h
current_pos	= qword	ptr -4040h
end_pos		= qword	ptr -4038h
state		= mbstate_t ptr	-4030h
backup_state	= mbstate_t ptr	-4028h
buf		= byte ptr -401Dh
var_1C		= dword	ptr -1Ch
fd		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 40ACh
		mov	eax, [ebp+arg_4]
		mov	[ebp+file_x], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+fstatus], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+ok], 1
		cmp	[ebp+file_x], 0
		jnz	short loc_8000474
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		jmp	short loc_800047A
; ---------------------------------------------------------------------------

loc_8000474:				; CODE XREF: wc+37j
		mov	eax, [ebp+file_x]

loc_800047A:				; CODE XREF: wc+49j
		mov	[ebp+file], eax
		mov	dword ptr [ebp+linelength], 0
		mov	dword ptr [ebp+linelength+4], 0
		mov	eax, dword ptr [ebp+linelength]
		mov	edx, dword ptr [ebp+linelength+4]
		mov	dword ptr [ebp+bytes], eax
		mov	dword ptr [ebp+bytes+4], edx
		mov	eax, dword ptr [ebp+bytes]
		mov	edx, dword ptr [ebp+bytes+4]
		mov	dword ptr [ebp+chars], eax
		mov	dword ptr [ebp+chars+4], edx
		mov	eax, dword ptr [ebp+chars]
		mov	edx, dword ptr [ebp+chars+4]
		mov	dword ptr [ebp+words], eax
		mov	dword ptr [ebp+words+4], edx
		mov	eax, dword ptr [ebp+words]
		mov	edx, dword ptr [ebp+words+4]
		mov	dword ptr [ebp+lines], eax
		mov	dword ptr [ebp+lines+4], edx
		call	__ctype_get_mb_cur_max
		cmp	eax, 1
		jbe	short loc_800051A
		movzx	eax, ds:print_bytes
		mov	[ebp+count_bytes], al
		movzx	eax, ds:print_chars
		mov	[ebp+count_chars], al
		jmp	short loc_8000550
; ---------------------------------------------------------------------------

loc_800051A:				; CODE XREF: wc+D3j
		movzx	eax, ds:print_bytes
		test	al, al
		jnz	short loc_8000530
		movzx	eax, ds:print_chars
		test	al, al
		jz	short loc_8000537

loc_8000530:				; CODE XREF: wc+FAj
		mov	eax, 1
		jmp	short loc_800053C
; ---------------------------------------------------------------------------

loc_8000537:				; CODE XREF: wc+105j
		mov	eax, 0

loc_800053C:				; CODE XREF: wc+10Cj
		mov	[ebp+count_bytes], al
		and	[ebp+count_bytes], 1
		mov	[ebp+count_chars], 0

loc_8000550:				; CODE XREF: wc+EFj
		movzx	eax, ds:print_words
		test	al, al
		jnz	short loc_8000566
		movzx	eax, ds:print_linelength
		test	al, al
		jz	short loc_800056D

loc_8000566:				; CODE XREF: wc+130j
		mov	eax, 1
		jmp	short loc_8000572
; ---------------------------------------------------------------------------

loc_800056D:				; CODE XREF: wc+13Bj
		mov	eax, 0

loc_8000572:				; CODE XREF: wc+142j
		mov	[ebp+count_complicated], al
		and	[ebp+count_complicated], 1
		cmp	[ebp+count_bytes], 0
		jz	loc_800075E
		movzx	eax, [ebp+count_chars]
		xor	eax, 1
		test	al, al
		jz	loc_800075E
		movzx	eax, ds:print_lines
		xor	eax, 1
		test	al, al
		jz	loc_800075E
		movzx	eax, [ebp+count_complicated]
		xor	eax, 1
		test	al, al
		jz	loc_800075E
		mov	eax, [ebp+fstatus]
		mov	eax, [eax]
		test	eax, eax
		jle	short loc_80005F0
		mov	eax, [ebp+fstatus]
		add	eax, 4
		sub	esp, 8
		push	eax
		push	[ebp+fd]
		call	fstat64
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+fstatus]
		mov	[eax], edx

loc_80005F0:				; CODE XREF: wc+1A3j
		mov	eax, [ebp+fstatus]
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_800072B
		mov	eax, [ebp+fstatus]
		mov	eax, [eax+14h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_800072B
		push	1
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+current_pos], eax
		mov	dword ptr [ebp+current_pos+4], edx
		mov	eax, dword ptr [ebp+current_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+current_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	loc_800072B
		push	2
		push	0
		push	0
		push	[ebp+fd]
		call	lseek64
		add	esp, 10h
		mov	dword ptr [ebp+end_pos], eax
		mov	dword ptr [ebp+end_pos+4], edx
		mov	eax, dword ptr [ebp+end_pos+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+end_pos]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jz	loc_800072B
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		cmp	edx, dword ptr [ebp+current_pos+4]
		jl	short loc_80006CD
		cmp	edx, dword ptr [ebp+current_pos+4]
		jg	short loc_80006B3
		cmp	eax, dword ptr [ebp+current_pos]
		jb	short loc_80006CD

loc_80006B3:				; CODE XREF: wc+280j
		mov	eax, dword ptr [ebp+end_pos]
		mov	edx, dword ptr [ebp+end_pos+4]
		sub	eax, dword ptr [ebp+current_pos]
		sbb	edx, dword ptr [ebp+current_pos+4]
		jmp	short loc_80006D7
; ---------------------------------------------------------------------------

loc_80006CD:				; CODE XREF: wc+278j wc+288j
		mov	eax, 0
		mov	edx, 0

loc_80006D7:				; CODE XREF: wc+2A2j
		mov	dword ptr [ebp+bytes], eax
		mov	dword ptr [ebp+bytes+4], edx
		jmp	short loc_8000759
; ---------------------------------------------------------------------------

loc_80006E5:				; CODE XREF: wc+329j
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8000714
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	short loc_8000759
; ---------------------------------------------------------------------------

loc_8000714:				; CODE XREF: wc+2C3j
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+bytes], eax
		adc	dword ptr [ebp+bytes+4], edx

loc_800072B:				; CODE XREF: wc+1D1j wc+1EAj ...
		sub	esp, 4
		push	4000h
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	short loc_80006E5
		jmp	loc_8000F11
; ---------------------------------------------------------------------------

loc_8000759:				; CODE XREF: wc+2BAj wc+2E9j
		jmp	loc_8000F11
; ---------------------------------------------------------------------------

loc_800075E:				; CODE XREF: wc+15Dj wc+16Fj ...
		movzx	eax, [ebp+count_chars]
		xor	eax, 1
		test	al, al
		jz	loc_8000861
		movzx	eax, [ebp+count_complicated]
		xor	eax, 1
		test	al, al
		jz	loc_8000861
		jmp	loc_800082F
; ---------------------------------------------------------------------------

loc_8000787:				; CODE XREF: wc+42Dj
		lea	eax, [ebp+buf]
		mov	[ebp+p], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_80007DB
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		nop
		jmp	loc_8000F11
; ---------------------------------------------------------------------------

loc_80007C6:				; CODE XREF: wc+3EDj
		add	[ebp+p], 1
		add	dword ptr [ebp+lines], 1
		adc	dword ptr [ebp+lines+4], 0

loc_80007DB:				; CODE XREF: wc+371j
		lea	edx, [ebp+buf]
		mov	eax, [ebp+bytes_read]
		add	eax, edx
		mov	edx, eax
		mov	eax, [ebp+p]
		sub	edx, eax
		mov	eax, edx
		sub	esp, 4
		push	eax		; n
		push	0Ah		; c
		push	[ebp+p]		; s
		call	memchr
		add	esp, 10h
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	short loc_80007C6
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+bytes], eax
		adc	dword ptr [ebp+bytes+4], edx

loc_800082F:				; CODE XREF: wc+359j
		sub	esp, 4
		push	4000h
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	loc_8000787
		jmp	loc_8000F11
; ---------------------------------------------------------------------------

loc_8000861:				; CODE XREF: wc+341j wc+353j
		call	__ctype_get_mb_cur_max
		cmp	eax, 1
		jbe	loc_8000C90
		mov	[ebp+in_word], 0
		mov	dword ptr [ebp+linepos], 0
		mov	dword ptr [ebp+linepos+4], 0
		mov	[ebp+state.__count], 0
		mov	dword ptr [ebp+state.__value], 0
		mov	[ebp+in_shift],	0
		mov	[ebp+prev], 0
		jmp	loc_8000BFB
; ---------------------------------------------------------------------------

loc_80008B4:				; CODE XREF: wc+808j
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_80008E6
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	loc_8000C37
; ---------------------------------------------------------------------------

loc_80008E6:				; CODE XREF: wc+492j
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+bytes], eax
		adc	dword ptr [ebp+bytes+4], edx
		lea	eax, [ebp+buf]
		mov	[ebp+p_0], eax
		mov	eax, [ebp+prev]
		add	[ebp+bytes_read], eax

loc_8000915:				; CODE XREF: wc+77Fj
		movzx	eax, [ebp+in_shift]
		xor	eax, 1
		test	al, al
		jz	short loc_8000960
		mov	eax, [ebp+p_0]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	is_basic
		add	esp, 10h
		test	al, al
		jz	short loc_8000960
		mov	[ebp+n], 1
		mov	eax, [ebp+p_0]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+wide_char], eax
		jmp	loc_8000A23
; ---------------------------------------------------------------------------

loc_8000960:				; CODE XREF: wc+4F8j wc+514j
		mov	[ebp+in_shift],	1
		mov	eax, [ebp+state.__count]
		mov	edx, dword ptr [ebp+state.__value]
		mov	[ebp+backup_state.__count], eax
		mov	dword ptr [ebp+backup_state.__value], edx
		lea	eax, [ebp+state]
		push	eax		; p
		push	[ebp+bytes_read] ; n
		push	[ebp+p_0]	; s
		lea	eax, [ebp+wide_char]
		push	eax		; pwc
		call	mbrtowc
		add	esp, 10h
		mov	[ebp+n], eax
		cmp	[ebp+n], 0FFFFFFFEh
		jnz	short loc_80009CD
		mov	eax, [ebp+backup_state.__count]
		mov	edx, dword ptr [ebp+backup_state.__value]
		mov	[ebp+state.__count], eax
		mov	dword ptr [ebp+state.__value], edx
		jmp	loc_8000BAE
; ---------------------------------------------------------------------------

loc_80009CD:				; CODE XREF: wc+585j
		cmp	[ebp+n], 0FFFFFFFFh
		jnz	short loc_80009E9
		add	[ebp+p_0], 1
		sub	[ebp+bytes_read], 1
		jmp	loc_8000BA1
; ---------------------------------------------------------------------------

loc_80009E9:				; CODE XREF: wc+5ABj
		sub	esp, 0Ch
		lea	eax, [ebp+state]
		push	eax		; ps
		call	mbsinit
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000A06
		mov	[ebp+in_shift],	0

loc_8000A06:				; CODE XREF: wc+5D4j
		cmp	[ebp+n], 0
		jnz	short loc_8000A23
		mov	[ebp+wide_char], 0
		mov	[ebp+n], 1

loc_8000A23:				; CODE XREF: wc+532j wc+5E4j
		mov	eax, [ebp+n]
		add	[ebp+p_0], eax
		mov	eax, [ebp+n]
		sub	[ebp+bytes_read], eax
		add	dword ptr [ebp+chars], 1
		adc	dword ptr [ebp+chars+4], 0
		mov	eax, [ebp+wide_char]
		sub	eax, 9		; switch 24 cases
		cmp	eax, 17h
		ja	loc_8000B34	; jumptable 08000A62 default case
		mov	eax, ds:off_8002308[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000A64:				; CODE XREF: wc+639j
					; DATA XREF: .rodata:off_8002308o
		add	dword ptr [ebp+lines], 1 ; jumptable 08000A62 case 10
		adc	dword ptr [ebp+lines+4], 0

loc_8000A72:				; CODE XREF: wc+639j
					; DATA XREF: .rodata:off_8002308o
		mov	eax, dword ptr [ebp+linepos] ; jumptable 08000A62 cases	12,13
		mov	edx, dword ptr [ebp+linepos+4]
		cmp	edx, dword ptr [ebp+linelength+4]
		jb	short loc_8000AAE
		cmp	edx, dword ptr [ebp+linelength+4]
		ja	short loc_8000A96
		cmp	eax, dword ptr [ebp+linelength]
		jbe	short loc_8000AAE

loc_8000A96:				; CODE XREF: wc+663j
		mov	eax, dword ptr [ebp+linepos]
		mov	edx, dword ptr [ebp+linepos+4]
		mov	dword ptr [ebp+linelength], eax
		mov	dword ptr [ebp+linelength+4], edx

loc_8000AAE:				; CODE XREF: wc+65Bj wc+66Bj
		mov	dword ptr [ebp+linepos], 0
		mov	dword ptr [ebp+linepos+4], 0
		jmp	short mb_word_separator	; jumptable 08000A62 case 11
; ---------------------------------------------------------------------------

loc_8000AC4:				; CODE XREF: wc+639j
					; DATA XREF: .rodata:off_8002308o
		mov	eax, dword ptr [ebp+linepos] ; jumptable 08000A62 case 9
		and	eax, 0FFFFFFF8h
		mov	[ebp+var_40B8],	eax
		mov	eax, dword ptr [ebp+linepos+4]
		and	ah, 0FFh
		mov	[ebp+var_40B4],	eax
		mov	eax, [ebp+var_40B8]
		mov	edx, [ebp+var_40B4]
		add	eax, 8
		adc	edx, 0
		mov	dword ptr [ebp+linepos], eax
		mov	dword ptr [ebp+linepos+4], edx
		jmp	short mb_word_separator	; jumptable 08000A62 case 11
; ---------------------------------------------------------------------------

loc_8000B02:				; CODE XREF: wc+639j
					; DATA XREF: .rodata:off_8002308o
		add	dword ptr [ebp+linepos], 1 ; jumptable 08000A62	case 32
		adc	dword ptr [ebp+linepos+4], 0
		jmp	short mb_word_separator	; jumptable 08000A62 case 11
; ---------------------------------------------------------------------------

loc_8000B12:				; CODE XREF: wc+769j
		nop

mb_word_separator:			; CODE XREF: wc+639j wc+699j ...
		movzx	eax, [ebp+in_word] ; jumptable 08000A62	case 11
		mov	edx, 0
		add	dword ptr [ebp+words], eax
		adc	dword ptr [ebp+words+4], edx
		mov	[ebp+in_word], 0
		jmp	short loc_8000BA1
; ---------------------------------------------------------------------------

loc_8000B34:				; CODE XREF: wc+62Cj wc+639j
					; DATA XREF: ...
		mov	eax, [ebp+wide_char] ; jumptable 08000A62 default case
		sub	esp, 0Ch
		push	eax		; wc
		call	iswprint
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000BA0
		mov	eax, [ebp+wide_char]
		sub	esp, 0Ch
		push	eax
		call	wcwidth
		add	esp, 10h
		mov	[ebp+width], eax
		cmp	[ebp+width], 0
		jle	short loc_8000B7E
		mov	eax, [ebp+width]
		cdq
		add	dword ptr [ebp+linepos], eax
		adc	dword ptr [ebp+linepos+4], edx

loc_8000B7E:				; CODE XREF: wc+740j
		mov	eax, [ebp+wide_char]
		sub	esp, 0Ch
		push	eax		; wc
		call	iswspace
		add	esp, 10h
		test	eax, eax
		jnz	loc_8000B12
		mov	[ebp+in_word], 1
		nop

loc_8000BA0:				; CODE XREF: wc+71Fj
		nop

loc_8000BA1:				; CODE XREF: wc+5BBj wc+709j
		cmp	[ebp+bytes_read], 0
		jnz	loc_8000915

loc_8000BAE:				; CODE XREF: wc+59Fj
		cmp	[ebp+bytes_read], 0
		jz	short loc_8000BEF
		cmp	[ebp+bytes_read], 4000h
		jnz	short loc_8000BD1
		add	[ebp+p_0], 1
		sub	[ebp+bytes_read], 1

loc_8000BD1:				; CODE XREF: wc+798j
		sub	esp, 4
		push	[ebp+bytes_read] ; n
		push	[ebp+p_0]	; src
		lea	eax, [ebp+buf]
		push	eax		; dest
		call	memmove
		add	esp, 10h

loc_8000BEF:				; CODE XREF: wc+78Cj
		mov	eax, [ebp+bytes_read]
		mov	[ebp+prev], eax

loc_8000BFB:				; CODE XREF: wc+486j
		mov	eax, 4000h
		sub	eax, [ebp+prev]
		lea	ecx, [ebp+buf]
		mov	edx, [ebp+prev]
		add	edx, ecx
		sub	esp, 4
		push	eax
		push	edx
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	loc_80008B4

loc_8000C37:				; CODE XREF: wc+4B8j
		mov	eax, dword ptr [ebp+linepos]
		mov	edx, dword ptr [ebp+linepos+4]
		cmp	edx, dword ptr [ebp+linelength+4]
		jb	short loc_8000C73
		cmp	edx, dword ptr [ebp+linelength+4]
		ja	short loc_8000C5B
		cmp	eax, dword ptr [ebp+linelength]
		jbe	short loc_8000C73

loc_8000C5B:				; CODE XREF: wc+828j
		mov	eax, dword ptr [ebp+linepos]
		mov	edx, dword ptr [ebp+linepos+4]
		mov	dword ptr [ebp+linelength], eax
		mov	dword ptr [ebp+linelength+4], edx

loc_8000C73:				; CODE XREF: wc+820j wc+830j
		movzx	eax, [ebp+in_word]
		mov	edx, 0
		add	dword ptr [ebp+words], eax
		adc	dword ptr [ebp+words+4], edx
		jmp	loc_8000F11
; ---------------------------------------------------------------------------

loc_8000C90:				; CODE XREF: wc+440j
		mov	[ebp+in_word_0], 0
		mov	dword ptr [ebp+linepos_0], 0
		mov	dword ptr [ebp+linepos_0+4], 0
		jmp	loc_8000E90
; ---------------------------------------------------------------------------

loc_8000CB0:				; CODE XREF: wc+A8Ej
		lea	eax, [ebp+buf]
		mov	[ebp+p_1], eax
		cmp	[ebp+bytes_read], 0FFFFFFFFh
		jnz	short loc_8000CEE
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+ok], 0
		jmp	loc_8000EBD
; ---------------------------------------------------------------------------

loc_8000CEE:				; CODE XREF: wc+89Aj
		mov	eax, [ebp+bytes_read]
		mov	edx, 0
		add	dword ptr [ebp+bytes], eax
		adc	dword ptr [ebp+bytes+4], edx

loc_8000D05:				; CODE XREF: wc+A61j
		mov	eax, [ebp+p_1]
		lea	edx, [eax+1]
		mov	[ebp+p_1], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 9		; switch 24 cases
		cmp	eax, 17h
		ja	loc_8000DF2	; jumptable 08000D2D default case
		mov	eax, ds:off_8002368[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000D2F:				; CODE XREF: wc+904j
					; DATA XREF: .rodata:off_8002368o
		add	dword ptr [ebp+lines], 1 ; jumptable 08000D2D case 10
		adc	dword ptr [ebp+lines+4], 0

loc_8000D3D:				; CODE XREF: wc+904j
					; DATA XREF: .rodata:off_8002368o
		mov	eax, dword ptr [ebp+linepos_0] ; jumptable 08000D2D cases 12,13
		mov	edx, dword ptr [ebp+linepos_0+4]
		cmp	edx, dword ptr [ebp+linelength+4]
		jb	short loc_8000D79
		cmp	edx, dword ptr [ebp+linelength+4]
		ja	short loc_8000D61
		cmp	eax, dword ptr [ebp+linelength]
		jbe	short loc_8000D79

loc_8000D61:				; CODE XREF: wc+92Ej
		mov	eax, dword ptr [ebp+linepos_0]
		mov	edx, dword ptr [ebp+linepos_0+4]
		mov	dword ptr [ebp+linelength], eax
		mov	dword ptr [ebp+linelength+4], edx

loc_8000D79:				; CODE XREF: wc+926j wc+936j
		mov	dword ptr [ebp+linepos_0], 0
		mov	dword ptr [ebp+linepos_0+4], 0
		jmp	short loc_8000DCE ; jumptable 08000D2D case 11
; ---------------------------------------------------------------------------

loc_8000D8F:				; CODE XREF: wc+904j
					; DATA XREF: .rodata:off_8002368o
		mov	eax, dword ptr [ebp+linepos_0] ; jumptable 08000D2D case 9
		and	eax, 0FFFFFFF8h
		mov	ebx, eax
		mov	eax, dword ptr [ebp+linepos_0+4]
		and	ah, 0FFh
		mov	esi, eax
		mov	eax, ebx
		mov	edx, esi
		add	eax, 8
		adc	edx, 0
		mov	dword ptr [ebp+linepos_0], eax
		mov	dword ptr [ebp+linepos_0+4], edx
		jmp	short loc_8000DCE ; jumptable 08000D2D case 11
; ---------------------------------------------------------------------------

loc_8000DBD:				; CODE XREF: wc+904j
					; DATA XREF: .rodata:off_8002368o
		add	dword ptr [ebp+linepos_0], 1 ; jumptable 08000D2D case 32
		adc	dword ptr [ebp+linepos_0+4], 0
		jmp	short loc_8000DCE ; jumptable 08000D2D case 11
; ---------------------------------------------------------------------------

loc_8000DCD:				; CODE XREF: wc+A45j
		nop

loc_8000DCE:				; CODE XREF: wc+904j wc+964j ...
		movzx	eax, [ebp+in_word_0] ; jumptable 08000D2D case 11
		mov	edx, 0
		add	dword ptr [ebp+words], eax
		adc	dword ptr [ebp+words+4], edx
		mov	[ebp+in_word_0], 0
		jmp	loc_8000E7C
; ---------------------------------------------------------------------------

loc_8000DF2:				; CODE XREF: wc+8F7j wc+904j
					; DATA XREF: ...
		call	__ctype_b_loc	; jumptable 08000D2D default case
		mov	edi, [eax]
		mov	eax, [ebp+p_1]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, edi
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_8000E7B
		add	dword ptr [ebp+linepos_0], 1
		adc	dword ptr [ebp+linepos_0+4], 0
		call	__ctype_b_loc
		mov	edi, [eax]
		mov	eax, [ebp+p_1]
		sub	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, edi
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 2000h
		test	eax, eax
		jnz	loc_8000DCD
		mov	[ebp+in_word_0], 1

loc_8000E7B:				; CODE XREF: wc+9FFj
		nop

loc_8000E7C:				; CODE XREF: wc+9C4j
		sub	[ebp+bytes_read], 1
		cmp	[ebp+bytes_read], 0
		jnz	loc_8000D05

loc_8000E90:				; CODE XREF: wc+882j
		sub	esp, 4
		push	4000h
		lea	eax, [ebp+buf]
		push	eax
		push	[ebp+fd]
		call	safe_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jnz	loc_8000CB0

loc_8000EBD:				; CODE XREF: wc+8C0j
		mov	eax, dword ptr [ebp+linepos_0]
		mov	edx, dword ptr [ebp+linepos_0+4]
		cmp	edx, dword ptr [ebp+linelength+4]
		jb	short loc_8000EF9
		cmp	edx, dword ptr [ebp+linelength+4]
		ja	short loc_8000EE1
		cmp	eax, dword ptr [ebp+linelength]
		jbe	short loc_8000EF9

loc_8000EE1:				; CODE XREF: wc+AAEj
		mov	eax, dword ptr [ebp+linepos_0]
		mov	edx, dword ptr [ebp+linepos_0+4]
		mov	dword ptr [ebp+linelength], eax
		mov	dword ptr [ebp+linelength+4], edx

loc_8000EF9:				; CODE XREF: wc+AA6j wc+AB6j
		movzx	eax, [ebp+in_word_0]
		mov	edx, 0
		add	dword ptr [ebp+words], eax
		adc	dword ptr [ebp+words+4], edx

loc_8000F11:				; CODE XREF: wc+32Bj wc:loc_8000759j ...
		movzx	edx, [ebp+count_chars]
		movzx	eax, ds:print_chars
		movzx	eax, al
		cmp	edx, eax
		jge	short loc_8000F3E
		mov	eax, dword ptr [ebp+bytes]
		mov	edx, dword ptr [ebp+bytes+4]
		mov	dword ptr [ebp+chars], eax
		mov	dword ptr [ebp+chars+4], edx

loc_8000F3E:				; CODE XREF: wc+AFBj
		sub	esp, 4
		push	[ebp+file_x]	; file
		push	dword ptr [ebp+linelength+4]
		push	dword ptr [ebp+linelength] ; linelength
		push	dword ptr [ebp+bytes+4]
		push	dword ptr [ebp+bytes] ;	bytes
		push	dword ptr [ebp+chars+4]
		push	dword ptr [ebp+chars] ;	chars
		push	dword ptr [ebp+words+4]
		push	dword ptr [ebp+words] ;	words
		push	dword ptr [ebp+lines+4]
		push	dword ptr [ebp+lines] ;	lines
		call	write_counts
		add	esp, 30h
		mov	ecx, dword ptr ds:total_lines
		mov	ebx, dword ptr ds:total_lines+4
		mov	eax, dword ptr [ebp+lines]
		mov	edx, dword ptr [ebp+lines+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:total_lines, eax
		mov	dword ptr ds:total_lines+4, edx
		mov	ecx, dword ptr ds:total_words
		mov	ebx, dword ptr ds:total_words+4
		mov	eax, dword ptr [ebp+words]
		mov	edx, dword ptr [ebp+words+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:total_words, eax
		mov	dword ptr ds:total_words+4, edx
		mov	ecx, dword ptr ds:total_chars
		mov	ebx, dword ptr ds:total_chars+4
		mov	eax, dword ptr [ebp+chars]
		mov	edx, dword ptr [ebp+chars+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:total_chars, eax
		mov	dword ptr ds:total_chars+4, edx
		mov	ecx, dword ptr ds:total_bytes
		mov	ebx, dword ptr ds:total_bytes+4
		mov	eax, dword ptr [ebp+bytes]
		mov	edx, dword ptr [ebp+bytes+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr ds:total_bytes, eax
		mov	dword ptr ds:total_bytes+4, edx
		mov	eax, dword ptr ds:max_line_length
		mov	edx, dword ptr ds:max_line_length+4
		cmp	dword ptr [ebp+linelength+4], edx
		jb	short loc_8001061
		cmp	dword ptr [ebp+linelength+4], edx
		ja	short loc_800104A
		cmp	dword ptr [ebp+linelength], eax
		jbe	short loc_8001061

loc_800104A:				; CODE XREF: wc+C17j
		mov	eax, dword ptr [ebp+linelength]
		mov	edx, dword ptr [ebp+linelength+4]
		mov	dword ptr ds:max_line_length, eax
		mov	dword ptr ds:max_line_length+4,	edx

loc_8001061:				; CODE XREF: wc+C0Fj wc+C1Fj
		movzx	eax, [ebp+ok]
		mov	esi, [ebp+var_1C]
		xor	esi, large gs:14h
		jz	short loc_8001079
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001079:				; CODE XREF: wc+C49j
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
wc		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	wc_file(const char *file, fstatus *fstatus)
wc_file		proc near		; CODE XREF: main+807p	main+85Bp

ok		= byte ptr -0Dh
fd		= dword	ptr -0Ch
file		= dword	ptr  8
fstatus		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		cmp	[ebp+file], 0
		jz	short loc_80010A4
		sub	esp, 8
		push	offset asc_80023C8 ; "-"
		push	[ebp+file]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80010C3

loc_80010A4:				; CODE XREF: wc_file+Aj
		mov	ds:have_read_stdin, 1
		sub	esp, 4
		push	[ebp+fstatus]	; fstatus
		push	[ebp+file]	; file_x
		push	0		; fd
		call	wc
		add	esp, 10h
		jmp	locret_800114B
; ---------------------------------------------------------------------------

loc_80010C3:				; CODE XREF: wc_file+21j
		sub	esp, 8
		push	0
		push	[ebp+file]
		call	open64
		add	esp, 10h
		mov	[ebp+fd], eax
		cmp	[ebp+fd], 0FFFFFFFFh
		jnz	short loc_80010FD
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_800114B
; ---------------------------------------------------------------------------

loc_80010FD:				; CODE XREF: wc_file+59j
		sub	esp, 4
		push	[ebp+fstatus]	; fstatus
		push	[ebp+file]	; file_x
		push	[ebp+fd]	; fd
		call	wc
		add	esp, 10h
		mov	[ebp+ok], al
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001147
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+file]
		push	offset aS_0	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_800114B
; ---------------------------------------------------------------------------

loc_8001147:				; CODE XREF: wc_file+A3j
		movzx	eax, [ebp+ok]

locret_800114B:				; CODE XREF: wc_file+3Dj wc_file+7Aj ...
		leave
		retn
wc_file		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; fstatus *__cdecl get_input_fstatus(int nfiles, char *const *file)
get_input_fstatus proc near		; CODE XREF: main+5C1p

i		= dword	ptr -10h
fstatus		= dword	ptr -0Ch
var_4		= dword	ptr -4
nfiles		= dword	ptr  8
file		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		cmp	[ebp+nfiles], 0
		jz	short loc_800115F
		mov	eax, [ebp+nfiles]
		jmp	short loc_8001164
; ---------------------------------------------------------------------------

loc_800115F:				; CODE XREF: get_input_fstatus+Bj
		mov	eax, 1

loc_8001164:				; CODE XREF: get_input_fstatus+10j
		sub	esp, 8
		push	64h
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+fstatus], eax
		cmp	[ebp+nfiles], 0
		jz	short loc_80011C0
		cmp	[ebp+nfiles], 1
		jnz	short loc_80011CE
		movzx	eax, ds:print_lines
		movzx	edx, al
		movzx	eax, ds:print_words
		movzx	eax, al
		add	edx, eax
		movzx	eax, ds:print_chars
		movzx	eax, al
		add	edx, eax
		movzx	eax, ds:print_bytes
		movzx	eax, al
		add	edx, eax
		movzx	eax, ds:print_linelength
		movzx	eax, al
		add	eax, edx
		cmp	eax, 1
		jnz	short loc_80011CE

loc_80011C0:				; CODE XREF: get_input_fstatus+2Cj
		mov	eax, [ebp+fstatus]
		mov	dword ptr [eax], 1
		jmp	loc_800127D
; ---------------------------------------------------------------------------

loc_80011CE:				; CODE XREF: get_input_fstatus+32j
					; get_input_fstatus+71j
		mov	[ebp+i], 0
		jmp	loc_8001271
; ---------------------------------------------------------------------------

loc_80011DA:				; CODE XREF: get_input_fstatus+12Aj
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		lea	ebx, [edx+eax]
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_8001221
		mov	eax, [ebp+i]
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80023C8 ; "-"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800123F

loc_8001221:				; CODE XREF: get_input_fstatus+ACj
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		add	eax, edx
		add	eax, 4
		sub	esp, 8
		push	eax
		push	0
		call	fstat64
		add	esp, 10h
		jmp	short loc_800126B
; ---------------------------------------------------------------------------

loc_800123F:				; CODE XREF: get_input_fstatus+D2j
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		add	eax, edx
		lea	edx, [eax+4]
		mov	eax, [ebp+i]
		lea	ecx, ds:0[eax*4]
		mov	eax, [ebp+file]
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx
		push	eax
		call	stat64
		add	esp, 10h

loc_800126B:				; CODE XREF: get_input_fstatus+F0j
		mov	[ebx], eax
		add	[ebp+i], 1

loc_8001271:				; CODE XREF: get_input_fstatus+88j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jl	loc_80011DA

loc_800127D:				; CODE XREF: get_input_fstatus+7Cj
		mov	eax, [ebp+fstatus]
		mov	ebx, [ebp+var_4]
		leave
		retn
get_input_fstatus endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl compute_number_width(int nfiles, const fstatus *fstatus)
compute_number_width proc near		; CODE XREF: main+5DEp

width		= dword	ptr -1Ch
minimum_width	= dword	ptr -18h
i		= dword	ptr -14h
regular_total	= qword	ptr -10h
nfiles		= dword	ptr  8
fstatus		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	[ebp+width], 1
		cmp	[ebp+nfiles], 0
		jle	loc_800135E
		mov	eax, [ebp+fstatus]
		mov	eax, [eax]
		test	eax, eax
		jg	loc_800135E
		mov	[ebp+minimum_width], 1
		mov	dword ptr [ebp+regular_total], 0
		mov	dword ptr [ebp+regular_total+4], 0
		mov	[ebp+i], 0
		jmp	short loc_8001316
; ---------------------------------------------------------------------------

loc_80012C7:				; CODE XREF: compute_number_width+97j
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_8001312
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		add	eax, edx
		mov	eax, [eax+14h]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_800130B
		mov	eax, [ebp+i]
		imul	edx, eax, 64h
		mov	eax, [ebp+fstatus]
		add	eax, edx
		mov	edx, [eax+34h]
		mov	eax, [eax+30h]
		add	dword ptr [ebp+regular_total], eax
		adc	dword ptr [ebp+regular_total+4], edx
		jmp	short loc_8001312
; ---------------------------------------------------------------------------

loc_800130B:				; CODE XREF: compute_number_width+6Bj
		mov	[ebp+minimum_width], 7

loc_8001312:				; CODE XREF: compute_number_width+51j
					; compute_number_width+84j
		add	[ebp+i], 1

loc_8001316:				; CODE XREF: compute_number_width+40j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nfiles]
		jl	short loc_80012C7
		jmp	short loc_800133E
; ---------------------------------------------------------------------------

loc_8001320:				; CODE XREF: compute_number_width+BDj
					; compute_number_width+C9j
		add	[ebp+width], 1
		mov	eax, dword ptr [ebp+regular_total]
		mov	edx, dword ptr [ebp+regular_total+4]
		push	0
		push	0Ah
		push	edx
		push	eax
		call	__udivdi3
		add	esp, 10h
		mov	dword ptr [ebp+regular_total], eax
		mov	dword ptr [ebp+regular_total+4], edx

loc_800133E:				; CODE XREF: compute_number_width+99j
		cmp	dword ptr [ebp+regular_total+4], 0
		ja	short loc_8001320
		cmp	dword ptr [ebp+regular_total+4], 0
		jb	short loc_8001350
		cmp	dword ptr [ebp+regular_total], 9
		ja	short loc_8001320

loc_8001350:				; CODE XREF: compute_number_width+C3j
		mov	eax, [ebp+width]
		cmp	eax, [ebp+minimum_width]
		jge	short loc_800135E
		mov	eax, [ebp+minimum_width]
		mov	[ebp+width], eax

loc_800135E:				; CODE XREF: compute_number_width+11j
					; compute_number_width+1Ej ...
		mov	eax, [ebp+width]
		leave
		retn
compute_number_width endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

chars		= qword	ptr -160h
bytes		= qword	ptr -158h
file		= dword	ptr -150h
argv		= dword	ptr -13Ch
ok		= byte ptr -137h
read_tokens	= byte ptr -136h
skip_file	= byte ptr -135h
nfiles		= dword	ptr -134h
files		= dword	ptr -130h
files_from	= dword	ptr -12Ch
ai		= dword	ptr -128h
stream		= dword	ptr -124h
i		= dword	ptr -120h
optc		= dword	ptr -11Ch
fstatus		= dword	ptr -118h
file_name	= dword	ptr -114h
file_number	= dword	ptr -110h
ai_err		= dword	ptr -10Ch
var_FC		= dword	ptr -0FCh
var_E0		= dword	ptr -0E0h
var_DC		= dword	ptr -0DCh
tok		= Tokens ptr -0ACh
var_1C		= dword	ptr -1Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 158h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_1C], eax
		xor	eax, eax
		mov	[ebp+files_from], 0
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, ds:stdout
		push	0		; n
		push	1		; modes
		push	0		; buf
		push	eax		; stream
		call	setvbuf
		add	esp, 10h
		mov	ds:print_bytes,	0
		movzx	eax, ds:print_bytes
		mov	ds:print_chars,	al
		movzx	eax, ds:print_chars
		mov	ds:print_words,	al
		movzx	eax, ds:print_words
		mov	ds:print_lines,	al
		mov	ds:print_linelength, 0
		mov	dword ptr ds:max_line_length, 0
		mov	dword ptr ds:max_line_length+4,	0
		mov	eax, dword ptr ds:max_line_length
		mov	edx, dword ptr ds:max_line_length+4
		mov	dword ptr ds:total_bytes, eax
		mov	dword ptr ds:total_bytes+4, edx
		mov	eax, dword ptr ds:total_bytes
		mov	edx, dword ptr ds:total_bytes+4
		mov	dword ptr ds:total_chars, eax
		mov	dword ptr ds:total_chars+4, edx
		mov	eax, dword ptr ds:total_chars
		mov	edx, dword ptr ds:total_chars+4
		mov	dword ptr ds:total_words, eax
		mov	dword ptr ds:total_words+4, edx
		mov	eax, dword ptr ds:total_words
		mov	edx, dword ptr ds:total_words+4
		mov	dword ptr ds:total_lines, eax
		mov	dword ptr ds:total_lines+4, edx
		jmp	loc_800157C
; ---------------------------------------------------------------------------

loc_80014AC:				; CODE XREF: main+245j
		mov	eax, [ebp+optc]
		cmp	eax, 63h
		jz	short loc_80014F6
		cmp	eax, 63h
		jg	short loc_80014D4
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8001530
		cmp	eax, 4Ch
		jz	short loc_800151A
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_800153A
		jmp	loc_8001572
; ---------------------------------------------------------------------------

loc_80014D4:				; CODE XREF: main+157j
		cmp	eax, 6Dh
		jz	short loc_80014FF
		cmp	eax, 6Dh
		jg	short loc_80014E8
		cmp	eax, 6Ch
		jz	short loc_8001508
		jmp	loc_8001572
; ---------------------------------------------------------------------------

loc_80014E8:				; CODE XREF: main+179j
		cmp	eax, 77h
		jz	short loc_8001511
		cmp	eax, 80h
		jz	short loc_8001523
		jmp	short loc_8001572
; ---------------------------------------------------------------------------

loc_80014F6:				; CODE XREF: main+152j
		mov	ds:print_bytes,	1
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_80014FF:				; CODE XREF: main+174j
		mov	ds:print_chars,	1
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_8001508:				; CODE XREF: main+17Ej
		mov	ds:print_lines,	1
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_8001511:				; CODE XREF: main+188j
		mov	ds:print_words,	1
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_800151A:				; CODE XREF: main+163j
		mov	ds:print_linelength, 1
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_8001523:				; CODE XREF: main+18Fj
		mov	eax, ds:optarg
		mov	[ebp+files_from], eax
		jmp	short loc_800157C
; ---------------------------------------------------------------------------

loc_8001530:				; CODE XREF: main+15Ej
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800153A:				; CODE XREF: main+16Aj
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	offset aPaulRubin ; "Paul Rubin"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aWc	; "wc"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8001572:				; CODE XREF: main+16Cj	main+180j ...
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800157C:				; CODE XREF: main+144j	main+19Aj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "clLmw"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+optc], eax
		cmp	[ebp+optc], 0FFFFFFFFh
		jnz	loc_80014AC
		movzx	eax, ds:print_lines
		xor	eax, 1
		test	al, al
		jz	short loc_8001613
		movzx	eax, ds:print_words
		xor	eax, 1
		test	al, al
		jz	short loc_8001613
		movzx	eax, ds:print_chars
		xor	eax, 1
		test	al, al
		jz	short loc_8001613
		movzx	eax, ds:print_bytes
		xor	eax, 1
		test	al, al
		jz	short loc_8001613
		movzx	eax, ds:print_linelength
		xor	eax, 1
		test	al, al
		jz	short loc_8001613
		mov	ds:print_bytes,	1
		movzx	eax, ds:print_bytes
		mov	ds:print_words,	al
		movzx	eax, ds:print_words
		mov	ds:print_lines,	al

loc_8001613:				; CODE XREF: main+257j	main+265j ...
		mov	[ebp+read_tokens], 0
		cmp	[ebp+files_from], 0
		jz	loc_80018B3
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_80016A5
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aFileOperandsCa ; "file operands	cannot be combined with	-"...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	edx
		push	offset aS_1	; "%s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80016A5:				; CODE XREF: main+2CBj
		sub	esp, 8
		push	offset asc_80023C8 ; "-"
		push	[ebp+files_from] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80016CC
		mov	eax, ds:stdin
		mov	[ebp+stream], eax
		jmp	short loc_800172A
; ---------------------------------------------------------------------------

loc_80016CC:				; CODE XREF: main+35Aj
		sub	esp, 8
		push	offset aR	; "r"
		push	[ebp+files_from]
		call	fopen64
		add	esp, 10h
		mov	[ebp+stream], eax
		cmp	[ebp+stream], 0
		jnz	short loc_800172A
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aCannotOpenSFor ; "cannot open %s for reading"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_800172A:				; CODE XREF: main+367j	main+38Cj
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	fileno
		add	esp, 10h
		mov	edx, eax
		sub	esp, 8
		lea	eax, [ebp+ai_err]
		push	eax
		push	edx
		call	fstat64
		add	esp, 10h
		test	eax, eax
		jnz	loc_8001886
		mov	eax, [ebp+var_FC]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	loc_8001886
		mov	eax, [ebp+var_E0]
		mov	edx, [ebp+var_DC]
		mov	[ebp+file], eax
		mov	[ebp+file+4], edx
		fild	qword ptr [ebp+file]
		fstp	qword ptr [ebp+file]
		call	physmem_available
		fld	ds:dbl_8002550
		fdivp	st(1), st
		fld	ds:dbl_8002558
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jbe	short loc_80017B5
		fld	ds:dbl_8002558
		jmp	short loc_80017C2
; ---------------------------------------------------------------------------

loc_80017B5:				; CODE XREF: main+448j
		call	physmem_available
		fld	ds:dbl_8002550
		fdivp	st(1), st

loc_80017C2:				; CODE XREF: main+450j
		fld	qword ptr [ebp+file]
		fxch	st(1)
		fucomip	st, st(1)
		fstp	st
		jb	loc_8001886
		mov	[ebp+read_tokens], 1
		sub	esp, 0Ch
		lea	eax, [ebp+tok]
		push	eax
		call	readtokens0_init
		add	esp, 10h
		sub	esp, 8
		lea	eax, [ebp+tok]
		push	eax
		push	[ebp+stream]
		call	readtokens0
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jnz	short loc_8001821
		sub	esp, 0Ch
		push	[ebp+stream]	; stream
		call	fclose
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001852

loc_8001821:				; CODE XREF: main+4A7j
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aCannotReadFile ; "cannot read file names from %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001852:				; CODE XREF: main+4BCj
		mov	eax, [ebp+tok.tok]
		mov	[ebp+files], eax
		mov	eax, [ebp+tok.n_tok]
		mov	[ebp+nfiles], eax
		sub	esp, 0Ch
		push	[ebp+files]
		call	argv_iter_init_argv
		add	esp, 10h
		mov	[ebp+ai], eax
		jmp	loc_8001915
; ---------------------------------------------------------------------------

loc_8001886:				; CODE XREF: main+3EFj	main+405j ...
		mov	[ebp+files], 0
		mov	[ebp+nfiles], 0
		sub	esp, 0Ch
		push	[ebp+stream]
		call	argv_iter_init_stream
		add	esp, 10h
		mov	[ebp+ai], eax
		jmp	short loc_8001915
; ---------------------------------------------------------------------------

loc_80018B3:				; CODE XREF: main+2BEj
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_80018D2
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		jmp	short loc_80018D7
; ---------------------------------------------------------------------------

loc_80018D2:				; CODE XREF: main+557j
		mov	eax, offset stdin_only_5941

loc_80018D7:				; CODE XREF: main+56Dj
		mov	[ebp+files], eax
		mov	eax, ds:optind
		cmp	eax, [ebx]
		jge	short loc_80018F3
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		jmp	short loc_80018F8
; ---------------------------------------------------------------------------

loc_80018F3:				; CODE XREF: main+581j
		mov	eax, 1

loc_80018F8:				; CODE XREF: main+58Ej
		mov	[ebp+nfiles], eax
		sub	esp, 0Ch
		push	[ebp+files]
		call	argv_iter_init_argv
		add	esp, 10h
		mov	[ebp+ai], eax

loc_8001915:				; CODE XREF: main+51Ej	main+54Ej
		sub	esp, 8
		push	[ebp+files]	; file
		push	[ebp+nfiles]	; nfiles
		call	get_input_fstatus
		add	esp, 10h
		mov	[ebp+fstatus], eax
		sub	esp, 8
		push	[ebp+fstatus]	; fstatus
		push	[ebp+nfiles]	; nfiles
		call	compute_number_width
		add	esp, 10h
		mov	ds:number_width, eax
		mov	[ebp+ok], 1
		mov	[ebp+i], 0

loc_800195F:				; CODE XREF: main+82Dj
		mov	[ebp+skip_file], 0
		sub	esp, 8
		lea	eax, [ebp+ai_err]
		push	eax
		push	[ebp+ai]
		call	argv_iter
		add	esp, 10h
		mov	[ebp+file_name], eax
		mov	eax, [ebp+ai_err]
		cmp	eax, 2
		jnz	short loc_80019A1
		cmp	[ebp+ok], 0
		jnz	loc_8001B95
		jmp	loc_8001BDD
; ---------------------------------------------------------------------------

loc_80019A1:				; CODE XREF: main+62Aj
		cmp	[ebp+file_name], 0
		jnz	short loc_8001A1D
		mov	eax, [ebp+ai_err]
		cmp	eax, 3
		jz	short loc_80019FF
		cmp	eax, 4
		jnz	short loc_8001A04
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aSReadError ; "%s: read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+skip_file], 1
		jmp	loc_8001B89
; ---------------------------------------------------------------------------

loc_80019FF:				; CODE XREF: main+650j
		call	xalloc_die

loc_8001A04:				; CODE XREF: main+655j
		push	offset __PRETTY_FUNCTION___5951	; "main"
		push	2D8h		; line
		push	offset file	; "wc.c"
		push	offset assertion ; "!\"unexpected error	code from argv_iter"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001A1D:				; CODE XREF: main+645j
		cmp	[ebp+files_from], 0
		jz	short loc_8001A92
		sub	esp, 8
		push	offset asc_80023C8 ; "-"
		push	[ebp+files_from] ; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A92
		sub	esp, 8
		push	offset asc_80023C8 ; "-"
		push	[ebp+file_name]	; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001A92
		sub	esp, 0Ch
		push	[ebp+file_name]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWhenReadingFil ; "when reading file names from stdin, no "...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	[ebp+skip_file], 1

loc_8001A92:				; CODE XREF: main+6C1j	main+6DBj ...
		mov	eax, [ebp+file_name]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001B2D
		cmp	[ebp+files_from], 0
		jnz	short loc_8001AD0
		sub	esp, 0Ch
		push	offset aInvalidZeroLen ; "invalid zero-length file name"
		call	gettext
		add	esp, 10h
		push	eax
		push	offset aS_0	; "%s"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001B26
; ---------------------------------------------------------------------------

loc_8001AD0:				; CODE XREF: main+747j
		sub	esp, 0Ch
		push	[ebp+ai]
		call	argv_iter_n_args
		add	esp, 10h
		mov	[ebp+file_number], eax
		sub	esp, 0Ch
		push	offset aInvalidZeroLen ; "invalid zero-length file name"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	[ebp+files_from]
		call	quotearg_colon
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	[ebp+file_number]
		push	eax
		push	offset aSLuS	; "%s:%lu: %s"
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h

loc_8001B26:				; CODE XREF: main+76Bj
		mov	[ebp+skip_file], 1

loc_8001B2D:				; CODE XREF: main+73Aj
		cmp	[ebp+skip_file], 0
		jz	short loc_8001B3F
		mov	[ebp+ok], 0
		jmp	short loc_8001B89
; ---------------------------------------------------------------------------

loc_8001B3F:				; CODE XREF: main+7D1j
		cmp	[ebp+nfiles], 0
		jz	short loc_8001B53
		mov	eax, [ebp+i]
		imul	eax, 64h
		jmp	short loc_8001B58
; ---------------------------------------------------------------------------

loc_8001B53:				; CODE XREF: main+7E3j
		mov	eax, 0

loc_8001B58:				; CODE XREF: main+7EEj
		mov	edx, [ebp+fstatus]
		add	eax, edx
		sub	esp, 8
		push	eax		; fstatus
		push	[ebp+file_name]	; file
		call	wc_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001B89:				; CODE XREF: main+697j	main+7DAj
		add	[ebp+i], 1
		jmp	loc_800195F
; ---------------------------------------------------------------------------

loc_8001B95:				; CODE XREF: main+633j
		cmp	[ebp+files_from], 0
		jnz	short loc_8001BDD
		sub	esp, 0Ch
		push	[ebp+ai]
		call	argv_iter_n_args
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001BDD
		sub	esp, 8
		push	[ebp+fstatus]	; fstatus
		push	0		; file
		call	wc_file
		add	esp, 10h
		movzx	edx, [ebp+ok]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+ok], al

loc_8001BDD:				; CODE XREF: main+639j	main+839j ...
		cmp	[ebp+read_tokens], 0
		jz	short loc_8001BF8
		sub	esp, 0Ch
		lea	eax, [ebp+tok]
		push	eax
		call	readtokens0_free
		add	esp, 10h

loc_8001BF8:				; CODE XREF: main+881j
		sub	esp, 0Ch
		push	[ebp+ai]
		call	argv_iter_n_args
		add	esp, 10h
		cmp	eax, 1
		jbe	loc_8001CAA
		sub	esp, 0Ch
		push	offset aTotal	; "total"
		call	gettext
		add	esp, 10h
		mov	[ebp+file], eax
		mov	esi, dword ptr ds:max_line_length
		mov	edi, dword ptr ds:max_line_length+4
		mov	ecx, dword ptr ds:total_bytes
		mov	ebx, dword ptr ds:total_bytes+4
		mov	dword ptr [ebp+bytes], ecx
		mov	dword ptr [ebp+bytes+4], ebx
		mov	edx, dword ptr ds:total_chars
		mov	ecx, dword ptr ds:total_chars+4
		mov	dword ptr [ebp+chars], edx
		mov	dword ptr [ebp+chars+4], ecx
		mov	ecx, dword ptr ds:total_words
		mov	ebx, dword ptr ds:total_words+4
		mov	eax, dword ptr ds:total_lines
		mov	edx, dword ptr ds:total_lines+4
		sub	esp, 4
		push	[ebp+file]	; file
		push	edi
		push	esi		; linelength
		push	dword ptr [ebp+bytes+4]
		push	dword ptr [ebp+bytes] ;	bytes
		push	dword ptr [ebp+chars+4]
		push	dword ptr [ebp+chars] ;	chars
		push	ebx
		push	ecx		; words
		push	edx
		push	eax		; lines
		call	write_counts
		add	esp, 30h

loc_8001CAA:				; CODE XREF: main+8A9j
		sub	esp, 0Ch
		push	[ebp+ai]
		call	argv_iter_free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+fstatus]	; ptr
		call	free
		add	esp, 10h
		movzx	eax, ds:have_read_stdin
		test	al, al
		jz	short loc_8001D02
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001D02
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	offset asc_80023C8 ; "-"
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001D02:				; CODE XREF: main+972j	main+983j
		cmp	[ebp+ok], 0
		jz	short loc_8001D12
		mov	eax, 0
		jmp	short loc_8001D17
; ---------------------------------------------------------------------------

loc_8001D12:				; CODE XREF: main+9A6j
		mov	eax, 1

loc_8001D17:				; CODE XREF: main+9ADj
		sub	esp, 0Ch
		push	eax		; status

loc_8001D1B:				; DATA XREF: .eh_frame:08002580o
					; .eh_frame:080025A0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment 'qword' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8001D28h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; uintmax_t total_lines
total_lines	dq ?			; DATA XREF: wc+B62r wc+B7Ew ...
; uintmax_t total_words
total_words	dq ?			; DATA XREF: wc+B89r wc+BA5w ...
; uintmax_t total_chars
total_chars	dq ?			; DATA XREF: wc+BB0r wc+BCCw ...
; uintmax_t total_bytes
total_bytes	dq ?			; DATA XREF: wc+BD7r wc+BF3w ...
; uintmax_t max_line_length
max_line_length	dq ?			; DATA XREF: wc+BFEr wc+C2Dw ...
; _Bool	print_lines
print_lines	db ?			; DATA XREF: write_counts+5Ar wc+175r	...
; _Bool	print_words
print_words	db ?			; DATA XREF: write_counts:loc_80002FEr
					; wc:loc_8000550r ...
; _Bool	print_chars
print_chars	db ?			; DATA XREF: write_counts:loc_800033Cr
					; wc+E2r ...
; _Bool	print_bytes
print_bytes	db ?			; DATA XREF: write_counts:loc_800037Ar
					; wc+D5r ...
; _Bool	print_linelength
print_linelength db ?			; DATA XREF: write_counts:loc_80003B8r
					; wc+132r ...
		align 4
; int number_width
number_width	dd ?			; DATA XREF: write_counts+7Cr
					; write_counts+BAr ...
; _Bool	have_read_stdin
have_read_stdin	db ?			; DATA XREF: wc_file:loc_80010A4w
					; main+969r
		align 10h
; Function-local static	variable
; char *stdin_only_5941[1]
stdin_only_5941	dd ?			; DATA XREF: main:loc_80018D2o
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8001D80h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+65o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+1F2o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aBytes		db 'bytes',0            ; DATA XREF: .rodata:longoptso
aChars		db 'chars',0            ; DATA XREF: .rodata:longoptso
aLines		db 'lines',0            ; DATA XREF: .rodata:longoptso
aWords		db 'words',0            ; DATA XREF: .rodata:longoptso
aFiles0From	db 'files0-from',0      ; DATA XREF: .rodata:longoptso
aMaxLineLength	db 'max-line-length',0  ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[9]
longopts	option <offset aBytes, 0, 0, 63h> ; DATA XREF: main+21Eo
		option <offset aChars, 0, 0, 6Dh> ; "bytes"
		option <offset aLines, 0, 0, 6Ch>
		option <offset aWords, 0, 0, 77h>
		option <offset aFiles0From, 1, 0, 80h>
		option <offset aMaxLineLength, 0, 0, 4Ch>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... [FILE]...',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s [OPTION]... --files0-from=F',0Ah,0
		align 10h
; char aPrintNewlineWo[]
aPrintNewlineWo	db 'Print newline, word, and byte counts for each FILE, and a total l'
					; DATA XREF: usage+6Eo
		db 'ine if',0Ah
		db 'more than one FILE is specified.  With no FILE, or when FILE is -'
		db ',',0Ah
		db 'read standard input.',0Ah
		db '  -c, --bytes            print the byte counts',0Ah
		db '  -m, --chars            print the character counts',0Ah
		db '  -l, --lines            print the newline counts',0Ah,0
		align 4
; char aFiles0FromFRea[]
aFiles0FromFRea	db '      --files0-from=F    read input from the files specified by',0Ah
					; DATA XREF: usage+91o
		db '                           NUL-terminated names in file F;',0Ah
		db '                           If F is - then read names from standar'
		db 'd input',0Ah
		db '  -L, --max-line-length  print the length of the longest line',0Ah
		db '  -w, --words            print the word counts',0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+B4o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+D7o
; char format[]
format		db ' %s',0              ; DATA XREF: write_counts+195o
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: wc+3Co
; char aS_0[]
aS_0		db '%s',0               ; DATA XREF: wc+2D2o wc+380o ...
off_8002308	dd offset loc_8000AC4	; DATA XREF: wc+632r
		dd offset loc_8000A64	; jump table for switch	statement
		dd offset mb_word_separator
		dd offset loc_8000A72
		dd offset loc_8000A72
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B34
		dd offset loc_8000B02
off_8002368	dd offset loc_8000D8F	; DATA XREF: wc+8FDr
		dd offset loc_8000D2F	; jump table for switch	statement
		dd offset loc_8000DCE
		dd offset loc_8000D3D
		dd offset loc_8000D3D
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DF2
		dd offset loc_8000DBD
; char asc_80023C8[2]
asc_80023C8	db '-',0                ; DATA XREF: wc_file+Fo
					; get_input_fstatus+C2o ...
; char locale
locale		db 0			; DATA XREF: main+4Eo
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+60o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+1E7o
aPaulRubin	db 'Paul Rubin',0       ; DATA XREF: main+1ECo
aWc		db 'wc',0               ; DATA XREF: main+1F7o
; char shortopts[]
shortopts	db 'clLmw',0            ; DATA XREF: main+223o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+2F4o
; char aFileOperandsCa[]
aFileOperandsCa	db 'file operands cannot be combined with --files0-from',0
					; DATA XREF: main+312o
; char aS_1[]
aS_1		db '%s',0Ah,0           ; DATA XREF: main+32Ao
aR		db 'r',0                ; DATA XREF: main+36Co
; char aCannotOpenSFor[]
aCannotOpenSFor	db 'cannot open %s for reading',0 ; DATA XREF: main+3A4o
		align 10h
; char aCannotReadFile[]
aCannotReadFile	db 'cannot read file names from %s',0 ; DATA XREF: main+4D4o
; char aSReadError[]
aSReadError	db '%s: read error',0   ; DATA XREF: main+66Do
; char file[]
file		db 'wc.c',0             ; DATA XREF: main+6ABo
		align 4
; char assertion[]
assertion	db '!"unexpected error code from argv_iter"',0 ; DATA XREF: main+6B0o
; char aWhenReadingFil[]
aWhenReadingFil	db 'when reading file names from stdin, no file name of %s allowed',0
					; DATA XREF: main+70Do
; char aInvalidZeroLen[]
aInvalidZeroLen	db 'invalid zero-length file name',0 ; DATA XREF: main+74Co
					; main+787o
; char aSLuS[]
aSLuS		db '%s:%lu: %s',0       ; DATA XREF: main+7B2o
; char aTotal[]
aTotal		db 'total',0            ; DATA XREF: main+8B2o
		align 4
; Function-local static	variable
; const	char format_sp_int_5810[5]
format_sp_int_5810 db ' %*s',0          ; DATA XREF: write_counts+91o
					; write_counts+CFo ...
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5951[5]
__PRETTY_FUNCTION___5951 db 'main',0    ; DATA XREF: main:loc_8001A04o
		align 10h
dbl_8002550	dq 2.0			; DATA XREF: main+434r	main+457r
dbl_8002558	dq 1.048576e7		; DATA XREF: main+43Cr	main+44Ar
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8002560h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8001D1B-800429Bh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8001D1B-80042A9h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8001D1B-80041B1h
		dd 37h,	80E4100h, 0D420285h, 0CC57305h,	404h, 1Ch, 80h
		dd offset loc_8001D1B-800419Ah
		dd 101h, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 0A0h
		dd offset loc_8001D1B-80040B9h
		dd 1C3h, 80E4100h, 0D420285h, 1BF0305h,	4040CC5h, 2Ch
		dd 0C0h
		dd offset loc_8001D1B-8003F16h
		dd 0C58h, 80E4100h, 0D420285h, 3874905h, 5830486h, 0C30C4803h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 0F0h
		dd offset loc_8001D1B-80032EEh
		dd 0CCh, 80E4100h, 0D420285h, 0C5C80205h, 4040Ch, 20h
		dd 110h
		dd offset loc_8001D1B-8003242h
		dd 138h, 80E4100h, 0D420285h, 3834405h,	0C5013003h, 4040CC3h
		dd 1Ch,	134h
		dd offset loc_8001D1B-800312Eh
		dd 0DEh, 80E4100h, 0D420285h, 0C5DA0205h, 4040Ch, 2Ch
		dd 154h
		dd offset loc_8001D1B-8003070h
		dd 9BDh, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+55p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn is_basic_table:dword ; DATA XREF:	is_basic+16r
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r	main+321r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep	main+330p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+FCp	main+20Ap ...
		extrn umaxtostr:near	; CODE XREF: write_counts+72p
					; write_counts+B0p ...
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: write_counts+1A7p
		extrn __stack_chk_fail:near ; CODE XREF: write_counts+1BCp
					; wc+C4Bp
; size_t _ctype_get_mb_cur_max(void)
		extrn __ctype_get_mb_cur_max:near ; CODE XREF: wc+CBp
					; wc:loc_8000861p
		extrn fstat64:near	; CODE XREF: wc+1B5p
					; get_input_fstatus+E8p ...
		extrn lseek64:near	; CODE XREF: wc+1F9p wc+234p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: wc+2C5p wc+373p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: wc+2DAp wc+388p ...
		extrn safe_read:near	; CODE XREF: wc+314p wc+418p ...
; void *memchr(const void *s, int c, size_t n)
		extrn memchr:near	; CODE XREF: wc+3D8p
; size_t mbrtowc(wchar_t *pwc, const char *s, size_t n,	mbstate_t *p)
		extrn mbrtowc:near	; CODE XREF: wc+570p
; int mbsinit(const mbstate_t *ps)
		extrn mbsinit:near	; CODE XREF: wc+5CAp
; int iswprint(wint_t wc)
		extrn iswprint:near	; CODE XREF: wc+715p
		extrn wcwidth:near	; CODE XREF: wc+72Bp
; int iswspace(wint_t wc)
		extrn iswspace:near	; CODE XREF: wc+75Fp
; void *memmove(void *dest, const void *src, size_t n)
		extrn memmove:near	; CODE XREF: wc+7BEp
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: wc:loc_8000DF2p wc+A0Fp
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: wc_file+17p
					; get_input_fstatus+C8p ...
		extrn open64:near	; CODE XREF: wc_file+4Ap
; int close(int	fd)
		extrn close:near	; CODE XREF: wc_file+99p main+979p
		extrn xnmalloc:near	; CODE XREF: get_input_fstatus+1Dp
		extrn stat64:near	; CODE XREF: get_input_fstatus+116p
		extrn __udivdi3:near	; CODE XREF: compute_number_width+ABp
		extrn set_program_name:near ; CODE XREF: main+43p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+6Ap
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+7Ap
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+85o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+8Ap
; int setvbuf(FILE *stream, char *buf, int modes, size_t n)
		extrn setvbuf:near	; CODE XREF: main+9Ep
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8001523r
		extrn Version:dword	; DATA XREF: main:loc_800153Ar
		extrn version_etc:near	; CODE XREF: main+1FDp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+230p
; int optind
		extrn optind:dword	; DATA XREF: main+2C4r	main+2CDr ...
		extrn quote:near	; CODE XREF: main+2E7p	main+397p ...
; struct _IO_FILE *stdin
		extrn stdin:dword	; DATA XREF: main+35Cr
		extrn fopen64:near	; CODE XREF: main+377p
; int fileno(FILE *stream)
		extrn fileno:near	; CODE XREF: main+3D0p
; double physmem_available(void)
		extrn physmem_available:near ; CODE XREF: main+42Fp
					; main:loc_80017B5p
		extrn readtokens0_init:near ; CODE XREF: main+482p
		extrn readtokens0:near	; CODE XREF: main+49Ap
; int fclose(FILE *stream)
		extrn fclose:near	; CODE XREF: main+4B2p
		extrn argv_iter_init_argv:near ; CODE XREF: main+510p
					; main+5A4p
		extrn argv_iter_init_stream:near ; CODE	XREF: main+540p
		extrn argv_iter:near	; CODE XREF: main+613p
		extrn xalloc_die:near	; CODE XREF: main:loc_80019FFp
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: main+6B5p
		extrn argv_iter_n_args:near ; CODE XREF: main+776p main+844p ...
		extrn quotearg_colon:near ; CODE XREF: main+79Fp
		extrn readtokens0_free:near ; CODE XREF: main+88Dp
		extrn argv_iter_free:near ; CODE XREF: main+950p
; void free(void *ptr)
		extrn free:near		; CODE XREF: main+961p


		end
