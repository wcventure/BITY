;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	FB97C534C85EBB691988DE4A6AF930DE
; Input	CRC32 :	4FDEDE59

; File Name   :	D:\coreutils-o\test.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'test.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+61p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl timespec_cmp(timespec a, timespec	b)
timespec_cmp	proc near		; CODE XREF: binary_operator+4A9p
					; binary_operator+6FCp

a		= timespec ptr	8
b		= timespec ptr	10h

		push	ebp
		mov	ebp, esp
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jl	short loc_8000053
		mov	edx, [ebp+a.tv_sec]
		mov	eax, [ebp+b.tv_sec]
		cmp	edx, eax
		jg	short loc_800004C
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		jl	short loc_8000045
		mov	edx, [ebp+a.tv_nsec]
		mov	eax, [ebp+b.tv_nsec]
		cmp	edx, eax
		setnle	al
		movzx	eax, al
		jmp	short loc_8000058
; ---------------------------------------------------------------------------

loc_8000045:				; CODE XREF: timespec_cmp+1Fj
		mov	eax, 0FFFFFFFFh
		jmp	short loc_8000058
; ---------------------------------------------------------------------------

loc_800004C:				; CODE XREF: timespec_cmp+15j
		mov	eax, 1
		jmp	short loc_8000058
; ---------------------------------------------------------------------------

loc_8000053:				; CODE XREF: timespec_cmp+Bj
		mov	eax, 0FFFFFFFFh

loc_8000058:				; CODE XREF: timespec_cmp+2Fj
					; timespec_cmp+36j ...
		pop	ebp
		retn
timespec_cmp	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: find_int+27p find_int+B8p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+279p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_8000152
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8000152
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_8000152:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; timespec *get_stat_mtime(timespec *__return_ptr __struct_ptr retstr, const stat *st)
get_stat_mtime	proc near		; CODE XREF: get_mtime+52p

retstr		= dword	ptr  8
st		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		mov	ecx, [ebp+retstr]
		mov	eax, [ebp+st]
		mov	edx, [eax+4Ch]
		mov	eax, [eax+48h]
		mov	[ecx], eax
		mov	[ecx+4], edx
		mov	eax, [ebp+retstr]
		pop	ebp
		retn	4
get_stat_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void __cdecl test_syntax_error(const char *format, const char	*arg)
test_syntax_error proc near		; CODE XREF: beyond+42p find_int+108p	...

format		= dword	ptr  8
arg		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, ds:argv
		mov	edx, [eax]
		mov	eax, ds:stderr
		sub	esp, 4
		push	edx
		push	offset format	; "%s: "
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	eax, ds:stderr
		sub	esp, 4
		push	[ebp+arg]
		push	[ebp+format]	; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		mov	eax, ds:stderr
		sub	esp, 8
		push	eax		; stream
		push	0Ah		; c
		call	fputc_unlocked
		add	esp, 10h
		mov	eax, ds:stderr
		sub	esp, 0Ch
		push	eax		; stream
		call	fflush_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	exit
test_syntax_error endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl advance(_Bool f)
advance		proc near		; CODE XREF: unary_advance+Bp term+12p ...

f		= byte ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+f], al
		mov	eax, ds:pos
		add	eax, 1
		mov	ds:pos,	eax
		cmp	[ebp+f], 0
		jz	short loc_800023F
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jl	short loc_800023F
		call	beyond
; ---------------------------------------------------------------------------

loc_800023F:				; CODE XREF: advance+1Dj advance+2Cj
		nop
		leave
		retn
advance		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void unary_advance()
unary_advance	proc near		; CODE XREF: unary_operator:loc_80011C3p
					; unary_operator:loc_80011FAp ...
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	1		; f
		call	advance
		add	esp, 10h
		mov	eax, ds:pos
		add	eax, 1
		mov	ds:pos,	eax
		nop
		leave
		retn
unary_advance	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn static bp-based frame

; void beyond()
beyond		proc near		; CODE XREF: advance+2Ep term+83p ...
		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		mov	eax, ds:argv
		mov	edx, ds:argc
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingArgumen ; "missing argument after %s"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
beyond		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; const	char *__cdecl find_int(const char *string)
find_int	proc near		; CODE XREF: binary_operator+224p
					; binary_operator+28Dp	...

p		= dword	ptr -10h
number_start	= dword	ptr -0Ch
var_4		= dword	ptr -4
string		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, [ebp+string]
		mov	[ebp+p], eax
		jmp	short loc_80002BF
; ---------------------------------------------------------------------------

loc_80002BB:				; CODE XREF: find_int+41j
		add	[ebp+p], 1

loc_80002BF:				; CODE XREF: find_int+Dj
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_80002BB
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Bh
		jnz	short loc_8000305
		add	[ebp+p], 1
		mov	eax, [ebp+p]
		mov	[ebp+number_start], eax
		jmp	short loc_800031C
; ---------------------------------------------------------------------------

loc_8000305:				; CODE XREF: find_int+4Bj
		mov	eax, [ebp+p]
		mov	[ebp+number_start], eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		setz	al
		movzx	eax, al
		add	[ebp+p], eax

loc_800031C:				; CODE XREF: find_int+57j
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_800038F
		jmp	short loc_8000339
; ---------------------------------------------------------------------------

loc_8000335:				; CODE XREF: find_int+9Cj
		add	[ebp+p], 1

loc_8000339:				; CODE XREF: find_int+87j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_8000335
		jmp	short loc_8000350
; ---------------------------------------------------------------------------

loc_800034C:				; CODE XREF: find_int+D2j
		add	[ebp+p], 1

loc_8000350:				; CODE XREF: find_int+9Ej
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		test	eax, eax
		jnz	short loc_800034C
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_800038F
		mov	eax, [ebp+number_start]
		jmp	short loc_80003B9
; ---------------------------------------------------------------------------

loc_800038F:				; CODE XREF: find_int+85j find_int+DCj
		sub	esp, 0Ch
		push	[ebp+string]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidInteger ; "invalid integer %s"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_80003B9:				; CODE XREF: find_int+E1j
		mov	ebx, [ebp+var_4]
		leave
		retn
find_int	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	get_mtime(const	char *filename,	timespec *mtime)
get_mtime	proc near		; CODE XREF: binary_operator+43Ep
					; binary_operator+46Cp	...

var_88		= timespec ptr -88h
mtime		= dword	ptr -80h
filename	= dword	ptr -7Ch
ok		= byte ptr -6Dh
finfo		= stat ptr -6Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 84h
		mov	eax, [ebp+arg_0]
		mov	[ebp+filename],	eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+mtime], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+finfo]
		push	eax
		push	[ebp+filename]
		call	stat64
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+ok], al
		cmp	[ebp+ok], 0
		jz	short loc_8000429
		mov	ebx, [ebp+mtime]
		lea	eax, [ebp+var_88]
		sub	esp, 8
		lea	edx, [ebp+finfo]
		push	edx		; st
		push	eax		; retstr
		call	get_stat_mtime
		add	esp, 0Ch
		mov	eax, [ebp+var_88.tv_sec]
		mov	edx, [ebp+var_88.tv_nsec]
		mov	[ebx], eax
		mov	[ebx+4], edx

loc_8000429:				; CODE XREF: get_mtime+3Fj
		movzx	eax, [ebp+ok]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_800043E
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800043E:				; CODE XREF: get_mtime+79j
		mov	ebx, [ebp+var_4]
		leave
		retn
get_mtime	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	binop(const char *s)
binop		proc near		; CODE XREF: term+242p	term+290p ...

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 8
		push	offset asc_8002237 ; "="
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_800055A
		sub	esp, 8
		push	offset asc_8002239 ; "!="
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_800055A
		sub	esp, 8
		push	offset aNt	; "-nt"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_800055A
		sub	esp, 8
		push	offset aOt	; "-ot"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_800055A
		sub	esp, 8
		push	offset aEf	; "-ef"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_800055A
		sub	esp, 8
		push	offset aEq	; "-eq"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800055A
		sub	esp, 8
		push	offset aNe	; "-ne"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800055A
		sub	esp, 8
		push	offset aLt	; "-lt"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800055A
		sub	esp, 8
		push	offset aLe	; "-le"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800055A
		sub	esp, 8
		push	offset aGt	; "-gt"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800055A
		sub	esp, 8
		push	offset aGe	; "-ge"
		push	[ebp+s]		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000561

loc_800055A:				; CODE XREF: binop+1Bj	binop+36j ...
		mov	eax, 1
		jmp	short loc_8000566
; ---------------------------------------------------------------------------

loc_8000561:				; CODE XREF: binop+115j
		mov	eax, 0

loc_8000566:				; CODE XREF: binop+11Cj
		and	eax, 1
		leave
		retn
binop		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	term()
term		proc near		; CODE XREF: and:loc_80017C0p

value		= byte ptr -0Eh
negated		= byte ptr -0Dh
nargs		= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	[ebp+negated], 0
		jmp	short loc_800059B
; ---------------------------------------------------------------------------

loc_8000578:				; CODE XREF: term+72j
		sub	esp, 0Ch
		push	1		; f
		call	advance
		add	esp, 10h
		movzx	eax, [ebp+negated]
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+negated], al
		and	[ebp+negated], 1

loc_800059B:				; CODE XREF: term+Bj
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jge	short loc_80005DF
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 21h
		jnz	short loc_80005DF
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000578

loc_80005DF:				; CODE XREF: term+3Dj term+56j
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jl	short loc_80005F3
		call	beyond
; ---------------------------------------------------------------------------

loc_80005F3:				; CODE XREF: term+81j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 28h
		jnz	loc_8000759
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000759
		sub	esp, 0Ch
		push	1		; f
		call	advance
		add	esp, 10h
		mov	[ebp+nargs], 1
		jmp	short loc_8000664
; ---------------------------------------------------------------------------

loc_8000646:				; CODE XREF: term+137j
		cmp	[ebp+nargs], 4
		jnz	short loc_8000660
		mov	edx, ds:argc
		mov	eax, ds:pos
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+nargs], eax
		jmp	short loc_80006A4
; ---------------------------------------------------------------------------

loc_8000660:				; CODE XREF: term+DFj
		add	[ebp+nargs], 1

loc_8000664:				; CODE XREF: term+D9j
		mov	edx, ds:pos
		mov	eax, [ebp+nargs]
		add	edx, eax
		mov	eax, ds:argc
		cmp	edx, eax
		jge	short loc_80006A4
		mov	eax, ds:argv
		mov	ecx, ds:pos
		mov	edx, [ebp+nargs]
		add	edx, ecx
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002260 ; ")"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000646

loc_80006A4:				; CODE XREF: term+F3j term+10Bj
		sub	esp, 0Ch
		push	[ebp+nargs]	; nargs
		call	posixtest
		add	esp, 10h
		mov	[ebp+value], al
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		test	eax, eax
		jnz	short loc_80006E6
		sub	esp, 0Ch
		push	offset aExpected ; "')' expected"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	0		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_80006E6:				; CODE XREF: term+15Ej
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 29h
		jnz	short loc_800071B
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000747

loc_800071B:				; CODE XREF: term+192j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aExpectedFoundS ; "')' expected, found %s"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8000747:				; CODE XREF: term+1AEj
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	loc_80008F3
; ---------------------------------------------------------------------------

loc_8000759:				; CODE XREF: term+9Fj term+BFj
		mov	edx, ds:argc
		mov	eax, ds:pos
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 3
		jle	short loc_80007CE
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002286 ; "-l"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80007CE
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 2
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	binop
		add	esp, 10h
		test	al, al
		jz	short loc_80007CE
		sub	esp, 0Ch
		push	1		; l_is_l
		call	binary_operator
		add	esp, 10h
		mov	[ebp+value], al
		jmp	loc_80008F3
; ---------------------------------------------------------------------------

loc_80007CE:				; CODE XREF: term+200j	term+227j ...
		mov	edx, ds:argc
		mov	eax, ds:pos
		sub	edx, eax
		mov	eax, edx
		cmp	eax, 2
		jle	short loc_800081C
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	binop
		add	esp, 10h
		test	al, al
		jz	short loc_800081C
		sub	esp, 0Ch
		push	0		; l_is_l
		call	binary_operator
		add	esp, 10h
		mov	[ebp+value], al
		jmp	loc_80008F3
; ---------------------------------------------------------------------------

loc_800081C:				; CODE XREF: term+275j	term+29Aj
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	loc_80008C9
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80008C9
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80008C9
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; op
		call	test_unop
		add	esp, 10h
		test	al, al
		jz	short loc_800089D
		call	unary_operator
		mov	[ebp+value], al
		jmp	short loc_80008F3
; ---------------------------------------------------------------------------

loc_800089D:				; CODE XREF: term+326j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSUnaryOperator ; "%s: unary operator expected"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_80008C9:				; CODE XREF: term+2C8j	term+2E8j ...
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		setnz	al
		mov	[ebp+value], al
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h

loc_80008F3:				; CODE XREF: term+1E9j	term+25Ej ...
		movzx	eax, [ebp+negated]
		xor	al, [ebp+value]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	ebx, [ebp+var_4]
		leave
		retn
term		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	binary_operator(_Bool l_is_l)
binary_operator	proc near		; CODE XREF: term+253p	term+2A1p ...

l_is_l		= byte ptr -11Ch
r_is_l		= byte ptr -110h
xe_operator	= byte ptr -10Fh
le		= byte ptr -10Eh
re		= byte ptr -10Dh
le_0		= byte ptr -10Ch
re_0		= byte ptr -10Bh
value		= byte ptr -10Ah
value_0		= byte ptr -109h
op		= dword	ptr -108h
l		= dword	ptr -104h
r		= dword	ptr -100h
cmp		= dword	ptr -0FCh
lt		= timespec ptr -0F8h
var_A0		= dword	ptr -0A0h
var_9C		= dword	ptr -9Ch
rt		= timespec ptr -98h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
lbuf		= byte ptr -36h
rbuf		= byte ptr -21h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 120h
		mov	eax, [ebp+arg_0]
		mov	[ebp+l_is_l], al
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		cmp	[ebp+l_is_l], 0
		jz	short loc_800093C
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h

loc_800093C:				; CODE XREF: binary_operator+26j
		mov	eax, ds:pos
		add	eax, 1
		mov	[ebp+op], eax
		mov	eax, ds:argc
		sub	eax, 2
		cmp	eax, [ebp+op]
		jle	short loc_800099A
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002286 ; "-l"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800099A
		mov	[ebp+r_is_l], 1
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	short loc_80009A1
; ---------------------------------------------------------------------------

loc_800099A:				; CODE XREF: binary_operator+51j
					; binary_operator+7Bj
		mov	[ebp+r_is_l], 0

loc_80009A1:				; CODE XREF: binary_operator+91j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	loc_8001056
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 6Ch
		jz	short loc_80009F6
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 67h
		jnz	short loc_8000A32

loc_80009F6:				; CODE XREF: binary_operator+D1j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 65h
		jz	loc_8000AAA
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 74h
		jz	short loc_8000AAA

loc_8000A32:				; CODE XREF: binary_operator+EDj
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 65h
		jnz	short loc_8000A6A
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 71h
		jz	short loc_8000AAA

loc_8000A6A:				; CODE XREF: binary_operator+145j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 6Eh
		jnz	loc_8000C71
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 65h
		jnz	loc_8000C71

loc_8000AAA:				; CODE XREF: binary_operator+109j
					; binary_operator+129j	...
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000C71
		cmp	[ebp+l_is_l], 0
		jz	short loc_8000B0F
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+lbuf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		jmp	short loc_8000B33
; ---------------------------------------------------------------------------

loc_8000B0F:				; CODE XREF: binary_operator+1CAj
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; string
		call	find_int
		add	esp, 10h

loc_8000B33:				; CODE XREF: binary_operator+206j
		mov	[ebp+l], eax
		cmp	[ebp+r_is_l], 0
		jz	short loc_8000B7B
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 2
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		mov	edx, 0
		sub	esp, 4
		lea	ecx, [ebp+rbuf]
		push	ecx
		push	edx
		push	eax
		call	umaxtostr
		add	esp, 10h
		jmp	short loc_8000B9C
; ---------------------------------------------------------------------------

loc_8000B7B:				; CODE XREF: binary_operator+239j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; string
		call	find_int
		add	esp, 10h

loc_8000B9C:				; CODE XREF: binary_operator+272j
		mov	[ebp+r], eax
		sub	esp, 8
		push	[ebp+r]
		push	[ebp+l]
		call	strintcmp
		add	esp, 10h
		mov	[ebp+cmp], eax
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 65h
		setz	al
		mov	[ebp+xe_operator], al
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 6Ch
		jnz	short loc_8000C20
		movzx	eax, [ebp+xe_operator]
		cmp	eax, [ebp+cmp]
		setnle	al
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8000C20:				; CODE XREF: binary_operator+302j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		cmp	al, 67h
		jnz	short loc_8000C53
		movzx	eax, [ebp+xe_operator]
		neg	eax
		cmp	eax, [ebp+cmp]
		setl	al
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8000C53:				; CODE XREF: binary_operator+333j
		cmp	[ebp+cmp], 0
		setnz	al
		movzx	edx, al
		movzx	eax, [ebp+xe_operator]
		cmp	edx, eax
		setz	al
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8000C71:				; CODE XREF: binary_operator+17Dj
					; binary_operator+19Dj	...
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 6Eh
		jz	short loc_8000CA8
		cmp	eax, 6Fh
		jz	loc_8000EFB
		cmp	eax, 65h
		jz	loc_8000DD0
		jmp	loc_800102A
; ---------------------------------------------------------------------------

loc_8000CA8:				; CODE XREF: binary_operator+388j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 74h
		jnz	loc_8001023
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001023
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		cmp	[ebp+l_is_l], 0
		jnz	short loc_8000D07
		cmp	[ebp+r_is_l], 0
		jz	short loc_8000D22

loc_8000D07:				; CODE XREF: binary_operator+3F5j
		sub	esp, 0Ch
		push	offset aNtDoesNotAccep ; "-nt does not accept -l"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	0		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8000D22:				; CODE XREF: binary_operator+3FEj
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+lt]
		push	edx		; mtime
		push	eax		; filename
		call	get_mtime
		add	esp, 10h
		mov	[ebp+le], al
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+rt]
		push	edx		; mtime
		push	eax		; filename
		call	get_mtime
		add	esp, 10h
		mov	[ebp+re], al
		cmp	[ebp+le], 0
		jz	short loc_8000DC3
		movzx	eax, [ebp+re]
		xor	eax, 1
		test	al, al
		jnz	short loc_8000DBC
		push	[ebp+rt.tv_nsec]
		push	[ebp+rt.tv_sec]	; b
		push	[ebp+lt.tv_nsec]
		push	[ebp+lt.tv_sec]	; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jle	short loc_8000DC3

loc_8000DBC:				; CODE XREF: binary_operator+48Fj
		mov	eax, 1
		jmp	short loc_8000DC8
; ---------------------------------------------------------------------------

loc_8000DC3:				; CODE XREF: binary_operator+481j
					; binary_operator+4B3j
		mov	eax, 0

loc_8000DC8:				; CODE XREF: binary_operator+4BAj
		and	eax, 1
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8000DD0:				; CODE XREF: binary_operator+396j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 66h
		jnz	loc_8001026
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001026
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		cmp	[ebp+l_is_l], 0
		jnz	short loc_8000E2F
		cmp	[ebp+r_is_l], 0
		jz	short loc_8000E4A

loc_8000E2F:				; CODE XREF: binary_operator+51Dj
		sub	esp, 0Ch
		push	offset aEfDoesNotAccep ; "-ef does not accept -l"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	0		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8000E4A:				; CODE XREF: binary_operator+526j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+lt]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000EEE
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+rt]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000EEE
		mov	ecx, [ebp+lt.tv_sec]
		mov	ebx, [ebp+lt.tv_nsec]
		mov	eax, [ebp+rt.tv_sec]
		mov	edx, [ebp+rt.tv_nsec]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8000EEE
		mov	ecx, [ebp+var_A0]
		mov	ebx, [ebp+var_9C]
		mov	eax, [ebp+var_40]
		mov	edx, [ebp+var_3C]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8000EEE
		mov	eax, 1
		jmp	short loc_8000EF3
; ---------------------------------------------------------------------------

loc_8000EEE:				; CODE XREF: binary_operator+570j
					; binary_operator+59Cj	...
		mov	eax, 0

loc_8000EF3:				; CODE XREF: binary_operator+5E5j
		and	eax, 1
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8000EFB:				; CODE XREF: binary_operator+38Dj
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		cmp	al, 74h
		jnz	loc_8001029
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 3
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8001029
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		cmp	[ebp+l_is_l], 0
		jnz	short loc_8000F5A
		cmp	[ebp+r_is_l], 0
		jz	short loc_8000F75

loc_8000F5A:				; CODE XREF: binary_operator+648j
		sub	esp, 0Ch
		push	offset aOtDoesNotAccep ; "-ot does not accept -l"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	0		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8000F75:				; CODE XREF: binary_operator+651j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+lt]
		push	edx		; mtime
		push	eax		; filename
		call	get_mtime
		add	esp, 10h
		mov	[ebp+le_0], al
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+rt]
		push	edx		; mtime
		push	eax		; filename
		call	get_mtime
		add	esp, 10h
		mov	[ebp+re_0], al
		cmp	[ebp+re_0], 0
		jz	short loc_8001016
		movzx	eax, [ebp+le_0]
		xor	eax, 1
		test	al, al
		jnz	short loc_800100F
		push	[ebp+rt.tv_nsec]
		push	[ebp+rt.tv_sec]	; b
		push	[ebp+lt.tv_nsec]
		push	[ebp+lt.tv_sec]	; a
		call	timespec_cmp
		add	esp, 10h
		test	eax, eax
		jns	short loc_8001016

loc_800100F:				; CODE XREF: binary_operator+6E2j
		mov	eax, 1
		jmp	short loc_800101B
; ---------------------------------------------------------------------------

loc_8001016:				; CODE XREF: binary_operator+6D4j
					; binary_operator+706j
		mov	eax, 0

loc_800101B:				; CODE XREF: binary_operator+70Dj
		and	eax, 1
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_8001023:				; CODE XREF: binary_operator+3BBj
					; binary_operator+3DBj
		nop
		jmp	short loc_800102A
; ---------------------------------------------------------------------------

loc_8001026:				; CODE XREF: binary_operator+4E3j
					; binary_operator+503j
		nop
		jmp	short loc_800102A
; ---------------------------------------------------------------------------

loc_8001029:				; CODE XREF: binary_operator+60Ej
					; binary_operator+62Ej
		nop

loc_800102A:				; CODE XREF: binary_operator+39Cj
					; binary_operator+71Dj	...
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aUnknownBinaryO ; "unknown binary operator"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8001056:				; CODE XREF: binary_operator+B1j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 3Dh
		jnz	short loc_80010E3
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_80010E3
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 2
		shl	edx, 2
		add	eax, edx
		mov	edx, [eax]
		mov	eax, ds:argv
		mov	ecx, ds:pos
		shl	ecx, 2
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setz	al
		mov	[ebp+value], al
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		movzx	eax, [ebp+value]
		jmp	loc_8001164
; ---------------------------------------------------------------------------

loc_80010E3:				; CODE XREF: binary_operator+766j
					; binary_operator+782j
		mov	eax, ds:argv
		mov	edx, [ebp+op]
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002239 ; "!="
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800115F
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 2
		shl	edx, 2
		add	eax, edx
		mov	edx, [eax]
		mov	eax, ds:argv
		mov	ecx, ds:pos
		shl	ecx, 2
		add	eax, ecx
		mov	eax, [eax]
		sub	esp, 8
		push	edx		; s2
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	[ebp+value_0], al
		mov	eax, ds:pos
		add	eax, 3
		mov	ds:pos,	eax
		movzx	eax, [ebp+value_0]
		jmp	short loc_8001164
; ---------------------------------------------------------------------------

loc_800115F:				; CODE XREF: binary_operator+801j
		call	abort
; ---------------------------------------------------------------------------

loc_8001164:				; CODE XREF: binary_operator+314j
					; binary_operator+347j	...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8001175
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001175:				; CODE XREF: binary_operator+867j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
binary_operator	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	unary_operator()
unary_operator	proc near		; CODE XREF: term+328p
					; two_arguments+D1p

arg		= dword	ptr -74h
fd		= dword	ptr -70h
stat_buf	= stat ptr -6Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 78h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 47h	; switch 52 cases
		cmp	eax, 33h
		ja	short loc_80011B9 ; jumptable 080011B7 default case
		mov	eax, ds:off_8002304[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80011B9:				; CODE XREF: unary_operator+32j
					; unary_operator+3Bj
					; DATA XREF: ...
		mov	eax, 0		; jumptable 080011B7 default case
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80011C3:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 cases 97,101
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		setz	al
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80011FA:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 114
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	4
		push	eax
		call	euidaccess
		add	esp, 10h
		test	eax, eax
		setz	al
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_800122F:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 119
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	2
		push	eax
		call	euidaccess
		add	esp, 10h
		test	eax, eax
		setz	al
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001264:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 120
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	1
		push	eax
		call	euidaccess
		add	esp, 10h
		test	eax, eax
		setz	al
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001299:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 79
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80012DF
		call	geteuid
		mov	edx, eax
		mov	eax, [ebp+stat_buf.st_uid]
		cmp	edx, eax
		jnz	short loc_80012DF
		mov	eax, 1
		jmp	short loc_80012E4
; ---------------------------------------------------------------------------

loc_80012DF:				; CODE XREF: unary_operator+14Cj
					; unary_operator+15Aj
		mov	eax, 0

loc_80012E4:				; CODE XREF: unary_operator+161j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80012EC:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 71
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001332
		call	getegid
		mov	edx, eax
		mov	eax, [ebp+stat_buf.st_gid]
		cmp	edx, eax
		jnz	short loc_8001332
		mov	eax, 1
		jmp	short loc_8001337
; ---------------------------------------------------------------------------

loc_8001332:				; CODE XREF: unary_operator+19Fj
					; unary_operator+1ADj
		mov	eax, 0

loc_8001337:				; CODE XREF: unary_operator+1B4j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_800133F:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 102
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001386
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 8000h
		jnz	short loc_8001386
		mov	eax, 1
		jmp	short loc_800138B
; ---------------------------------------------------------------------------

loc_8001386:				; CODE XREF: unary_operator+1F2j
					; unary_operator+201j
		mov	eax, 0

loc_800138B:				; CODE XREF: unary_operator+208j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001393:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 100
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80013DA
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 4000h
		jnz	short loc_80013DA
		mov	eax, 1
		jmp	short loc_80013DF
; ---------------------------------------------------------------------------

loc_80013DA:				; CODE XREF: unary_operator+246j
					; unary_operator+255j
		mov	eax, 0

loc_80013DF:				; CODE XREF: unary_operator+25Cj
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80013E7:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 115
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001432
		mov	eax, dword ptr [ebp+stat_buf.st_size]
		mov	edx, dword ptr [ebp+stat_buf.st_size+4]
		test	edx, edx
		js	short loc_8001432
		test	edx, edx
		jg	short loc_800142B
		cmp	eax, 0
		jbe	short loc_8001432

loc_800142B:				; CODE XREF: unary_operator+2A8j
		mov	eax, 1
		jmp	short loc_8001437
; ---------------------------------------------------------------------------

loc_8001432:				; CODE XREF: unary_operator+29Aj
					; unary_operator+2A4j ...
		mov	eax, 0

loc_8001437:				; CODE XREF: unary_operator+2B4j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_800143F:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 83
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001486
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 0C000h
		jnz	short loc_8001486
		mov	eax, 1
		jmp	short loc_800148B
; ---------------------------------------------------------------------------

loc_8001486:				; CODE XREF: unary_operator+2F2j
					; unary_operator+301j
		mov	eax, 0

loc_800148B:				; CODE XREF: unary_operator+308j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001493:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 99
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80014DA
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 2000h
		jnz	short loc_80014DA
		mov	eax, 1
		jmp	short loc_80014DF
; ---------------------------------------------------------------------------

loc_80014DA:				; CODE XREF: unary_operator+346j
					; unary_operator+355j
		mov	eax, 0

loc_80014DF:				; CODE XREF: unary_operator+35Cj
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80014E7:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 98
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800152E
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 6000h
		jnz	short loc_800152E
		mov	eax, 1
		jmp	short loc_8001533
; ---------------------------------------------------------------------------

loc_800152E:				; CODE XREF: unary_operator+39Aj
					; unary_operator+3A9j
		mov	eax, 0

loc_8001533:				; CODE XREF: unary_operator+3B0j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_800153B:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 112
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001582
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 1000h
		jnz	short loc_8001582
		mov	eax, 1
		jmp	short loc_8001587
; ---------------------------------------------------------------------------

loc_8001582:				; CODE XREF: unary_operator+3EEj
					; unary_operator+3FDj
		mov	eax, 0

loc_8001587:				; CODE XREF: unary_operator+404j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_800158F:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 cases 76,104
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	lstat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80015D6
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 0F000h
		cmp	eax, 0A000h
		jnz	short loc_80015D6
		mov	eax, 1
		jmp	short loc_80015DB
; ---------------------------------------------------------------------------

loc_80015D6:				; CODE XREF: unary_operator+442j
					; unary_operator+451j
		mov	eax, 0

loc_80015DB:				; CODE XREF: unary_operator+458j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80015E3:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 117
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001627
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 800h
		test	eax, eax
		jz	short loc_8001627
		mov	eax, 1
		jmp	short loc_800162C
; ---------------------------------------------------------------------------

loc_8001627:				; CODE XREF: unary_operator+496j
					; unary_operator+4A2j
		mov	eax, 0

loc_800162C:				; CODE XREF: unary_operator+4A9j
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001634:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 103
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001678
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 400h
		test	eax, eax
		jz	short loc_8001678
		mov	eax, 1
		jmp	short loc_800167D
; ---------------------------------------------------------------------------

loc_8001678:				; CODE XREF: unary_operator+4E7j
					; unary_operator+4F3j
		mov	eax, 0

loc_800167D:				; CODE XREF: unary_operator+4FAj
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_8001685:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 107
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		lea	edx, [ebp+stat_buf]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80016C9
		mov	eax, [ebp+stat_buf.st_mode]
		and	eax, 200h
		test	eax, eax
		jz	short loc_80016C9
		mov	eax, 1
		jmp	short loc_80016CE
; ---------------------------------------------------------------------------

loc_80016C9:				; CODE XREF: unary_operator+538j
					; unary_operator+544j
		mov	eax, 0

loc_80016CE:				; CODE XREF: unary_operator+54Bj
		and	eax, 1
		jmp	loc_80017A3
; ---------------------------------------------------------------------------

loc_80016D6:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 116
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; string
		call	find_int
		add	esp, 10h
		mov	[ebp+arg], eax
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	0Ah		; base
		push	0		; endptr
		push	[ebp+arg]	; nptr
		call	strtol
		add	esp, 10h
		mov	[ebp+fd], eax
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 22h
		jz	short loc_800174D
		cmp	[ebp+fd], 0
		js	short loc_800174D
		sub	esp, 0Ch
		push	[ebp+fd]	; fd
		call	isatty
		add	esp, 10h
		test	eax, eax
		jz	short loc_800174D
		mov	eax, 1
		jmp	short loc_8001752
; ---------------------------------------------------------------------------

loc_800174D:				; CODE XREF: unary_operator+5B0j
					; unary_operator+5B6j ...
		mov	eax, 0

loc_8001752:				; CODE XREF: unary_operator+5CFj
		and	eax, 1
		jmp	short loc_80017A3
; ---------------------------------------------------------------------------

loc_8001757:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 110
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		setnz	al
		jmp	short loc_80017A3
; ---------------------------------------------------------------------------

loc_800177E:				; CODE XREF: unary_operator+3Bj
					; DATA XREF: .rodata:off_8002304o
		call	unary_advance	; jumptable 080011B7 case 122
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3FFFFFFFh
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		setz	al

loc_80017A3:				; CODE XREF: unary_operator+42j
					; unary_operator+79j ...
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80017B4
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80017B4:				; CODE XREF: unary_operator+631j
		leave
		retn
unary_operator	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	and()
and		proc near		; CODE XREF: or:loc_800182Dp

value		= byte ptr -9

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+value], 1

loc_80017C0:				; CODE XREF: and+69j
		call	term
		movzx	edx, [ebp+value]
		movzx	eax, al
		and	eax, edx
		test	eax, eax
		setnz	al
		mov	[ebp+value], al
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jge	short loc_800180C
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset aA	; "-a"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001812

loc_800180C:				; CODE XREF: and+2Dj
		movzx	eax, [ebp+value]
		jmp	short locret_8001821
; ---------------------------------------------------------------------------

loc_8001812:				; CODE XREF: and+54j
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	short loc_80017C0
; ---------------------------------------------------------------------------

locret_8001821:				; CODE XREF: and+5Aj
		leave
		retn
and		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	or()
or		proc near		; CODE XREF: expr:loc_80018A7p

value		= byte ptr -9

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+value], 0

loc_800182D:				; CODE XREF: or+66j
		call	and
		or	al, [ebp+value]
		movzx	eax, al
		test	eax, eax
		setnz	al
		mov	[ebp+value], al
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jge	short loc_8001876
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset aO	; "-o"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_800187C

loc_8001876:				; CODE XREF: or+2Aj
		movzx	eax, [ebp+value]
		jmp	short locret_800188B
; ---------------------------------------------------------------------------

loc_800187C:				; CODE XREF: or+51j
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	short loc_800182D
; ---------------------------------------------------------------------------

locret_800188B:				; CODE XREF: or+57j
		leave
		retn
or		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	expr()
expr		proc near		; CODE XREF: three_arguments:loc_8001B8Ap
					; posixtest:loc_8001CF2p
		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jl	short loc_80018A7
		call	beyond
; ---------------------------------------------------------------------------

loc_80018A7:				; CODE XREF: expr+13j
		call	or
		leave
		retn
expr		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	test_unop(const	char *op)
test_unop	proc near		; CODE XREF: term+31Cp
					; two_arguments+C5p

op		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+op]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jz	short loc_80018C2
		mov	eax, 0
		jmp	short loc_80018EB
; ---------------------------------------------------------------------------

loc_80018C2:				; CODE XREF: test_unop+Bj
		mov	eax, [ebp+op]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 47h	; switch 52 cases
		cmp	eax, 33h
		ja	short loc_80018E6 ; jumptable 080018DD default case
		mov	eax, ds:off_80023DC[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80018DF:				; CODE XREF: test_unop+2Fj
					; DATA XREF: .rodata:off_80023DCo
		mov	eax, 1		; jumptable 080018DD cases 71,76,78,79,83,97-104,107,110-112,114-117,119,120,122
		jmp	short loc_80018EB
; ---------------------------------------------------------------------------

loc_80018E6:				; CODE XREF: test_unop+26j
					; test_unop+2Fj
					; DATA XREF: ...
		mov	eax, 0		; jumptable 080018DD default case

loc_80018EB:				; CODE XREF: test_unop+12j
					; test_unop+36j
		pop	ebp
		retn
test_unop	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	one_argument()
one_argument	proc near		; CODE XREF: two_arguments+3Bp
					; three_arguments+F2p ...
		push	ebp
		mov	ebp, esp
		mov	ecx, ds:argv
		mov	eax, ds:pos
		lea	edx, [eax+1]
		mov	ds:pos,	edx
		shl	eax, 2
		add	eax, ecx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		setnz	al
		pop	ebp
		retn
one_argument	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	two_arguments()
two_arguments	proc near		; CODE XREF: three_arguments+75p
					; posixtest:loc_8001C05p ...

value		= byte ptr -9
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024AC ; "!"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800196F
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		call	one_argument
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+value], al
		and	[ebp+value], 1
		jmp	loc_8001A21
; ---------------------------------------------------------------------------

loc_800196F:				; CODE XREF: two_arguments+2Cj
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Dh
		jnz	loc_8001A1C
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 1
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001A1C
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		add	eax, 2
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8001A1C
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; op
		call	test_unop
		add	esp, 10h
		test	al, al
		jz	short loc_80019F0
		call	unary_operator
		mov	[ebp+value], al
		jmp	short loc_8001A21
; ---------------------------------------------------------------------------

loc_80019F0:				; CODE XREF: two_arguments+CFj
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSUnaryOperator ; "%s: unary operator expected"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8001A1C:				; CODE XREF: two_arguments+71j
					; two_arguments+91j ...
		call	beyond
; ---------------------------------------------------------------------------

loc_8001A21:				; CODE XREF: two_arguments+55j
					; two_arguments+D9j
		movzx	eax, [ebp+value]
		mov	ebx, [ebp+var_4]
		leave
		retn
two_arguments	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	three_arguments()
three_arguments	proc near		; CODE XREF: posixtest:loc_8001C12p
					; posixtest+87p

value		= byte ptr -9
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	binop
		add	esp, 10h
		test	al, al
		jz	short loc_8001A6B
		sub	esp, 0Ch
		push	0		; l_is_l
		call	binary_operator
		add	esp, 10h
		mov	[ebp+value], al
		jmp	loc_8001BC3
; ---------------------------------------------------------------------------

loc_8001A6B:				; CODE XREF: three_arguments+2Aj
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024AC ; "!"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001ABE
		sub	esp, 0Ch
		push	1		; f
		call	advance
		add	esp, 10h
		call	two_arguments
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+value], al
		and	[ebp+value], 1
		jmp	loc_8001BC3
; ---------------------------------------------------------------------------

loc_8001ABE:				; CODE XREF: three_arguments+66j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024AE ; "("
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001B36
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 2
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002260 ; ")"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001B36
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		call	one_argument
		mov	[ebp+value], al
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	loc_8001BC3
; ---------------------------------------------------------------------------

loc_8001B36:				; CODE XREF: three_arguments+B9j
					; three_arguments+E3j
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset aA	; "-a"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_8001B8A
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset aO	; "-o"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001B94

loc_8001B8A:				; CODE XREF: three_arguments+134j
		call	expr
		mov	[ebp+value], al
		jmp	short loc_8001BC3
; ---------------------------------------------------------------------------

loc_8001B94:				; CODE XREF: three_arguments+15Ej
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 1
		shl	edx, 2
		add	eax, edx
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aSBinaryOperato ; "%s: binary operator expected"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8001BC3:				; CODE XREF: three_arguments+3Cj
					; three_arguments+8Fj ...
		movzx	eax, [ebp+value]
		mov	ebx, [ebp+var_4]
		leave
		retn
three_arguments	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	posixtest(int nargs)
posixtest	proc near		; CODE XREF: term+13Fp	main+B7p

value		= byte ptr -9
nargs		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+nargs]
		cmp	eax, 2
		jz	short loc_8001C05
		cmp	eax, 2
		jg	short loc_8001BE9
		cmp	eax, 1
		jz	short loc_8001BF8
		jmp	loc_8001CE7
; ---------------------------------------------------------------------------

loc_8001BE9:				; CODE XREF: posixtest+11j
		cmp	eax, 3
		jz	short loc_8001C12
		cmp	eax, 4
		jz	short loc_8001C1F
		jmp	loc_8001CE7
; ---------------------------------------------------------------------------

loc_8001BF8:				; CODE XREF: posixtest+16j
		call	one_argument
		mov	[ebp+value], al
		jmp	loc_8001CFA
; ---------------------------------------------------------------------------

loc_8001C05:				; CODE XREF: posixtest+Cj
		call	two_arguments
		mov	[ebp+value], al
		jmp	loc_8001CFA
; ---------------------------------------------------------------------------

loc_8001C12:				; CODE XREF: posixtest+20j
		call	three_arguments
		mov	[ebp+value], al
		jmp	loc_8001CFA
; ---------------------------------------------------------------------------

loc_8001C1F:				; CODE XREF: posixtest+25j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024AC ; "!"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001C72
		sub	esp, 0Ch
		push	1		; f
		call	advance
		add	esp, 10h
		call	three_arguments
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		mov	[ebp+value], al
		and	[ebp+value], 1
		jmp	loc_8001CFA
; ---------------------------------------------------------------------------

loc_8001C72:				; CODE XREF: posixtest+78j
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_80024AE ; "("
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001CE7
		mov	eax, ds:argv
		mov	edx, ds:pos
		add	edx, 3
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_8002260 ; ")"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8001CE7
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		call	two_arguments
		mov	[ebp+value], al
		sub	esp, 0Ch
		push	0		; f
		call	advance
		add	esp, 10h
		jmp	short loc_8001CFA
; ---------------------------------------------------------------------------

loc_8001CE7:				; CODE XREF: posixtest+18j
					; posixtest+27j ...
		cmp	[ebp+nargs], 0
		jg	short loc_8001CF2
		call	abort
; ---------------------------------------------------------------------------

loc_8001CF2:				; CODE XREF: posixtest+11Fj
		call	expr
		mov	[ebp+value], al

loc_8001CFA:				; CODE XREF: posixtest+34j
					; posixtest+41j ...
		movzx	eax, [ebp+value]
		leave
		retn
posixtest	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8001D3D
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8001F7E
; ---------------------------------------------------------------------------

loc_8001D3D:				; CODE XREF: usage+Bj
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aUsageTestExpre ; "Usage: test EXPRESSION\n  or:	 test\n	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aExitWithTheSta ; "Exit with the	status determined by EXPR"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aAnOmittedExpre ; "\nAn omitted EXPRESSION defaults to fal"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aExpressionExpr ; "\n  (	EXPRESSION )		   EXPRES"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNStringTheLeng ; "\n  -n STRING		   the length of "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aInteger1EqInte ; "\n  INTEGER1 -eq INTEGER2   INTEGER1 is"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFile1EfFile2Fi ; "\n  FILE1 -ef	FILE2	FILE1 and FILE2	h"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBFileFileExist ; "\n  -b FILE	  FILE exists and is bloc"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFFileFileExist ; "  -f FILE	FILE exists and	is a regu"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aLFileFileExist ; "  -L FILE	FILE exists and	is a symb"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSFileFileExist ; "  -S FILE	FILE exists and	is a sock"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aExceptForHAndL ; "\nExcept for -h and -L, all FILE-relate"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoteHonorsTheH ; "\nNOTE: [ honors the --help and --versi"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aTestAndOr ; "test and/or ["
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aNoteYourShellM ; "\nNOTE: your shell may have its own ver"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_8001F7E:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

value		= byte ptr -9
margc		= dword	ptr  0Ch
margv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	2		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	eax, [ebx+4]
		mov	ds:argv, eax
		mov	eax, [ebx]
		mov	ds:argc, eax
		mov	ds:pos,	1
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jl	short loc_8002034
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002034:				; CODE XREF: main+9Fj
		mov	eax, ds:argc
		sub	eax, 1
		sub	esp, 0Ch
		push	eax		; nargs
		call	posixtest
		add	esp, 10h
		mov	[ebp+value], al
		mov	edx, ds:pos
		mov	eax, ds:argc
		cmp	edx, eax
		jz	short loc_8002094
		mov	eax, ds:argv
		mov	edx, ds:pos
		shl	edx, 2
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraArgumentS ; "extra	argument %s"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx		; arg
		push	eax		; format
		call	test_syntax_error
; ---------------------------------------------------------------------------

loc_8002094:				; CODE XREF: main+CFj
		cmp	[ebp+value], 0
		jz	short loc_80020A1
		mov	eax, 0
		jmp	short loc_80020A6
; ---------------------------------------------------------------------------

loc_80020A1:				; CODE XREF: main+10Fj
		mov	eax, 1

loc_80020A6:				; CODE XREF: main+116j
		sub	esp, 0Ch
		push	eax		; status

loc_80020AA:				; DATA XREF: .eh_frame:08003120o
					; .eh_frame:08003140o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 80020B0h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; int pos
pos		dd ?			; DATA XREF: advance+Cr advance+14w ...
; int argc
argc		dd ?			; DATA XREF: advance+25r beyond+Cr ...
; char **argv
argv		dd ?			; DATA XREF: test_syntax_error+6r
					; beyond+7r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 80020BCh
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
; char format[]
format		db '%s: ',0             ; DATA XREF: test_syntax_error+16o
; char aMissingArgumen[]
aMissingArgumen	db 'missing argument after %s',0 ; DATA XREF: beyond+30o
; char aInvalidInteger[]
aInvalidInteger	db 'invalid integer %s',0 ; DATA XREF: find_int+F6o
; char asc_8002237[]
asc_8002237	db '=',0                ; DATA XREF: binop+9o
; char asc_8002239[]
asc_8002239	db '!=',0               ; DATA XREF: binop+24o
					; binary_operator+7F1o
; char aNt[]
aNt		db '-nt',0              ; DATA XREF: binop+3Fo
; char aOt[]
aOt		db '-ot',0              ; DATA XREF: binop+5Ao
; char aEf[]
aEf		db '-ef',0              ; DATA XREF: binop+75o
; char aEq[]
aEq		db '-eq',0              ; DATA XREF: binop+90o
; char aNe[]
aNe		db '-ne',0              ; DATA XREF: binop+A7o
; char aLt[]
aLt		db '-lt',0              ; DATA XREF: binop+BEo
; char aLe[]
aLe		db '-le',0              ; DATA XREF: binop+D5o
; char aGt[]
aGt		db '-gt',0              ; DATA XREF: binop+ECo
; char aGe[]
aGe		db '-ge',0              ; DATA XREF: binop+103o
; char asc_8002260[]
asc_8002260	db ')',0                ; DATA XREF: term+127o
					; three_arguments+D3o ...
; char aExpected[]
aExpected	db 27h,')',27h,' expected',0 ; DATA XREF: term+163o
; char aExpectedFoundS[]
aExpectedFoundS	db 27h,')',27h,' expected, found %s',0 ; DATA XREF: term+1C5o
; char asc_8002286[]
asc_8002286	db '-l',0               ; DATA XREF: term+217o
					; binary_operator+6Bo
; char aSUnaryOperator[]
aSUnaryOperator	db '%s: unary operator expected',0 ; DATA XREF: term+347o
					; two_arguments+F0o
; char aNtDoesNotAccep[]
aNtDoesNotAccep	db '-nt does not accept -l',0 ; DATA XREF: binary_operator+403o
; char aEfDoesNotAccep[]
aEfDoesNotAccep	db '-ef does not accept -l',0 ; DATA XREF: binary_operator+52Bo
; char aOtDoesNotAccep[]
aOtDoesNotAccep	db '-ot does not accept -l',0 ; DATA XREF: binary_operator+656o
; char aUnknownBinaryO[]
aUnknownBinaryO	db 'unknown binary operator',0 ; DATA XREF: binary_operator+738o
		align 4
off_8002304	dd offset loc_80012EC, offset loc_80011B9, offset loc_80011B9
					; DATA XREF: unary_operator+34r
		dd offset loc_80011B9, offset loc_80011B9, offset loc_800158F ;	jump table for switch statement
		dd offset loc_80011B9, offset loc_80011B9, offset loc_8001299
		dd offset loc_80011B9, offset loc_80011B9, offset loc_80011B9
		dd offset loc_800143F, offset loc_80011B9, offset loc_80011B9
		dd offset loc_80011B9, offset loc_80011B9, offset loc_80011B9
		dd offset loc_80011B9, offset loc_80011B9, offset loc_80011B9
		dd offset loc_80011B9, offset loc_80011B9, offset loc_80011B9
		dd offset loc_80011B9, offset loc_80011B9, offset loc_80011C3
		dd offset loc_80014E7, offset loc_8001493, offset loc_8001393
		dd offset loc_80011C3, offset loc_800133F, offset loc_8001634
		dd offset loc_800158F, offset loc_80011B9, offset loc_80011B9
		dd offset loc_8001685, offset loc_80011B9, offset loc_80011B9
		dd offset loc_8001757, offset loc_80011B9, offset loc_800153B
		dd offset loc_80011B9, offset loc_80011FA, offset loc_80013E7
		dd offset loc_80016D6, offset loc_80015E3, offset loc_80011B9
		dd offset loc_800122F, offset loc_8001264, offset loc_80011B9
		dd offset loc_800177E
; char aA[3]
aA		db '-a',0               ; DATA XREF: and+44o
					; three_arguments+124o
; char aO[3]
aO		db '-o',0               ; DATA XREF: or+41o
					; three_arguments+14Eo
		align 4
off_80023DC	dd offset loc_80018DF, offset loc_80018E6, offset loc_80018E6
					; DATA XREF: test_unop+28r
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018DF ;	jump table for switch statement
		dd offset loc_80018E6, offset loc_80018DF, offset loc_80018DF
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018DF, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018E6, offset loc_80018E6, offset loc_80018DF
		dd offset loc_80018DF, offset loc_80018DF, offset loc_80018DF
		dd offset loc_80018DF, offset loc_80018DF, offset loc_80018DF
		dd offset loc_80018DF, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018DF, offset loc_80018E6, offset loc_80018E6
		dd offset loc_80018DF, offset loc_80018DF, offset loc_80018DF
		dd offset loc_80018E6, offset loc_80018DF, offset loc_80018DF
		dd offset loc_80018DF, offset loc_80018DF, offset loc_80018E6
		dd offset loc_80018DF, offset loc_80018DF, offset loc_80018E6
		dd offset loc_80018DF
; char asc_80024AC[2]
asc_80024AC	db '!',0                ; DATA XREF: two_arguments+1Co
					; three_arguments+56o ...
; char asc_80024AE[2]
asc_80024AE	db '(',0                ; DATA XREF: three_arguments+A9o
					; posixtest+BBo
; char aSBinaryOperato[]
aSBinaryOperato	db '%s: binary operator expected',0 ; DATA XREF: three_arguments+182o
		align 10h
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageTestExpre[]
aUsageTestExpre	db 'Usage: test EXPRESSION',0Ah ; DATA XREF: usage+46o
		db '  or:  test',0Ah
		db '  or:  [ EXPRESSION ]',0Ah
		db '  or:  [ ]',0Ah
		db '  or:  [ OPTION',0Ah,0
		align 10h
; char aExitWithTheSta[]
aExitWithTheSta	db 'Exit with the status determined by EXPRESSION.',0Ah
					; DATA XREF: usage+69o
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+8Co
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+AFo
		align 4
; char aAnOmittedExpre[]
aAnOmittedExpre	db 0Ah			; DATA XREF: usage+D2o
		db 'An omitted EXPRESSION defaults to false.  Otherwise,',0Ah
		db 'EXPRESSION is true or false and sets exit status.  It is one of:',0Ah
		db 0
; char aExpressionExpr[]
aExpressionExpr	db 0Ah			; DATA XREF: usage+F5o
		db '  ( EXPRESSION )               EXPRESSION is true',0Ah
		db '  ! EXPRESSION                 EXPRESSION is false',0Ah
		db '  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 a'
		db 're true',0Ah
		db '  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 '
		db 'is true',0Ah,0
		align 10h
; char aNStringTheLeng[]
aNStringTheLeng	db 0Ah			; DATA XREF: usage+118o
		db '  -n STRING            the length of STRING is nonzero',0Ah
		db '  STRING               equivalent to -n STRING',0Ah
		db '  -z STRING            the length of STRING is zero',0Ah
		db '  STRING1 = STRING2    the strings are equal',0Ah
		db '  STRING1 != STRING2   the strings are not equal',0Ah,0
		align 4
; char aInteger1EqInte[]
aInteger1EqInte	db 0Ah			; DATA XREF: usage+13Bo
		db '  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2',0Ah
		db '  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to IN'
		db 'TEGER2',0Ah
		db '  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2',0Ah
		db '  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEG'
		db 'ER2',0Ah
		db '  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2',0Ah
		db '  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2',0Ah,0
; char aFile1EfFile2Fi[]
aFile1EfFile2Fi	db 0Ah			; DATA XREF: usage+15Eo
		db '  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inod'
		db 'e numbers',0Ah
		db '  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2'
		db 0Ah
		db '  FILE1 -ot FILE2   FILE1 is older than FILE2',0Ah,0
		align 4
; char aBFileFileExist[]
aBFileFileExist	db 0Ah			; DATA XREF: usage+181o
		db '  -b FILE     FILE exists and is block special',0Ah
		db '  -c FILE     FILE exists and is character special',0Ah
		db '  -d FILE     FILE exists and is a directory',0Ah
		db '  -e FILE     FILE exists',0Ah,0
		align 10h
; char aFFileFileExist[]
aFFileFileExist	db '  -f FILE     FILE exists and is a regular file',0Ah
					; DATA XREF: usage+1A4o
		db '  -g FILE     FILE exists and is set-group-ID',0Ah
		db '  -G FILE     FILE exists and is owned by the effective group ID',0Ah
		db '  -h FILE     FILE exists and is a symbolic link (same as -L)',0Ah
		db '  -k FILE     FILE exists and has its sticky bit set',0Ah,0
		align 4
; char aLFileFileExist[]
aLFileFileExist	db '  -L FILE     FILE exists and is a symbolic link (same as -h)',0Ah
					; DATA XREF: usage+1C7o
		db '  -O FILE     FILE exists and is owned by the effective user ID',0Ah
		db '  -p FILE     FILE exists and is a named pipe',0Ah
		db '  -r FILE     FILE exists and read permission is granted',0Ah
		db '  -s FILE     FILE exists and has a size greater than zero',0Ah,0
		align 4
; char aSFileFileExist[]
aSFileFileExist	db '  -S FILE     FILE exists and is a socket',0Ah ; DATA XREF: usage+1EAo
		db '  -t FD       file descriptor FD is opened on a terminal',0Ah
		db '  -u FILE     FILE exists and its set-user-ID bit is set',0Ah
		db '  -w FILE     FILE exists and write permission is granted',0Ah
		db '  -x FILE     FILE exists and execute (or search) permission is g'
		db 'ranted',0Ah,0
		align 4
; char aExceptForHAndL[]
aExceptForHAndL	db 0Ah			; DATA XREF: usage+20Do
		db 'Except for -h and -L, all FILE-related tests dereference symbolic'
		db ' links.',0Ah
		db 'Beware that parentheses need to be escaped (e.g., by backslashes)'
		db ' for shells.',0Ah
		db 'INTEGER may also be -l STRING, which evaluates to the length of S'
		db 'TRING.',0Ah,0
		align 4
; char aNoteHonorsTheH[]
aNoteHonorsTheH	db 0Ah			; DATA XREF: usage+230o
		db 'NOTE: [ honors the --help and --version options, but test does no'
		db 't.',0Ah
		db 'test treats each of those as it treats any other nonempty STRING.'
		db 0Ah,0
; char aTestAndOr[]
aTestAndOr	db 'test and/or [',0    ; DATA XREF: usage+24Do
		align 4
; char aNoteYourShellM[]
aNoteYourShellM	db 0Ah			; DATA XREF: usage+25Fo
		db 'NOTE: your shell may have its own version of %s, which usually su'
		db 'persedes',0Ah
		db 'the version described here.  Please refer to your shell',27h,'s docu'
		db 'mentation',0Ah
		db 'for details about the options it supports.',0Ah,0
; char locale
locale		db 0			; DATA XREF: main+28o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
; char aExtraArgumentS[]
aExtraArgumentS	db 'extra argument %s',0 ; DATA XREF: main+F4o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8003100h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_80020AA-80051CAh
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 1Ch, 3Ch
		dd offset loc_80020AA-80051D6h
		dd 46h,	80E4100h, 0D420285h, 0C5420205h, 4040Ch, 1Ch, 5Ch
		dd offset loc_80020AA-80051B0h
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 7Ch
		dd offset loc_80020AA-80051BEh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	0A0h
		dd offset loc_80020AA-80050C6h
		dd 1Bh,	80E4100h, 0D420285h, 0CC55505h,	404h, 18h, 0C0h
		dd offset loc_80020AA-80050CBh
		dd 69h,	80E4100h, 0D420285h, 5,	1Ch, 0DCh
		dd offset loc_80020AA-800507Eh
		dd 36h,	80E4100h, 0D420285h, 0CC57205h,	404h, 1Ch, 0FCh
		dd offset loc_80020AA-8005068h
		dd 23h,	80E4100h, 0D420285h, 0CC55F05h,	404h, 18h, 11Ch
		dd offset loc_80020AA-8005065h
		dd 47h,	80E4100h, 0D420285h, 3834405h, 20h, 138h
		dd offset loc_80020AA-800503Ah
		dd 112h, 80E4100h, 0D420285h, 3834405h,	0C5010A03h, 4040CC3h
		dd 20h,	15Ch
		dd offset loc_80020AA-8004F4Ch
		dd 85h,	80E4100h, 0D420285h, 3834705h, 0C3C57A02h, 4040Ch
		dd 1Ch,	180h
		dd offset loc_80020AA-8004EEBh
		dd 128h, 80E4100h, 0D420285h, 1240305h,	4040CC5h, 20h
		dd 1A0h
		dd offset loc_80020AA-8004DE3h
		dd 39Ch, 80E4100h, 0D420285h, 3834405h,	0C5039403h, 4040CC3h
		dd 28h,	1C4h
		dd offset loc_80020AA-8004A6Bh
		dd 875h, 80E4100h, 0D420285h, 3864805h,	67030483h, 0C641C308h
		dd 40CC541h, 4,	1Ch, 1F0h
		dd offset loc_80020AA-8004222h
		dd 63Ah, 80E4100h, 0D420285h, 6360305h,	4040CC5h, 1Ch
		dd 210h
		dd offset loc_80020AA-8003C08h
		dd 6Dh,	80E4100h, 0D420285h, 0C5690205h, 4040Ch, 1Ch, 230h
		dd offset loc_80020AA-8003BBBh
		dd 6Ah,	80E4100h, 0D420285h, 0C5660205h, 4040Ch, 1Ch, 250h
		dd offset loc_80020AA-8003B71h
		dd 21h,	80E4100h, 0D420285h, 0CC55D05h,	404h, 1Ch, 270h
		dd offset loc_80020AA-8003B70h
		dd 3Fh,	80E4100h, 0D420285h, 0CC57B05h,	404h, 1Ch, 290h
		dd offset loc_80020AA-8003B51h
		dd 28h,	80E4100h, 0D420285h, 0CC56405h,	404h, 20h, 2B0h
		dd offset loc_80020AA-8003B49h
		dd 115h, 80E4100h, 0D420285h, 3834405h,	0C5010D03h, 4040CC3h
		dd 20h,	2D4h
		dd offset loc_80020AA-8003A58h
		dd 1A2h, 80E4100h, 0D420285h, 3834405h,	0C5019A03h, 4040CC3h
		dd 1Ch,	2F8h
		dd offset loc_80020AA-80038DAh
		dd 134h, 80E4100h, 0D420285h, 1300305h,	4040CC5h, 18h
		dd 318h
		dd offset loc_80020AA-80037C6h
		dd 289h, 80E4100h, 0D420285h, 3834405h,	24h, 334h
		dd offset loc_80020AA-8003559h
		dd 126h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage:loc_8001D3Dr ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+58p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: test_syntax_error+Dr
					; test_syntax_error+24r ...
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: test_syntax_error+1Cp
					; test_syntax_error+33p ...
; int fputc_unlocked(int c, FILE *stream)
		extrn fputc_unlocked:near ; CODE XREF: test_syntax_error+46p
; int fflush_unlocked(FILE *stream)
		extrn fflush_unlocked:near ; CODE XREF:	test_syntax_error+57p
; void exit(int	status)
		extrn exit:near		; CODE XREF: test_syntax_error+64p
					; usage+284p ...
		extrn quote:near	; CODE XREF: beyond+23p find_int+E9p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: find_int:loc_80002BFp
					; find_int:loc_8000350p
		extrn stat64:near	; CODE XREF: get_mtime+2Bp
					; binary_operator+566p	...
		extrn __stack_chk_fail:near ; CODE XREF: get_mtime+7Bp
					; binary_operator+869p	...
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: binop+11p	binop+2Cp ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: binary_operator+1E8p
					; binary_operator+254p
		extrn umaxtostr:near	; CODE XREF: binary_operator+1FEp
					; binary_operator+26Ap
		extrn strintcmp:near	; CODE XREF: binary_operator+2AAp
; void abort(void)
		extrn abort:near	; CODE XREF: binary_operator:loc_800115Fp
					; posixtest+121p
		extrn euidaccess:near	; CODE XREF: unary_operator+A1p
					; unary_operator+D6p ...
; __uid_t geteuid(void)
		extrn geteuid:near	; CODE XREF: unary_operator+14Ep
; __gid_t getegid(void)
		extrn getegid:near	; CODE XREF: unary_operator+1A1p
		extrn lstat64:near	; CODE XREF: unary_operator+438p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: unary_operator+586p
					; unary_operator+5A6p
; __int32 strtol(const char *nptr, char	**endptr, int base)
		extrn strtol:near	; CODE XREF: unary_operator+59Bp
; int isatty(int fd)
		extrn isatty:near	; CODE XREF: unary_operator+5BEp
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+6Co
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+71p


		end
