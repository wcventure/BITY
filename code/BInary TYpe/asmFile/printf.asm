;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	BD7717BF310DEC1566FF2F7FC5F8006F
; Input	CRC32 :	7692B58C

; File Name   :	D:\coreutils-o\printf.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'printf.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: print_esc+B8p
					; print_esc+245p

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+17Bp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+B7p main+15Fp

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		cmp	[ebp+status], 0
		jz	short loc_8000169
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002AE
; ---------------------------------------------------------------------------

loc_8000169:				; CODE XREF: usage+9j
		mov	esi, ds:program_name
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSFormatAr ; "Usage: %s FORMAT [ARGUMENT]...\n  or:	 "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	esi
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aPrintArgumentS ; "Print	ARGUMENT(s) according to FORMAT, "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aFormatControls ; "\nFORMAT controls the	output as in C pr"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aBackslashAAler ; "  \\\\      backslash\n  \\a	    alert"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNnnByteWithOct ; "  \\NNN    byte with octal value NNN (1"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aASingleBArgume ; "  %%	    a single %\n  %b	  ARGUMEN"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aNoteYourShellM ; "\nNOTE: your shell may have its own ver"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	offset aPrintf	; "printf"
		push	eax		; format
		call	printf
		add	esp, 10h
		call	emit_ancillary_info

loc_80002AE:				; CODE XREF: usage+36j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl verify_numeric(const char *s, const char	*end)
verify_numeric	proc near		; CODE XREF: vstrtoimax+B4p
					; vstrtoumax+B4p ...

s		= dword	ptr  8
end		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		call	__errno_location
		mov	eax, [eax]
		test	eax, eax
		jz	short loc_80002F0
		call	__errno_location
		mov	eax, [eax]
		push	[ebp+s]
		push	offset format	; "%s"
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	ds:exit_status,	1
		jmp	short loc_800034E
; ---------------------------------------------------------------------------

loc_80002F0:				; CODE XREF: verify_numeric+Fj
		mov	eax, [ebp+end]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_800034E
		mov	eax, [ebp+s]
		cmp	eax, [ebp+end]
		jnz	short loc_8000324
		sub	esp, 0Ch
		push	offset aSExpectedANume ; "%s: expected a numeric value"
		call	gettext
		add	esp, 10h
		push	[ebp+s]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000344
; ---------------------------------------------------------------------------

loc_8000324:				; CODE XREF: verify_numeric+47j
		sub	esp, 0Ch
		push	offset aSValueNotCompl ; "%s: value not	completely converted"
		call	gettext
		add	esp, 10h
		push	[ebp+s]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8000344:				; CODE XREF: verify_numeric+69j
		mov	ds:exit_status,	1

loc_800034E:				; CODE XREF: verify_numeric+35j
					; verify_numeric+3Fj
		nop
		leave
		retn
verify_numeric	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; intmax_t __cdecl vstrtoimax(const char *s)
vstrtoimax	proc near		; CODE XREF: print_direc+D7p
					; print_formatted+313p	...

s		= dword	ptr -2Ch
ch_0		= byte ptr -1Dh
end		= dword	ptr -1Ch
val		= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 22h
		jz	short loc_800037C
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 27h
		jnz	short loc_80003D6

loc_800037C:				; CODE XREF: vstrtoimax+1Fj
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], 0
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_800040F
		movzx	eax, ds:posixly_correct
		xor	eax, 1
		test	al, al
		jz	short loc_800040F
		mov	eax, offset aWarningSCharac ; "warning:	%s: character(s) following cha"...
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		push	[ebp+s]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_800040F
; ---------------------------------------------------------------------------

loc_80003D6:				; CODE XREF: vstrtoimax+29j
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	0		; base
		lea	eax, [ebp+end]
		push	eax		; endptr
		push	[ebp+s]		; nptr
		call	strtoimax
		add	esp, 10h
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	eax, [ebp+end]
		sub	esp, 8
		push	eax		; end
		push	[ebp+s]		; s
		call	verify_numeric
		add	esp, 10h
		jmp	short loc_8000410
; ---------------------------------------------------------------------------

loc_800040F:				; CODE XREF: vstrtoimax+52j
					; vstrtoimax+60j ...
		nop

loc_8000410:				; CODE XREF: vstrtoimax+BCj
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8000427
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000427:				; CODE XREF: vstrtoimax+CFj
		leave
		retn
vstrtoimax	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; uintmax_t __cdecl vstrtoumax(const char *s)
vstrtoumax	proc near		; CODE XREF: print_direc+176p

s		= dword	ptr -2Ch
ch_0		= byte ptr -1Dh
end		= dword	ptr -1Ch
val		= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 22h
		jz	short loc_8000454
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 27h
		jnz	short loc_80004AE

loc_8000454:				; CODE XREF: vstrtoumax+1Fj
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], 0
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80004E7
		movzx	eax, ds:posixly_correct
		xor	eax, 1
		test	al, al
		jz	short loc_80004E7
		mov	eax, offset aWarningSCharac ; "warning:	%s: character(s) following cha"...
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		push	[ebp+s]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_80004E7
; ---------------------------------------------------------------------------

loc_80004AE:				; CODE XREF: vstrtoumax+29j
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 4
		push	0		; base
		lea	eax, [ebp+end]
		push	eax		; endptr
		push	[ebp+s]		; nptr
		call	strtoumax
		add	esp, 10h
		mov	dword ptr [ebp+val], eax
		mov	dword ptr [ebp+val+4], edx
		mov	eax, [ebp+end]
		sub	esp, 8
		push	eax		; end
		push	[ebp+s]		; s
		call	verify_numeric
		add	esp, 10h
		jmp	short loc_80004E8
; ---------------------------------------------------------------------------

loc_80004E7:				; CODE XREF: vstrtoumax+52j
					; vstrtoumax+60j ...
		nop

loc_80004E8:				; CODE XREF: vstrtoumax+BCj
		mov	eax, dword ptr [ebp+val]
		mov	edx, dword ptr [ebp+val+4]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80004FF
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80004FF:				; CODE XREF: vstrtoumax+CFj
		leave
		retn
vstrtoumax	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; long double __cdecl vstrtold(const char *s)
vstrtold	proc near		; CODE XREF: print_direc+215p

var_48		= tbyte	ptr -48h
s		= dword	ptr -2Ch
ch_0		= byte ptr -1Dh
end		= dword	ptr -1Ch
val		= LONG_DOUBLE_12 ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 48h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 22h
		jz	short loc_800052C
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		cmp	al, 27h
		jnz	short loc_8000586

loc_800052C:				; CODE XREF: vstrtold+1Fj
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		mov	word ptr [ebp+var_48], ax
		fild	word ptr [ebp+var_48]
		fstp	[ebp+val.value]
		add	[ebp+s], 1
		mov	eax, [ebp+s]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_80005CC
		movzx	eax, ds:posixly_correct
		xor	eax, 1
		test	al, al
		jz	short loc_80005CC
		mov	eax, offset aWarningSCharac ; "warning:	%s: character(s) following cha"...
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		push	[ebp+s]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_80005CC
; ---------------------------------------------------------------------------

loc_8000586:				; CODE XREF: vstrtold+29j
		call	__errno_location
		mov	dword ptr [eax], 0
		sub	esp, 8
		lea	eax, [ebp+end]
		push	eax
		push	[ebp+s]
		call	c_strtold
		add	esp, 10h
		fstp	[ebp+var_48]
		mov	eax, dword ptr [ebp+var_48]
		mov	edx, dword ptr [ebp+var_48+4]
		mov	ecx, dword ptr [ebp+var_48+8]
		mov	dword ptr [ebp+val.value], eax
		mov	dword ptr [ebp+val.value+4], edx
		mov	dword ptr [ebp+val.value+8], ecx
		mov	eax, [ebp+end]
		sub	esp, 8
		push	eax		; end
		push	[ebp+s]		; s
		call	verify_numeric
		add	esp, 10h
		jmp	short loc_80005CD
; ---------------------------------------------------------------------------

loc_80005CC:				; CODE XREF: vstrtold+52j vstrtold+60j ...
		nop

loc_80005CD:				; CODE XREF: vstrtold+C9j
		fld	[ebp+val.value]
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short locret_80005E3
		fstp	st
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80005E3:				; CODE XREF: vstrtold+D9j
		leave
		retn
vstrtold	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_esc_char(char c)
print_esc_char	proc near		; CODE XREF: print_esc+1DEp

c		= byte ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		movsx	eax, [ebp+c]
		sub	eax, 61h	; switch 22 cases
		cmp	eax, 15h
		ja	loc_800068F	; jumptable 08000608 default case
		mov	eax, ds:off_8001DC8[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_800060A:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 97
		push	7		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_80006A0
; ---------------------------------------------------------------------------

loc_800061C:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 98
		push	8		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_800062B:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 99
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000635:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 101
		push	1Bh		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_8000644:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 102
		push	0Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_8000653:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 110
		push	0Ah		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_8000662:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 114
		push	0Dh		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_8000671:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 116
		push	9		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_8000680:				; CODE XREF: print_esc_char+23j
					; DATA XREF: .rodata:off_8001DC8o
		sub	esp, 0Ch	; jumptable 08000608 case 118
		push	0Bh		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_80006A0
; ---------------------------------------------------------------------------

loc_800068F:				; CODE XREF: print_esc_char+16j
					; print_esc_char+23j
					; DATA XREF: ...
		movsx	eax, [ebp+c]	; jumptable 08000608 default case
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		nop

loc_80006A0:				; CODE XREF: print_esc_char+32j
					; print_esc_char+44j ...
		nop
		leave
		retn
print_esc_char	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl print_esc(const char *escstart, _Bool octal_0)
print_esc	proc near		; CODE XREF: print_esc_string+1Ap
					; print_formatted+613p

octal_0		= byte ptr -2Ch
esc_char	= byte ptr -19h
p		= dword	ptr -18h
esc_value	= dword	ptr -14h
esc_length	= dword	ptr -10h
uni_value	= dword	ptr -0Ch
escstart	= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 30h
		mov	eax, [ebp+arg_4]
		mov	[ebp+octal_0], al
		mov	eax, [ebp+escstart]
		add	eax, 1
		mov	[ebp+p], eax
		mov	[ebp+esc_value], 0
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 78h
		jnz	loc_80007B6
		mov	[ebp+esc_length], 0
		add	[ebp+p], 1
		jmp	short loc_8000741
; ---------------------------------------------------------------------------

loc_80006DC:				; CODE XREF: print_esc+D4j
		mov	eax, [ebp+esc_value]
		shl	eax, 4
		mov	edx, eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 60h
		jle	short loc_8000706
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 66h
		jg	short loc_8000706
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 57h
		jmp	short loc_8000734
; ---------------------------------------------------------------------------

loc_8000706:				; CODE XREF: print_esc+49j
					; print_esc+53j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 40h
		jle	short loc_8000728
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 46h
		jg	short loc_8000728
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 37h
		jmp	short loc_8000734
; ---------------------------------------------------------------------------

loc_8000728:				; CODE XREF: print_esc+6Bj
					; print_esc+75j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h

loc_8000734:				; CODE XREF: print_esc+61j
					; print_esc+83j
		add	eax, edx
		mov	[ebp+esc_value], eax
		add	[ebp+esc_length], 1
		add	[ebp+p], 1

loc_8000741:				; CODE XREF: print_esc+37j
		cmp	[ebp+esc_length], 1
		jg	short loc_800077D
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1000h
		test	eax, eax
		jnz	loc_80006DC

loc_800077D:				; CODE XREF: print_esc+A2j
		cmp	[ebp+esc_length], 0
		jnz	short loc_80007A3
		sub	esp, 0Ch
		push	offset aMissingHexadec ; "missing hexadecimal number in	escape"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80007A3:				; CODE XREF: print_esc+DEj
		sub	esp, 0Ch
		push	[ebp+esc_value]	; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000A45
; ---------------------------------------------------------------------------

loc_80007B6:				; CODE XREF: print_esc+26j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jle	loc_8000846
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 37h
		jg	short loc_8000846
		mov	[ebp+esc_length], 0
		cmp	[ebp+octal_0], 0
		jz	short loc_80007EC
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 30h
		jnz	short loc_80007EC
		mov	eax, 1
		jmp	short loc_80007F1
; ---------------------------------------------------------------------------

loc_80007EC:				; CODE XREF: print_esc+136j
					; print_esc+140j
		mov	eax, 0

loc_80007F1:				; CODE XREF: print_esc+147j
		add	[ebp+p], eax
		jmp	short loc_8000819
; ---------------------------------------------------------------------------

loc_80007F6:				; CODE XREF: print_esc+18Ej
		mov	eax, [ebp+esc_value]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		add	eax, edx
		mov	[ebp+esc_value], eax
		add	[ebp+esc_length], 1
		add	[ebp+p], 1

loc_8000819:				; CODE XREF: print_esc+151j
		cmp	[ebp+esc_length], 2
		jg	short loc_8000833
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Fh
		jle	short loc_8000833
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 37h
		jle	short loc_80007F6

loc_8000833:				; CODE XREF: print_esc+17Aj
					; print_esc+184j
		sub	esp, 0Ch
		push	[ebp+esc_value]	; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_8000A45
; ---------------------------------------------------------------------------

loc_8000846:				; CODE XREF: print_esc+11Bj
					; print_esc+129j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_800088E
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax		; c
		push	offset s	; "\"\\abcefnrtv"
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_800088E
		mov	eax, [ebp+p]
		lea	edx, [eax+1]
		mov	[ebp+p], edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	print_esc_char
		add	esp, 10h
		jmp	loc_8000A45
; ---------------------------------------------------------------------------

loc_800088E:				; CODE XREF: print_esc+1ABj
					; print_esc+1C9j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 75h
		jz	short loc_80008A6
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 55h
		jnz	loc_8000A15

loc_80008A6:				; CODE XREF: print_esc+1F3j
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		mov	[ebp+esc_char],	al
		mov	[ebp+uni_value], 0
		cmp	[ebp+esc_char],	75h
		jnz	short loc_80008C3
		mov	eax, 4
		jmp	short loc_80008C8
; ---------------------------------------------------------------------------

loc_80008C3:				; CODE XREF: print_esc+217j
		mov	eax, 8

loc_80008C8:				; CODE XREF: print_esc+21Ej
		mov	[ebp+esc_length], eax
		add	[ebp+p], 1
		jmp	loc_800098B
; ---------------------------------------------------------------------------

loc_80008D4:				; CODE XREF: print_esc+2ECj
		call	__ctype_b_loc
		mov	ebx, [eax]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		add	eax, eax
		add	eax, ebx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1000h
		test	eax, eax
		jnz	short loc_8000926
		sub	esp, 0Ch
		push	offset aMissingHexadec ; "missing hexadecimal number in	escape"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8000926:				; CODE XREF: print_esc+261j
		mov	eax, [ebp+uni_value]
		shl	eax, 4
		mov	edx, eax
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 60h
		jle	short loc_8000950
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 66h
		jg	short loc_8000950
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 57h
		jmp	short loc_800097E
; ---------------------------------------------------------------------------

loc_8000950:				; CODE XREF: print_esc+293j
					; print_esc+29Dj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 40h
		jle	short loc_8000972
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		cmp	al, 46h
		jg	short loc_8000972
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 37h
		jmp	short loc_800097E
; ---------------------------------------------------------------------------

loc_8000972:				; CODE XREF: print_esc+2B5j
					; print_esc+2BFj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h

loc_800097E:				; CODE XREF: print_esc+2ABj
					; print_esc+2CDj
		add	eax, edx
		mov	[ebp+uni_value], eax
		sub	[ebp+esc_length], 1
		add	[ebp+p], 1

loc_800098B:				; CODE XREF: print_esc+22Cj
		cmp	[ebp+esc_length], 0
		jg	loc_80008D4
		cmp	[ebp+uni_value], 9Fh
		ja	short loc_80009B0
		cmp	[ebp+uni_value], 24h
		jz	short loc_80009B0
		cmp	[ebp+uni_value], 40h
		jz	short loc_80009B0
		cmp	[ebp+uni_value], 60h
		jnz	short loc_80009C2

loc_80009B0:				; CODE XREF: print_esc+2F9j
					; print_esc+2FFj ...
		cmp	[ebp+uni_value], 0D7FFh
		jbe	short loc_80009FD
		cmp	[ebp+uni_value], 0DFFFh
		ja	short loc_80009FD

loc_80009C2:				; CODE XREF: print_esc+30Bj
		cmp	[ebp+esc_char],	75h
		jnz	short loc_80009CF
		mov	esi, 4
		jmp	short loc_80009D4
; ---------------------------------------------------------------------------

loc_80009CF:				; CODE XREF: print_esc+323j
		mov	esi, 8

loc_80009D4:				; CODE XREF: print_esc+32Aj
		movsx	ebx, [ebp+esc_char]
		sub	esp, 0Ch
		push	offset aInvalidUnivers ; "invalid universal character name \\%c%0"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	[ebp+uni_value]
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80009FD:				; CODE XREF: print_esc+314j
					; print_esc+31Dj
		mov	eax, ds:stdout
		sub	esp, 4
		push	0
		push	[ebp+uni_value]
		push	eax
		call	print_unicode_char
		add	esp, 10h
		jmp	short loc_8000A45
; ---------------------------------------------------------------------------

loc_8000A15:				; CODE XREF: print_esc+1FDj
		sub	esp, 0Ch
		push	5Ch		; c
		call	putchar_unlocked
		add	esp, 10h
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8000A45
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		add	[ebp+p], 1

loc_8000A45:				; CODE XREF: print_esc+10Ej
					; print_esc+19Ej ...
		mov	edx, [ebp+p]
		mov	eax, [ebp+escstart]
		sub	edx, eax
		mov	eax, edx
		sub	eax, 1
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
print_esc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_esc_string(const char *str)
print_esc_string proc near		; CODE XREF: print_formatted+E9p

str		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		jmp	short loc_8000A99
; ---------------------------------------------------------------------------

loc_8000A61:				; CODE XREF: print_esc_string+48j
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		cmp	al, 5Ch
		jnz	short loc_8000A80
		sub	esp, 8
		push	1		; octal_0
		push	[ebp+str]	; escstart
		call	print_esc
		add	esp, 10h
		add	[ebp+str], eax
		jmp	short loc_8000A95
; ---------------------------------------------------------------------------

loc_8000A80:				; CODE XREF: print_esc_string+10j
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h

loc_8000A95:				; CODE XREF: print_esc_string+25j
		add	[ebp+str], 1

loc_8000A99:				; CODE XREF: print_esc_string+6j
		mov	eax, [ebp+str]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000A61
		nop
		leave
		retn
print_esc_string endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl print_direc(const char *start, size_t length, char conversion, _Bool have_field_width, int field_width, _Bool have_precision, int precision, const char *argument)
print_direc	proc near		; CODE XREF: print_formatted+5FEp

var_58		= tbyte	ptr -58h
have_precision	= byte ptr -44h
have_field_width= byte ptr -40h
conversion	= byte ptr -3Ch
length_modifier	= dword	ptr -38h
length_modifier_len= dword ptr -34h
p		= dword	ptr -30h
q		= dword	ptr -2Ch
arg		= qword	ptr -28h
arg_0		= qword	ptr -20h
arg_1		= LONG_DOUBLE_12 ptr -18h
start		= dword	ptr  8
length		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
field_width	= dword	ptr  18h
arg_14		= dword	ptr  1Ch
precision	= dword	ptr  20h
argument	= dword	ptr  24h

		push	ebp
		mov	ebp, esp
		sub	esp, 58h
		mov	ecx, [ebp+arg_8]
		mov	edx, [ebp+arg_C]
		mov	eax, [ebp+arg_14]
		mov	[ebp+conversion], cl
		mov	[ebp+have_field_width],	dl
		mov	[ebp+have_precision], al
		movsx	eax, [ebp+conversion]
		sub	eax, 41h	; switch 56 cases
		cmp	eax, 37h
		ja	short loc_8000AF3 ; jumptable 08000AD1 default case
		mov	eax, ds:off_8001E84[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000AD3:				; CODE XREF: print_direc+2Bj
					; DATA XREF: .rodata:off_8001E84o
		mov	[ebp+length_modifier], offset aLld ; jumptable 08000AD1	cases 88,100,105,111,117,120
		mov	[ebp+length_modifier_len], 2
		jmp	short loc_8000B01
; ---------------------------------------------------------------------------

loc_8000AE3:				; CODE XREF: print_direc+2Bj
					; DATA XREF: .rodata:off_8001E84o
		mov	[ebp+length_modifier], offset asc_8001E81 ; jumptable 08000AD1 cases 65,69-71,97,101-103
		mov	[ebp+length_modifier_len], 1
		jmp	short loc_8000B01
; ---------------------------------------------------------------------------

loc_8000AF3:				; CODE XREF: print_direc+22j
					; print_direc+2Bj
					; DATA XREF: ...
		mov	eax, [ebp+start] ; jumptable 08000AD1 default case
		mov	[ebp+length_modifier], eax
		mov	[ebp+length_modifier_len], 0
		nop

loc_8000B01:				; CODE XREF: print_direc+3Bj
					; print_direc+4Bj
		mov	edx, [ebp+length]
		mov	eax, [ebp+length_modifier_len]
		add	eax, edx
		add	eax, 2
		sub	esp, 0Ch
		push	eax		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+p], eax
		sub	esp, 4
		push	[ebp+length]
		push	[ebp+start]
		push	[ebp+p]
		call	mempcpy
		add	esp, 10h
		mov	[ebp+q], eax
		sub	esp, 4
		push	[ebp+length_modifier_len]
		push	[ebp+length_modifier]
		push	[ebp+q]
		call	mempcpy
		add	esp, 10h
		mov	[ebp+q], eax
		mov	eax, [ebp+q]
		lea	edx, [eax+1]
		mov	[ebp+q], edx
		movzx	edx, [ebp+conversion]
		mov	[eax], dl
		mov	eax, [ebp+q]
		mov	byte ptr [eax],	0
		movsx	eax, [ebp+conversion]
		sub	eax, 41h	; switch 56 cases
		cmp	eax, 37h
		ja	loc_8000E2C	; jumptable 08000B75 default case
		mov	eax, ds:off_8001F64[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8000B77:				; CODE XREF: print_direc+CFj
					; DATA XREF: .rodata:off_8001F64o
		sub	esp, 0Ch	; jumptable 08000B75 cases 100,105
		push	[ebp+argument]	; s
		call	vstrtoimax
		add	esp, 10h
		mov	dword ptr [ebp+arg], eax
		mov	dword ptr [ebp+arg+4], edx
		movzx	eax, [ebp+have_field_width]
		xor	eax, 1
		test	al, al
		jz	short loc_8000BD3
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000BBA
		sub	esp, 4
		push	dword ptr [ebp+arg+4]
		push	dword ptr [ebp+arg]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000BBA:				; CODE XREF: print_direc+F9j
		push	dword ptr [ebp+arg+4]
		push	dword ptr [ebp+arg]
		push	[ebp+precision]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000BD3:				; CODE XREF: print_direc+EEj
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000BF7
		push	dword ptr [ebp+arg+4]
		push	dword ptr [ebp+arg]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000BF7:				; CODE XREF: print_direc+136j
		sub	esp, 0Ch
		push	dword ptr [ebp+arg+4]
		push	dword ptr [ebp+arg]
		push	[ebp+precision]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 20h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000C16:				; CODE XREF: print_direc+CFj
					; DATA XREF: .rodata:off_8001F64o
		sub	esp, 0Ch	; jumptable 08000B75 cases 88,111,117,120
		push	[ebp+argument]	; s
		call	vstrtoumax
		add	esp, 10h
		mov	dword ptr [ebp+arg_0], eax
		mov	dword ptr [ebp+arg_0+4], edx
		movzx	eax, [ebp+have_field_width]
		xor	eax, 1
		test	al, al
		jz	short loc_8000C72
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000C59
		sub	esp, 4
		push	dword ptr [ebp+arg_0+4]
		push	dword ptr [ebp+arg_0]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000C59:				; CODE XREF: print_direc+198j
		push	dword ptr [ebp+arg_0+4]
		push	dword ptr [ebp+arg_0]
		push	[ebp+precision]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000C72:				; CODE XREF: print_direc+18Dj
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000C96
		push	dword ptr [ebp+arg_0+4]
		push	dword ptr [ebp+arg_0]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000C96:				; CODE XREF: print_direc+1D5j
		sub	esp, 0Ch
		push	dword ptr [ebp+arg_0+4]
		push	dword ptr [ebp+arg_0]
		push	[ebp+precision]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 20h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000CB5:				; CODE XREF: print_direc+CFj
					; DATA XREF: .rodata:off_8001F64o
		sub	esp, 0Ch	; jumptable 08000B75 cases 65,69-71,97,101-103
		push	[ebp+argument]	; s
		call	vstrtold
		add	esp, 10h
		fstp	[ebp+var_58]
		mov	eax, dword ptr [ebp+var_58]
		mov	edx, dword ptr [ebp+var_58+4]
		mov	ecx, dword ptr [ebp+var_58+8]
		mov	dword ptr [ebp+arg_1.value], eax
		mov	dword ptr [ebp+arg_1.value+4], edx
		mov	dword ptr [ebp+arg_1.value+8], ecx
		movzx	eax, [ebp+have_field_width]
		xor	eax, 1
		test	al, al
		jz	short loc_8000D26
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000D07
		push	dword ptr [ebp+arg_1.value+8]
		push	dword ptr [ebp+arg_1.value+4]
		push	dword ptr [ebp+arg_1.value]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000D07:				; CODE XREF: print_direc+246j
		sub	esp, 0Ch
		push	dword ptr [ebp+arg_1.value+8]
		push	dword ptr [ebp+arg_1.value+4]
		push	dword ptr [ebp+arg_1.value]
		push	[ebp+precision]
		push	[ebp+p]
		call	xprintf
		add	esp, 20h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000D26:				; CODE XREF: print_direc+23Bj
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000D50
		sub	esp, 0Ch
		push	dword ptr [ebp+arg_1.value+8]
		push	dword ptr [ebp+arg_1.value+4]
		push	dword ptr [ebp+arg_1.value]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 20h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000D50:				; CODE XREF: print_direc+289j
		sub	esp, 8
		push	dword ptr [ebp+arg_1.value+8]
		push	dword ptr [ebp+arg_1.value+4]
		push	dword ptr [ebp+arg_1.value]
		push	[ebp+precision]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 20h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000D72:				; CODE XREF: print_direc+CFj
					; DATA XREF: .rodata:off_8001F64o
		movzx	eax, [ebp+have_field_width] ; jumptable	08000B75 case 99
		xor	eax, 1
		test	al, al
		jz	short loc_8000D9A
		mov	eax, [ebp+argument]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 8
		push	eax
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	loc_8000E2C	; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000D9A:				; CODE XREF: print_direc+2D5j
		mov	eax, [ebp+argument]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 4
		push	eax
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	short loc_8000E2C ; jumptable 08000B75 default case
; ---------------------------------------------------------------------------

loc_8000DB7:				; CODE XREF: print_direc+CFj
					; DATA XREF: .rodata:off_8001F64o
		movzx	eax, [ebp+have_field_width] ; jumptable	08000B75 case 115
		xor	eax, 1
		test	al, al
		jz	short loc_8000DF6
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000DE0
		sub	esp, 8
		push	[ebp+argument]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	short loc_8000E2B
; ---------------------------------------------------------------------------

loc_8000DE0:				; CODE XREF: print_direc+325j
		sub	esp, 4
		push	[ebp+argument]
		push	[ebp+precision]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	short loc_8000E2B
; ---------------------------------------------------------------------------

loc_8000DF6:				; CODE XREF: print_direc+31Aj
		movzx	eax, [ebp+have_precision]
		xor	eax, 1
		test	al, al
		jz	short loc_8000E17
		sub	esp, 4
		push	[ebp+argument]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h
		jmp	short loc_8000E2B
; ---------------------------------------------------------------------------

loc_8000E17:				; CODE XREF: print_direc+359j
		push	[ebp+argument]
		push	[ebp+precision]
		push	[ebp+field_width]
		push	[ebp+p]
		call	xprintf
		add	esp, 10h

loc_8000E2B:				; CODE XREF: print_direc+338j
					; print_direc+34Ej ...
		nop

loc_8000E2C:				; CODE XREF: print_direc+C2j
					; print_direc+CFj ...
		sub	esp, 0Ch	; jumptable 08000B75 default case
		push	[ebp+p]		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
print_direc	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl print_formatted(const char *format, int argc, char **argv)
print_formatted	proc near		; CODE XREF: main+17Fp

argv		= dword	ptr -150h
format		= dword	ptr -14Ch
have_field_width= byte ptr -13Bh
have_precision	= byte ptr -13Ah
conversion	= byte ptr -139h
f		= dword	ptr -138h
direc_length	= dword	ptr -134h
field_width	= dword	ptr -130h
precision	= dword	ptr -12Ch
save_argc	= dword	ptr -128h
direc_start	= dword	ptr -124h
width		= qword	ptr -120h
prec		= qword	ptr -118h
ok		= byte ptr -10Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
argc		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 154h
		mov	eax, [ebp+arg_0]
		mov	[ebp+format], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+argc]
		mov	[ebp+save_argc], eax
		mov	[ebp+field_width], 0
		mov	[ebp+precision], 0
		mov	eax, [ebp+format]
		mov	[ebp+f], eax
		jmp	loc_8001482
; ---------------------------------------------------------------------------

loc_8000E92:				; CODE XREF: print_formatted+650j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 25h
		jz	short loc_8000EB1
		cmp	eax, 5Ch
		jz	loc_8001445
		jmp	loc_8001460
; ---------------------------------------------------------------------------

loc_8000EB1:				; CODE XREF: print_formatted+64j
		mov	eax, [ebp+f]
		lea	edx, [eax+1]
		mov	[ebp+f], edx
		mov	[ebp+direc_start], eax
		mov	[ebp+direc_length], 1
		mov	[ebp+have_precision], 0
		movzx	eax, [ebp+have_precision]
		mov	[ebp+have_field_width],	al
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 25h
		jnz	short loc_8000F03
		sub	esp, 0Ch
		push	25h		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	loc_800147B
; ---------------------------------------------------------------------------

loc_8000F03:				; CODE XREF: print_formatted+B2j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 62h
		jnz	short loc_8000F3E
		cmp	[ebp+argc], 0
		jle	loc_800147A
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; str
		call	print_esc_string
		add	esp, 10h
		add	[ebp+argv], 4
		sub	[ebp+argc], 1
		jmp	loc_800147A
; ---------------------------------------------------------------------------

loc_8000F3E:				; CODE XREF: print_formatted+D1j
		sub	esp, 4
		push	100h		; n
		push	0		; c
		lea	eax, [ebp+ok]
		push	eax		; s
		call	memset
		add	esp, 10h
		mov	[ebp+ok+58h], 1
		movzx	eax, [ebp+ok+58h]
		mov	[ebp+ok+78h], al
		movzx	eax, [ebp+ok+78h]
		mov	[ebp+ok+75h], al
		movzx	eax, [ebp+ok+75h]
		mov	[ebp+ok+73h], al
		movzx	eax, [ebp+ok+73h]
		mov	[ebp+ok+6Fh], al
		movzx	eax, [ebp+ok+6Fh]
		mov	[ebp+ok+69h], al
		movzx	eax, [ebp+ok+69h]
		mov	[ebp+ok+47h], al
		movzx	eax, [ebp+ok+47h]
		mov	[ebp+ok+67h], al
		movzx	eax, [ebp+ok+67h]
		mov	[ebp+ok+46h], al
		movzx	eax, [ebp+ok+46h]
		mov	[ebp+ok+66h], al
		movzx	eax, [ebp+ok+66h]
		mov	[ebp+ok+45h], al
		movzx	eax, [ebp+ok+45h]
		mov	[ebp+ok+65h], al
		movzx	eax, [ebp+ok+65h]
		mov	[ebp+ok+64h], al
		movzx	eax, [ebp+ok+64h]
		mov	[ebp+ok+63h], al
		movzx	eax, [ebp+ok+63h]
		mov	[ebp+ok+41h], al
		movzx	eax, [ebp+ok+41h]
		mov	[ebp+ok+61h], al

loc_8001021:				; CODE XREF: print_formatted+2D8j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 20h	; switch 42 cases
		cmp	eax, 29h
		ja	loc_800111A	; jumptable 08001040 default case
		mov	eax, ds:off_800209C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001042:				; CODE XREF: print_formatted+203j
					; DATA XREF: .rodata:off_800209Co
		mov	[ebp+ok+58h], 0	; jumptable 08001040 cases 39,73
		movzx	eax, [ebp+ok+58h]
		mov	[ebp+ok+78h], al
		movzx	eax, [ebp+ok+78h]
		mov	[ebp+ok+73h], al
		movzx	eax, [ebp+ok+73h]
		mov	[ebp+ok+6Fh], al
		movzx	eax, [ebp+ok+6Fh]
		mov	[ebp+ok+45h], al
		movzx	eax, [ebp+ok+45h]
		mov	[ebp+ok+65h], al
		movzx	eax, [ebp+ok+65h]
		mov	[ebp+ok+63h], al
		movzx	eax, [ebp+ok+63h]
		mov	[ebp+ok+41h], al
		movzx	eax, [ebp+ok+41h]
		mov	[ebp+ok+61h], al
		jmp	short loc_8001107
; ---------------------------------------------------------------------------

loc_80010B3:				; CODE XREF: print_formatted+203j
					; DATA XREF: .rodata:off_800209Co
		mov	[ebp+ok+75h], 0	; jumptable 08001040 case 35
		movzx	eax, [ebp+ok+75h]
		mov	[ebp+ok+73h], al
		movzx	eax, [ebp+ok+73h]
		mov	[ebp+ok+69h], al
		movzx	eax, [ebp+ok+69h]
		mov	[ebp+ok+64h], al
		movzx	eax, [ebp+ok+64h]
		mov	[ebp+ok+63h], al
		jmp	short loc_8001107
; ---------------------------------------------------------------------------

loc_80010F0:				; CODE XREF: print_formatted+203j
					; DATA XREF: .rodata:off_800209Co
		mov	[ebp+ok+73h], 0	; jumptable 08001040 case 48
		movzx	eax, [ebp+ok+73h]
		mov	[ebp+ok+63h], al
		jmp	short loc_8001107
; ---------------------------------------------------------------------------

loc_8001106:				; CODE XREF: print_formatted+203j
					; DATA XREF: .rodata:off_800209Co
		nop			; jumptable 08001040 cases 32,43,45

loc_8001107:				; CODE XREF: print_formatted+274j
					; print_formatted+2B1j	...
		add	[ebp+f], 1
		add	[ebp+direc_length], 1
		jmp	loc_8001021
; ---------------------------------------------------------------------------

loc_800111A:				; CODE XREF: print_formatted+1F6j
					; print_formatted+203j
					; DATA XREF: ...
		nop			; jumptable 08001040 default case

no_more_flag_characters:
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ah
		jnz	loc_8001202
		add	[ebp+f], 1
		add	[ebp+direc_length], 1
		cmp	[ebp+argc], 0
		jle	loc_80011E1
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	vstrtoimax
		add	esp, 10h
		mov	dword ptr [ebp+width], eax
		mov	dword ptr [ebp+width+4], edx
		cmp	dword ptr [ebp+width+4], 0FFFFFFFFh
		jl	short loc_80011AE
		cmp	dword ptr [ebp+width+4], 0FFFFFFFFh
		jg	short loc_8001182
		cmp	dword ptr [ebp+width], 80000000h
		jb	short loc_80011AE

loc_8001182:				; CODE XREF: print_formatted+337j
		cmp	dword ptr [ebp+width+4], 0
		jg	short loc_80011AE
		cmp	dword ptr [ebp+width+4], 0
		js	short loc_80011A0
		cmp	dword ptr [ebp+width], 7FFFFFFFh
		ja	short loc_80011AE

loc_80011A0:				; CODE XREF: print_formatted+355j
		mov	eax, dword ptr [ebp+width]
		mov	[ebp+field_width], eax
		jmp	short loc_80011D4
; ---------------------------------------------------------------------------

loc_80011AE:				; CODE XREF: print_formatted+32Ej
					; print_formatted+343j	...
		mov	eax, [ebp+argv]
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aInvalidFieldWi ; "invalid field	width: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80011D4:				; CODE XREF: print_formatted+36Fj
		add	[ebp+argv], 4
		sub	[ebp+argc], 1
		jmp	short loc_80011EB
; ---------------------------------------------------------------------------

loc_80011E1:				; CODE XREF: print_formatted+301j
		mov	[ebp+field_width], 0

loc_80011EB:				; CODE XREF: print_formatted+3A2j
		mov	[ebp+have_field_width],	1
		jmp	short loc_8001216
; ---------------------------------------------------------------------------

loc_80011F4:				; CODE XREF: print_formatted+3D7j
		add	[ebp+f], 1
		add	[ebp+direc_length], 1

loc_8001202:				; CODE XREF: print_formatted+2E9j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_80011F4

loc_8001216:				; CODE XREF: print_formatted+3B5j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Eh
		jnz	loc_8001337
		add	[ebp+f], 1
		add	[ebp+direc_length], 1
		mov	[ebp+ok+63h], 0
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 2Ah
		jnz	loc_800131A
		add	[ebp+f], 1
		add	[ebp+direc_length], 1
		cmp	[ebp+argc], 0
		jle	loc_80012F9
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; s
		call	vstrtoimax
		add	esp, 10h
		mov	dword ptr [ebp+prec], eax
		mov	dword ptr [ebp+prec+4],	edx
		cmp	dword ptr [ebp+prec+4],	0
		jns	short loc_800129A
		mov	[ebp+precision], 0FFFFFFFFh
		jmp	short loc_80012EC
; ---------------------------------------------------------------------------

loc_800129A:				; CODE XREF: print_formatted+44Fj
		cmp	dword ptr [ebp+prec+4],	0
		js	short loc_80012E0
		cmp	dword ptr [ebp+prec+4],	0
		jg	short loc_80012B8
		cmp	dword ptr [ebp+prec], 7FFFFFFFh
		jbe	short loc_80012E0

loc_80012B8:				; CODE XREF: print_formatted+46Dj
		mov	eax, [ebp+argv]
		mov	ebx, [eax]
		sub	esp, 0Ch
		push	offset aInvalidPrecisi ; "invalid precision: %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_80012EC
; ---------------------------------------------------------------------------

loc_80012E0:				; CODE XREF: print_formatted+464j
					; print_formatted+479j
		mov	eax, dword ptr [ebp+prec]
		mov	[ebp+precision], eax

loc_80012EC:				; CODE XREF: print_formatted+45Bj
					; print_formatted+4A1j
		add	[ebp+argv], 4
		sub	[ebp+argc], 1
		jmp	short loc_8001303
; ---------------------------------------------------------------------------

loc_80012F9:				; CODE XREF: print_formatted+422j
		mov	[ebp+precision], 0

loc_8001303:				; CODE XREF: print_formatted+4BAj
		mov	[ebp+have_precision], 1
		jmp	short loc_8001337
; ---------------------------------------------------------------------------

loc_800130C:				; CODE XREF: print_formatted+4EFj
		add	[ebp+f], 1
		add	[ebp+direc_length], 1

loc_800131A:				; CODE XREF: print_formatted+40Aj
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		jbe	short loc_800130C
		jmp	short loc_8001337
; ---------------------------------------------------------------------------

loc_8001330:				; CODE XREF: print_formatted+505j
					; print_formatted+512j	...
		add	[ebp+f], 1

loc_8001337:				; CODE XREF: print_formatted+3E4j
					; print_formatted+4CDj	...
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 6Ch
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 4Ch
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 68h
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 6Ah
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 74h
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		cmp	al, 7Ah
		jz	short loc_8001330
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		mov	[ebp+conversion], al
		movzx	eax, [ebp+conversion]
		movzx	eax, [ebp+eax+ok]
		test	al, al
		jnz	short loc_80013E3
		mov	eax, [ebp+f]
		add	eax, 1
		mov	edx, eax
		mov	eax, [ebp+direc_start]
		mov	ebx, edx
		sub	ebx, eax
		sub	esp, 0Ch
		push	offset a_SInvalidConve ; "%.*s:	invalid	conversion specification"
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+direc_start]
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 20h

loc_80013E3:				; CODE XREF: print_formatted+568j
		cmp	[ebp+argc], 0
		jle	short loc_8001400
		sub	[ebp+argc], 1
		mov	eax, [ebp+argv]
		lea	edx, [eax+4]
		mov	[ebp+argv], edx
		mov	eax, [eax]
		jmp	short loc_8001405
; ---------------------------------------------------------------------------

loc_8001400:				; CODE XREF: print_formatted+5AAj
		mov	eax, offset locale

loc_8001405:				; CODE XREF: print_formatted+5C1j
		movzx	ebx, [ebp+have_precision]
		movzx	ecx, [ebp+have_field_width]
		mov	edx, [ebp+f]
		movzx	edx, byte ptr [edx]
		movsx	edx, dl
		push	eax		; argument
		push	[ebp+precision]	; precision
		push	ebx		; have_precision
		push	[ebp+field_width] ; field_width
		push	ecx		; have_field_width
		push	edx		; conversion
		push	[ebp+direc_length] ; length
		push	[ebp+direc_start] ; start
		call	print_direc
		add	esp, 20h
		jmp	short loc_800147B
; ---------------------------------------------------------------------------

loc_8001445:				; CODE XREF: print_formatted+69j
		sub	esp, 8
		push	0		; octal_0
		push	[ebp+f]		; escstart
		call	print_esc
		add	esp, 10h
		add	[ebp+f], eax
		jmp	short loc_800147B
; ---------------------------------------------------------------------------

loc_8001460:				; CODE XREF: print_formatted+6Fj
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; c
		call	putchar_unlocked
		add	esp, 10h
		jmp	short loc_800147B
; ---------------------------------------------------------------------------

loc_800147A:				; CODE XREF: print_formatted+D7j
					; print_formatted+FCj
		nop

loc_800147B:				; CODE XREF: print_formatted+C1j
					; print_formatted+606j	...
		add	[ebp+f], 1

loc_8001482:				; CODE XREF: print_formatted+50j
		mov	eax, [ebp+f]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_8000E92
		mov	eax, [ebp+save_argc]
		sub	eax, [ebp+argc]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80014AD
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80014AD:				; CODE XREF: print_formatted+669j
		mov	ebx, [ebp+var_4]
		leave
		retn
print_formatted	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

format		= dword	ptr -10h
args_used	= dword	ptr -0Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 10h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		mov	ds:exit_status,	0
		sub	esp, 0Ch
		push	offset name	; "POSIXLY_CORRECT"
		call	getenv
		add	esp, 10h
		test	eax, eax
		setnz	al
		mov	ds:posixly_correct, al
		cmp	dword ptr [ebx], 2
		jnz	short loc_80015BE
		mov	eax, [ebx+4]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset aHelp	; "--help"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800156E
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800156E:				; CODE XREF: main+B0j
		mov	eax, [ebx+4]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset aVersion	; "--version"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80015BE
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aDavidMackenzie ; "David	MacKenzie"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aPrintf	; "printf"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80015BE:				; CODE XREF: main+93j main+D7j
		cmp	dword ptr [ebx], 1
		jle	short loc_80015E7
		mov	eax, [ebx+4]
		add	eax, 4
		mov	eax, [eax]
		sub	esp, 8
		push	offset asc_800218D ; "--"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_80015E7
		sub	dword ptr [ebx], 1
		add	dword ptr [ebx+4], 4

loc_80015E7:				; CODE XREF: main+10Fj	main+12Cj
		cmp	dword ptr [ebx], 1
		jg	short loc_8001616
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8001616:				; CODE XREF: main+138j
		mov	eax, [ebx+4]
		mov	eax, [eax+4]
		mov	[ebp+format], eax
		sub	dword ptr [ebx], 2
		add	dword ptr [ebx+4], 8

loc_8001626:				; CODE XREF: main+1A1j
		sub	esp, 4
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		push	[ebp+format]	; format
		call	print_formatted
		add	esp, 10h
		mov	[ebp+args_used], eax
		mov	eax, [ebp+args_used]
		sub	[ebx], eax
		mov	eax, [ebp+args_used]
		shl	eax, 2
		add	[ebx+4], eax
		cmp	[ebp+args_used], 0
		jle	short loc_8001655
		cmp	dword ptr [ebx], 0
		jg	short loc_8001626

loc_8001655:				; CODE XREF: main+19Cj
		cmp	dword ptr [ebx], 0
		jle	short loc_800168B
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aWarningIgnorin ; "warning: ignoring excess arguments, sta"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_800168B:				; CODE XREF: main+1A6j
		mov	eax, ds:exit_status
		sub	esp, 0Ch
		push	eax		; status

loc_8001694:				; DATA XREF: .eh_frame:080021F8o
					; .eh_frame:08002218o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
_bss		segment	dword public 'BSS' use32
		assume cs:_bss
		;org 800169Ch
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; int exit_status
exit_status	dd ?			; DATA XREF: verify_numeric+2Bw
					; verify_numeric:loc_8000344w ...
; _Bool	posixly_correct
posixly_correct	db ?			; DATA XREF: vstrtoimax+54r
					; vstrtoumax+54r ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_rodata		segment	dword public 'CONST' use32
		assume cs:_rodata
		;org 80016A4h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 4
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+3Fo ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+EFo
		align 10h
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
		align 10h
; char aWarningSCharac[]
aWarningSCharac	db 'warning: %s: character(s) following character constant have been '
					; DATA XREF: vstrtoimax+62o
					; vstrtoumax+62o ...
		db 'ignored',0
		align 4
; const	char *const cfcc_msg
cfcc_msg	dd offset aWarningSCharac ; "warning: %s: character(s) following cha"...
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+14o
		align 4
; char aUsageSFormatAr[]
aUsageSFormatAr	db 'Usage: %s FORMAT [ARGUMENT]...',0Ah ; DATA XREF: usage+4Ao
		db '  or:  %s OPTION',0Ah,0
		align 4
; char aPrintArgumentS[]
aPrintArgumentS	db 'Print ARGUMENT(s) according to FORMAT, or execute according to OP'
					; DATA XREF: usage+6Eo
		db 'TION:',0Ah
		db 0Ah,0
		align 4
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+91o
		align 4
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+B4o
		align 10h
; char aFormatControls[]
aFormatControls	db 0Ah			; DATA XREF: usage+D7o
		db 'FORMAT controls the output as in C printf.  Interpreted sequences'
		db ' are:',0Ah
		db 0Ah
		db '  \"      double quote',0Ah,0
		align 4
; char aBackslashAAler[]
aBackslashAAler	db '  \\      backslash',0Ah ; DATA XREF: usage+FAo
		db '  \a      alert (BEL)',0Ah
		db '  \b      backspace',0Ah
		db '  \c      produce no further output',0Ah
		db '  \e      escape',0Ah
		db '  \f      form feed',0Ah
		db '  \n      new line',0Ah
		db '  \r      carriage return',0Ah
		db '  \t      horizontal tab',0Ah
		db '  \v      vertical tab',0Ah,0
		align 4
; char aNnnByteWithOct[]
aNnnByteWithOct	db '  \NNN    byte with octal value NNN (1 to 3 digits)',0Ah
					; DATA XREF: usage+11Do
		db '  \xHH    byte with hexadecimal value HH (1 to 2 digits)',0Ah
		db '  \uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH ('
		db '4 digits)',0Ah
		db '  \UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits'
		db ')',0Ah,0
; char aASingleBArgume[]
aASingleBArgume	db '  %%      a single %',0Ah ; DATA XREF: usage+140o
		db '  %b      ARGUMENT as a string with `\',27h,' escapes interpreted,',0Ah
		db '          except that octal escapes are of the form \0 or \0NNN',0Ah
		db 0Ah
		db 'and all C format specifications ending with one of diouxXfeEgGcs,'
		db ' with',0Ah
		db 'ARGUMENTs converted to proper type first.  Variable widths are ha'
		db 'ndled.',0Ah,0
		align 4
; char aNoteYourShellM[]
aNoteYourShellM	db 0Ah			; DATA XREF: usage+15Do
		db 'NOTE: your shell may have its own version of %s, which usually su'
		db 'persedes',0Ah
		db 'the version described here.  Please refer to your shell',27h,'s docu'
		db 'mentation',0Ah
		db 'for details about the options it supports.',0Ah,0
aPrintf		db 'printf',0           ; DATA XREF: usage+16Do main+F4o
; char format[]
format		db '%s',0               ; DATA XREF: verify_numeric+1Bo
; char aSExpectedANume[]
aSExpectedANume	db '%s: expected a numeric value',0 ; DATA XREF: verify_numeric+4Co
		align 4
; char aSValueNotCompl[]
aSValueNotCompl	db '%s: value not completely converted',0 ; DATA XREF: verify_numeric+6Eo
		align 4
off_8001DC8	dd offset loc_800060A	; DATA XREF: print_esc_char+1Cr
		dd offset loc_800061C	; jump table for switch	statement
		dd offset loc_800062B
		dd offset loc_800068F
		dd offset loc_8000635
		dd offset loc_8000644
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_8000653
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_800068F
		dd offset loc_8000662
		dd offset loc_800068F
		dd offset loc_8000671
		dd offset loc_800068F
		dd offset loc_8000680
; char aMissingHexadec[]
aMissingHexadec	db 'missing hexadecimal number in escape',0 ; DATA XREF: print_esc+E3o
					; print_esc+266o
; char s[]
s		db '"\abcefnrtv',0      ; DATA XREF: print_esc+1BAo
		align 4
; char aInvalidUnivers[]
aInvalidUnivers	db 'invalid universal character name \%c%0*x',0 ; DATA XREF: print_esc+338o
aLld		db 'lld',0              ; DATA XREF: print_direc:loc_8000AD3o
asc_8001E81	db 'L',0                ; DATA XREF: print_direc:loc_8000AE3o
		align 4
off_8001E84	dd offset loc_8000AE3, offset loc_8000AF3, offset loc_8000AF3
					; DATA XREF: print_direc+24r
		dd offset loc_8000AF3, offset loc_8000AE3, offset loc_8000AE3 ;	jump table for switch statement
		dd offset loc_8000AE3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AD3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AE3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AD3
		dd offset loc_8000AE3, offset loc_8000AE3, offset loc_8000AE3
		dd offset loc_8000AF3, offset loc_8000AD3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AD3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AF3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AD3, offset loc_8000AF3
		dd offset loc_8000AF3, offset loc_8000AD3
off_8001F64	dd offset loc_8000CB5, offset loc_8000E2C, offset loc_8000E2C
					; DATA XREF: print_direc+C8r
		dd offset loc_8000E2C, offset loc_8000CB5, offset loc_8000CB5 ;	jump table for switch statement
		dd offset loc_8000CB5, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000C16
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000CB5
		dd offset loc_8000E2C, offset loc_8000D72, offset loc_8000B77
		dd offset loc_8000CB5, offset loc_8000CB5, offset loc_8000CB5
		dd offset loc_8000E2C, offset loc_8000B77, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000C16, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000E2C, offset loc_8000DB7
		dd offset loc_8000E2C, offset loc_8000C16, offset loc_8000E2C
		dd offset loc_8000E2C, offset loc_8000C16
; char aInvalidFieldWi[]
aInvalidFieldWi	db 'invalid field width: %s',0 ; DATA XREF: print_formatted+37Co
; char aInvalidPrecisi[]
aInvalidPrecisi	db 'invalid precision: %s',0 ; DATA XREF: print_formatted+486o
		align 4
; char a_SInvalidConve[]
a_SInvalidConve	db '%.*s: invalid conversion specification',0
					; DATA XREF: print_formatted+582o
; char locale
locale		db 0			; DATA XREF: print_formatted:loc_8001400o
					; main+28o
off_800209C	dd offset loc_8001106	; DATA XREF: print_formatted+1FCr
		dd offset loc_800111A	; jump table for switch	statement
		dd offset loc_800111A
		dd offset loc_80010B3
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_8001042
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_8001106
		dd offset loc_800111A
		dd offset loc_8001106
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_80010F0
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_800111A
		dd offset loc_8001042
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Ao
; char name[]
name		db 'POSIXLY_CORRECT',0  ; DATA XREF: main+79o
; char aHelp[]
aHelp		db '--help',0           ; DATA XREF: main+A0o
; char aVersion[]
aVersion	db '--version',0        ; DATA XREF: main+C7o
aDavidMackenzie	db 'David MacKenzie',0  ; DATA XREF: main+E9o
; char asc_800218D[]
asc_800218D	db '--',0               ; DATA XREF: main+11Co
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+13Do
; char aWarningIgnorin[]
aWarningIgnorin	db 'warning: ignoring excess arguments, starting with %s',0
					; DATA XREF: main+1BEo
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 80021D8h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8001694-800388Ch
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8001694-800389Ah
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8001694-80037A2h
		dd 18Bh, 80E4100h, 0D420285h, 3864205h,	483h, 1Ch, 80h
		dd offset loc_8001694-8003637h
		dd 98h,	80E4100h, 0D420285h, 0C5940205h, 4040Ch, 1Ch, 0A0h
		dd offset loc_8001694-80035BFh
		dd 0D8h, 80E4100h, 0D420285h, 0C5D40205h, 4040Ch, 1Ch
		dd 0C0h
		dd offset loc_8001694-8003507h
		dd 0D8h, 80E4100h, 0D420285h, 0C5D40205h, 4040Ch, 1Ch
		dd 0E0h
		dd offset loc_8001694-800344Fh
		dd 0E4h, 80E4100h, 0D420285h, 0C5E00205h, 4040Ch, 1Ch
		dd 100h
		dd offset loc_8001694-800338Bh
		dd 0BEh, 80E4100h, 0D420285h, 0C5BA0205h, 4040Ch, 28h
		dd 120h
		dd offset loc_8001694-80032EDh
		dd 3B6h, 80E4100h, 0D420285h, 3864505h,	0AB030483h, 0C641C303h
		dd 40CC541h, 4,	1Ch, 14Ch
		dd offset loc_8001694-8002F63h
		dd 4Dh,	80E4100h, 0D420285h, 0C5490205h, 4040Ch, 1Ch, 16Ch
		dd offset loc_8001694-8002F36h
		dd 397h, 80E4100h, 0D420285h, 3930305h,	4040CC5h, 20h
		dd 18Ch
		dd offset loc_8001694-8002BBFh
		dd 675h, 80E4100h, 0D420285h, 3834705h,	0C5066A03h, 4040CC3h
		dd 24h,	1B0h
		dd offset loc_8001694-800256Eh
		dd 1E7h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+65r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+80p ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+2Fp
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+23r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+2Ep
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+186p
					; print_esc_char+4Bp ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: verify_numeric+6p
					; verify_numeric+11p ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: verify_numeric+23p
					; verify_numeric+61p ...
; intmax_t strtoimax(const char	*nptr, char **endptr, int base)
		extrn strtoimax:near	; CODE XREF: vstrtoimax+9Cp
		extrn __stack_chk_fail:near ; CODE XREF: vstrtoimax+D1p
					; vstrtoumax+D1p ...
; uintmax_t strtoumax(const char *nptr,	char **endptr, int base)
		extrn strtoumax:near	; CODE XREF: vstrtoumax+9Cp
		extrn c_strtold:near	; CODE XREF: vstrtold+9Ap
; int putchar_unlocked(int c)
		extrn putchar_unlocked:near ; CODE XREF: print_esc_char+2Ap
					; print_esc_char+3Cp ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: print_esc+A4p
					; print_esc:loc_80008D4p
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: print_esc+1BFp
		extrn print_unicode_char:near ;	CODE XREF: print_esc+368p
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: print_direc+6Ap
		extrn mempcpy:near	; CODE XREF: print_direc+81p
					; print_direc+98p
		extrn xprintf:near	; CODE XREF: print_direc+107p
					; print_direc+120p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: print_direc+38Cp
; void *memset(void *s,	int c, size_t n)
		extrn memset:near	; CODE XREF: print_formatted+112p
		extrn set_program_name:near ; CODE XREF: main+1Dp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+44p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+54p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+5Fo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+64p
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: main+7Ep
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+A6p main+CDp ...
		extrn Version:dword	; DATA XREF: main+D9r
		extrn version_etc:near	; CODE XREF: main+FAp
		extrn quote:near	; CODE XREF: main+1B1p


		end
