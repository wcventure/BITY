;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	3E9179F08A65A2B11CFEC35929F9AA8D
; Input	CRC32 :	7639D424

; File Name   :	D:\coreutils-o\stdbuf.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'stdbuf.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl initialize_exit_failure(int status)
initialize_exit_failure	proc near	; CODE XREF: main+63p

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		cmp	[ebp+status], 1
		jz	short loc_8000011
		mov	eax, [ebp+status]
		mov	ds:exit_failure, eax

loc_8000011:				; CODE XREF: initialize_exit_failure+7j
		nop
		pop	ebp
		retn
initialize_exit_failure	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+19Bp

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000FA
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000FA
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000FA:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl parse_size(const char *str, size_t *size)
parse_size	proc near		; CODE XREF: main+1BEp

size		= dword	ptr -30h
str		= dword	ptr -2Ch
e		= dword	ptr -1Ch
tmp_size	= qword	ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+str], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+size], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aEgkkmptyz0 ; "EGkKMPTYZ0"
		lea	eax, [ebp+tmp_size]
		push	eax
		push	0Ah
		push	0
		push	[ebp+str]
		call	xstrtoumax
		add	esp, 20h
		mov	[ebp+e], eax
		cmp	[ebp+e], 0
		jnz	short loc_8000183
		mov	eax, dword ptr [ebp+tmp_size]
		mov	edx, dword ptr [ebp+tmp_size+4]
		cmp	edx, 0
		jbe	short loc_8000183
		mov	[ebp+e], 1

loc_8000183:				; CODE XREF: parse_size+3Fj
					; parse_size+4Aj
		cmp	[ebp+e], 0
		jnz	short loc_80001A8
		call	__errno_location
		mov	dword ptr [eax], 0
		mov	eax, dword ptr [ebp+tmp_size]
		mov	edx, dword ptr [ebp+tmp_size+4]
		mov	edx, eax
		mov	eax, [ebp+size]
		mov	[eax], edx
		mov	eax, 0
		jmp	short loc_80001C6
; ---------------------------------------------------------------------------

loc_80001A8:				; CODE XREF: parse_size+57j
		call	__errno_location
		cmp	[ebp+e], 1
		jnz	short loc_80001BA
		mov	edx, 4Bh
		jmp	short loc_80001BF
; ---------------------------------------------------------------------------

loc_80001BA:				; CODE XREF: parse_size+81j
		mov	edx, 0

loc_80001BF:				; CODE XREF: parse_size+88j
		mov	[eax], edx
		mov	eax, 0FFFFFFFFh

loc_80001C6:				; CODE XREF: parse_size+76j
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_80001D7
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_80001D7:				; CODE XREF: parse_size+A0j
		leave
		retn
parse_size	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+17Fp	main+20Fp ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_8000216
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_8000379
; ---------------------------------------------------------------------------

loc_8000216:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s OPTION... COMMAND\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aRunCommandWith ; "Run COMMAND, with modified buffering op"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aMandatoryArgum ; "Mandatory arguments to long options are"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIInputModeAdju ; "  -i,	--input=MODE   Adjust standard in"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfModeIsLTheCo ; "\nIf MODE is `L' the corresponding stre"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aIfModeIs0TheCo ; "\nIf MODE is `0' the corresponding stre"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aOtherwiseModeI ; "\nOtherwise MODE is a	number which may "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aNoteIfCommandA ; "\nNOTE: If COMMAND adjusts the bufferin"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_8000379:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_program_path(const char *arg)
set_program_path proc near		; CODE XREF: main+2DCp

path		= dword	ptr -14h
dir		= dword	ptr -10h
candidate	= dword	ptr -0Ch
arg		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	2Fh		; c
		push	[ebp+arg]	; s
		call	strchr
		add	esp, 10h
		test	eax, eax
		jz	short loc_80003B6
		sub	esp, 0Ch
		push	[ebp+arg]
		call	dir_name
		add	esp, 10h
		mov	ds:program_path, eax
		jmp	loc_80004B1
; ---------------------------------------------------------------------------

loc_80003B6:				; CODE XREF: set_program_path+18j
		sub	esp, 0Ch
		push	offset aProcSelfExe ; "/proc/self/exe"
		call	xreadlink
		add	esp, 10h
		mov	[ebp+path], eax
		cmp	[ebp+path], 0
		jz	short loc_80003E7
		sub	esp, 0Ch
		push	[ebp+path]
		call	dir_name
		add	esp, 10h
		mov	ds:program_path, eax
		jmp	loc_80004A3
; ---------------------------------------------------------------------------

loc_80003E7:				; CODE XREF: set_program_path+49j
		sub	esp, 0Ch
		push	offset name	; "PATH"
		call	getenv
		add	esp, 10h
		mov	[ebp+path], eax
		cmp	[ebp+path], 0
		jz	loc_80004A3
		sub	esp, 0Ch
		push	[ebp+path]	; char *
		call	xstrdup
		add	esp, 10h
		mov	[ebp+path], eax
		sub	esp, 8
		push	offset delim	; ":"
		push	[ebp+path]	; s
		call	strtok
		add	esp, 10h
		mov	[ebp+dir], eax
		jmp	short loc_800049D
; ---------------------------------------------------------------------------

loc_800042D:				; CODE XREF: set_program_path+11Dj
		sub	esp, 4
		push	0
		push	[ebp+arg]
		push	[ebp+dir]
		call	file_name_concat
		add	esp, 10h
		mov	[ebp+candidate], eax
		sub	esp, 8
		push	1		; type
		push	[ebp+candidate]	; name
		call	access
		add	esp, 10h
		test	eax, eax
		jnz	short loc_800047A
		sub	esp, 0Ch
		push	[ebp+candidate]
		call	dir_name
		add	esp, 10h
		mov	ds:program_path, eax
		sub	esp, 0Ch
		push	[ebp+candidate]	; ptr
		call	free
		add	esp, 10h
		jmp	short loc_80004A3
; ---------------------------------------------------------------------------

loc_800047A:				; CODE XREF: set_program_path+D1j
		sub	esp, 0Ch
		push	[ebp+candidate]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 8
		push	offset delim	; ":"
		push	0		; s
		call	strtok
		add	esp, 10h
		mov	[ebp+dir], eax

loc_800049D:				; CODE XREF: set_program_path+A7j
		cmp	[ebp+dir], 0
		jnz	short loc_800042D

loc_80004A3:				; CODE XREF: set_program_path+5Ej
					; set_program_path+7Aj	...
		sub	esp, 0Ch
		push	[ebp+path]	; ptr
		call	free
		add	esp, 10h

loc_80004B1:				; CODE XREF: set_program_path+2Dj
		nop
		leave
		retn
set_program_path endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl optc_to_fileno(int c)
optc_to_fileno	proc near		; CODE XREF: main+BCp

ret		= dword	ptr -4
c		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		mov	[ebp+ret], 0FFFFFFFFh
		mov	eax, [ebp+c]
		cmp	eax, 69h
		jz	short loc_80004DC
		cmp	eax, 6Fh
		jz	short loc_80004E5
		cmp	eax, 65h
		jnz	short loc_80004ED
		mov	[ebp+ret], 2
		jmp	short loc_80004ED
; ---------------------------------------------------------------------------

loc_80004DC:				; CODE XREF: optc_to_fileno+13j
		mov	[ebp+ret], 0
		jmp	short loc_80004ED
; ---------------------------------------------------------------------------

loc_80004E5:				; CODE XREF: optc_to_fileno+18j
		mov	[ebp+ret], 1
		nop

loc_80004ED:				; CODE XREF: optc_to_fileno+1Dj
					; optc_to_fileno+26j ...
		mov	eax, [ebp+ret]
		leave
		retn
optc_to_fileno	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void set_LD_PRELOAD()
set_LD_PRELOAD	proc near		; CODE XREF: main:loc_8000B23p

libstdbuf	= dword	ptr -8Ch
ret		= dword	ptr -88h
path		= dword	ptr -84h
old_libs	= dword	ptr -80h
sb		= stat ptr -7Ch
search_path	= dword	ptr -1Ch
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 90h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 0Ch
		push	offset aLd_preload ; "LD_PRELOAD"
		call	getenv
		add	esp, 10h
		mov	[ebp+old_libs],	eax
		mov	eax, ds:program_path
		mov	[ebp+search_path], eax
		mov	[ebp+search_path+4], offset aUsrLocalLibCor ; "/usr/local/lib/coreutils"
		mov	[ebp+search_path+8], offset locale
		mov	[ebp+search_path+0Ch], 0
		lea	eax, [ebp+search_path]
		mov	[ebp+path], eax

loc_8000541:				; CODE XREF: set_LD_PRELOAD+E9j
		mov	eax, [ebp+path]
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	short loc_8000568
		sub	esp, 0Ch
		push	offset aLibstdbuf_so ; "libstdbuf.so"
		call	xstrdup
		add	esp, 10h
		mov	[ebp+libstdbuf], eax
		jmp	short loc_80005E4
; ---------------------------------------------------------------------------

loc_8000568:				; CODE XREF: set_LD_PRELOAD+5Cj
		mov	eax, [ebp+path]
		mov	eax, [eax]
		push	offset aLibstdbuf_so ; "libstdbuf.so"
		push	eax
		push	offset aSS	; "%s/%s"
		lea	eax, [ebp+libstdbuf]
		push	eax
		call	rpl_asprintf
		add	esp, 10h
		mov	[ebp+ret], eax
		cmp	[ebp+ret], 0
		jns	short loc_800059E
		call	xalloc_die

loc_800059E:				; CODE XREF: set_LD_PRELOAD+A5j
		mov	eax, [ebp+libstdbuf]
		sub	esp, 8
		lea	edx, [ebp+sb]
		push	edx
		push	eax
		call	stat64
		add	esp, 10h
		test	eax, eax
		jz	short loc_80005E3
		mov	eax, [ebp+libstdbuf]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		add	[ebp+path], 4
		mov	eax, [ebp+path]
		mov	eax, [eax]
		test	eax, eax
		jnz	loc_8000541
		jmp	short loc_80005E4
; ---------------------------------------------------------------------------

loc_80005E3:				; CODE XREF: set_LD_PRELOAD+C4j
		nop

loc_80005E4:				; CODE XREF: set_LD_PRELOAD+74j
					; set_LD_PRELOAD+EFj
		cmp	[ebp+old_libs],	0
		jz	short loc_800060D
		mov	eax, [ebp+libstdbuf]
		push	eax
		push	[ebp+old_libs]
		push	offset aLd_preloadSS ; "LD_PRELOAD=%s:%s"
		lea	eax, [ebp+sb]
		push	eax
		call	rpl_asprintf
		add	esp, 10h
		mov	[ebp+ret], eax
		jmp	short loc_800062E
; ---------------------------------------------------------------------------

loc_800060D:				; CODE XREF: set_LD_PRELOAD+F6j
		mov	eax, [ebp+libstdbuf]
		sub	esp, 4
		push	eax
		push	offset aLd_preloadS ; "LD_PRELOAD=%s"
		lea	eax, [ebp+sb]
		push	eax
		call	rpl_asprintf
		add	esp, 10h
		mov	[ebp+ret], eax

loc_800062E:				; CODE XREF: set_LD_PRELOAD+119j
		cmp	[ebp+ret], 0
		jns	short loc_800063C
		call	xalloc_die

loc_800063C:				; CODE XREF: set_LD_PRELOAD+143j
		mov	eax, [ebp+libstdbuf]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax		; string
		call	putenv
		add	esp, 10h
		mov	[ebp+ret], eax
		cmp	[ebp+ret], 0
		jz	short loc_80006A3
		mov	eax, dword ptr [ebp+sb.st_dev]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToUpdate ; "failed to update the environment with	%"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	7Dh		; status
		call	error
		add	esp, 10h

loc_80006A3:				; CODE XREF: set_LD_PRELOAD+178j
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_80006B5
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80006B5:				; CODE XREF: set_LD_PRELOAD+1BCj
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
set_LD_PRELOAD	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void set_libstdbuf_options()
set_libstdbuf_options proc near		; CODE XREF: main:loc_8000AEFp

var		= dword	ptr -18h
i		= dword	ptr -14h
ret		= dword	ptr -10h
var_C		= dword	ptr -0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+i], 0
		jmp	loc_80007FC
; ---------------------------------------------------------------------------

loc_80006DB:				; CODE XREF: set_libstdbuf_options+146j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf.optarg
		mov	eax, [eax]
		test	eax, eax
		jz	loc_80007F8
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf.optarg
		mov	eax, [eax]
		movzx	eax, byte ptr [eax]
		cmp	al, 4Ch
		jnz	short loc_800074B
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf.optc
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; c
		call	toupper
		add	esp, 10h
		push	eax
		push	offset a_stdbuf_ ; "_STDBUF_"
		push	offset aSCL	; "%s%c=L"
		lea	eax, [ebp+var]
		push	eax
		call	rpl_asprintf
		add	esp, 10h
		mov	[ebp+ret], eax
		jmp	short loc_80007A3
; ---------------------------------------------------------------------------

loc_800074B:				; CODE XREF: set_libstdbuf_options+52j
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf
		mov	eax, [eax]
		mov	ebx, eax
		mov	esi, 0
		mov	edx, [ebp+i]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf.optc
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; c
		call	toupper
		add	esp, 10h
		sub	esp, 8
		push	esi
		push	ebx
		push	eax
		push	offset a_stdbuf_ ; "_STDBUF_"
		push	offset aSCLlu	; "%s%c=%llu"
		lea	eax, [ebp+var]
		push	eax
		call	rpl_asprintf
		add	esp, 20h
		mov	[ebp+ret], eax

loc_80007A3:				; CODE XREF: set_libstdbuf_options+8Dj
		cmp	[ebp+ret], 0
		jns	short loc_80007AE
		call	xalloc_die

loc_80007AE:				; CODE XREF: set_libstdbuf_options+EBj
		mov	eax, [ebp+var]
		sub	esp, 0Ch
		push	eax		; string
		call	putenv
		add	esp, 10h
		test	eax, eax
		jz	short loc_80007F8
		mov	eax, [ebp+var]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToUpdate ; "failed to update the environment with	%"...
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	7Dh		; status
		call	error
		add	esp, 10h

loc_80007F8:				; CODE XREF: set_libstdbuf_options+34j
					; set_libstdbuf_options+103j
		add	[ebp+i], 1

loc_80007FC:				; CODE XREF: set_libstdbuf_options+1Aj
		mov	eax, [ebp+i]
		cmp	eax, 2
		jbe	loc_80006DB
		nop
		mov	eax, [ebp+var_C]
		xor	eax, large gs:14h
		jz	short loc_800081A
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_800081A:				; CODE XREF: set_libstdbuf_options+157j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
set_libstdbuf_options endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

c		= dword	ptr -24h
opt_fileno	= dword	ptr -20h
exit_status	= dword	ptr -1Ch
argc		= dword	ptr  0Ch
argv		= dword	ptr  10h
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		push	ecx
		sub	esp, 18h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	7Dh		; status
		call	initialize_exit_failure
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	loc_8000A85
; ---------------------------------------------------------------------------

loc_80008A1:				; CODE XREF: main+287j
		mov	eax, [ebp+c]
		cmp	eax, 65h
		jz	short loc_80008D7
		cmp	eax, 65h
		jg	short loc_80008C9
		cmp	eax, 0FFFFFF7Dh
		jz	loc_8000A35
		cmp	eax, 0FFFFFF7Eh
		jz	loc_8000A2B
		jmp	loc_8000A7B
; ---------------------------------------------------------------------------

loc_80008C9:				; CODE XREF: main+8Bj
		cmp	eax, 69h
		jz	short loc_80008D7
		cmp	eax, 6Fh
		jnz	loc_8000A7B

loc_80008D7:				; CODE XREF: main+86j main+ABj
		sub	esp, 0Ch
		push	[ebp+c]		; c
		call	optc_to_fileno
		add	esp, 10h
		mov	[ebp+opt_fileno], eax
		cmp	[ebp+opt_fileno], 0
		js	short loc_80008F6
		mov	eax, [ebp+opt_fileno]
		cmp	eax, 2
		jbe	short loc_800090F

loc_80008F6:				; CODE XREF: main+CBj
		push	offset __PRETTY_FUNCTION___5235	; "main"
		push	137h		; line
		push	offset file	; "stdbuf.c"
		push	offset assertion ; "0 <= opt_fileno && opt_fileno < ARRAY_C"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800090F:				; CODE XREF: main+D3j
		mov	edx, [ebp+opt_fileno]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, stdbuf.optc[eax]
		mov	eax, [ebp+c]
		mov	[edx], eax
		jmp	short loc_8000935
; ---------------------------------------------------------------------------

loc_8000928:				; CODE XREF: main+12Dj
		mov	eax, ds:optarg
		add	eax, 1
		mov	ds:optarg, eax

loc_8000935:				; CODE XREF: main+105j
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax
		call	c_isspace
		add	esp, 10h
		test	al, al
		jnz	short loc_8000928
		mov	ecx, ds:optarg
		mov	edx, [ebp+opt_fileno]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		add	eax, offset stdbuf.optarg
		mov	[eax], ecx
		cmp	[ebp+c], 69h
		jnz	short loc_80009A5
		mov	eax, ds:optarg
		movzx	eax, byte ptr [eax]
		cmp	al, 4Ch
		jnz	short loc_80009A5
		sub	esp, 0Ch
		push	offset aLineBufferingS ; "line buffering stdin is meaningless"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80009A5:				; CODE XREF: main+14Cj	main+158j
		mov	eax, ds:optarg
		sub	esp, 8
		push	offset asc_80013FC ; "L"
		push	eax		; s1
		call	strcmp
		add	esp, 10h
		test	eax, eax
		jz	loc_8000A85
		mov	edx, [ebp+opt_fileno]
		mov	eax, edx
		add	eax, eax
		add	eax, edx
		shl	eax, 2
		lea	edx, stdbuf.size[eax]
		mov	eax, ds:optarg
		sub	esp, 8
		push	edx		; size
		push	eax		; str
		call	parse_size
		add	esp, 10h
		cmp	eax, 0FFFFFFFFh
		jnz	loc_8000A85
		mov	eax, ds:optarg
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	edi, eax
		sub	esp, 0Ch
		push	offset aInvalidModeS ; "invalid	mode %s"
		call	gettext
		add	esp, 10h
		mov	esi, eax
		call	__errno_location
		mov	eax, [eax]
		push	edi
		push	esi		; format
		push	eax		; errnum
		push	7Dh		; status
		call	error
		add	esp, 10h
		jmp	short loc_8000A85
; ---------------------------------------------------------------------------

loc_8000A2B:				; CODE XREF: main+9Dj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000A35:				; CODE XREF: main+92j
		sub	esp, 8
		push	offset aPBdraigBrady ; "Pádraig Brady"
		push	offset aPadraigBrady ; "Padraig	Brady"
		call	proper_name_utf8
		add	esp, 10h
		mov	ecx, eax
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	ecx
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aStdbuf	; "stdbuf"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8000A7B:				; CODE XREF: main+A3j main+B0j
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000A85:				; CODE XREF: main+7Bj main+19Cj ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset longopts	; longopts
		push	offset shortopts ; "+i:o:e:"
		push	dword ptr [ebx+4] ; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_80008A1
		mov	eax, ds:optind
		shl	eax, 2
		add	[ebx+4], eax
		mov	eax, ds:optind
		sub	[ebx], eax
		cmp	dword ptr [ebx], 0
		jg	short loc_8000AEF
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	7Dh		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8000AEF:				; CODE XREF: main+2A2j
		call	set_libstdbuf_options
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; arg
		call	set_program_path
		add	esp, 10h
		mov	eax, ds:program_path
		test	eax, eax
		jnz	short loc_8000B23
		sub	esp, 0Ch
		push	offset aUsrLocalLibCor ; "/usr/local/lib/coreutils"
		call	xstrdup
		add	esp, 10h
		mov	ds:program_path, eax

loc_8000B23:				; CODE XREF: main+2EBj
		call	set_LD_PRELOAD
		mov	eax, ds:program_path
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 8
		push	dword ptr [ebx+4] ; argv
		push	eax		; file
		call	execvp
		add	esp, 10h
		call	__errno_location
		mov	eax, [eax]
		cmp	eax, 2
		jnz	short loc_8000B60
		mov	eax, 7Fh
		jmp	short loc_8000B65
; ---------------------------------------------------------------------------

loc_8000B60:				; CODE XREF: main+336j
		mov	eax, 7Eh

loc_8000B65:				; CODE XREF: main+33Dj
		mov	[ebp+exit_status], eax
		mov	eax, [ebx+4]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	esi, eax
		sub	esp, 0Ch
		push	offset aFailedToRunCom ; "failed to run	command	%s"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		push	esi
		push	ebx		; format
		push	eax		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+exit_status] ; status

loc_8000BA7:				; DATA XREF: .eh_frame:0800148Co
					; .eh_frame:080014ACo ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8000BC0h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; char *program_path
program_path	dd ?			; DATA XREF: set_program_path+28w
					; set_program_path+59w	...
		align 20h
; $DEBDBAB647A56CCAB13999F930B7807B stdbuf[3]
stdbuf		$DEBDBAB647A56CCAB13999F930B7807B 3 dup(<?>)
					; DATA XREF: set_libstdbuf_options+9Bo
					; main+1AEo ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8000C20h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+41o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+23Do
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aInput		db 'input',0            ; DATA XREF: .rodata:longoptso
aOutput		db 'output',0           ; DATA XREF: .rodata:longoptso
aError		db 'error',0            ; DATA XREF: .rodata:longoptso
aHelp		db 'help',0             ; DATA XREF: .rodata:longoptso
aVersion	db 'version',0          ; DATA XREF: .rodata:longoptso
		align 20h
; const	option longopts[6]
longopts	option <offset aInput, 1, 0, 69h> ; DATA XREF: main+269o
		option <offset aOutput,	1, 0, 6Fh> ; "input"
		option <offset aError, 1, 0, 65h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
aEgkkmptyz0	db 'EGkKMPTYZ0',0       ; DATA XREF: parse_size+20o
		align 4
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s OPTION... COMMAND',0Ah,0 ; DATA XREF: usage+46o
; char aRunCommandWith[]
aRunCommandWith	db 'Run COMMAND, with modified buffering operations for its standard '
					; DATA XREF: usage+69o
		db 'streams.',0Ah
		db 0Ah,0
; char aMandatoryArgum[]
aMandatoryArgum	db 'Mandatory arguments to long options are mandatory for short optio'
					; DATA XREF: usage+8Co
		db 'ns too.',0Ah,0
		align 4
; char aIInputModeAdju[]
aIInputModeAdju	db '  -i, --input=MODE   Adjust standard input stream buffering',0Ah
					; DATA XREF: usage+AFo
		db '  -o, --output=MODE  Adjust standard output stream buffering',0Ah
		db '  -e, --error=MODE   Adjust standard error stream buffering',0Ah,0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+D2o
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+F5o
		align 4
; char aIfModeIsLTheCo[]
aIfModeIsLTheCo	db 0Ah			; DATA XREF: usage+118o
		db 'If MODE is `L',27h,' the corresponding stream will be line buffered.'
		db 0Ah
		db 'This option is invalid with standard input.',0Ah,0
		align 4
; char aIfModeIs0TheCo[]
aIfModeIs0TheCo	db 0Ah			; DATA XREF: usage+13Bo
		db 'If MODE is `0',27h,' the corresponding stream will be unbuffered.',0Ah,0
		align 4
; char aOtherwiseModeI[]
aOtherwiseModeI	db 0Ah			; DATA XREF: usage+15Eo
		db 'Otherwise MODE is a number which may be followed by one of the fo'
		db 'llowing:',0Ah
		db 'KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P'
		db ', E, Z, Y.',0Ah
		db 'In this case the corresponding stream will be fully buffered with'
		db ' the buffer',0Ah
		db 'size set to MODE bytes.',0Ah,0
		align 4
; char aNoteIfCommandA[]
aNoteIfCommandA	db 0Ah			; DATA XREF: usage+181o
		db 'NOTE: If COMMAND adjusts the buffering of its standard streams (`'
		db 'tee',27h,' does',0Ah
		db 'for e.g.) then that will override corresponding settings changed '
		db 'by `stdbuf',27h,'.',0Ah
		db 'Also some filters (like `dd',27h,' and `cat',27h,' etc.) don',27h,'t use s'
		db 'treams for I/O,',0Ah
		db 'and are thus unaffected by `stdbuf',27h,' settings.',0Ah,0
aProcSelfExe	db '/proc/self/exe',0   ; DATA XREF: set_program_path+35o
; char name[]
name		db 'PATH',0             ; DATA XREF: set_program_path+66o
; char delim[]
delim		db ':',0                ; DATA XREF: set_program_path+94o
					; set_program_path+107o
; char aLd_preload[]
aLd_preload	db 'LD_PRELOAD',0       ; DATA XREF: set_LD_PRELOAD+19o
; char aUsrLocalLibCor[]
aUsrLocalLibCor	db '/usr/local/lib/coreutils',0 ; DATA XREF: set_LD_PRELOAD+31o
					; main+2F0o
; char locale
locale		db 0			; DATA XREF: set_LD_PRELOAD+38o
					; main+2Ao
; char aLibstdbuf_so[]
aLibstdbuf_so	db 'libstdbuf.so',0     ; DATA XREF: set_LD_PRELOAD+61o
					; set_LD_PRELOAD+7Eo
aSS		db '%s/%s',0            ; DATA XREF: set_LD_PRELOAD+84o
aLd_preloadSS	db 'LD_PRELOAD=%s:%s',0 ; DATA XREF: set_LD_PRELOAD+102o
aLd_preloadS	db 'LD_PRELOAD=%s',0    ; DATA XREF: set_LD_PRELOAD+125o
		align 4
; char aFailedToUpdate[]
aFailedToUpdate	db 'failed to update the environment with %s',0
					; DATA XREF: set_LD_PRELOAD+18Eo
					; set_libstdbuf_options+119o
a_stdbuf_	db '_STDBUF_',0         ; DATA XREF: set_libstdbuf_options+74o
					; set_libstdbuf_options+CEo
aSCL		db '%s%c=L',0           ; DATA XREF: set_libstdbuf_options+79o
aSCLlu		db '%s%c=%llu',0        ; DATA XREF: set_libstdbuf_options+D3o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+3Co
; char file[]
file		db 'stdbuf.c',0         ; DATA XREF: main+DFo
; char assertion[]
assertion	db '0 <= opt_fileno && opt_fileno < ARRAY_CARDINALITY (stdbuf)',0
					; DATA XREF: main+E4o
		align 4
; char aLineBufferingS[]
aLineBufferingS	db 'line buffering stdin is meaningless',0 ; DATA XREF: main+15Do
; char asc_80013FC[]
asc_80013FC	db 'L',0                ; DATA XREF: main+18Co
; char aInvalidModeS[]
aInvalidModeS	db 'invalid mode %s',0  ; DATA XREF: main+1E5o
aPBdraigBrady	db 'Pádraig Brady',0   ; DATA XREF: main+217o
aPadraigBrady	db 'Padraig Brady',0    ; DATA XREF: main+21Co
aStdbuf		db 'stdbuf',0           ; DATA XREF: main+242o
; char shortopts[]
shortopts	db '+i:o:e:',0          ; DATA XREF: main+26Eo
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+2A7o
; char aFailedToRunCom[]
aFailedToRunCom	db 'failed to run command %s',0 ; DATA XREF: main+35Do
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5235[5]
__PRETTY_FUNCTION___5235 db 'main',0    ; DATA XREF: main:loc_80008F6o
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 800146Ch
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8000BA7-8002033h
		dd 14h,	80E4100h, 0D420285h, 0CC55005h,	404h, 20h, 3Ch
		dd offset loc_8000BA7-800203Fh
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8000BA7-8001F47h
		dd 0A9h, 80E4100h, 0D420285h, 0C5A50205h, 4040Ch, 18h
		dd 80h
		dd offset loc_8000BA7-8001EBEh
		dd 1ABh, 80E4100h, 0D420285h, 3834405h,	1Ch, 9Ch
		dd offset loc_8000BA7-8001D2Fh
		dd 130h, 80E4100h, 0D420285h, 12C0305h,	4040CC5h, 1Ch
		dd 0BCh
		dd offset loc_8000BA7-8001C1Fh
		dd 3Eh,	80E4100h, 0D420285h, 0CC57A05h,	404h, 28h, 0DCh
		dd offset loc_8000BA7-8001C01h
		dd 1CAh, 80E4100h, 0D420285h, 3864805h,	0BC030483h, 0C641C301h
		dd 40CC541h, 4,	28h, 108h
		dd offset loc_8000BA7-8001A63h
		dd 165h, 80E4100h, 0D420285h, 3864505h,	5A030483h, 0C641C301h
		dd 40CC541h, 4,	2Ch, 134h
		dd offset loc_8000BA7-800192Ah
		dd 38Bh, 10C4400h, 5104700h, 46007502h,	7075030Fh, 2071006h
		dd 6107C75h, 10787502h,	74750203h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn exit_failure:dword ; DATA	XREF: initialize_exit_failure+Cw
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+31p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
		extrn xstrtoumax:near	; CODE XREF: parse_size+30p
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: parse_size+59p
					; parse_size:loc_80001A8p ...
		extrn __stack_chk_fail:near ; CODE XREF: parse_size+A2p
					; set_LD_PRELOAD+1BEp ...
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+1A6p main+255p ...
; char *strchr(const char *s, int c)
		extrn strchr:near	; CODE XREF: set_program_path+Ep
		extrn dir_name:near	; CODE XREF: set_program_path+20p
					; set_program_path+51p	...
		extrn xreadlink:near	; CODE XREF: set_program_path+3Ap
; char *getenv(const char *name)
		extrn getenv:near	; CODE XREF: set_program_path+6Bp
					; set_LD_PRELOAD+1Ep
; char *xstrdup(const char *)
		extrn xstrdup:near	; CODE XREF: set_program_path+86p
					; set_LD_PRELOAD+66p ...
; char *strtok(char *s,	const char *delim)
		extrn strtok:near	; CODE XREF: set_program_path+9Cp
					; set_program_path+10Ep
		extrn file_name_concat:near ; CODE XREF: set_program_path+B4p
; int access(const char	*name, int type)
		extrn access:near	; CODE XREF: set_program_path+C7p
; void free(void *ptr)
		extrn free:near		; CODE XREF: set_program_path+ECp
					; set_program_path+FCp	...
		extrn rpl_asprintf:near	; CODE XREF: set_LD_PRELOAD+90p
					; set_LD_PRELOAD+10Bp ...
		extrn xalloc_die:near	; CODE XREF: set_LD_PRELOAD+A7p
					; set_LD_PRELOAD+145p ...
		extrn stat64:near	; CODE XREF: set_LD_PRELOAD+BAp
; int putenv(char *string)
		extrn putenv:near	; CODE XREF: set_LD_PRELOAD+163p
					; set_libstdbuf_options+F9p
		extrn quote:near	; CODE XREF: set_LD_PRELOAD+181p
					; set_libstdbuf_options+10Cp ...
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: set_LD_PRELOAD+1A9p
					; set_libstdbuf_options+134p ...
; int toupper(int c)
		extrn toupper:near	; CODE XREF: set_libstdbuf_options+6Bp
					; set_libstdbuf_options+C0p
		extrn set_program_name:near ; CODE XREF: main+1Fp
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+46p
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+56p
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+6Eo
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+73p
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: main+E9p
; char *optarg
		extrn optarg:dword	; DATA XREF: main:loc_8000928r
					; main+10Fw ...
		extrn c_isspace:near	; CODE XREF: main+123p
; int strcmp(const char	*s1, const char	*s2)
		extrn strcmp:near	; CODE XREF: main+192p
		extrn proper_name_utf8:near ; CODE XREF: main+221p
		extrn Version:dword	; DATA XREF: main+22Br
		extrn version_etc:near	; CODE XREF: main+248p
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+278p
; int optind
		extrn optind:dword	; DATA XREF: main+28Dr	main+298r
; int execvp(const char	*file, char *const *argv)
		extrn execvp:near	; CODE XREF: main+324p


		end
