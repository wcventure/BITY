;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2015 Hex-Rays, <support@hex-rays.com>	    |
; |			 License info: 48-B611-7234-BB			    |
; |		Doskey Lee, Kingsoft Internet Security Software		    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	48A34DD7638CB8C15959F175627A83F7
; Input	CRC32 :	F70C929E

; File Name   :	D:\coreutils-o\tr.o
; Format      :	ELF for	Intel 386 (Relocatable)
;
; Source File :	'tr.c'

		.686p
		.mmx
		.model flat
.intel_syntax noprefix

; ===========================================================================

; Segment type:	Pure code
; Segment permissions: Read/Execute
_text		segment	byte public 'CODE' use32
		assume cs:_text
		;org 8000000h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing

; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; unsigned __int8 __cdecl to_uchar(char	ch_0)
to_uchar	proc near		; CODE XREF: star_digits_closebracket+40p
					; squeeze_filter+7Cp ...

ch_0		= byte ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_0]
		mov	[ebp+ch_0], al
		movzx	eax, [ebp+ch_0]
		leave
		retn
to_uchar	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void emit_ancillary_info()
emit_ancillary_info proc near		; CODE XREF: usage+155p

lc_messages	= dword	ptr -0Ch
var_4		= dword	ptr -4

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset msgid	; "\nReport %s bugs to %s\n"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset aBugCoreutils@g ; "bug-coreutils@gnu.org"
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		sub	esp, 0Ch
		push	offset aSHomePageHttpW ; "%s home page:	<http://www.gnu.org/softw"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	offset domainname ; "coreutils"
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGeneralHelpUsi ; "General help using GNU software: <http:"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		sub	esp, 8
		push	0		; locale
		push	5		; category
		call	setlocale
		add	esp, 10h
		mov	[ebp+lc_messages], eax
		cmp	[ebp+lc_messages], 0
		jz	short loc_80000F8
		sub	esp, 4
		push	3		; n
		push	offset s2	; "en_"
		push	[ebp+lc_messages] ; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jz	short loc_80000F8
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aReportSTransla ; "Report %s translation	bugs to	<http://t"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h

loc_80000F8:				; CODE XREF: emit_ancillary_info+9Bj
					; emit_ancillary_info+B4j
		mov	eax, ds:program_name
		sub	esp, 0Ch
		push	eax
		call	last_component
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aForCompleteDoc ; "For complete documentation, run: info	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
emit_ancillary_info endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	es_match(const E_string	*es_0, size_t i, char c)
es_match	proc near		; CODE XREF: find_bracketed_repeat+62p
					; star_digits_closebracket+Ep ...

c		= byte ptr -4
es_0		= dword	ptr  8
i		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 4
		mov	eax, [ebp+arg_8]
		mov	[ebp+c], al
		mov	eax, [ebp+es_0]
		mov	edx, [eax]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+c]
		jnz	short loc_8000168
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8000168
		mov	eax, 1
		jmp	short loc_800016D
; ---------------------------------------------------------------------------

loc_8000168:				; CODE XREF: es_match+1Cj es_match+31j
		mov	eax, 0

loc_800016D:				; CODE XREF: es_match+38j
		and	eax, 1
		leave
		retn
es_match	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; void __cdecl usage(int status)
		public usage
usage		proc near		; CODE XREF: main+F6p main+133p ...

status		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 4
		cmp	[ebp+status], 0
		jz	short loc_80001AF
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aTrySHelpForMor ; "Try `%s --help' for more information.\n"
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	ebx
		push	edx		; format
		push	eax		; stream
		call	fprintf
		add	esp, 10h
		jmp	loc_80002CC
; ---------------------------------------------------------------------------

loc_80001AF:				; CODE XREF: usage+Bj
		mov	ebx, ds:program_name
		sub	esp, 0Ch
		push	offset aUsageSOption__ ; "Usage: %s [OPTION]...	SET1 [SET2]\n"
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax		; format
		call	printf
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTranslateSquee ; "Translate, squeeze, and/or delete chara"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aHelpDisplayThi ; "	--help	   display this	help and "...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVersionOutputV ; "	--version  output version informa"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aSetsAreSpecifi ; "\nSETs are specified as strings of char"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aVVerticalTabCh ; "  \\v		     vertical tab\n  CHAR"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aGraphAllPrinta ; "  [:graph:]	    all	printable charact"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		mov	ebx, ds:stdout
		sub	esp, 0Ch
		push	offset aTranslationOcc ; "\nTranslation	occurs if -d is	not given"...
		call	gettext
		add	esp, 10h
		sub	esp, 8
		push	ebx
		push	eax
		call	fputs_unlocked
		add	esp, 10h
		call	emit_ancillary_info

loc_80002CC:				; CODE XREF: usage+38j
		sub	esp, 0Ch
		push	[ebp+status]	; status
		call	exit
usage		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_equiv_class_member(unsigned __int8 equiv_class, unsigned __int8 c)
is_equiv_class_member proc near		; CODE XREF: get_spec_stats+14Dp

c		= byte ptr -8
equiv_class	= byte ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	edx, [ebp+arg_0]
		mov	eax, [ebp+arg_4]
		mov	[ebp+equiv_class], dl
		mov	[ebp+c], al
		movzx	eax, [ebp+equiv_class]
		cmp	al, [ebp+c]
		setz	al
		leave
		retn
is_equiv_class_member endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	is_char_class_member(Char_class	char_class, unsigned __int8 c)
is_char_class_member proc near		; CODE XREF: get_next+1ADp
					; get_next+20Fp ...

c		= byte ptr -1Ch
result		= dword	ptr -0Ch
char_class	= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		cmp	[ebp+char_class], 0Bh ;	switch 12 cases
		ja	loc_800049B	; jumptable 08000318 default case
		mov	eax, [ebp+char_class]
		shl	eax, 2
		add	eax, offset off_8005D08
		mov	eax, [eax]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_800031A:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 0
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 8
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_800033A:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 1
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 400h
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_800035C:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 2
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_800037C:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 3
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 2
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_800039C:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 4
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 800h
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_80003BE:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 5
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 8000h
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_80003E0:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 6
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 200h
		mov	[ebp+result], eax
		jmp	loc_80004A0
; ---------------------------------------------------------------------------

loc_8000402:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 7
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		mov	[ebp+result], eax
		jmp	short loc_80004A0
; ---------------------------------------------------------------------------

loc_8000421:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 8
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4
		mov	[ebp+result], eax
		jmp	short loc_80004A0
; ---------------------------------------------------------------------------

loc_800043E:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 9
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 2000h
		mov	[ebp+result], eax
		jmp	short loc_80004A0
; ---------------------------------------------------------------------------

loc_800045D:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 10
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 100h
		mov	[ebp+result], eax
		jmp	short loc_80004A0
; ---------------------------------------------------------------------------

loc_800047C:				; CODE XREF: is_char_class_member+23j
					; DATA XREF: .rodata:off_8005D08o
		call	__ctype_b_loc	; jumptable 08000318 case 11
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 1000h
		mov	[ebp+result], eax
		jmp	short loc_80004A0
; ---------------------------------------------------------------------------

loc_800049B:				; CODE XREF: is_char_class_member+10j
		call	abort		; jumptable 08000318 default case
; ---------------------------------------------------------------------------

loc_80004A0:				; CODE XREF: is_char_class_member+40j
					; is_char_class_member+62j ...
		cmp	[ebp+result], 0
		setnz	al
		leave
		retn
is_char_class_member endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl es_free(E_string	*es_0)
es_free		proc near		; CODE XREF: parse_str+63p

es_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		mov	eax, [ebp+es_0]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		mov	eax, [ebp+es_0]
		mov	eax, [eax+4]
		sub	esp, 0Ch
		push	eax		; ptr
		call	free
		add	esp, 10h
		nop
		leave
		retn
es_free		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	unquote(const char *s, E_string	*es_0)
unquote		proc near		; CODE XREF: parse_str+27p

var_44		= dword	ptr -44h
var_40		= dword	ptr -40h
var_3C		= dword	ptr -3Ch
c		= byte ptr -29h
i		= dword	ptr -28h
j		= dword	ptr -24h
len		= dword	ptr -20h
oct_digit	= dword	ptr -1Ch
s		= dword	ptr  8
es_0		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	edi
		push	esi
		push	ebx
		sub	esp, 3Ch
		sub	esp, 0Ch
		push	[ebp+s]		; s
		call	strlen
		add	esp, 10h
		mov	[ebp+len], eax
		sub	esp, 0Ch
		push	[ebp+len]	; size_t
		call	xmalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+es_0]
		mov	[eax], edx
		sub	esp, 8
		push	1		; size_t
		push	[ebp+len]	; size_t
		call	xcalloc
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+es_0]
		mov	[eax+4], edx
		mov	[ebp+j], 0
		mov	[ebp+i], 0
		jmp	loc_80007E0
; ---------------------------------------------------------------------------

loc_800052F:				; CODE XREF: unquote+318j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 5Ch
		jnz	loc_80007BD
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+j]
		add	eax, edx
		mov	byte ptr [eax],	1
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, 62h
		jz	short loc_80005D3
		cmp	eax, 62h
		jg	short loc_8000599
		cmp	eax, 37h
		jg	short loc_800058A
		cmp	eax, 30h
		jge	loc_8000609
		test	eax, eax
		jz	loc_8000754
		jmp	loc_800078C
; ---------------------------------------------------------------------------

loc_800058A:				; CODE XREF: unquote+9Dj
		cmp	eax, 5Ch
		jz	short loc_80005C1
		cmp	eax, 61h
		jz	short loc_80005CA
		jmp	loc_800078C
; ---------------------------------------------------------------------------

loc_8000599:				; CODE XREF: unquote+98j
		cmp	eax, 72h
		jz	short loc_80005EE
		cmp	eax, 72h
		jg	short loc_80005B2
		cmp	eax, 66h
		jz	short loc_80005DC
		cmp	eax, 6Eh
		jz	short loc_80005E5
		jmp	loc_800078C
; ---------------------------------------------------------------------------

loc_80005B2:				; CODE XREF: unquote+CCj
		cmp	eax, 74h
		jz	short loc_80005F7
		cmp	eax, 76h
		jz	short loc_8000600
		jmp	loc_800078C
; ---------------------------------------------------------------------------

loc_80005C1:				; CODE XREF: unquote+B8j
		mov	[ebp+c], 5Ch
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005CA:				; CODE XREF: unquote+BDj
		mov	[ebp+c], 7
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005D3:				; CODE XREF: unquote+93j
		mov	[ebp+c], 8
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005DC:				; CODE XREF: unquote+D1j
		mov	[ebp+c], 0Ch
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005E5:				; CODE XREF: unquote+D6j
		mov	[ebp+c], 0Ah
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005EE:				; CODE XREF: unquote+C7j
		mov	[ebp+c], 0Dh
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_80005F7:				; CODE XREF: unquote+E0j
		mov	[ebp+c], 9
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_8000600:				; CODE XREF: unquote+E5j
		mov	[ebp+c], 0Bh
		jmp	loc_80007A0
; ---------------------------------------------------------------------------

loc_8000609:				; CODE XREF: unquote+A2j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		sub	eax, 30h
		mov	[ebp+c], al
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		mov	[ebp+oct_digit], eax
		cmp	[ebp+oct_digit], 0
		js	loc_800079F
		cmp	[ebp+oct_digit], 7
		jg	loc_800079F
		movzx	eax, [ebp+c]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+oct_digit]
		add	eax, edx
		mov	[ebp+c], al
		add	[ebp+i], 1
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	eax, 30h
		mov	[ebp+oct_digit], eax
		cmp	[ebp+oct_digit], 0
		js	loc_800079F
		cmp	[ebp+oct_digit], 7
		jg	loc_800079F
		movzx	eax, [ebp+c]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+oct_digit]
		add	eax, edx
		cmp	eax, 0FFh
		jg	short loc_80006BD
		movzx	eax, [ebp+c]
		lea	edx, ds:0[eax*8]
		mov	eax, [ebp+oct_digit]
		add	eax, edx
		mov	[ebp+c], al
		add	[ebp+i], 1
		jmp	loc_800079F
; ---------------------------------------------------------------------------

loc_80006BD:				; CODE XREF: unquote+1CAj
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+var_3C], eax
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	ebx, al
		mov	[ebp+var_40], ebx
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	esi, al
		mov	[ebp+var_44], esi
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	edi, al
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	esi, al
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	ebx, al
		sub	esp, 0Ch
		push	offset aWarningTheAmbi ; "warning: the ambiguous octal escape \\%"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+var_3C]
		push	[ebp+var_40]
		push	[ebp+var_44]
		push	edi
		push	esi
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 30h
		jmp	short loc_800079F
; ---------------------------------------------------------------------------

loc_8000754:				; CODE XREF: unquote+AAj
		sub	esp, 0Ch
		push	offset aWarningAnUnesc ; "warning: an unescaped	backslash at end "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+j]
		add	eax, edx
		mov	byte ptr [eax],	0
		sub	[ebp+i], 1
		mov	[ebp+c], 5Ch
		jmp	short loc_80007A0
; ---------------------------------------------------------------------------

loc_800078C:				; CODE XREF: unquote+B0j unquote+BFj ...
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		jmp	short loc_80007A0
; ---------------------------------------------------------------------------

loc_800079F:				; CODE XREF: unquote+163j unquote+16Dj ...
		nop

loc_80007A0:				; CODE XREF: unquote+F0j unquote+F9j ...
		add	[ebp+i], 1
		mov	eax, [ebp+es_0]
		mov	ecx, [eax]
		mov	eax, [ebp+j]
		lea	edx, [eax+1]
		mov	[ebp+j], edx
		lea	edx, [ecx+eax]
		movzx	eax, [ebp+c]
		mov	[edx], al
		jmp	short loc_80007DC
; ---------------------------------------------------------------------------

loc_80007BD:				; CODE XREF: unquote+6Bj
		mov	eax, [ebp+es_0]
		mov	ecx, [eax]
		mov	eax, [ebp+j]
		lea	edx, [eax+1]
		mov	[ebp+j], edx
		lea	edx, [ecx+eax]
		mov	ecx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		mov	[edx], al
		nop

loc_80007DC:				; CODE XREF: unquote+2E6j
		add	[ebp+i], 1

loc_80007E0:				; CODE XREF: unquote+55j
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jnz	loc_800052F
		mov	eax, [ebp+es_0]
		mov	edx, [ebp+j]
		mov	[eax+8], edx
		mov	eax, 1
		lea	esp, [ebp-0Ch]
		pop	ebx
		pop	esi
		pop	edi
		pop	ebp
		retn
unquote		endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; Char_class __cdecl look_up_char_class(const char *class_str, size_t len)
look_up_char_class proc	near		; CODE XREF: append_char_class+Fp

i		= dword	ptr -0Ch
class_str	= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	[ebp+i], 0
		jmp	short loc_800085C
; ---------------------------------------------------------------------------

loc_8000818:				; CODE XREF: look_up_char_class+57j
		mov	eax, [ebp+i]
		mov	eax, ds:char_class_name[eax*4]
		sub	esp, 4
		push	[ebp+len]	; n
		push	eax		; s2
		push	[ebp+class_str]	; s1
		call	strncmp
		add	esp, 10h
		test	eax, eax
		jnz	short loc_8000858
		mov	eax, [ebp+i]
		mov	eax, ds:char_class_name[eax*4]
		sub	esp, 0Ch
		push	eax		; s
		call	strlen
		add	esp, 10h
		cmp	eax, [ebp+len]
		jnz	short loc_8000858
		mov	eax, [ebp+i]
		jmp	short locret_8000867
; ---------------------------------------------------------------------------

loc_8000858:				; CODE XREF: look_up_char_class+2Dj
					; look_up_char_class+48j
		add	[ebp+i], 1

loc_800085C:				; CODE XREF: look_up_char_class+Dj
		cmp	[ebp+i], 0Bh
		jbe	short loc_8000818
		mov	eax, 270Fh

locret_8000867:				; CODE XREF: look_up_char_class+4Dj
		leave
		retn
look_up_char_class endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	make_printable_char(unsigned __int8 c)
make_printable_char proc near		; CODE XREF: append_range+23p
					; append_range+36p

c		= byte ptr -1Ch
buf		= dword	ptr -0Ch
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_0]
		mov	[ebp+c], al
		sub	esp, 0Ch
		push	5		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+buf], eax
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_80008B7
		movzx	edx, [ebp+c]
		mov	eax, [ebp+buf]
		mov	[eax], dl
		mov	eax, [ebp+buf]
		add	eax, 1
		mov	byte ptr [eax],	0
		jmp	short loc_80008CF
; ---------------------------------------------------------------------------

loc_80008B7:				; CODE XREF: make_printable_char+38j
		movzx	eax, [ebp+c]
		sub	esp, 4
		push	eax
		push	offset format	; "\\%03o"
		push	[ebp+buf]	; s
		call	sprintf
		add	esp, 10h

loc_80008CF:				; CODE XREF: make_printable_char+4Cj
		mov	eax, [ebp+buf]
		leave
		retn
make_printable_char endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; char *__cdecl	make_printable_str(const char *s, size_t len)
make_printable_str proc	near		; CODE XREF: find_bracketed_repeat+149p
					; build_spec_list+18Bp	...

s		= dword	ptr -2Ch
c		= byte ptr -25h
p		= dword	ptr -24h
i		= dword	ptr -20h
tmp		= dword	ptr -1Ch
printable_buf	= dword	ptr -18h
buf		= byte ptr -11h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
len		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+len]
		add	eax, 1
		sub	esp, 8
		push	4
		push	eax
		call	xnmalloc
		add	esp, 10h
		mov	[ebp+printable_buf], eax
		mov	eax, [ebp+printable_buf]
		mov	[ebp+p], eax
		mov	[ebp+i], 0
		jmp	loc_8000A0D
; ---------------------------------------------------------------------------

loc_8000914:				; CODE XREF: make_printable_str+13Fj
		mov	[ebp+tmp], 0
		mov	edx, [ebp+s]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	[ebp+c], al
		movzx	eax, [ebp+c]
		cmp	eax, 0Ah
		jz	short loc_8000986
		cmp	eax, 0Ah
		jg	short loc_8000948
		cmp	eax, 8
		jz	short loc_8000974
		cmp	eax, 8
		jg	short loc_8000998
		cmp	eax, 7
		jz	short loc_8000968
		jmp	short loc_80009AA
; ---------------------------------------------------------------------------

loc_8000948:				; CODE XREF: make_printable_str+61j
		cmp	eax, 0Ch
		jz	short loc_800097D
		cmp	eax, 0Ch
		jl	short loc_80009A1
		cmp	eax, 0Dh
		jz	short loc_800098F
		cmp	eax, 5Ch
		jnz	short loc_80009AA
		mov	[ebp+tmp], offset asc_8005DE3 ;	"\\"
		jmp	loc_80009F5
; ---------------------------------------------------------------------------

loc_8000968:				; CODE XREF: make_printable_str+70j
		mov	[ebp+tmp], offset aA ; "\\a"
		jmp	loc_80009F5
; ---------------------------------------------------------------------------

loc_8000974:				; CODE XREF: make_printable_str+66j
		mov	[ebp+tmp], offset aB ; "\\b"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_800097D:				; CODE XREF: make_printable_str+77j
		mov	[ebp+tmp], offset asc_8005DEB ;	"\\f"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_8000986:				; CODE XREF: make_printable_str+5Cj
		mov	[ebp+tmp], offset aN ; "\\n"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_800098F:				; CODE XREF: make_printable_str+81j
		mov	[ebp+tmp], offset aR ; "\\r"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_8000998:				; CODE XREF: make_printable_str+6Bj
		mov	[ebp+tmp], offset aT ; "\\t"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_80009A1:				; CODE XREF: make_printable_str+7Cj
		mov	[ebp+tmp], offset aV ; "\\v"
		jmp	short loc_80009F5
; ---------------------------------------------------------------------------

loc_80009AA:				; CODE XREF: make_printable_str+72j
					; make_printable_str+86j
		call	__ctype_b_loc
		mov	eax, [eax]
		movzx	edx, [ebp+c]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 4000h
		test	eax, eax
		jz	short loc_80009D5
		movzx	eax, [ebp+c]
		mov	[ebp+buf], al
		mov	[ebp+buf+1], 0
		jmp	short loc_80009EE
; ---------------------------------------------------------------------------

loc_80009D5:				; CODE XREF: make_printable_str+F2j
		movzx	eax, [ebp+c]
		sub	esp, 4
		push	eax
		push	offset format	; "\\%03o"
		lea	eax, [ebp+buf]
		push	eax		; s
		call	sprintf
		add	esp, 10h

loc_80009EE:				; CODE XREF: make_printable_str+FFj
		lea	eax, [ebp+buf]
		mov	[ebp+tmp], eax
		nop

loc_80009F5:				; CODE XREF: make_printable_str+8Fj
					; make_printable_str+9Bj ...
		sub	esp, 8
		push	[ebp+tmp]
		push	[ebp+p]
		call	stpcpy
		add	esp, 10h
		mov	[ebp+p], eax
		add	[ebp+i], 1

loc_8000A0D:				; CODE XREF: make_printable_str+3Bj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+len]
		jb	loc_8000914
		mov	eax, [ebp+printable_buf]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short locret_8000A2D
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8000A2D:				; CODE XREF: make_printable_str+152j
		leave
		retn
make_printable_str endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl append_normal_char(Spec_list *list, unsigned __int8 c)
append_normal_char proc	near		; CODE XREF: build_spec_list+350p
					; build_spec_list+387p

c		= byte ptr -1Ch
new		= dword	ptr -0Ch
list		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+c], al
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+new]
		mov	dword ptr [eax], 0
		mov	eax, [ebp+new]
		movzx	edx, [ebp+c]
		mov	[eax+8], dl
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8000A8B
		push	offset __PRETTY_FUNCTION___5314	; "append_normal_char"
		push	28Ch		; line
		push	offset file	; "tr.c"
		push	offset assertion ; "list->tail"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000A8B:				; CODE XREF: append_normal_char+41j
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		nop
		leave
		retn
append_normal_char endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	append_range(Spec_list *list, unsigned __int8 first, unsigned __int8 last)
append_range	proc near		; CODE XREF: build_spec_list+31Fp

last		= byte ptr -20h
first		= byte ptr -1Ch
tmp1		= dword	ptr -14h
tmp2		= dword	ptr -10h
new		= dword	ptr -0Ch
list		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	edx, [ebp+arg_4]
		mov	eax, [ebp+arg_8]
		mov	[ebp+first], dl
		mov	[ebp+last], al
		movzx	eax, [ebp+last]
		cmp	al, [ebp+first]
		jnb	short loc_8000B2D
		movzx	eax, [ebp+first]
		sub	esp, 0Ch
		push	eax		; c
		call	make_printable_char
		add	esp, 10h
		mov	[ebp+tmp1], eax
		movzx	eax, [ebp+last]
		sub	esp, 0Ch
		push	eax		; c
		call	make_printable_char
		add	esp, 10h
		mov	[ebp+tmp2], eax
		sub	esp, 0Ch
		push	offset aRangeEndpoints ; "range-endpoints of `%s-%s' are in rever"...
		call	gettext
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tmp2]
		push	[ebp+tmp1]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 20h
		sub	esp, 0Ch
		push	[ebp+tmp1]	; ptr
		call	free
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tmp2]	; ptr
		call	free
		add	esp, 10h
		mov	eax, 0
		jmp	short locret_8000BA1
; ---------------------------------------------------------------------------

loc_8000B2D:				; CODE XREF: append_range+19j
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+new]
		mov	dword ptr [eax], 1
		mov	eax, [ebp+new]
		movzx	edx, [ebp+first]
		mov	[eax+8], dl
		mov	eax, [ebp+new]
		movzx	edx, [ebp+last]
		mov	[eax+9], dl
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8000B87
		push	offset __PRETTY_FUNCTION___5323	; "append_range"
		push	2ACh		; line
		push	offset file	; "tr.c"
		push	offset assertion ; "list->tail"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000B87:				; CODE XREF: append_range+C9j
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, 1

locret_8000BA1:				; CODE XREF: append_range+88j
		leave
		retn
append_range	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	append_char_class(Spec_list *list, const char *char_class_str, size_t len)
append_char_class proc near		; CODE XREF: build_spec_list+152p

char_class	= dword	ptr -10h
new		= dword	ptr -0Ch
list		= dword	ptr  8
char_class_str	= dword	ptr  0Ch
len		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 8
		push	[ebp+len]	; len
		push	[ebp+char_class_str] ; class_str
		call	look_up_char_class
		add	esp, 10h
		mov	[ebp+char_class], eax
		cmp	[ebp+char_class], 270Fh
		jnz	short loc_8000BCD
		mov	eax, 0
		jmp	short locret_8000C36
; ---------------------------------------------------------------------------

loc_8000BCD:				; CODE XREF: append_char_class+21j
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+new]
		mov	dword ptr [eax], 2
		mov	eax, [ebp+new]
		mov	edx, [ebp+char_class]
		mov	[eax+8], edx
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8000C1C
		push	offset __PRETTY_FUNCTION___5331	; "append_char_class"
		push	2C5h		; line
		push	offset file	; "tr.c"
		push	offset assertion ; "list->tail"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000C1C:				; CODE XREF: append_char_class+5Ej
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, 1

locret_8000C36:				; CODE XREF: append_char_class+28j
		leave
		retn
append_char_class endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl append_repeated_char(Spec_list *list, unsigned __int8 the_char, count repeat_count)
append_repeated_char proc near		; CODE XREF: build_spec_list+2ABp
					; string2_extend+156p

repeat_count	= qword	ptr -28h
the_char	= byte ptr -1Ch
new		= dword	ptr -0Ch
list		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+the_char],	al
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+repeat_count], eax
		mov	eax, [ebp+arg_C]
		mov	dword ptr [ebp+repeat_count+4],	eax
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+new]
		mov	dword ptr [eax], 4
		mov	eax, [ebp+new]
		movzx	edx, [ebp+the_char]
		mov	[eax+8], dl
		mov	ecx, [ebp+new]
		mov	eax, dword ptr [ebp+repeat_count]
		mov	edx, dword ptr [ebp+repeat_count+4]
		mov	[ecx+0Ch], eax
		mov	[ecx+10h], edx
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8000CAF
		push	offset __PRETTY_FUNCTION___5338	; "append_repeated_char"
		push	2DBh		; line
		push	offset file	; "tr.c"
		push	offset assertion ; "list->tail"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000CAF:				; CODE XREF: append_repeated_char+5Cj
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		nop
		leave
		retn
append_repeated_char endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	append_equiv_class(Spec_list *list, const char *equiv_class_str, size_t	len)
append_equiv_class proc	near		; CODE XREF: build_spec_list+1E8p

new		= dword	ptr -0Ch
list		= dword	ptr  8
equiv_class_str	= dword	ptr  0Ch
len		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		cmp	[ebp+len], 1
		jz	short loc_8000CDA
		mov	eax, 0
		jmp	short locret_8000D48
; ---------------------------------------------------------------------------

loc_8000CDA:				; CODE XREF: append_equiv_class+Aj
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+new]
		mov	dword ptr [eax+4], 0
		mov	eax, [ebp+new]
		mov	dword ptr [eax], 3
		mov	eax, [ebp+equiv_class_str]
		movzx	eax, byte ptr [eax]
		mov	edx, eax
		mov	eax, [ebp+new]
		mov	[eax+8], dl
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		test	eax, eax
		jnz	short loc_8000D2E
		push	offset __PRETTY_FUNCTION___5345	; "append_equiv_class"
		push	2F2h		; line
		push	offset file	; "tr.c"
		push	offset assertion ; "list->tail"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000D2E:				; CODE XREF: append_equiv_class+4Cj
		mov	eax, [ebp+list]
		mov	eax, [eax+4]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, 1

locret_8000D48:				; CODE XREF: append_equiv_class+11j
		leave
		retn
append_equiv_class endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	find_closing_delim(const E_string *es_0, size_t	start_idx, char	pre_bracket_char, size_t *result_idx)
find_closing_delim proc	near		; CODE XREF: build_spec_list+A2p

pre_bracket_char= byte ptr -14h
i		= dword	ptr -4
es_0		= dword	ptr  8
start_idx	= dword	ptr  0Ch
arg_8		= dword	ptr  10h
result_idx	= dword	ptr  14h

		push	ebp
		mov	ebp, esp
		sub	esp, 14h
		mov	eax, [ebp+arg_8]
		mov	[ebp+pre_bracket_char],	al
		mov	eax, [ebp+start_idx]
		mov	[ebp+i], eax
		jmp	short loc_8000DC4
; ---------------------------------------------------------------------------

loc_8000D5E:				; CODE XREF: find_closing_delim+86j
		mov	eax, [ebp+es_0]
		mov	edx, [eax]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, [ebp+pre_bracket_char]
		jnz	short loc_8000DC0
		mov	eax, [ebp+es_0]
		mov	eax, [eax]
		mov	edx, [ebp+i]
		add	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 5Dh
		jnz	short loc_8000DC0
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8000DC0
		mov	eax, [ebp+es_0]
		mov	eax, [eax+4]
		mov	edx, [ebp+i]
		add	edx, 1
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8000DC0
		mov	eax, [ebp+result_idx]
		mov	edx, [ebp+i]
		mov	[eax], edx
		mov	eax, 1
		jmp	short locret_8000DD7
; ---------------------------------------------------------------------------

loc_8000DC0:				; CODE XREF: find_closing_delim+24j
					; find_closing_delim+38j ...
		add	[ebp+i], 1

loc_8000DC4:				; CODE XREF: find_closing_delim+12j
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		sub	eax, 1
		cmp	eax, [ebp+i]
		ja	short loc_8000D5E
		mov	eax, 0

locret_8000DD7:				; CODE XREF: find_closing_delim+74j
		leave
		retn
find_closing_delim endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl find_bracketed_repeat(const E_string *es_0, size_t start_idx, unsigned __int8 *char_to_repeat, count *repeat_count, size_t *closing_bracket_idx)
find_bracketed_repeat proc near		; CODE XREF: build_spec_list+287p

closing_bracket_idx= dword ptr -38h
repeat_count	= dword	ptr -34h
char_to_repeat	= dword	ptr -30h
es_0		= dword	ptr -2Ch
d_end		= dword	ptr -20h
i		= dword	ptr -1Ch
digit_str_len	= dword	ptr -18h
digit_str	= dword	ptr -14h
tmp		= dword	ptr -10h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
start_idx	= dword	ptr  0Ch
arg_8		= dword	ptr  10h
arg_C		= dword	ptr  14h
arg_10		= dword	ptr  18h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 34h
		mov	eax, [ebp+arg_0]
		mov	[ebp+es_0], eax
		mov	eax, [ebp+arg_8]
		mov	[ebp+char_to_repeat], eax
		mov	eax, [ebp+arg_C]
		mov	[ebp+repeat_count], eax
		mov	eax, [ebp+arg_10]
		mov	[ebp+closing_bracket_idx], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+start_idx]
		lea	edx, [eax+1]
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		cmp	edx, eax
		jb	short loc_8000E2C
		push	offset __PRETTY_FUNCTION___5364	; "find_bracketed_repeat"
		push	31Fh		; line
		push	offset file	; "tr.c"
		push	offset aStart_idx1EsLe ; "start_idx + 1	< es->len"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8000E2C:				; CODE XREF: find_bracketed_repeat+38j
		mov	eax, [ebp+start_idx]
		add	eax, 1
		sub	esp, 4
		push	2Ah		; c
		push	eax		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8000E54
		mov	eax, 0FFFFFFFFh
		jmp	loc_8000FAC
; ---------------------------------------------------------------------------

loc_8000E54:				; CODE XREF: find_bracketed_repeat+6Fj
		mov	eax, [ebp+start_idx]
		add	eax, 2
		mov	[ebp+i], eax
		jmp	loc_8000F83
; ---------------------------------------------------------------------------

loc_8000E62:				; CODE XREF: find_bracketed_repeat+1C8j
		mov	eax, [ebp+es_0]
		mov	edx, [eax]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 5Dh
		jnz	loc_8000F7F
		mov	eax, [ebp+i]
		sub	eax, [ebp+start_idx]
		sub	eax, 2
		mov	[ebp+digit_str_len], eax
		mov	eax, [ebp+es_0]
		mov	edx, [eax]
		mov	eax, [ebp+start_idx]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		mov	edx, eax
		mov	eax, [ebp+char_to_repeat]
		mov	[eax], dl
		cmp	[ebp+digit_str_len], 0
		jnz	short loc_8000EB2
		mov	eax, [ebp+repeat_count]
		mov	dword ptr [eax], 0
		mov	dword ptr [eax+4], 0
		jmp	loc_8000F70
; ---------------------------------------------------------------------------

loc_8000EB2:				; CODE XREF: find_bracketed_repeat+C2j
		mov	eax, [ebp+es_0]
		mov	eax, [eax]
		mov	edx, [ebp+start_idx]
		add	edx, 2
		add	eax, edx
		mov	[ebp+digit_str], eax
		mov	eax, [ebp+digit_str]
		movzx	eax, byte ptr [eax]
		cmp	al, 30h
		jnz	short loc_8000ED3
		mov	eax, 8
		jmp	short loc_8000ED8
; ---------------------------------------------------------------------------

loc_8000ED3:				; CODE XREF: find_bracketed_repeat+F1j
		mov	eax, 0Ah

loc_8000ED8:				; CODE XREF: find_bracketed_repeat+F8j
		sub	esp, 0Ch
		push	0
		push	[ebp+repeat_count]
		push	eax
		lea	eax, [ebp+d_end]
		push	eax
		push	[ebp+digit_str]
		call	xstrtoumax
		add	esp, 20h
		test	eax, eax
		jnz	short loc_8000F19
		mov	eax, [ebp+repeat_count]
		mov	edx, [eax+4]
		mov	eax, [eax]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jz	short loc_8000F19
		mov	edx, [ebp+digit_str]
		mov	eax, [ebp+digit_str_len]
		add	edx, eax
		mov	eax, [ebp+d_end]
		cmp	edx, eax
		jz	short loc_8000F70

loc_8000F19:				; CODE XREF: find_bracketed_repeat+119j
					; find_bracketed_repeat+12Fj
		sub	esp, 8
		push	[ebp+digit_str_len] ; len
		push	[ebp+digit_str]	; s
		call	make_printable_str
		add	esp, 10h
		mov	[ebp+tmp], eax
		sub	esp, 0Ch
		push	[ebp+tmp]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidRepeatC ; "invalid repeat count %s in [c*n] constr"...
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tmp]	; ptr
		call	free
		add	esp, 10h
		mov	eax, 0FFFFFFFEh
		jmp	short loc_8000FAC
; ---------------------------------------------------------------------------

loc_8000F70:				; CODE XREF: find_bracketed_repeat+D4j
					; find_bracketed_repeat+13Ej
		mov	eax, [ebp+closing_bracket_idx]
		mov	edx, [ebp+i]
		mov	[eax], edx
		mov	eax, 0
		jmp	short loc_8000FAC
; ---------------------------------------------------------------------------

loc_8000F7F:				; CODE XREF: find_bracketed_repeat+98j
		add	[ebp+i], 1

loc_8000F83:				; CODE XREF: find_bracketed_repeat+84j
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		cmp	eax, [ebp+i]
		jbe	short loc_8000FA7
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jnz	loc_8000E62

loc_8000FA7:				; CODE XREF: find_bracketed_repeat+1B3j
		mov	eax, 0FFFFFFFFh

loc_8000FAC:				; CODE XREF: find_bracketed_repeat+76j
					; find_bracketed_repeat+195j ...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8000FBD
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8000FBD:				; CODE XREF: find_bracketed_repeat+1DDj
		mov	ebx, [ebp+var_4]
		leave
		retn
find_bracketed_repeat endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	star_digits_closebracket(const E_string	*es_0, size_t idx)
star_digits_closebracket proc near	; CODE XREF: build_spec_list+172p
					; build_spec_list+204p

i		= dword	ptr -4
es_0		= dword	ptr  8
idx		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 10h
		push	2Ah		; c
		push	[ebp+idx]	; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 0Ch
		xor	eax, 1
		test	al, al
		jz	short loc_8000FE6
		mov	eax, 0
		jmp	short locret_800104D
; ---------------------------------------------------------------------------

loc_8000FE6:				; CODE XREF: star_digits_closebracket+1Bj
		mov	eax, [ebp+idx]
		add	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_800103D
; ---------------------------------------------------------------------------

loc_8000FF1:				; CODE XREF: star_digits_closebracket+84j
		mov	eax, [ebp+es_0]
		mov	edx, [eax]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		push	eax		; ch_0
		call	to_uchar
		add	esp, 4
		movzx	eax, al
		sub	eax, 30h
		cmp	eax, 9
		ja	short loc_8001027
		mov	eax, [ebp+es_0]
		mov	edx, [eax+4]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		test	al, al
		jz	short loc_8001039

loc_8001027:				; CODE XREF: star_digits_closebracket+51j
		push	5Dh		; c
		push	[ebp+i]		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 0Ch
		jmp	short locret_800104D
; ---------------------------------------------------------------------------

loc_8001039:				; CODE XREF: star_digits_closebracket+63j
		add	[ebp+i], 1

loc_800103D:				; CODE XREF: star_digits_closebracket+2Dj
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		cmp	eax, [ebp+i]
		ja	short loc_8000FF1
		mov	eax, 0

locret_800104D:				; CODE XREF: star_digits_closebracket+22j
					; star_digits_closebracket+75j
		leave
		retn
star_digits_closebracket endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	build_spec_list(const E_string *es_0, Spec_list	*result)
build_spec_list	proc near		; CODE XREF: parse_str+3Dp

result		= dword	ptr -50h
es_0		= dword	ptr -4Ch
char_to_repeat	= byte ptr -3Ah
matched_multi_char_construct= byte ptr -39h
closing_bracket_idx= dword ptr -38h
i		= dword	ptr -34h
p		= dword	ptr -30h
err		= dword	ptr -2Ch
opnd_str_len	= dword	ptr -28h
opnd_str	= dword	ptr -24h
tmp		= dword	ptr -20h
tmp_0		= dword	ptr -1Ch
closing_delim_idx= dword ptr -18h
var_14		= dword	ptr -14h
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 54h
		mov	eax, [ebp+arg_0]
		mov	[ebp+es_0], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+result], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	eax, [ebp+es_0]
		mov	eax, [eax]
		mov	[ebp+p], eax
		mov	[ebp+i], 0
		jmp	loc_80013AB
; ---------------------------------------------------------------------------

loc_8001081:				; CODE XREF: build_spec_list+36Aj
		push	5Bh		; c
		push	[ebp+i]		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 0Ch
		test	al, al
		jz	loc_800132C
		mov	[ebp+matched_multi_char_construct], 1
		mov	eax, [ebp+i]
		add	eax, 1
		push	3Ah		; c
		push	eax		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 0Ch
		test	al, al
		jnz	short loc_80010D1
		mov	eax, [ebp+i]
		add	eax, 1
		push	3Dh		; c
		push	eax		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 0Ch
		test	al, al
		jz	try_bracketed_repeat

loc_80010D1:				; CODE XREF: build_spec_list+64j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+p]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	edx, [ebp+i]
		lea	ecx, [edx+2]
		lea	edx, [ebp+closing_delim_idx]
		push	edx		; result_idx
		push	eax		; pre_bracket_char
		push	ecx		; start_idx
		push	[ebp+es_0]	; es_0
		call	find_closing_delim
		add	esp, 10h
		test	al, al
		jz	try_bracketed_repeat
		mov	eax, [ebp+closing_delim_idx]
		sub	eax, [ebp+i]
		sub	eax, 2
		mov	[ebp+opnd_str_len], eax
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+p]
		add	eax, edx
		mov	[ebp+opnd_str],	eax
		cmp	[ebp+opnd_str_len], 0
		jnz	short loc_800117F
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+p]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 3Ah
		jnz	short loc_8001155
		sub	esp, 0Ch
		push	offset aMissingCharact ; "missing character class name `[::]'"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	short loc_8001175
; ---------------------------------------------------------------------------

loc_8001155:				; CODE XREF: build_spec_list+E2j
		sub	esp, 0Ch
		push	offset aMissingEquival ; "missing equivalence class character `[="...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h

loc_8001175:				; CODE XREF: build_spec_list+104j
		mov	eax, 0
		jmp	loc_80013F2
; ---------------------------------------------------------------------------

loc_800117F:				; CODE XREF: build_spec_list+D0j
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		mov	eax, [ebp+p]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		cmp	al, 3Ah
		jnz	loc_800122B
		sub	esp, 4
		push	[ebp+opnd_str_len] ; len
		push	[ebp+opnd_str]	; char_class_str
		push	[ebp+result]	; list
		call	append_char_class
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	loc_80012AB
		mov	eax, [ebp+i]
		add	eax, 2
		sub	esp, 8
		push	eax		; idx
		push	[ebp+es_0]	; es_0
		call	star_digits_closebracket
		add	esp, 10h
		test	al, al
		jnz	loc_80012B9
		sub	esp, 8
		push	[ebp+opnd_str_len] ; len
		push	[ebp+opnd_str]	; s
		call	make_printable_str
		add	esp, 10h
		mov	[ebp+tmp], eax
		sub	esp, 0Ch
		push	[ebp+tmp]
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aInvalidCharact ; "invalid character class %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tmp]	; ptr
		call	free
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80013F2
; ---------------------------------------------------------------------------

loc_800122B:				; CODE XREF: build_spec_list+140j
		sub	esp, 4
		push	[ebp+opnd_str_len] ; len
		push	[ebp+opnd_str]	; equiv_class_str
		push	[ebp+result]	; list
		call	append_equiv_class
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80012AB
		mov	eax, [ebp+i]
		add	eax, 2
		sub	esp, 8
		push	eax		; idx
		push	[ebp+es_0]	; es_0
		call	star_digits_closebracket
		add	esp, 10h
		test	al, al
		jnz	short loc_80012BC
		sub	esp, 8
		push	[ebp+opnd_str_len] ; len
		push	[ebp+opnd_str]	; s
		call	make_printable_str
		add	esp, 10h
		mov	[ebp+tmp_0], eax
		sub	esp, 0Ch
		push	offset aSEquivalenceCl ; "%s: equivalence class	operand	must be	a"...
		call	gettext
		add	esp, 10h
		push	[ebp+tmp_0]
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+tmp_0]	; ptr
		call	free
		add	esp, 10h
		mov	eax, 0
		jmp	loc_80013F2
; ---------------------------------------------------------------------------

loc_80012AB:				; CODE XREF: build_spec_list+15Fj
					; build_spec_list+1F5j
		mov	eax, [ebp+closing_delim_idx]
		add	eax, 2
		mov	[ebp+i], eax
		jmp	loc_80013AB
; ---------------------------------------------------------------------------

loc_80012B9:				; CODE XREF: build_spec_list+17Cj
		nop
		jmp	short try_bracketed_repeat
; ---------------------------------------------------------------------------

loc_80012BC:				; CODE XREF: build_spec_list+20Ej
		nop

try_bracketed_repeat:			; CODE XREF: build_spec_list+7Cj
					; build_spec_list+ACj ...
		mov	eax, [ebp+i]
		lea	edx, [eax+1]
		sub	esp, 0Ch
		lea	eax, [ebp+closing_bracket_idx]
		push	eax		; closing_bracket_idx
		lea	eax, [ebp+closing_delim_idx]
		push	eax		; repeat_count
		lea	eax, [ebp+char_to_repeat]
		push	eax		; char_to_repeat
		push	edx		; start_idx
		push	[ebp+es_0]	; es_0
		call	find_bracketed_repeat
		add	esp, 20h
		mov	[ebp+err], eax
		cmp	[ebp+err], 0
		jnz	short loc_800130D
		mov	eax, [ebp+closing_delim_idx]
		mov	edx, [ebp+var_14]
		movzx	ecx, [ebp+char_to_repeat]
		movzx	ecx, cl
		push	edx
		push	eax		; repeat_count
		push	ecx		; the_char
		push	[ebp+result]	; list
		call	append_repeated_char
		add	esp, 10h
		mov	eax, [ebp+closing_bracket_idx]
		add	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_8001323
; ---------------------------------------------------------------------------

loc_800130D:				; CODE XREF: build_spec_list+296j
		cmp	[ebp+err], 0FFFFFFFFh
		jnz	short loc_8001319
		mov	[ebp+matched_multi_char_construct], 0
		jmp	short loc_8001323
; ---------------------------------------------------------------------------

loc_8001319:				; CODE XREF: build_spec_list+2C2j
		mov	eax, 0
		jmp	loc_80013F2
; ---------------------------------------------------------------------------

loc_8001323:				; CODE XREF: build_spec_list+2BCj
					; build_spec_list+2C8j
		cmp	[ebp+matched_multi_char_construct], 0
		jz	short loc_800132C
		nop
		jmp	short loc_80013AB
; ---------------------------------------------------------------------------

loc_800132C:				; CODE XREF: build_spec_list+44j
					; build_spec_list+2D8j
		mov	eax, [ebp+i]
		add	eax, 1
		sub	esp, 4
		push	2Dh		; c
		push	eax		; i
		push	[ebp+es_0]	; es_0
		call	es_match
		add	esp, 10h
		test	al, al
		jz	short loc_800138A
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+p]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	edx, al
		mov	ecx, [ebp+p]
		mov	eax, [ebp+i]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 4
		push	edx		; last
		push	eax		; first
		push	[ebp+result]	; list
		call	append_range
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001384
		mov	eax, 0
		jmp	short loc_80013F2
; ---------------------------------------------------------------------------

loc_8001384:				; CODE XREF: build_spec_list+32Cj
		add	[ebp+i], 3
		jmp	short loc_80013AB
; ---------------------------------------------------------------------------

loc_800138A:				; CODE XREF: build_spec_list+2F6j
		mov	edx, [ebp+p]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 8
		push	eax		; c
		push	[ebp+result]	; list
		call	append_normal_char
		add	esp, 10h
		add	[ebp+i], 1

loc_80013AB:				; CODE XREF: build_spec_list+2Dj
					; build_spec_list+265j	...
		mov	eax, [ebp+i]
		lea	edx, [eax+2]
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		cmp	edx, eax
		jb	loc_8001081
		jmp	short loc_80013E2
; ---------------------------------------------------------------------------

loc_80013C1:				; CODE XREF: build_spec_list+39Cj
		mov	edx, [ebp+p]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		sub	esp, 8
		push	eax		; c
		push	[ebp+result]	; list
		call	append_normal_char
		add	esp, 10h
		add	[ebp+i], 1

loc_80013E2:				; CODE XREF: build_spec_list+370j
		mov	eax, [ebp+es_0]
		mov	eax, [eax+8]
		cmp	eax, [ebp+i]
		ja	short loc_80013C1
		mov	eax, 1

loc_80013F2:				; CODE XREF: build_spec_list+12Bj
					; build_spec_list+1D7j	...
		mov	ebx, [ebp+var_C]
		xor	ebx, large gs:14h
		jz	short loc_8001403
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_8001403:				; CODE XREF: build_spec_list+3ADj
		mov	ebx, [ebp+var_4]
		leave
		retn
build_spec_list	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl skip_construct(Spec_list	*s)
skip_construct	proc near		; CODE XREF: main+6D1p	main+6E2p

s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		mov	eax, [ebp+s]
		mov	eax, [eax+4]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		nop
		pop	ebp
		retn
skip_construct	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl get_next(Spec_list *s, Upper_Lower_class *class)
get_next	proc near		; CODE XREF: get_next+31Fp
					; card_of_complement+8Bp ...

var_19		= byte ptr -19h
return_val	= dword	ptr -14h
i		= dword	ptr -10h
p		= dword	ptr -0Ch
s		= dword	ptr  8
class		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 20h
		cmp	[ebp+class], 0
		jz	short loc_8001445
		mov	eax, [ebp+class]
		mov	dword ptr [eax], 2

loc_8001445:				; CODE XREF: get_next+Cj
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFEh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_800147B
		mov	eax, [ebp+s]
		mov	eax, [eax]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh

loc_800147B:				; CODE XREF: get_next+2Cj
		mov	eax, [ebp+s]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		cmp	[ebp+p], 0
		jnz	short loc_8001494
		mov	eax, 0FFFFFFFFh
		jmp	loc_80017F3
; ---------------------------------------------------------------------------

loc_8001494:				; CODE XREF: get_next+5Aj
		mov	eax, [ebp+p]
		mov	eax, [eax]
		cmp	eax, 4		; switch 5 cases
		ja	loc_80017E7	; jumptable 080014A9 default case
		mov	eax, ds:off_8005F7C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_80014AB:				; CODE XREF: get_next+7Bj
					; DATA XREF: .rodata:off_8005F7Co
		mov	eax, [ebp+p]	; jumptable 080014A9 case 0
		movzx	eax, byte ptr [eax+8]
		movzx	eax, al
		mov	[ebp+return_val], eax
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		jmp	loc_80017F0
; ---------------------------------------------------------------------------

loc_80014DA:				; CODE XREF: get_next+7Bj
					; DATA XREF: .rodata:off_8005F7Co
		mov	eax, [ebp+s]	; jumptable 080014A9 case 1
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_800150B
		mov	eax, [ebp+p]
		movzx	ecx, byte ptr [eax+8]
		movzx	eax, cl
		mov	edx, 0
		mov	ecx, [ebp+s]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		jmp	short loc_8001523
; ---------------------------------------------------------------------------

loc_800150B:				; CODE XREF: get_next+C1j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		add	eax, 1
		adc	edx, 0
		mov	ecx, [ebp+s]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx

loc_8001523:				; CODE XREF: get_next+DBj
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	[ebp+return_val], eax
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, [ebp+p]
		movzx	ebx, byte ptr [ecx+9]
		mov	[ebp+var_19], bl
		movzx	ecx, [ebp+var_19]
		mov	ebx, 0
		mov	esi, edx
		xor	esi, ebx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	loc_80017EC
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		jmp	loc_80017EC
; ---------------------------------------------------------------------------

loc_800157D:				; CODE XREF: get_next+7Bj
					; DATA XREF: .rodata:off_8005F7Co
		cmp	[ebp+class], 0	; jumptable 080014A9 case 2
		jz	short loc_80015AA
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 6
		jz	short loc_8001595
		cmp	eax, 0Ah
		jz	short loc_80015A0
		jmp	short loc_80015AA
; ---------------------------------------------------------------------------

loc_8001595:				; CODE XREF: get_next+15Ej
		mov	eax, [ebp+class]
		mov	dword ptr [eax], 0
		jmp	short loc_80015AA
; ---------------------------------------------------------------------------

loc_80015A0:				; CODE XREF: get_next+163j
		mov	eax, [ebp+class]
		mov	dword ptr [eax], 1
		nop

loc_80015AA:				; CODE XREF: get_next+153j
					; get_next+165j ...
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001626
		mov	[ebp+i], 0
		jmp	short loc_80015EB
; ---------------------------------------------------------------------------

loc_80015CA:				; CODE XREF: get_next+1C4j
		mov	eax, [ebp+i]
		movzx	edx, al
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 8
		push	edx		; c
		push	eax		; char_class
		call	is_char_class_member
		add	esp, 10h
		test	al, al
		jnz	short loc_80015F6
		add	[ebp+i], 1

loc_80015EB:				; CODE XREF: get_next+19Aj
		cmp	[ebp+i], 0FFh
		jle	short loc_80015CA
		jmp	short loc_80015F7
; ---------------------------------------------------------------------------

loc_80015F6:				; CODE XREF: get_next+1B7j
		nop

loc_80015F7:				; CODE XREF: get_next+1C6j
		cmp	[ebp+i], 0FFh
		jle	short loc_8001619
		push	offset __PRETTY_FUNCTION___5424	; "get_next"
		push	44Ah		; line
		push	offset file	; "tr.c"
		push	offset aIN_chars ; "i <	N_CHARS"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001619:				; CODE XREF: get_next+1D0j
		mov	eax, [ebp+i]
		cdq
		mov	ecx, [ebp+s]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx

loc_8001626:				; CODE XREF: get_next+191j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		movzx	edx, al
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 8
		push	edx		; c
		push	eax		; char_class
		call	is_char_class_member
		add	esp, 10h
		test	al, al
		jnz	short loc_8001662
		push	offset __PRETTY_FUNCTION___5424	; "get_next"
		push	44Dh		; line
		push	offset file	; "tr.c"
		push	offset aIs_char_class_ ; "is_char_class_member (p->u.char_class, "...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001662:				; CODE XREF: get_next+219j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	[ebp+return_val], eax
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		add	eax, 1
		mov	[ebp+i], eax
		jmp	short loc_80016A0
; ---------------------------------------------------------------------------

loc_800167F:				; CODE XREF: get_next+279j
		mov	eax, [ebp+i]
		movzx	edx, al
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 8
		push	edx		; c
		push	eax		; char_class
		call	is_char_class_member
		add	esp, 10h
		test	al, al
		jnz	short loc_80016AB
		add	[ebp+i], 1

loc_80016A0:				; CODE XREF: get_next+24Fj
		cmp	[ebp+i], 0FFh
		jle	short loc_800167F
		jmp	short loc_80016AC
; ---------------------------------------------------------------------------

loc_80016AB:				; CODE XREF: get_next+26Cj
		nop

loc_80016AC:				; CODE XREF: get_next+27Bj
		cmp	[ebp+i], 0FFh
		jg	short loc_80016C7
		mov	eax, [ebp+i]
		cdq
		mov	ecx, [ebp+s]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		jmp	loc_80017F0
; ---------------------------------------------------------------------------

loc_80016C7:				; CODE XREF: get_next+285j
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		jmp	loc_80017F0
; ---------------------------------------------------------------------------

loc_80016E9:				; CODE XREF: get_next+7Bj
					; DATA XREF: .rodata:off_8005F7Co
		mov	eax, [ebp+p]	; jumptable 080014A9 case 3
		movzx	eax, byte ptr [eax+8]
		movzx	eax, al
		mov	[ebp+return_val], eax
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		jmp	loc_80017F0
; ---------------------------------------------------------------------------

loc_8001718:				; CODE XREF: get_next+7Bj
					; DATA XREF: .rodata:off_8005F7Co
		mov	eax, [ebp+p]	; jumptable 080014A9 case 4
		mov	edx, [eax+10h]
		mov	eax, [eax+0Ch]
		or	eax, edx
		test	eax, eax
		jnz	short loc_800175D
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		sub	esp, 8
		push	[ebp+class]	; class
		push	[ebp+s]		; s
		call	get_next
		add	esp, 10h
		mov	[ebp+return_val], eax
		jmp	loc_80017EF
; ---------------------------------------------------------------------------

loc_800175D:				; CODE XREF: get_next+2F7j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		mov	ecx, edx
		xor	ecx, 0FFFFFFFFh
		xor	eax, 0FFFFFFFFh
		or	eax, ecx
		test	eax, eax
		jnz	short loc_8001785
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0
		mov	dword ptr [eax+0Ch], 0

loc_8001785:				; CODE XREF: get_next+344j
		mov	eax, [ebp+s]
		mov	edx, [eax+0Ch]
		mov	eax, [eax+8]
		add	eax, 1
		adc	edx, 0
		mov	ecx, [ebp+s]
		mov	[ecx+8], eax
		mov	[ecx+0Ch], edx
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+8]
		movzx	eax, al
		mov	[ebp+return_val], eax
		mov	eax, [ebp+s]
		mov	ecx, [eax+8]
		mov	ebx, [eax+0Ch]
		mov	eax, [ebp+p]
		mov	edx, [eax+10h]
		mov	eax, [eax+0Ch]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_80017EF
		mov	eax, [ebp+p]
		mov	edx, [eax+4]
		mov	eax, [ebp+s]
		mov	[eax+4], edx
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFFh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		jmp	short loc_80017EF
; ---------------------------------------------------------------------------

loc_80017E7:				; CODE XREF: get_next+6Ej
		call	abort		; jumptable 080014A9 default case
; ---------------------------------------------------------------------------

loc_80017EC:				; CODE XREF: get_next+127j
					; get_next+14Aj
		nop
		jmp	short loc_80017F0
; ---------------------------------------------------------------------------

loc_80017EF:				; CODE XREF: get_next+32Aj
					; get_next+398j ...
		nop

loc_80017F0:				; CODE XREF: get_next+A7j
					; get_next+294j ...
		mov	eax, [ebp+return_val]

loc_80017F3:				; CODE XREF: get_next+61j
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
get_next	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; int __cdecl card_of_complement(Spec_list *s)
card_of_complement proc	near		; CODE XREF: get_s1_spec_stats+25p

s		= dword	ptr -11Ch
cardinality	= dword	ptr -114h
c		= dword	ptr -110h
in_set		= byte ptr -10Ch
var_C		= dword	ptr -0Ch
var_4		= dword	ptr -4
arg_0		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	edi
		sub	esp, 124h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		mov	[ebp+cardinality], 100h
		lea	edx, [ebp+in_set]
		mov	eax, 0
		mov	ecx, 40h
		mov	edi, edx
		rep stosd
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		jmp	short loc_800187A
; ---------------------------------------------------------------------------

loc_800184C:				; CODE XREF: card_of_complement+A0j
		lea	edx, [ebp+in_set]
		mov	eax, [ebp+c]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		movzx	eax, al
		sub	[ebp+cardinality], eax
		lea	edx, [ebp+in_set]
		mov	eax, [ebp+c]
		add	eax, edx
		mov	byte ptr [eax],	1

loc_800187A:				; CODE XREF: card_of_complement+50j
		sub	esp, 8
		push	0		; class
		push	[ebp+s]		; s
		call	get_next
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_800184C
		mov	eax, [ebp+cardinality]
		mov	ecx, [ebp+var_C]
		xor	ecx, large gs:14h
		jz	short loc_80018B3
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

loc_80018B3:				; CODE XREF: card_of_complement+B2j
		mov	edi, [ebp+var_4]
		leave
		retn
card_of_complement endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl get_spec_stats(Spec_list	*s)
get_spec_stats	proc near		; CODE XREF: get_s1_spec_stats+Cp
					; get_s2_spec_stats+1Ap

p		= dword	ptr -28h
i		= dword	ptr -24h
length		= qword	ptr -20h
len		= qword	ptr -18h
new_length	= qword	ptr -10h
var_4		= dword	ptr -4
s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	dword ptr [ebp+length],	0
		mov	dword ptr [ebp+length+4], 0
		mov	eax, [ebp+s]
		mov	dword ptr [eax+18h], 0
		mov	eax, [ebp+s]
		mov	byte ptr [eax+20h], 0
		mov	eax, [ebp+s]
		mov	byte ptr [eax+22h], 0
		mov	eax, [ebp+s]
		mov	byte ptr [eax+21h], 0
		mov	eax, [ebp+s]
		mov	eax, [eax]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		jmp	loc_8001AE2
; ---------------------------------------------------------------------------

loc_80018FC:				; CODE XREF: get_spec_stats+22Ej
		mov	dword ptr [ebp+len], 0
		mov	dword ptr [ebp+len+4], 0
		mov	eax, [ebp+p]
		mov	eax, [eax]
		cmp	eax, 4		; switch 5 cases
		ja	loc_8001A69	; jumptable 0800191F default case
		mov	eax, ds:off_8005FDC[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001921:				; CODE XREF: get_spec_stats+67j
					; DATA XREF: .rodata:off_8005FDCo
		mov	dword ptr [ebp+len], 1 ; jumptable 0800191F case 0
		mov	dword ptr [ebp+len+4], 0
		jmp	loc_8001A6E
; ---------------------------------------------------------------------------

loc_8001934:				; CODE XREF: get_spec_stats+67j
					; DATA XREF: .rodata:off_8005FDCo
		mov	eax, [ebp+p]	; jumptable 0800191F case 1
		movzx	edx, byte ptr [eax+9]
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+8]
		cmp	dl, al
		jnb	short loc_800195F
		push	offset __PRETTY_FUNCTION___5451	; "get_spec_stats"
		push	4BFh		; line
		push	offset file	; "tr.c"
		push	offset aPU_range_last_ ; "p->u.range.last_char >= p->u.range.firs"...
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_800195F:				; CODE XREF: get_spec_stats+8Cj
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+9]
		movzx	edx, al
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+8]
		movzx	eax, al
		sub	edx, eax
		mov	eax, edx
		add	eax, 1
		cdq
		mov	dword ptr [ebp+len], eax
		mov	dword ptr [ebp+len+4], edx
		jmp	loc_8001A6E
; ---------------------------------------------------------------------------

loc_8001986:				; CODE XREF: get_spec_stats+67j
					; DATA XREF: .rodata:off_8005FDCo
		mov	eax, [ebp+s]	; jumptable 0800191F case 2
		mov	byte ptr [eax+21h], 1
		mov	[ebp+i], 0
		jmp	short loc_80019BF
; ---------------------------------------------------------------------------

loc_8001996:				; CODE XREF: get_spec_stats+10Ej
		mov	eax, [ebp+i]
		movzx	edx, al
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 8
		push	edx		; c
		push	eax		; char_class
		call	is_char_class_member
		add	esp, 10h
		test	al, al
		jz	short loc_80019BB
		add	dword ptr [ebp+len], 1
		adc	dword ptr [ebp+len+4], 0

loc_80019BB:				; CODE XREF: get_spec_stats+F9j
		add	[ebp+i], 1

loc_80019BF:				; CODE XREF: get_spec_stats+DCj
		cmp	[ebp+i], 0FFh
		jle	short loc_8001996
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		cmp	eax, 6
		jz	short loc_80019E1
		cmp	eax, 0Ah
		jz	short loc_80019E1
		mov	eax, [ebp+s]
		mov	byte ptr [eax+22h], 1
		jmp	short loc_80019E2
; ---------------------------------------------------------------------------

loc_80019E1:				; CODE XREF: get_spec_stats+119j
					; get_spec_stats+11Ej
		nop

loc_80019E2:				; CODE XREF: get_spec_stats+127j
		jmp	loc_8001A6E
; ---------------------------------------------------------------------------

loc_80019E7:				; CODE XREF: get_spec_stats+67j
					; DATA XREF: .rodata:off_8005FDCo
		mov	[ebp+i], 0	; jumptable 0800191F case 3
		jmp	short loc_8001A1D
; ---------------------------------------------------------------------------

loc_80019F0:				; CODE XREF: get_spec_stats+16Cj
		mov	eax, [ebp+i]
		movzx	edx, al
		mov	eax, [ebp+p]
		movzx	eax, byte ptr [eax+8]
		movzx	eax, al
		sub	esp, 8
		push	edx		; c
		push	eax		; equiv_class
		call	is_equiv_class_member
		add	esp, 10h
		test	al, al
		jz	short loc_8001A19
		add	dword ptr [ebp+len], 1
		adc	dword ptr [ebp+len+4], 0

loc_8001A19:				; CODE XREF: get_spec_stats+157j
		add	[ebp+i], 1

loc_8001A1D:				; CODE XREF: get_spec_stats+136j
		cmp	[ebp+i], 0FFh
		jle	short loc_80019F0
		mov	eax, [ebp+s]
		mov	byte ptr [eax+20h], 1
		jmp	short loc_8001A6E
; ---------------------------------------------------------------------------

loc_8001A2F:				; CODE XREF: get_spec_stats+67j
					; DATA XREF: .rodata:off_8005FDCo
		mov	eax, [ebp+p]	; jumptable 0800191F case 4
		mov	edx, [eax+10h]
		mov	eax, [eax+0Ch]
		or	eax, edx
		test	eax, eax
		jz	short loc_8001A4F
		mov	eax, [ebp+p]
		mov	edx, [eax+10h]
		mov	eax, [eax+0Ch]
		mov	dword ptr [ebp+len], eax
		mov	dword ptr [ebp+len+4], edx
		jmp	short loc_8001A6E
; ---------------------------------------------------------------------------

loc_8001A4F:				; CODE XREF: get_spec_stats+184j
		mov	eax, [ebp+s]
		mov	edx, [ebp+p]
		mov	[eax+1Ch], edx
		mov	eax, [ebp+s]
		mov	eax, [eax+18h]
		lea	edx, [eax+1]
		mov	eax, [ebp+s]
		mov	[eax+18h], edx
		jmp	short loc_8001A6E
; ---------------------------------------------------------------------------

loc_8001A69:				; CODE XREF: get_spec_stats+5Aj
		call	abort		; jumptable 0800191F default case
; ---------------------------------------------------------------------------

loc_8001A6E:				; CODE XREF: get_spec_stats+77j
					; get_spec_stats+C9j ...
		mov	ecx, dword ptr [ebp+length]
		mov	ebx, dword ptr [ebp+length+4]
		mov	eax, dword ptr [ebp+len]
		mov	edx, dword ptr [ebp+len+4]
		add	eax, ecx
		adc	edx, ebx
		mov	dword ptr [ebp+new_length], eax
		mov	dword ptr [ebp+new_length+4], edx
		mov	eax, dword ptr [ebp+length]
		mov	edx, dword ptr [ebp+length+4]
		cmp	edx, dword ptr [ebp+new_length+4]
		ja	short loc_8001AAD
		cmp	edx, dword ptr [ebp+new_length+4]
		jb	short loc_8001A99
		cmp	eax, dword ptr [ebp+new_length]
		ja	short loc_8001AAD

loc_8001A99:				; CODE XREF: get_spec_stats+1DAj
		mov	eax, dword ptr [ebp+new_length+4]
		xor	eax, 0FFFFFFFFh
		mov	edx, eax
		mov	eax, dword ptr [ebp+new_length]
		xor	eax, 0FFFFFFFFh
		or	eax, edx
		test	eax, eax
		jnz	short loc_8001ACD

loc_8001AAD:				; CODE XREF: get_spec_stats+1D5j
					; get_spec_stats+1DFj
		sub	esp, 0Ch
		push	offset aTooManyCharact ; "too many characters in set"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001ACD:				; CODE XREF: get_spec_stats+1F3j
		mov	eax, dword ptr [ebp+new_length]
		mov	edx, dword ptr [ebp+new_length+4]
		mov	dword ptr [ebp+length],	eax
		mov	dword ptr [ebp+length+4], edx
		mov	eax, [ebp+p]
		mov	eax, [eax+4]
		mov	[ebp+p], eax

loc_8001AE2:				; CODE XREF: get_spec_stats+3Fj
		cmp	[ebp+p], 0
		jnz	loc_80018FC
		mov	ecx, [ebp+s]
		mov	eax, dword ptr [ebp+length]
		mov	edx, dword ptr [ebp+length+4]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
get_spec_stats	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl get_s1_spec_stats(Spec_list *s1)
get_s1_spec_stats proc near		; CODE XREF: validate+Bp

s1		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 8
		sub	esp, 0Ch
		push	[ebp+s1]	; s
		call	get_spec_stats
		add	esp, 10h
		movzx	eax, ds:complement
		test	al, al
		jz	short loc_8001B38
		sub	esp, 0Ch
		push	[ebp+s1]	; s
		call	card_of_complement
		add	esp, 10h
		cdq
		mov	ecx, [ebp+s1]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx

loc_8001B38:				; CODE XREF: get_s1_spec_stats+1Dj
		nop
		leave
		retn
get_s1_spec_stats endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl get_s2_spec_stats(Spec_list *s2,	count len_s1)
get_s2_spec_stats proc near		; CODE XREF: validate+58p

len_s1		= qword	ptr -10h
s2		= dword	ptr  8
arg_4		= dword	ptr  0Ch
arg_8		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 10h
		mov	eax, [ebp+arg_4]
		mov	dword ptr [ebp+len_s1],	eax
		mov	eax, [ebp+arg_8]
		mov	dword ptr [ebp+len_s1+4], eax
		sub	esp, 0Ch
		push	[ebp+s2]	; s
		call	get_spec_stats
		add	esp, 10h
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		cmp	edx, dword ptr [ebp+len_s1+4]
		ja	short loc_8001BB2
		cmp	edx, dword ptr [ebp+len_s1+4]
		jb	short loc_8001B75
		cmp	eax, dword ptr [ebp+len_s1]
		ja	short loc_8001BB2

loc_8001B75:				; CODE XREF: get_s2_spec_stats+33j
		mov	eax, [ebp+s2]
		mov	eax, [eax+18h]
		cmp	eax, 1
		jnz	short loc_8001BB2
		mov	eax, [ebp+s2]
		mov	esi, [eax+1Ch]
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	ecx, dword ptr [ebp+len_s1]
		mov	ebx, dword ptr [ebp+len_s1+4]
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		mov	[esi+0Ch], eax
		mov	[esi+10h], edx
		mov	ecx, [ebp+s2]
		mov	eax, dword ptr [ebp+len_s1]
		mov	edx, dword ptr [ebp+len_s1+4]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx

loc_8001BB2:				; CODE XREF: get_s2_spec_stats+2Ej
					; get_s2_spec_stats+38j ...
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
get_s2_spec_stats endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl spec_init(Spec_list *spec_list)
spec_init	proc near		; CODE XREF: main+336p	main+383p

new		= dword	ptr -0Ch
spec_list	= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		sub	esp, 0Ch
		push	14h		; size_t
		call	xmalloc
		add	esp, 10h
		mov	[ebp+new], eax
		mov	eax, [ebp+spec_list]
		mov	edx, [ebp+new]
		mov	[eax+4], edx
		mov	eax, [ebp+spec_list]
		mov	edx, [eax+4]
		mov	eax, [ebp+spec_list]
		mov	[eax], edx
		mov	eax, [ebp+spec_list]
		mov	eax, [eax]
		mov	dword ptr [eax+4], 0
		nop
		leave
		retn
spec_init	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	parse_str(const	char *s, Spec_list *spec_list)
parse_str	proc near		; CODE XREF: main+35Bp	main+3AEp

spec_list	= dword	ptr -30h
s		= dword	ptr -2Ch
ok		= byte ptr -19h
es_0		= E_string ptr -18h
var_C		= dword	ptr -0Ch
arg_0		= dword	ptr  8
arg_4		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 38h
		mov	eax, [ebp+arg_0]
		mov	[ebp+s], eax
		mov	eax, [ebp+arg_4]
		mov	[ebp+spec_list], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		sub	esp, 8
		lea	eax, [ebp+es_0]
		push	eax		; es_0
		push	[ebp+s]		; s
		call	unquote
		add	esp, 10h
		test	al, al
		jz	short loc_8001C43
		sub	esp, 8
		push	[ebp+spec_list]	; result
		lea	eax, [ebp+es_0]
		push	eax		; es_0
		call	build_spec_list
		add	esp, 10h
		test	al, al
		jz	short loc_8001C43
		mov	eax, 1
		jmp	short loc_8001C48
; ---------------------------------------------------------------------------

loc_8001C43:				; CODE XREF: parse_str+31j
					; parse_str+47j
		mov	eax, 0

loc_8001C48:				; CODE XREF: parse_str+4Ej
		mov	[ebp+ok], al
		and	[ebp+ok], 1
		sub	esp, 0Ch
		lea	eax, [ebp+es_0]
		push	eax		; es_0
		call	es_free
		add	esp, 10h
		movzx	eax, [ebp+ok]
		mov	edx, [ebp+var_C]
		xor	edx, large gs:14h
		jz	short locret_8001C73
		call	__stack_chk_fail
; ---------------------------------------------------------------------------

locret_8001C73:				; CODE XREF: parse_str+79j
		leave
		retn
parse_str	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl string2_extend(const Spec_list *s1, Spec_list *s2)
string2_extend	proc near		; CODE XREF: validate+129p

char_to_repeat	= byte ptr -11h
i		= dword	ptr -10h
p		= dword	ptr -0Ch
var_4		= dword	ptr -4
s1		= dword	ptr  8
s2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		movzx	eax, ds:translating
		test	al, al
		jnz	short loc_8001CA0
		push	offset __PRETTY_FUNCTION___5493	; "string2_extend"
		push	537h		; line
		push	offset file	; "tr.c"
		push	offset aTranslating ; "translating"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001CA0:				; CODE XREF: string2_extend+10j
		mov	eax, [ebp+s1]
		mov	ecx, [eax+10h]
		mov	ebx, [eax+14h]
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		cmp	ebx, edx
		ja	short loc_8001CD7
		cmp	ebx, edx
		jb	short loc_8001CBE
		cmp	ecx, eax
		ja	short loc_8001CD7

loc_8001CBE:				; CODE XREF: string2_extend+43j
		push	offset __PRETTY_FUNCTION___5493	; "string2_extend"
		push	538h		; line
		push	offset file	; "tr.c"
		push	offset aS1LengthS2Leng ; "s1->length > s2->length"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001CD7:				; CODE XREF: string2_extend+3Fj
					; string2_extend+47j
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		or	eax, edx
		test	eax, eax
		jnz	short loc_8001CFF
		push	offset __PRETTY_FUNCTION___5493	; "string2_extend"
		push	539h		; line
		push	offset file	; "tr.c"
		push	offset aS2Length0 ; "s2->length	> 0"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001CFF:				; CODE XREF: string2_extend+6Fj
		mov	eax, [ebp+s2]
		mov	eax, [eax+4]
		mov	[ebp+p], eax
		mov	eax, [ebp+p]
		mov	eax, [eax]
		cmp	eax, 4		; switch 5 cases
		ja	loc_8001DA2	; jumptable 08001D1D default case
		mov	eax, ds:off_800602C[eax*4]
		jmp	eax		; switch jump
; ---------------------------------------------------------------------------

loc_8001D1F:				; CODE XREF: string2_extend+A8j
					; DATA XREF: .rodata:off_800602Co
		mov	eax, [ebp+p]	; jumptable 08001D1D case 0
		movzx	eax, byte ptr [eax+8]
		mov	[ebp+char_to_repeat], al
		jmp	short loc_8001DA7
; ---------------------------------------------------------------------------

loc_8001D2B:				; CODE XREF: string2_extend+A8j
					; DATA XREF: .rodata:off_800602Co
		mov	eax, [ebp+p]	; jumptable 08001D1D case 1
		movzx	eax, byte ptr [eax+9]
		mov	[ebp+char_to_repeat], al
		jmp	short loc_8001DA7
; ---------------------------------------------------------------------------

loc_8001D37:				; CODE XREF: string2_extend+A8j
					; DATA XREF: .rodata:off_800602Co
		mov	[ebp+i], 0FFh	; jumptable 08001D1D case 2
		jmp	short loc_8001D61
; ---------------------------------------------------------------------------

loc_8001D40:				; CODE XREF: string2_extend+F0j
		mov	eax, [ebp+i]
		movzx	edx, al
		mov	eax, [ebp+p]
		mov	eax, [eax+8]
		sub	esp, 8
		push	edx		; c
		push	eax		; char_class
		call	is_char_class_member
		add	esp, 10h
		test	al, al
		jnz	short loc_8001D69
		sub	[ebp+i], 1

loc_8001D61:				; CODE XREF: string2_extend+C9j
		cmp	[ebp+i], 0
		jns	short loc_8001D40
		jmp	short loc_8001D6A
; ---------------------------------------------------------------------------

loc_8001D69:				; CODE XREF: string2_extend+E6j
		nop

loc_8001D6A:				; CODE XREF: string2_extend+F2j
		cmp	[ebp+i], 0
		jns	short loc_8001D89
		push	offset __PRETTY_FUNCTION___5493	; "string2_extend"
		push	548h		; line
		push	offset file	; "tr.c"
		push	offset aI0	; "i >=	0"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8001D89:				; CODE XREF: string2_extend+F9j
		mov	eax, [ebp+i]
		mov	[ebp+char_to_repeat], al
		jmp	short loc_8001DA7
; ---------------------------------------------------------------------------

loc_8001D91:				; CODE XREF: string2_extend+A8j
					; DATA XREF: .rodata:off_800602Co
		mov	eax, [ebp+p]	; jumptable 08001D1D case 4
		movzx	eax, byte ptr [eax+8]
		mov	[ebp+char_to_repeat], al
		jmp	short loc_8001DA7
; ---------------------------------------------------------------------------

loc_8001D9D:				; CODE XREF: string2_extend+A8j
					; DATA XREF: .rodata:off_800602Co
		call	abort		; jumptable 08001D1D case 3
; ---------------------------------------------------------------------------

loc_8001DA2:				; CODE XREF: string2_extend+9Bj
		call	abort		; jumptable 08001D1D default case
; ---------------------------------------------------------------------------

loc_8001DA7:				; CODE XREF: string2_extend+B4j
					; string2_extend+C0j ...
		mov	eax, [ebp+s1]
		mov	ecx, [eax+10h]
		mov	ebx, [eax+14h]
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		sub	ecx, eax
		sbb	ebx, edx
		mov	eax, ecx
		mov	edx, ebx
		movzx	ecx, [ebp+char_to_repeat]
		push	edx
		push	eax		; repeat_count
		push	ecx		; the_char
		push	[ebp+s2]	; list
		call	append_repeated_char
		add	esp, 10h
		mov	eax, [ebp+s1]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	ecx, [ebp+s2]
		mov	[ecx+10h], eax
		mov	[ecx+14h], edx
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
string2_extend	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; _Bool	__cdecl	homogeneous_spec_list(Spec_list	*s)
homogeneous_spec_list proc near		; CODE XREF: validate+16Bp

b		= dword	ptr -10h
c		= dword	ptr -0Ch
s		= dword	ptr  8

		push	ebp
		mov	ebp, esp
		sub	esp, 18h
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		sub	esp, 8
		push	0		; class
		push	[ebp+s]		; s
		call	get_next
		add	esp, 10h
		mov	[ebp+b], eax
		cmp	[ebp+b], 0FFFFFFFFh
		jnz	short loc_8001E31
		mov	eax, 0
		jmp	short locret_8001E4F
; ---------------------------------------------------------------------------

loc_8001E22:				; CODE XREF: homogeneous_spec_list+5Dj
		mov	eax, [ebp+c]
		cmp	eax, [ebp+b]
		jz	short loc_8001E31
		mov	eax, 0
		jmp	short locret_8001E4F
; ---------------------------------------------------------------------------

loc_8001E31:				; CODE XREF: homogeneous_spec_list+2Ej
					; homogeneous_spec_list+3Dj
		sub	esp, 8
		push	0		; class
		push	[ebp+s]		; s
		call	get_next
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_8001E22
		mov	eax, 1

locret_8001E4F:				; CODE XREF: homogeneous_spec_list+35j
					; homogeneous_spec_list+44j
		leave
		retn
homogeneous_spec_list endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl validate(Spec_list *s1, Spec_list *s2)
validate	proc near		; CODE XREF: main+3DDp

s1		= dword	ptr  8
s2		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	esi
		push	ebx
		sub	esp, 0Ch
		push	[ebp+s1]	; s1
		call	get_s1_spec_stats
		add	esp, 10h
		mov	eax, [ebp+s1]
		mov	eax, [eax+18h]
		test	eax, eax
		jz	short loc_8001E8E
		sub	esp, 0Ch
		push	offset aTheCRepeatCons ; "the [c*] repeat construct may	not appea"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001E8E:				; CODE XREF: validate+1Bj
		cmp	[ebp+s2], 0
		jz	loc_8002042
		mov	eax, [ebp+s1]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		sub	esp, 4
		push	edx
		push	eax		; len_s1
		push	[ebp+s2]	; s2
		call	get_s2_spec_stats
		add	esp, 10h
		mov	eax, [ebp+s2]
		mov	eax, [eax+18h]
		cmp	eax, 1
		jbe	short loc_8001EDC
		sub	esp, 0Ch
		push	offset aOnlyOneCRepeat ; "only one [c*]	repeat construct may appe"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001EDC:				; CODE XREF: validate+69j
		movzx	eax, ds:translating
		test	al, al
		jz	loc_8002018
		mov	eax, [ebp+s2]
		movzx	eax, byte ptr [eax+20h]
		test	al, al
		jz	short loc_8001F16
		sub	esp, 0Ch
		push	offset aCExpressionsMa ; "[=c=]	expressions may	not appear in str"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001F16:				; CODE XREF: validate+A3j
		mov	eax, [ebp+s1]
		mov	ecx, [eax+10h]
		mov	ebx, [eax+14h]
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		cmp	ebx, edx
		jb	short loc_8001F82
		cmp	ebx, edx
		ja	short loc_8001F34
		cmp	ecx, eax
		jbe	short loc_8001F82

loc_8001F34:				; CODE XREF: validate+DDj
		movzx	eax, ds:truncate_set1
		xor	eax, 1
		test	al, al
		jz	short loc_8001F82
		mov	eax, [ebp+s2]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		or	eax, edx
		test	eax, eax
		jnz	short loc_8001F71
		sub	esp, 0Ch
		push	offset aWhenNotTruncat ; "when not truncating set1, string2 must "...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001F71:				; CODE XREF: validate+FEj
		sub	esp, 8
		push	[ebp+s2]	; s2
		push	[ebp+s1]	; s1
		call	string2_extend
		add	esp, 10h

loc_8001F82:				; CODE XREF: validate+D9j validate+E1j ...
		movzx	eax, ds:complement
		test	al, al
		jz	short loc_8001FEB
		mov	eax, [ebp+s1]
		movzx	eax, byte ptr [eax+21h]
		test	al, al
		jz	short loc_8001FEB
		mov	eax, [ebp+s2]
		mov	ecx, [eax+10h]
		mov	ebx, [eax+14h]
		mov	eax, [ebp+s1]
		mov	edx, [eax+14h]
		mov	eax, [eax+10h]
		mov	esi, ebx
		xor	esi, edx
		xor	eax, ecx
		or	eax, esi
		test	eax, eax
		jnz	short loc_8001FCB
		sub	esp, 0Ch
		push	[ebp+s2]	; s
		call	homogeneous_spec_list
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8001FEB

loc_8001FCB:				; CODE XREF: validate+163j
		sub	esp, 0Ch
		push	offset aWhenTranslatin ; "when translating with	complemented char"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8001FEB:				; CODE XREF: validate+13Aj
					; validate+145j ...
		mov	eax, [ebp+s2]
		movzx	eax, byte ptr [eax+22h]
		test	al, al
		jz	short loc_8002042
		sub	esp, 0Ch
		push	offset aWhenTranslat_0 ; "when translating, the	only character cl"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002042
; ---------------------------------------------------------------------------

loc_8002018:				; CODE XREF: validate+94j
		mov	eax, [ebp+s2]
		mov	eax, [eax+18h]
		test	eax, eax
		jz	short loc_8002042
		sub	esp, 0Ch
		push	offset aTheCConstructM ; "the [c*] construct may appear	in string"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002042:				; CODE XREF: validate+41j
					; validate+1A3j ...
		nop
		lea	esp, [ebp-8]
		pop	ebx
		pop	esi
		pop	ebp
		retn
validate	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl squeeze_filter(char *buf, size_t	size, size_t (*reader)(char *, size_t))
squeeze_filter	proc near		; CODE XREF: main+426p	main+539p ...

char_to_squeeze	= dword	ptr -1Ch
i		= dword	ptr -18h
nr		= dword	ptr -14h
out_len		= dword	ptr -10h
begin		= dword	ptr -0Ch
var_4		= dword	ptr -4
buf		= dword	ptr  8
size		= dword	ptr  0Ch
reader		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 24h
		mov	[ebp+char_to_squeeze], 80h
		mov	[ebp+i], 0
		mov	[ebp+nr], 0

loc_8002066:				; CODE XREF: squeeze_filter+176j
					; squeeze_filter+1A3j ...
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jb	short loc_8002093
		sub	esp, 8
		push	[ebp+size]
		push	[ebp+buf]
		mov	eax, [ebp+reader]
		call	eax
		add	esp, 10h
		mov	[ebp+nr], eax
		cmp	[ebp+nr], 0
		jz	loc_80021FF
		mov	[ebp+i], 0

loc_8002093:				; CODE XREF: squeeze_filter+22j
		mov	eax, [ebp+i]
		mov	[ebp+begin], eax
		cmp	[ebp+char_to_squeeze], 80h
		jnz	loc_80021B9
		jmp	short loc_80020AC
; ---------------------------------------------------------------------------

loc_80020A8:				; CODE XREF: squeeze_filter+93j
		add	[ebp+i], 2

loc_80020AC:				; CODE XREF: squeeze_filter+5Cj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jnb	short loc_80020DF
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:in_squeeze_set[eax]
		xor	eax, 1
		test	al, al
		jnz	short loc_80020A8

loc_80020DF:				; CODE XREF: squeeze_filter+68j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jnz	short loc_8002116
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+buf]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:in_squeeze_set[eax]
		test	al, al
		jz	short loc_8002116
		sub	[ebp+i], 1

loc_8002116:				; CODE XREF: squeeze_filter+9Bj
					; squeeze_filter+C6j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jb	short loc_8002129
		mov	eax, [ebp+nr]
		sub	eax, [ebp+begin]
		mov	[ebp+out_len], eax
		jmp	short loc_800216A
; ---------------------------------------------------------------------------

loc_8002129:				; CODE XREF: squeeze_filter+D2j
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		mov	[ebp+char_to_squeeze], eax
		mov	eax, [ebp+i]
		sub	eax, [ebp+begin]
		add	eax, 1
		mov	[ebp+out_len], eax
		cmp	[ebp+i], 0
		jz	short loc_8002166
		mov	eax, [ebp+i]
		lea	edx, [eax-1]
		mov	eax, [ebp+buf]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, [ebp+char_to_squeeze]
		jnz	short loc_8002166
		sub	[ebp+out_len], 1

loc_8002166:				; CODE XREF: squeeze_filter+100j
					; squeeze_filter+116j
		add	[ebp+i], 1

loc_800216A:				; CODE XREF: squeeze_filter+DDj
		cmp	[ebp+out_len], 0
		jz	short loc_80021B9
		mov	eax, ds:stdout
		mov	ecx, [ebp+buf]
		mov	edx, [ebp+begin]
		add	edx, ecx
		push	eax		; stream
		push	[ebp+out_len]	; n
		push	1		; size
		push	edx		; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+out_len]
		jz	short loc_80021B9
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_80021B9:				; CODE XREF: squeeze_filter+56j
					; squeeze_filter+124j ...
		cmp	[ebp+char_to_squeeze], 80h
		jz	loc_8002066
		jmp	short loc_80021CC
; ---------------------------------------------------------------------------

loc_80021C8:				; CODE XREF: squeeze_filter+19Bj
		add	[ebp+i], 1

loc_80021CC:				; CODE XREF: squeeze_filter+17Cj
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jnb	short loc_80021E7
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		cmp	eax, [ebp+char_to_squeeze]
		jz	short loc_80021C8

loc_80021E7:				; CODE XREF: squeeze_filter+188j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jnb	loc_8002066
		mov	[ebp+char_to_squeeze], 80h
		jmp	loc_8002066
; ---------------------------------------------------------------------------

loc_80021FF:				; CODE XREF: squeeze_filter+3Cj
		nop
		nop
		mov	ebx, [ebp+var_4]
		leave
		retn
squeeze_filter	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl plain_read(char *buf, size_t size)
plain_read	proc near		; CODE XREF: read_and_delete+Fp
					; read_and_xlate+10p
					; DATA XREF: ...

nr		= dword	ptr -0Ch
var_4		= dword	ptr -4
buf		= dword	ptr  8
size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 4
		push	[ebp+size]
		push	[ebp+buf]
		push	0
		call	safe_read
		add	esp, 10h
		mov	[ebp+nr], eax
		cmp	[ebp+nr], 0FFFFFFFFh
		jnz	short loc_8002251
		sub	esp, 0Ch
		push	offset aReadError ; "read error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002251:				; CODE XREF: plain_read+21j
		mov	eax, [ebp+nr]
		mov	ebx, [ebp+var_4]
		leave
		retn
plain_read	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl read_and_delete(char *buf, size_t size)
read_and_delete	proc near		; CODE XREF: main+477p
					; DATA XREF: main+52Ao

n_saved		= dword	ptr -14h
i		= dword	ptr -10h
nr		= dword	ptr -0Ch
buf		= dword	ptr  8
size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		sub	esp, 18h

loc_800225F:				; CODE XREF: read_and_delete+CCj
		sub	esp, 8
		push	[ebp+size]	; size
		push	[ebp+buf]	; buf
		call	plain_read
		add	esp, 10h
		mov	[ebp+nr], eax
		cmp	[ebp+nr], 0
		jnz	short loc_8002283
		mov	eax, 0
		jmp	locret_800232E
; ---------------------------------------------------------------------------

loc_8002283:				; CODE XREF: read_and_delete+1Ej
		mov	[ebp+i], 0
		jmp	short loc_8002290
; ---------------------------------------------------------------------------

loc_800228C:				; CODE XREF: read_and_delete+68j
		add	[ebp+i], 1

loc_8002290:				; CODE XREF: read_and_delete+31j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jnb	short loc_80022C3
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:in_delete_set[eax]
		xor	eax, 1
		test	al, al
		jnz	short loc_800228C

loc_80022C3:				; CODE XREF: read_and_delete+3Dj
		mov	eax, [ebp+i]
		mov	[ebp+n_saved], eax
		add	[ebp+i], 1
		jmp	short loc_8002319
; ---------------------------------------------------------------------------

loc_80022CF:				; CODE XREF: read_and_delete+C6j
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:in_delete_set[eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8002315
		mov	eax, [ebp+n_saved]
		lea	edx, [eax+1]
		mov	[ebp+n_saved], edx
		mov	edx, [ebp+buf]
		add	edx, eax
		mov	ecx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		mov	[edx], al

loc_8002315:				; CODE XREF: read_and_delete+9Fj
		add	[ebp+i], 1

loc_8002319:				; CODE XREF: read_and_delete+74j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+nr]
		jb	short loc_80022CF
		cmp	[ebp+n_saved], 0
		jz	loc_800225F
		mov	eax, [ebp+n_saved]

locret_800232E:				; CODE XREF: read_and_delete+25j
		leave
		retn
read_and_delete	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; size_t __cdecl read_and_xlate(char *buf, size_t size)
read_and_xlate	proc near		; CODE XREF: main+925p
					; DATA XREF: main+8FFo

i		= dword	ptr -10h
bytes_read	= dword	ptr -0Ch
var_4		= dword	ptr -4
buf		= dword	ptr  8
size		= dword	ptr  0Ch

		push	ebp
		mov	ebp, esp
		push	ebx
		sub	esp, 14h
		sub	esp, 8
		push	[ebp+size]	; size
		push	[ebp+buf]	; buf
		call	plain_read
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		mov	[ebp+i], 0
		jmp	short loc_8002387
; ---------------------------------------------------------------------------

loc_8002354:				; CODE XREF: read_and_xlate+5Dj
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		lea	ebx, [edx+eax]
		mov	edx, [ebp+buf]
		mov	eax, [ebp+i]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		movsx	eax, al
		sub	esp, 0Ch
		push	eax		; ch_0
		call	to_uchar
		add	esp, 10h
		movzx	eax, al
		movzx	eax, ds:xlate[eax]
		mov	[ebx], al
		add	[ebp+i], 1

loc_8002387:				; CODE XREF: read_and_xlate+22j
		mov	eax, [ebp+i]
		cmp	eax, [ebp+bytes_read]
		jb	short loc_8002354
		mov	eax, [ebp+bytes_read]
		mov	ebx, [ebp+var_4]
		leave
		retn
read_and_xlate	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: static bp-based frame

; void __cdecl set_initialize(Spec_list	*s, _Bool complement_this_set, _Bool *in_set)
set_initialize	proc near		; CODE XREF: main+40Cp	main+462p ...

complement_this_set= byte ptr -1Ch
i		= dword	ptr -10h
c		= dword	ptr -0Ch
s		= dword	ptr  8
arg_4		= dword	ptr  0Ch
in_set		= dword	ptr  10h

		push	ebp
		mov	ebp, esp
		sub	esp, 28h
		mov	eax, [ebp+arg_4]
		mov	[ebp+complement_this_set], al
		mov	eax, [ebp+s]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		jmp	short loc_80023C1
; ---------------------------------------------------------------------------

loc_80023B6:				; CODE XREF: set_initialize+41j
		mov	edx, [ebp+c]
		mov	eax, [ebp+in_set]
		add	eax, edx
		mov	byte ptr [eax],	1

loc_80023C1:				; CODE XREF: set_initialize+1Dj
		sub	esp, 8
		push	0		; class
		push	[ebp+s]		; s
		call	get_next
		add	esp, 10h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	short loc_80023B6
		cmp	[ebp+complement_this_set], 0
		jz	short loc_800241C
		mov	[ebp+i], 0
		jmp	short loc_8002413
; ---------------------------------------------------------------------------

loc_80023E9:				; CODE XREF: set_initialize+83j
		mov	edx, [ebp+in_set]
		mov	eax, [ebp+i]
		add	edx, eax
		mov	ecx, [ebp+in_set]
		mov	eax, [ebp+i]
		add	eax, ecx
		movzx	eax, byte ptr [eax]
		movzx	eax, al
		test	eax, eax
		setnz	al
		xor	eax, 1
		movzx	eax, al
		and	eax, 1
		mov	[edx], al
		add	[ebp+i], 1

loc_8002413:				; CODE XREF: set_initialize+50j
		cmp	[ebp+i], 0FFh
		jbe	short loc_80023E9

loc_800241C:				; CODE XREF: set_initialize+47j
		nop
		leave
		retn
set_initialize	endp


; =============== S U B	R O U T	I N E =======================================

; Attributes: noreturn bp-based	frame

; int __cdecl main(int argc, const char	**argv,	const char **envp)
		public main
main		proc near

argv		= dword	ptr -9Ch
case_convert	= byte ptr -95h
class_s1	= dword	ptr -94h
class_s2	= dword	ptr -90h
s2		= dword	ptr -8Ch
i		= dword	ptr -88h
i_0		= dword	ptr -84h
s1		= dword	ptr -80h
c		= dword	ptr -7Ch
non_option_args	= dword	ptr -78h
min_operands	= dword	ptr -74h
max_operands	= dword	ptr -70h
nr		= dword	ptr -6Ch
in_s1		= dword	ptr -68h
ch_0		= dword	ptr -64h
c1		= dword	ptr -60h
c2		= dword	ptr -5Ch
bytes_read	= dword	ptr -58h
buf1		= Spec_list ptr	-54h
buf2		= Spec_list ptr	-30h
var_C		= dword	ptr -0Ch
argc		= dword	ptr  0Ch
envp		= dword	ptr  14h

		lea	ecx, [esp+4]
		and	esp, 0FFFFFFF0h
		push	dword ptr [ecx-4]
		push	ebp
		mov	ebp, esp
		push	ebx
		push	ecx
		sub	esp, 0A0h
		mov	ebx, ecx
		mov	eax, [ebx+4]
		mov	[ebp+argv], eax
		mov	eax, large gs:14h
		mov	[ebp+var_C], eax
		xor	eax, eax
		lea	eax, [ebp+buf1]
		mov	[ebp+s1], eax
		lea	eax, [ebp+buf2]
		mov	[ebp+s2], eax
		mov	eax, [ebp+argv]
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	set_program_name
		add	esp, 10h
		sub	esp, 8
		push	offset locale	; locale
		push	6		; category
		call	setlocale
		add	esp, 10h
		sub	esp, 8
		push	offset dirname	; "/usr/local/share/locale"
		push	offset domainname ; "coreutils"
		call	bindtextdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset domainname ; "coreutils"
		call	textdomain
		add	esp, 10h
		sub	esp, 0Ch
		push	offset close_stdout ; func
		call	atexit
		add	esp, 10h
		jmp	loc_8002557
; ---------------------------------------------------------------------------

loc_80024B9:				; CODE XREF: main+15Ej
		mov	eax, [ebp+c]
		cmp	eax, 63h
		jz	short loc_80024EC
		cmp	eax, 63h
		jg	short loc_80024DB
		cmp	eax, 0FFFFFF7Eh
		jz	short loc_8002510
		cmp	eax, 43h
		jz	short loc_80024EC
		cmp	eax, 0FFFFFF7Dh
		jz	short loc_800251A
		jmp	short loc_800254D
; ---------------------------------------------------------------------------

loc_80024DB:				; CODE XREF: main+A5j
		cmp	eax, 73h
		jz	short loc_80024FE
		cmp	eax, 74h
		jz	short loc_8002507
		cmp	eax, 64h
		jz	short loc_80024F5
		jmp	short loc_800254D
; ---------------------------------------------------------------------------

loc_80024EC:				; CODE XREF: main+A0j main+B1j
		mov	ds:complement, 1
		jmp	short loc_8002557
; ---------------------------------------------------------------------------

loc_80024F5:				; CODE XREF: main+C9j
		mov	ds:delete, 1
		jmp	short loc_8002557
; ---------------------------------------------------------------------------

loc_80024FE:				; CODE XREF: main+BFj
		mov	ds:squeeze_repeats, 1
		jmp	short loc_8002557
; ---------------------------------------------------------------------------

loc_8002507:				; CODE XREF: main+C4j
		mov	ds:truncate_set1, 1
		jmp	short loc_8002557
; ---------------------------------------------------------------------------

loc_8002510:				; CODE XREF: main+ACj
		sub	esp, 0Ch
		push	0		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800251A:				; CODE XREF: main+B8j
		mov	edx, ds:Version
		mov	eax, ds:stdout
		sub	esp, 8
		push	0
		push	offset aJimMeyering ; "Jim Meyering"
		push	edx
		push	offset aGnuCoreutils ; "GNU coreutils"
		push	offset aTr	; "tr"
		push	eax
		call	version_etc
		add	esp, 20h
		sub	esp, 0Ch
		push	0		; status
		call	exit
; ---------------------------------------------------------------------------

loc_800254D:				; CODE XREF: main+BAj main+CBj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_8002557:				; CODE XREF: main+95j main+D4j ...
		sub	esp, 0Ch
		push	0		; longind
		push	offset long_options ; longopts
		push	offset shortopts ; "+cCdst"
		push	[ebp+argv]	; argv
		push	dword ptr [ebx]	; argc
		call	getopt_long
		add	esp, 20h
		mov	[ebp+c], eax
		cmp	[ebp+c], 0FFFFFFFFh
		jnz	loc_80024B9
		mov	eax, ds:optind
		mov	edx, [ebx]
		sub	edx, eax
		mov	eax, edx
		mov	[ebp+non_option_args], eax
		cmp	[ebp+non_option_args], 2
		jnz	short loc_80025AC
		movzx	eax, ds:delete
		xor	eax, 1
		test	al, al
		jz	short loc_80025AC
		mov	eax, 1
		jmp	short loc_80025B1
; ---------------------------------------------------------------------------

loc_80025AC:				; CODE XREF: main+176j	main+184j
		mov	eax, 0

loc_80025B1:				; CODE XREF: main+18Bj
		and	eax, 1
		mov	ds:translating,	al
		movzx	edx, ds:delete
		movzx	eax, ds:squeeze_repeats
		cmp	dl, al
		jnz	short loc_80025D2
		mov	eax, 2
		jmp	short loc_80025D7
; ---------------------------------------------------------------------------

loc_80025D2:				; CODE XREF: main+1AAj
		mov	eax, 1

loc_80025D7:				; CODE XREF: main+1B1j
		mov	[ebp+min_operands], eax
		movzx	eax, ds:delete
		movzx	edx, al
		movzx	eax, ds:squeeze_repeats
		movzx	eax, al
		cmp	edx, eax
		jg	short loc_80025F9
		mov	eax, 2
		jmp	short loc_80025FE
; ---------------------------------------------------------------------------

loc_80025F9:				; CODE XREF: main+1D1j
		mov	eax, 1

loc_80025FE:				; CODE XREF: main+1D8j
		mov	[ebp+max_operands], eax
		mov	eax, [ebp+non_option_args]
		cmp	eax, [ebp+min_operands]
		jge	loc_80026C2
		cmp	[ebp+non_option_args], 0
		jnz	short loc_8002638
		sub	esp, 0Ch
		push	offset aMissingOperand ; "missing operand"
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		jmp	loc_80026B8
; ---------------------------------------------------------------------------

loc_8002638:				; CODE XREF: main+1F2j
		mov	eax, [ebx]
		add	eax, 3FFFFFFFh
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aMissingOpera_0 ; "missing operand after	%s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		movzx	eax, ds:squeeze_repeats
		test	al, al
		jz	short loc_800268E
		mov	eax, offset aTwoStringsMust ; "Two strings must	be given when both del"...
		jmp	short loc_8002693
; ---------------------------------------------------------------------------

loc_800268E:				; CODE XREF: main+266j
		mov	eax, offset aTwoStringsMu_0 ; "Two strings must	be given when translat"...

loc_8002693:				; CODE XREF: main+26Dj
		sub	esp, 0Ch
		push	eax		; msgid
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	edx
		push	offset aS	; "%s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h

loc_80026B8:				; CODE XREF: main+214j
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_80026C2:				; CODE XREF: main+1E8j
		mov	eax, [ebp+max_operands]
		cmp	eax, [ebp+non_option_args]
		jge	loc_800274F
		mov	edx, ds:optind
		mov	eax, [ebp+max_operands]
		add	eax, edx
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 0Ch
		push	eax
		call	quote
		add	esp, 10h
		mov	ebx, eax
		sub	esp, 0Ch
		push	offset aExtraOperandS ;	"extra operand %s"
		call	gettext
		add	esp, 10h
		push	ebx
		push	eax		; format
		push	0		; errnum
		push	0		; status
		call	error
		add	esp, 10h
		cmp	[ebp+non_option_args], 2
		jnz	short loc_8002745
		sub	esp, 0Ch
		push	offset aOnlyOneStringM ; "Only one string may be given when delet"...
		call	gettext
		add	esp, 10h
		mov	edx, eax
		mov	eax, ds:stderr
		sub	esp, 4
		push	edx
		push	offset aS	; "%s\n"
		push	eax		; stream
		call	fprintf
		add	esp, 10h

loc_8002745:				; CODE XREF: main+2FBj
		sub	esp, 0Ch
		push	1		; status
		call	usage
; ---------------------------------------------------------------------------

loc_800274F:				; CODE XREF: main+2A9j
		sub	esp, 0Ch
		push	[ebp+s1]	; spec_list
		call	spec_init
		add	esp, 10h
		mov	eax, ds:optind
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+s1]	; spec_list
		push	eax		; s
		call	parse_str
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_8002793
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_8002793:				; CODE XREF: main+368j
		cmp	[ebp+non_option_args], 2
		jnz	short loc_80027E6
		sub	esp, 0Ch
		push	[ebp+s2]	; spec_list
		call	spec_init
		add	esp, 10h
		mov	eax, ds:optind
		add	eax, 1
		lea	edx, ds:0[eax*4]
		mov	eax, [ebp+argv]
		add	eax, edx
		mov	eax, [eax]
		sub	esp, 8
		push	[ebp+s2]	; spec_list
		push	eax		; s
		call	parse_str
		add	esp, 10h
		xor	eax, 1
		test	al, al
		jz	short loc_80027F0
		sub	esp, 0Ch
		push	1		; status
		call	exit
; ---------------------------------------------------------------------------

loc_80027E6:				; CODE XREF: main+378j
		mov	[ebp+s2], 0

loc_80027F0:				; CODE XREF: main+3BBj
		sub	esp, 8
		push	[ebp+s2]	; s2
		push	[ebp+s1]	; s1
		call	validate
		add	esp, 10h
		movzx	eax, ds:squeeze_repeats
		test	al, al
		jz	short loc_8002852
		cmp	[ebp+non_option_args], 1
		jnz	short loc_8002852
		movzx	eax, ds:complement
		movzx	eax, al
		sub	esp, 4
		push	offset in_squeeze_set ;	in_set
		push	eax		; complement_this_set
		push	[ebp+s1]	; s
		call	set_initialize
		add	esp, 10h
		sub	esp, 4
		push	offset plain_read ; reader
		push	2000h		; size
		push	offset io_buf	; buf
		call	squeeze_filter
		add	esp, 10h
		jmp	loc_8002D9D
; ---------------------------------------------------------------------------

loc_8002852:				; CODE XREF: main+3EEj	main+3F4j
		movzx	eax, ds:delete
		test	al, al
		jz	loc_80028F4
		cmp	[ebp+non_option_args], 1
		jnz	loc_80028F4
		movzx	eax, ds:complement
		movzx	eax, al
		sub	esp, 4
		push	offset in_delete_set ; in_set
		push	eax		; complement_this_set
		push	[ebp+s1]	; s
		call	set_initialize
		add	esp, 10h

loc_8002889:				; CODE XREF: main+4A3j	main+4CDj
		sub	esp, 8
		push	2000h		; size
		push	offset io_buf	; buf
		call	read_and_delete
		add	esp, 10h
		mov	[ebp+nr], eax
		cmp	[ebp+nr], 0
		jz	short loc_80028EE
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+nr]	; n
		push	1		; size
		push	offset io_buf	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+nr]
		jz	short loc_8002889
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002889
; ---------------------------------------------------------------------------

loc_80028EE:				; CODE XREF: main+486j
		nop
		jmp	loc_8002D9D
; ---------------------------------------------------------------------------

loc_80028F4:				; CODE XREF: main+43Cj	main+446j
		movzx	eax, ds:squeeze_repeats
		test	al, al
		jz	short loc_8002965
		movzx	eax, ds:delete
		test	al, al
		jz	short loc_8002965
		cmp	[ebp+non_option_args], 2
		jnz	short loc_8002965
		movzx	eax, ds:complement
		movzx	eax, al
		sub	esp, 4
		push	offset in_delete_set ; in_set
		push	eax		; complement_this_set
		push	[ebp+s1]	; s
		call	set_initialize
		add	esp, 10h
		sub	esp, 4
		push	offset in_squeeze_set ;	in_set
		push	0		; complement_this_set
		push	[ebp+s2]	; s
		call	set_initialize
		add	esp, 10h
		sub	esp, 4
		push	offset read_and_delete ; reader
		push	2000h		; size
		push	offset io_buf	; buf
		call	squeeze_filter
		add	esp, 10h
		jmp	loc_8002D9D
; ---------------------------------------------------------------------------

loc_8002965:				; CODE XREF: main+4DEj	main+4E9j ...
		movzx	eax, ds:translating
		test	al, al
		jz	loc_8002D9D
		movzx	eax, ds:complement
		test	al, al
		jz	loc_8002A81
		mov	[ebp+in_s1], offset in_delete_set
		sub	esp, 4
		push	[ebp+in_s1]	; in_set
		push	0		; complement_this_set
		push	[ebp+s1]	; s
		call	set_initialize
		add	esp, 10h
		mov	eax, [ebp+s2]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	[ebp+i], 0
		jmp	short loc_80029D9
; ---------------------------------------------------------------------------

loc_80029BD:				; CODE XREF: main+5C4j
		mov	eax, [ebp+i]
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset xlate
		mov	[eax], dl
		add	[ebp+i], 1

loc_80029D9:				; CODE XREF: main+59Cj
		cmp	[ebp+i], 0FFh
		jle	short loc_80029BD
		mov	[ebp+i], 0
		jmp	short loc_8002A6C
; ---------------------------------------------------------------------------

loc_80029F1:				; CODE XREF: main+657j
		mov	edx, [ebp+i]
		mov	eax, [ebp+in_s1]
		add	eax, edx
		movzx	eax, byte ptr [eax]
		xor	eax, 1
		test	al, al
		jz	short loc_8002A65
		sub	esp, 8
		push	0		; class
		push	[ebp+s2]	; s
		call	get_next
		add	esp, 10h
		mov	[ebp+ch_0], eax
		cmp	[ebp+ch_0], 0FFFFFFFFh
		jnz	short loc_8002A49
		movzx	eax, ds:truncate_set1
		xor	eax, 1
		test	al, al
		jz	short loc_8002A49
		push	offset __PRETTY_FUNCTION___5616	; "main"
		push	705h		; line
		push	offset file	; "tr.c"
		push	offset aCh1Truncate_se ; "ch !=	-1 || truncate_set1"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8002A49:				; CODE XREF: main+601j	main+60Fj
		cmp	[ebp+ch_0], 0FFFFFFFFh
		jz	loc_8002CF7
		mov	eax, [ebp+ch_0]
		mov	edx, eax
		mov	eax, [ebp+i]
		add	eax, offset xlate
		mov	[eax], dl

loc_8002A65:				; CODE XREF: main+5E5j
		add	[ebp+i], 1

loc_8002A6C:				; CODE XREF: main+5D0j
		cmp	[ebp+i], 0FFh
		jle	loc_80029F1
		jmp	loc_8002CF8
; ---------------------------------------------------------------------------

loc_8002A81:				; CODE XREF: main+55Ej
		mov	[ebp+case_convert], 0
		mov	[ebp+i_0], 0
		jmp	short loc_8002AB0
; ---------------------------------------------------------------------------

loc_8002A94:				; CODE XREF: main+69Bj
		mov	eax, [ebp+i_0]
		mov	edx, eax
		mov	eax, [ebp+i_0]
		add	eax, offset xlate
		mov	[eax], dl
		add	[ebp+i_0], 1

loc_8002AB0:				; CODE XREF: main+673j
		cmp	[ebp+i_0], 0FFh
		jle	short loc_8002A94
		mov	eax, [ebp+s1]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh
		mov	eax, [ebp+s2]
		mov	dword ptr [eax+8], 0FFFFFFFEh
		mov	dword ptr [eax+0Ch], 0FFFFFFFFh

loc_8002AE1:				; CODE XREF: main:loc_8002CC5j
		cmp	[ebp+case_convert], 0
		jz	short loc_8002B10
		sub	esp, 0Ch
		push	[ebp+s1]	; s
		call	skip_construct
		add	esp, 10h
		sub	esp, 0Ch
		push	[ebp+s2]	; s
		call	skip_construct
		add	esp, 10h
		mov	[ebp+case_convert], 0

loc_8002B10:				; CODE XREF: main+6C9j
		sub	esp, 8
		lea	eax, [ebp+class_s1]
		push	eax		; class
		push	[ebp+s1]	; s
		call	get_next
		add	esp, 10h
		mov	[ebp+c1], eax
		sub	esp, 8
		lea	eax, [ebp+class_s2]
		push	eax		; class
		push	[ebp+s2]	; s
		call	get_next
		add	esp, 10h
		mov	[ebp+c2], eax
		mov	eax, [ebp+class_s1]
		cmp	eax, 2
		jnz	short loc_8002B83
		mov	eax, [ebp+class_s2]
		test	eax, eax
		jz	short loc_8002B63
		mov	eax, [ebp+class_s2]
		cmp	eax, 1
		jnz	short loc_8002B83

loc_8002B63:				; CODE XREF: main+737j
		sub	esp, 0Ch
		push	offset aMisalignedUppe ; "misaligned [:upper:] and/or [:lower:]	c"...
		call	gettext
		add	esp, 10h
		sub	esp, 4
		push	eax		; format
		push	0		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002B83:				; CODE XREF: main+72Dj	main+742j
		mov	eax, [ebp+class_s1]
		test	eax, eax
		jnz	short loc_8002C03
		mov	eax, [ebp+class_s2]
		cmp	eax, 1
		jnz	short loc_8002C03
		mov	[ebp+case_convert], 1
		mov	[ebp+i_0], 0
		jmp	short loc_8002BF2
; ---------------------------------------------------------------------------

loc_8002BAB:				; CODE XREF: main+7DDj
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i_0]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 200h
		test	eax, eax
		jz	short loc_8002BEB
		sub	esp, 0Ch
		push	[ebp+i_0]	; c
		call	toupper
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i_0]
		add	eax, offset xlate
		mov	[eax], dl

loc_8002BEB:				; CODE XREF: main+7AAj
		add	[ebp+i_0], 1

loc_8002BF2:				; CODE XREF: main+78Aj
		cmp	[ebp+i_0], 0FFh
		jle	short loc_8002BAB
		jmp	loc_8002CC5
; ---------------------------------------------------------------------------

loc_8002C03:				; CODE XREF: main+76Cj	main+777j
		mov	eax, [ebp+class_s1]
		cmp	eax, 1
		jnz	short loc_8002C80
		mov	eax, [ebp+class_s2]
		test	eax, eax
		jnz	short loc_8002C80
		mov	[ebp+case_convert], 1
		mov	[ebp+i_0], 0
		jmp	short loc_8002C72
; ---------------------------------------------------------------------------

loc_8002C2B:				; CODE XREF: main+85Dj
		call	__ctype_b_loc
		mov	eax, [eax]
		mov	edx, [ebp+i_0]
		add	edx, edx
		add	eax, edx
		movzx	eax, word ptr [eax]
		movzx	eax, ax
		and	eax, 100h
		test	eax, eax
		jz	short loc_8002C6B
		sub	esp, 0Ch
		push	[ebp+i_0]	; c
		call	tolower
		add	esp, 10h
		mov	edx, eax
		mov	eax, [ebp+i_0]
		add	eax, offset xlate
		mov	[eax], dl

loc_8002C6B:				; CODE XREF: main+82Aj
		add	[ebp+i_0], 1

loc_8002C72:				; CODE XREF: main+80Aj
		cmp	[ebp+i_0], 0FFh
		jle	short loc_8002C2B
		jmp	short loc_8002CC5
; ---------------------------------------------------------------------------

loc_8002C80:				; CODE XREF: main+7EDj	main+7F7j
		mov	eax, [ebp+class_s1]
		test	eax, eax
		jnz	short loc_8002C94
		mov	eax, [ebp+class_s2]
		test	eax, eax
		jz	short loc_8002CC5

loc_8002C94:				; CODE XREF: main+869j
		mov	eax, [ebp+class_s1]
		cmp	eax, 1
		jnz	short loc_8002CAA
		mov	eax, [ebp+class_s2]
		cmp	eax, 1
		jz	short loc_8002CC5

loc_8002CAA:				; CODE XREF: main+87Ej
		cmp	[ebp+c1], 0FFFFFFFFh
		jz	short loc_8002CCA
		cmp	[ebp+c2], 0FFFFFFFFh
		jz	short loc_8002CCA
		mov	eax, [ebp+c2]
		mov	edx, eax
		mov	eax, [ebp+c1]
		add	eax, offset xlate
		mov	[eax], dl

loc_8002CC5:				; CODE XREF: main+7DFj	main+85Fj ...
		jmp	loc_8002AE1
; ---------------------------------------------------------------------------

loc_8002CCA:				; CODE XREF: main+88Fj	main+895j
		cmp	[ebp+c1], 0FFFFFFFFh
		jz	short loc_8002CF8
		movzx	eax, ds:truncate_set1
		xor	eax, 1
		test	al, al
		jz	short loc_8002CF8
		push	offset __PRETTY_FUNCTION___5616	; "main"
		push	74Fh		; line
		push	offset file	; "tr.c"
		push	offset aC11Truncate_se ; "c1 ==	-1 || truncate_set1"
		call	__assert_fail
; ---------------------------------------------------------------------------

loc_8002CF7:				; CODE XREF: main+62Ej
		nop

loc_8002CF8:				; CODE XREF: main+65Dj	main+8AFj ...
		movzx	eax, ds:squeeze_repeats
		test	al, al
		jz	short loc_8002D37
		sub	esp, 4
		push	offset in_squeeze_set ;	in_set
		push	0		; complement_this_set
		push	[ebp+s2]	; s
		call	set_initialize
		add	esp, 10h
		sub	esp, 4
		push	offset read_and_xlate ;	reader
		push	2000h		; size
		push	offset io_buf	; buf
		call	squeeze_filter
		add	esp, 10h
		jmp	short loc_8002D9D
; ---------------------------------------------------------------------------

loc_8002D37:				; CODE XREF: main+8E2j	main+951j ...
		sub	esp, 8
		push	2000h		; size
		push	offset io_buf	; buf
		call	read_and_xlate
		add	esp, 10h
		mov	[ebp+bytes_read], eax
		cmp	[ebp+bytes_read], 0
		jz	short loc_8002D9C
		mov	eax, ds:stdout
		push	eax		; stream
		push	[ebp+bytes_read] ; n
		push	1		; size
		push	offset io_buf	; ptr
		call	fwrite_unlocked
		add	esp, 10h
		cmp	eax, [ebp+bytes_read]
		jz	short loc_8002D37
		sub	esp, 0Ch
		push	offset aWriteError ; "write error"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h
		jmp	short loc_8002D37
; ---------------------------------------------------------------------------

loc_8002D9C:				; CODE XREF: main+934j
		nop

loc_8002D9D:				; CODE XREF: main+42Ej	main+4D0j ...
		sub	esp, 0Ch
		push	0		; fd
		call	close
		add	esp, 10h
		test	eax, eax
		jz	short loc_8002DD6
		sub	esp, 0Ch
		push	offset aStandardInput ;	"standard input"
		call	gettext
		add	esp, 10h
		mov	ebx, eax
		call	__errno_location
		mov	eax, [eax]
		sub	esp, 4
		push	ebx		; format
		push	eax		; errnum
		push	1		; status
		call	error
		add	esp, 10h

loc_8002DD6:				; CODE XREF: main+98Dj
		sub	esp, 0Ch
		push	0		; status

loc_8002DDB:				; DATA XREF: .eh_frame:080064B0o
					; .eh_frame:080064D0o ...
		call	exit
main		endp

_text		ends

; ===========================================================================

; Segment type:	Zero-length
; Segment permissions: Read/Write
_data		segment	byte public 'DATA' use32
_data		ends

; ===========================================================================

; Segment type:	Uninitialized
; Segment permissions: Read/Write
; Segment alignment '32byte' can not be represented in assembly
_bss		segment	para public 'BSS' use32
		assume cs:_bss
		;org 8002E00h
		assume es:nothing, ss:nothing, ds:_text, fs:nothing, gs:nothing
; _Bool	squeeze_repeats
squeeze_repeats	db ?			; DATA XREF: main:loc_80024FEw
					; main+1A1r ...
; _Bool	delete
delete		db ?			; DATA XREF: main:loc_80024F5w
					; main+178r ...
; _Bool	complement
complement	db ?			; DATA XREF: get_s1_spec_stats+14r
					; validate:loc_8001F82r ...
; _Bool	truncate_set1
truncate_set1	db ?			; DATA XREF: validate:loc_8001F34r
					; main:loc_8002507w ...
; _Bool	translating
translating	db ?			; DATA XREF: string2_extend+7r
					; validate:loc_8001EDCr ...
		align 20h
; char io_buf[8192]
io_buf		db 2000h dup(?)		; DATA XREF: main+421o	main+472o ...
; _Bool	in_squeeze_set[256]
in_squeeze_set	db 100h	dup(?)		; DATA XREF: squeeze_filter+87r
					; squeeze_filter+BDr ...
; _Bool	in_delete_set[256]
in_delete_set	db 100h	dup(?)		; DATA XREF: read_and_delete+5Cr
					; read_and_delete+93r ...
; char xlate[256]
xlate		db 100h	dup(?)		; DATA XREF: read_and_xlate+4Ar
					; main+5ACo ...
_bss		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
; Segment alignment '32byte' can not be represented in assembly
_rodata		segment	para public 'CONST' use32
		assume cs:_rodata
		;org 8005120h
; char msgid[]
msgid		db 0Ah			; DATA XREF: emit_ancillary_info+1Do
		db 'Report %s bugs to %s',0Ah,0
aBugCoreutils@g	db 'bug-coreutils@gnu.org',0 ; DATA XREF: emit_ancillary_info+2Do
		align 10h
; char aSHomePageHttpW[]
aSHomePageHttpW	db '%s home page: <http://www.gnu.org/software/%s/>',0Ah,0
					; DATA XREF: emit_ancillary_info+3Fo
; char domainname[]
domainname	db 'coreutils',0        ; DATA XREF: emit_ancillary_info+4Fo
					; main+68o ...
aGnuCoreutils	db 'GNU coreutils',0    ; DATA XREF: emit_ancillary_info+54o
					; main+111o
		align 4
; char aGeneralHelpUsi[]
aGeneralHelpUsi	db 'General help using GNU software: <http://www.gnu.org/gethelp/>',0Ah,0
					; DATA XREF: emit_ancillary_info+6Bo
; char s2[]
s2		db 'en_',0              ; DATA XREF: emit_ancillary_info+A2o
; char aReportSTransla[]
aReportSTransla	db 'Report %s translation bugs to <http://translationproject.org/team'
					; DATA XREF: emit_ancillary_info+CCo
		db '/>',0Ah,0
		align 4
; char aForCompleteDoc[]
aForCompleteDoc	db 'For complete documentation, run: info coreutils ',27h,'%s invocation'
					; DATA XREF: emit_ancillary_info+FCo
		db 27h,0Ah,0
aAlnum		db 'alnum',0            ; DATA XREF: .rodata:char_class_nameo
aAlpha		db 'alpha',0            ; DATA XREF: .rodata:char_class_nameo
aBlank		db 'blank',0            ; DATA XREF: .rodata:char_class_nameo
aCntrl		db 'cntrl',0            ; DATA XREF: .rodata:char_class_nameo
aDigit		db 'digit',0            ; DATA XREF: .rodata:char_class_nameo
aGraph		db 'graph',0            ; DATA XREF: .rodata:char_class_nameo
aLower		db 'lower',0            ; DATA XREF: .rodata:char_class_nameo
aPrint		db 'print',0            ; DATA XREF: .rodata:char_class_nameo
aPunct		db 'punct',0            ; DATA XREF: .rodata:char_class_nameo
aSpace		db 'space',0            ; DATA XREF: .rodata:char_class_nameo
aUpper		db 'upper',0            ; DATA XREF: .rodata:char_class_nameo
aXdigit		db 'xdigit',0           ; DATA XREF: .rodata:char_class_nameo
		align 10h
; const	char *const char_class_name[12]
char_class_name	dd offset aAlnum, offset aAlpha, offset	aBlank,	offset aCntrl
					; DATA XREF: look_up_char_class+12r
					; look_up_char_class+32r
		dd offset aDigit, offset aGraph, offset	aLower,	offset aPrint ;	"alnum"
		dd offset aPunct, offset aSpace, offset	aUpper,	offset aXdigit
aComplement	db 'complement',0       ; DATA XREF: .rodata:long_optionso
aDelete		db 'delete',0           ; DATA XREF: .rodata:long_optionso
aSqueezeRepeats	db 'squeeze-repeats',0  ; DATA XREF: .rodata:long_optionso
aTruncateSet1	db 'truncate-set1',0    ; DATA XREF: .rodata:long_optionso
aHelp		db 'help',0             ; DATA XREF: .rodata:long_optionso
aVersion	db 'version',0          ; DATA XREF: .rodata:long_optionso
		align 20h
; const	option long_options[7]
long_options	option <offset aComplement, 0, 0, 63h> ; DATA XREF: main+13Do
		option <offset aDelete,	0, 0, 64h> ; "complement"
		option <offset aSqueezeRepeats,	0, 0, 73h>
		option <offset aTruncateSet1, 0, 0, 74h>
		option <offset aHelp, 0, 0, 0FFFFFF7Eh>
		option <offset aVersion, 0, 0, 0FFFFFF7Dh>
		option	<0>
; char aTrySHelpForMor[]
aTrySHelpForMor	db 'Try `%s --help',27h,' for more information.',0Ah,0
					; DATA XREF: usage+16o
		align 4
; char aUsageSOption__[]
aUsageSOption__	db 'Usage: %s [OPTION]... SET1 [SET2]',0Ah,0 ; DATA XREF: usage+46o
		align 4
; char aTranslateSquee[]
aTranslateSquee	db 'Translate, squeeze, and/or delete characters from standard input,'
					; DATA XREF: usage+69o
		db 0Ah
		db 'writing to standard output.',0Ah
		db 0Ah
		db '  -c, -C, --complement    use the complement of SET1',0Ah
		db '  -d, --delete            delete characters in SET1, do not trans'
		db 'late',0Ah
		db '  -s, --squeeze-repeats   replace each input sequence of a repeat'
		db 'ed character',0Ah
		db '                            that is listed in SET1 with a single '
		db 'occurrence',0Ah
		db '                            of that character',0Ah
		db '  -t, --truncate-set1     first truncate SET1 to length of SET2',0Ah
		db 0
		align 10h
; char aHelpDisplayThi[]
aHelpDisplayThi	db '      --help     display this help and exit',0Ah,0
					; DATA XREF: usage+8Co
		align 10h
; char aVersionOutputV[]
aVersionOutputV	db '      --version  output version information and exit',0Ah,0
					; DATA XREF: usage+AFo
		align 4
; char aSetsAreSpecifi[]
aSetsAreSpecifi	db 0Ah			; DATA XREF: usage+D2o
		db 'SETs are specified as strings of characters.  Most represent them'
		db 'selves.',0Ah
		db 'Interpreted sequences are:',0Ah
		db 0Ah
		db '  \NNN            character with octal value NNN (1 to 3 octal di'
		db 'gits)',0Ah
		db '  \\              backslash',0Ah
		db '  \a              audible BEL',0Ah
		db '  \b              backspace',0Ah
		db '  \f              form feed',0Ah
		db '  \n              new line',0Ah
		db '  \r              return',0Ah
		db '  \t              horizontal tab',0Ah,0
		align 10h
; char aVVerticalTabCh[]
aVVerticalTabCh	db '  \v              vertical tab',0Ah ; DATA XREF: usage+F5o
		db '  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending'
		db ' order',0Ah
		db '  [CHAR*]         in SET2, copies of CHAR until length of SET1',0Ah
		db '  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting'
		db ' with 0',0Ah
		db '  [:alnum:]       all letters and digits',0Ah
		db '  [:alpha:]       all letters',0Ah
		db '  [:blank:]       all horizontal whitespace',0Ah
		db '  [:cntrl:]       all control characters',0Ah
		db '  [:digit:]       all digits',0Ah,0
		align 4
; char aGraphAllPrinta[]
aGraphAllPrinta	db '  [:graph:]       all printable characters, not including space',0Ah
					; DATA XREF: usage+118o
		db '  [:lower:]       all lower case letters',0Ah
		db '  [:print:]       all printable characters, including space',0Ah
		db '  [:punct:]       all punctuation characters',0Ah
		db '  [:space:]       all horizontal or vertical whitespace',0Ah
		db '  [:upper:]       all upper case letters',0Ah
		db '  [:xdigit:]      all hexadecimal digits',0Ah
		db '  [=CHAR=]        all characters which are equivalent to CHAR',0Ah,0
		align 4
; char aTranslationOcc[]
aTranslationOcc	db 0Ah			; DATA XREF: usage+13Bo
		db 'Translation occurs if -d is not given and both SET1 and SET2 appe'
		db 'ar.',0Ah
		db '-t may be used only when translating.  SET2 is extended to length'
		db ' of',0Ah
		db 'SET1 by repeating its last character as necessary.  Excess charac'
		db 'ters',0Ah
		db 'of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed'
		db ' to',0Ah
		db 'expand in ascending order; used in SET2 while translating, they m'
		db 'ay',0Ah
		db 'only be used in pairs to specify case conversion.  -s uses SET1 i'
		db 'f not',0Ah
		db 'translating nor deleting; else squeezing uses SET2 and occurs aft'
		db 'er',0Ah
		db 'translation or deletion.',0Ah,0
		align 4
off_8005D08	dd offset loc_800031A	; DATA XREF: is_char_class_member+1Co
		dd offset loc_800033A	; jump table for switch	statement
		dd offset loc_800035C
		dd offset loc_800037C
		dd offset loc_800039C
		dd offset loc_80003BE
		dd offset loc_80003E0
		dd offset loc_8000402
		dd offset loc_8000421
		dd offset loc_800043E
		dd offset loc_800045D
		dd offset loc_800047C
; char aWarningTheAmbi[]
aWarningTheAmbi	db 'warning: the ambiguous octal escape \%c%c%c is being',0Ah
					; DATA XREF: unquote+254o
		db 9,'interpreted as the 2-byte sequence \0%c%c, %c',0
; char aWarningAnUnesc[]
aWarningAnUnesc	db 'warning: an unescaped backslash at end of string is not portable',0
					; DATA XREF: unquote+282o
; char format[]
format		db '\%03o',0            ; DATA XREF: make_printable_char+56o
					; make_printable_str+109o
asc_8005DE3	db '\',0                ; DATA XREF: make_printable_str+88o
aA		db '\a',0               ; DATA XREF: make_printable_str:loc_8000968o
aB		db '\b',0               ; DATA XREF: make_printable_str:loc_8000974o
asc_8005DEB	db '\f',0               ; DATA XREF: make_printable_str:loc_800097Do
aN		db '\n',0               ; DATA XREF: make_printable_str:loc_8000986o
aR		db '\r',0               ; DATA XREF: make_printable_str:loc_800098Fo
aT		db '\t',0               ; DATA XREF: make_printable_str:loc_8000998o
aV		db '\v',0               ; DATA XREF: make_printable_str:loc_80009A1o
; char file[]
file		db 'tr.c',0             ; DATA XREF: append_normal_char+4Do
					; append_range+D5o ...
; char assertion[]
assertion	db 'list->tail',0       ; DATA XREF: append_normal_char+52o
					; append_range+DAo ...
		align 4
; char aRangeEndpoints[]
aRangeEndpoints	db 'range-endpoints of `%s-%s',27h,' are in reverse collating sequence o'
					; DATA XREF: append_range+44o
		db 'rder',0
; char aStart_idx1EsLe[]
aStart_idx1EsLe	db 'start_idx + 1 < es->len',0 ; DATA XREF: find_bracketed_repeat+49o
		align 4
; char aInvalidRepeatC[]
aInvalidRepeatC	db 'invalid repeat count %s in [c*n] construct',0
					; DATA XREF: find_bracketed_repeat+167o
		align 4
; char aMissingCharact[]
aMissingCharact	db 'missing character class name `[::]',27h,0
					; DATA XREF: build_spec_list+E7o
; char aMissingEquival[]
aMissingEquival	db 'missing equivalence class character `[==]',27h,0
					; DATA XREF: build_spec_list+109o
; char aInvalidCharact[]
aInvalidCharact	db 'invalid character class %s',0 ; DATA XREF: build_spec_list+1A9o
		align 10h
; char aSEquivalenceCl[]
aSEquivalenceCl	db '%s: equivalence class operand must be a single character',0
					; DATA XREF: build_spec_list+227o
; char aIN_chars[]
aIN_chars	db 'i < N_CHARS',0      ; DATA XREF: get_next+1E1o
		align 4
; char aIs_char_class_[]
aIs_char_class_	db 'is_char_class_member (p->u.char_class, s->state)',0
					; DATA XREF: get_next+22Ao
		align 4
off_8005F7C	dd offset loc_80014AB	; DATA XREF: get_next+74r
		dd offset loc_80014DA	; jump table for switch	statement
		dd offset loc_800157D
		dd offset loc_80016E9
		dd offset loc_8001718
; char aPU_range_last_[]
aPU_range_last_	db 'p->u.range.last_char >= p->u.range.first_char',0
					; DATA XREF: get_spec_stats+9Do
; char aTooManyCharact[]
aTooManyCharact	db 'too many characters in set',0 ; DATA XREF: get_spec_stats+1F8o
		align 4
off_8005FDC	dd offset loc_8001921	; DATA XREF: get_spec_stats+60r
		dd offset loc_8001934	; jump table for switch	statement
		dd offset loc_8001986
		dd offset loc_80019E7
		dd offset loc_8001A2F
; char aTranslating[]
aTranslating	db 'translating',0      ; DATA XREF: string2_extend+21o
; char aS1LengthS2Leng[]
aS1LengthS2Leng	db 's1->length > s2->length',0 ; DATA XREF: string2_extend+58o
; char aS2Length0[]
aS2Length0	db 's2->length > 0',0   ; DATA XREF: string2_extend+80o
; char aI0[]
aI0		db 'i >= 0',0           ; DATA XREF: string2_extend+10Ao
		align 4
off_800602C	dd offset loc_8001D1F	; DATA XREF: string2_extend+A1r
		dd offset loc_8001D2B	; jump table for switch	statement
		dd offset loc_8001D37
		dd offset loc_8001D9D
		dd offset loc_8001D91
; char aTheCRepeatCons[]
aTheCRepeatCons	db 'the [c*] repeat construct may not appear in string1',0
					; DATA XREF: validate+20o
; char aOnlyOneCRepeat[]
aOnlyOneCRepeat	db 'only one [c*] repeat construct may appear in string2',0
					; DATA XREF: validate+6Eo
		align 4
; char aCExpressionsMa[]
aCExpressionsMa	db '[=c=] expressions may not appear in string2 when translating',0
					; DATA XREF: validate+A8o
		align 4
; char aWhenNotTruncat[]
aWhenNotTruncat	db 'when not truncating set1, string2 must be non-empty',0
					; DATA XREF: validate+103o
; char aWhenTranslatin[]
aWhenTranslatin	db 'when translating with complemented character classes,',0Ah
					; DATA XREF: validate+17Do
		db 'string2 must map all characters in the domain to one',0
		align 4
; char aWhenTranslat_0[]
aWhenTranslat_0	db 'when translating, the only character classes that may appear in',0Ah
					; DATA XREF: validate+1A8o
		db 'string2 are `upper',27h,' and `lower',27h,0
; char aTheCConstructM[]
aTheCConstructM	db 'the [c*] construct may appear in string2 only when translating',0
					; DATA XREF: validate+1D4o
; char aWriteError[]
aWriteError	db 'write error',0      ; DATA XREF: squeeze_filter+14Ao
					; main+4A8o ...
; char aReadError[]
aReadError	db 'read error',0       ; DATA XREF: plain_read+26o
; char locale
locale		db 0			; DATA XREF: main+51o
; char dirname[]
dirname		db '/usr/local/share/locale',0 ; DATA XREF: main+63o
aJimMeyering	db 'Jim Meyering',0     ; DATA XREF: main+10Bo
aTr		db 'tr',0               ; DATA XREF: main+116o
; char shortopts[]
shortopts	db '+cCdst',0           ; DATA XREF: main+142o
; char aMissingOperand[]
aMissingOperand	db 'missing operand',0  ; DATA XREF: main+1F7o
; char aMissingOpera_0[]
aMissingOpera_0	db 'missing operand after %s',0 ; DATA XREF: main+242o
		align 4
; char aTwoStringsMust[]
aTwoStringsMust	db 'Two strings must be given when both deleting and squeezing repeat'
					; DATA XREF: main+268o
		db 's.',0
aTwoStringsMu_0	db 'Two strings must be given when translating.',0
					; DATA XREF: main:loc_800268Eo
; char aS[]
aS		db '%s',0Ah,0           ; DATA XREF: main+28Bo main+318o
; char aExtraOperandS[]
aExtraOperandS	db 'extra operand %s',0 ; DATA XREF: main+2DCo
		align 4
; char aOnlyOneStringM[]
aOnlyOneStringM	db 'Only one string may be given when deleting without squeezing repe'
					; DATA XREF: main+300o
		db 'ats.',0
; char aCh1Truncate_se[]
aCh1Truncate_se	db 'ch != -1 || truncate_set1',0 ; DATA XREF: main+620o
; char aMisalignedUppe[]
aMisalignedUppe	db 'misaligned [:upper:] and/or [:lower:] construct',0
					; DATA XREF: main+747o
; char aC11Truncate_se[]
aC11Truncate_se	db 'c1 == -1 || truncate_set1',0 ; DATA XREF: main+8CEo
; char aStandardInput[]
aStandardInput	db 'standard input',0   ; DATA XREF: main+992o
		align 10h
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5314[19]
__PRETTY_FUNCTION___5314 db 'append_normal_char',0 ; DATA XREF: append_normal_char+43o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5323[13]
__PRETTY_FUNCTION___5323 db 'append_range',0 ; DATA XREF: append_range+CBo
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5331[18]
__PRETTY_FUNCTION___5331 db 'append_char_class',0 ; DATA XREF: append_char_class+60o
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5338[21]
__PRETTY_FUNCTION___5338 db 'append_repeated_char',0 ; DATA XREF: append_repeated_char+5Eo
		align 10h
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5345[19]
__PRETTY_FUNCTION___5345 db 'append_equiv_class',0 ; DATA XREF: append_equiv_class+4Eo
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5364[22]
__PRETTY_FUNCTION___5364 db 'find_bracketed_repeat',0 ; DATA XREF: find_bracketed_repeat+3Ao
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5424[9]
__PRETTY_FUNCTION___5424 db 'get_next',0 ; DATA XREF: get_next+1D2o
					; get_next+21Bo
		align 4
; Function-local static	variable
; char _PRETTY_FUNCTION___5451[15]
__PRETTY_FUNCTION___5451 db 'get_spec_stats',0 ; DATA XREF: get_spec_stats+8Eo
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5493[15]
__PRETTY_FUNCTION___5493 db 'string2_extend',0 ; DATA XREF: string2_extend+12o
					; string2_extend:loc_8001CBEo ...
		align 4
; Function-local static	variable
; const	char _PRETTY_FUNCTION___5616[5]
__PRETTY_FUNCTION___5616 db 'main',0    ; DATA XREF: main+611o main+8BFo
_rodata		ends

; ===========================================================================

; Segment type:	Pure data
; Segment permissions: Read
_eh_frame	segment	dword public 'CONST' use32
		assume cs:_eh_frame
		;org 8006490h
		dd 14h,	0
		dd 527A01h, 1087C01h, 4040C1Bh,	188h, 2	dup(1Ch)
		dd offset loc_8002DDB-800928Bh
		dd 12h,	80E4100h, 0D420285h, 0CC54E05h,	404h, 20h, 3Ch
		dd offset loc_8002DDB-8009299h
		dd 11Ch, 80E4100h, 0D420285h, 3834405h,	0C5011403h, 4040CC3h
		dd 1Ch,	60h
		dd offset loc_8002DDB-80091A1h
		dd 44h,	80E4100h, 0D420285h, 0C5400205h, 4040Ch, 18h, 80h
		dd offset loc_8002DDB-800917Dh
		dd 165h, 80E4100h, 0D420285h, 3834405h,	1Ch, 9Ch
		dd offset loc_8002DDB-8009034h
		dd 1Eh,	80E4100h, 0D420285h, 0CC55A05h,	404h, 1Ch, 0BCh
		dd offset loc_8002DDB-8009036h
		dd 1B4h, 80E4100h, 0D420285h, 1B00305h,	4040CC5h, 1Ch
		dd 0DCh
		dd offset loc_8002DDB-8008EA2h
		dd 2Ch,	80E4100h, 0D420285h, 0CC56805h,	404h, 2Ch, 0FCh
		dd offset loc_8002DDB-8008E96h
		dd 334h, 80E4100h, 0D420285h, 3874605h,	5830486h, 0C3032703h
		dd 0C741C641h, 40CC541h, 4, 1Ch, 12Ch
		dd offset loc_8002DDB-8008B92h
		dd 60h,	80E4100h, 0D420285h, 0C55C0205h, 4040Ch, 1Ch, 14Ch
		dd offset loc_8002DDB-8008B52h
		dd 6Bh,	80E4100h, 0D420285h, 0C5670205h, 4040Ch, 1Ch, 16Ch
		dd offset loc_8002DDB-8008B07h
		dd 15Bh, 80E4100h, 0D420285h, 1570305h,	4040CC5h, 1Ch
		dd 18Ch
		dd offset loc_8002DDB-80089CCh
		dd 74h,	80E4100h, 0D420285h, 0C5700205h, 4040Ch, 1Ch, 1ACh
		dd offset loc_8002DDB-8008978h
		dd 100h, 80E4100h, 0D420285h, 0C5FC0205h, 4040Ch, 1Ch
		dd 1CCh
		dd offset loc_8002DDB-8008898h
		dd 95h,	80E4100h, 0D420285h, 0C5910205h, 4040Ch, 1Ch, 1ECh
		dd offset loc_8002DDB-8008823h
		dd 8Fh,	80E4100h, 0D420285h, 0C58B0205h, 4040Ch, 1Ch, 20Ch
		dd offset loc_8002DDB-80087B4h
		dd 83h,	80E4100h, 0D420285h, 0C57F0205h, 4040Ch, 1Ch, 22Ch
		dd offset loc_8002DDB-8008751h
		dd 8Fh,	80E4100h, 0D420285h, 0C58B0205h, 4040Ch, 20h, 24Ch
		dd offset loc_8002DDB-80086E2h
		dd 1E9h, 80E4100h, 0D420285h, 3834405h,	0C501E103h, 4040CC3h
		dd 1Ch,	270h
		dd offset loc_8002DDB-800851Dh
		dd 8Dh,	80E4100h, 0D420285h, 0C5890205h, 4040Ch, 20h, 290h
		dd offset loc_8002DDB-80084B0h
		dd 3B9h, 80E4100h, 0D420285h, 3834405h,	0C503B103h, 4040CC3h
		dd 1Ch,	2B4h
		dd offset loc_8002DDB-800811Bh
		dd 26h,	80E4100h, 0D420285h, 0CC56205h,	404h, 28h, 2D4h
		dd offset loc_8002DDB-8008115h
		dd 3CCh, 80E4100h, 0D420285h, 3864505h,	0C1030483h, 0C641C303h
		dd 40CC541h, 4,	20h, 300h
		dd offset loc_8002DDB-8007D75h
		dd 0BEh, 80E4100h, 0D420285h, 3874705h,	0C7C5B302h, 4040Ch
		dd 20h,	324h
		dd offset loc_8002DDB-8007CDBh
		dd 249h, 80E4100h, 0D420285h, 3834405h,	0C5024103h, 4040CC3h
		dd 1Ch,	348h
		dd offset loc_8002DDB-8007AB6h
		dd 3Ah,	80E4100h, 0D420285h, 0CC57605h,	404h, 24h, 368h
		dd offset loc_8002DDB-8007A9Ch
		dd 7Fh,	80E4100h, 0D420285h, 3864505h, 74020483h, 41C641C3h
		dd 4040CC5h, 1Ch, 390h
		dd offset loc_8002DDB-8007A45h
		dd 39h,	80E4100h, 0D420285h, 0CC57505h,	404h, 1Ch, 3B0h
		dd offset loc_8002DDB-8007A2Ch
		dd 82h,	80E4100h, 0D420285h, 0C57E0205h, 4040Ch, 20h, 3D0h
		dd offset loc_8002DDB-80079CAh
		dd 176h, 80E4100h, 0D420285h, 3834405h,	0C5016E03h, 4040CC3h
		dd 1Ch,	3F4h
		dd offset loc_8002DDB-8007878h
		dd 66h,	80E4100h, 0D420285h, 0C5620205h, 4040Ch, 28h, 414h
		dd offset loc_8002DDB-8007832h
		dd 1F9h, 80E4100h, 0D420285h, 3864205h,	0F1030483h, 0C641C301h
		dd 40CC541h, 4,	20h, 440h
		dd offset loc_8002DDB-8007665h
		dd 1BCh, 80E4100h, 0D420285h, 3834405h,	0C501B403h, 4040CC3h
		dd 20h,	464h
		dd offset loc_8002DDB-80074CDh
		dd 53h,	80E4100h, 0D420285h, 3834405h, 0C3C54B02h, 4040Ch
		dd 1Ch,	488h
		dd offset loc_8002DDB-800749Eh
		dd 0D7h, 80E4100h, 0D420285h, 0C5D30205h, 4040Ch, 20h
		dd 4A8h
		dd offset loc_8002DDB-80073E7h
		dd 67h,	80E4100h, 0D420285h, 3834405h, 0C3C55F02h, 4040Ch
		dd 1Ch,	4CCh
		dd offset loc_8002DDB-80073A4h
		dd 88h,	80E4100h, 0D420285h, 0C5840205h, 4040Ch, 24h, 4ECh
		dd offset loc_8002DDB-800733Ch
		dd 9C1h, 10C4400h, 5104700h, 44007502h,	7875030Fh, 2031006h
		dd 7C75h
_eh_frame	ends

; ===========================================================================

; Segment type:	Externs
; extern
		extrn program_name:dword ; DATA	XREF: emit_ancillary_info+7r
					; emit_ancillary_info+B6r ...
		extrn last_component:near ; CODE XREF: emit_ancillary_info+10p
					; emit_ancillary_info+BFp ...
; char *gettext(const char *msgid)
		extrn gettext:near	; CODE XREF: emit_ancillary_info+22p
					; emit_ancillary_info+44p ...
; int printf(const char	*format, ...)
		extrn printf:near	; CODE XREF: emit_ancillary_info+34p
					; emit_ancillary_info+5Ap ...
; struct _IO_FILE *stdout
		extrn stdout:dword	; DATA XREF: emit_ancillary_info+62r
					; usage+60r ...
		extrn fputs_unlocked:near ; CODE XREF: emit_ancillary_info+7Dp
					; usage+7Bp ...
; char *setlocale(int category,	const char *locale)
		extrn setlocale:near	; CODE XREF: emit_ancillary_info+8Cp
					; main+58p
; int strncmp(const char *s1, const char *s2, size_t n)
		extrn strncmp:near	; CODE XREF: emit_ancillary_info+AAp
					; look_up_char_class+23p
; struct _IO_FILE *stderr
		extrn stderr:dword	; DATA XREF: usage+25r	main+282r ...
; int fprintf(FILE *stream, const char *format,	...)
		extrn fprintf:near	; CODE XREF: usage+30p	main+291p ...
; void exit(int	status)
		extrn exit:near		; CODE XREF: usage+160p main+129p ...
; const	unsigned __int16 **_ctype_b_loc(void)
		extrn __ctype_b_loc:near ; CODE	XREF: is_char_class_member:loc_800031Ap
					; is_char_class_member:loc_800033Ap ...
; void abort(void)
		extrn abort:near	; CODE XREF: is_char_class_member:loc_800049Bp
					; get_next:loc_80017E7p ...
; void free(void *ptr)
		extrn free:near		; CODE XREF: es_free+Fp es_free+21p ...
; size_t strlen(const char *s)
		extrn strlen:near	; CODE XREF: unquote+Fp
					; look_up_char_class+3Dp
; void *xmalloc(size_t)
		extrn xmalloc:near	; CODE XREF: unquote+20p
					; make_printable_char+11p ...
; void *xcalloc(size_t,	size_t)
		extrn xcalloc:near	; CODE XREF: unquote+37p
; void error(int status, int errnum, const char	*format, ...)
		extrn error:near	; CODE XREF: unquote+275p unquote+297p ...
; int sprintf(char *s, const char *format, ...)
		extrn sprintf:near	; CODE XREF: make_printable_char+5Ep
					; make_printable_str+112p
		extrn xnmalloc:near	; CODE XREF: make_printable_str+23p
		extrn stpcpy:near	; CODE XREF: make_printable_str+12Ap
		extrn __stack_chk_fail:near ; CODE XREF: make_printable_str+154p
					; find_bracketed_repeat+1DFp ...
; void _assert_fail(const char *assertion, const char *file, unsigned int line,	const char *function)
		extrn __assert_fail:near ; CODE	XREF: append_normal_char+57p
					; append_range+DFp ...
		extrn xstrtoumax:near	; CODE XREF: find_bracketed_repeat+10Fp
		extrn quote:near	; CODE XREF: find_bracketed_repeat+15Ap
					; build_spec_list+19Cp	...
; size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream)
		extrn fwrite_unlocked:near ; CODE XREF:	squeeze_filter+13Ap
					; main+498p ...
; int *_errno_location(void)
		extrn __errno_location:near ; CODE XREF: squeeze_filter+159p
					; plain_read+35p ...
		extrn safe_read:near	; CODE XREF: plain_read+12p
		extrn set_program_name:near ; CODE XREF: main+46p
; char *bindtextdomain(const char *domainname, const char *dirname)
		extrn bindtextdomain:near ; CODE XREF: main+6Dp
; char *textdomain(const char *domainname)
		extrn textdomain:near	; CODE XREF: main+7Dp
; void close_stdout(void)
		extrn close_stdout	; DATA XREF: main+88o
; int atexit(void (*func)(void))
		extrn atexit:near	; CODE XREF: main+8Dp
		extrn Version:dword	; DATA XREF: main:loc_800251Ar
		extrn version_etc:near	; CODE XREF: main+11Cp
; int getopt_long(int argc, char *const	*argv, const char *shortopts, const struct option *longopts, int *longind)
		extrn getopt_long:near	; CODE XREF: main+14Fp
; int optind
		extrn optind:dword	; DATA XREF: main+164r	main+2AFr ...
; int toupper(int c)
		extrn toupper:near	; CODE XREF: main+7B5p
; int tolower(int c)
		extrn tolower:near	; CODE XREF: main+835p
; int close(int	fd)
		extrn close:near	; CODE XREF: main+983p


		end
